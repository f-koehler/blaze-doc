<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sparse Vectors</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sparse Vectors<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../dc/dcf/group__vector.html">Vectors</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:d9/dd2/group__sparse__vector__expression"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd2/group__sparse__vector__expression.html">Expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/da9/group__compressed__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html">CompressedVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">blaze::SparseVector&lt; VT, TF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sparse vectors.The <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html" title="Base class for sparse vectors.The SparseVector class is a base class for all arbitrarily sized (N-dim...">SparseVector</a> class is a base class for all arbitrarily sized (N-dimensional) sparse vectors. It provides an abstraction from the actual type of the sparse vector, but enables a conversion back to this type via the <a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> base class.  <a href="../../d6/d31/structblaze_1_1SparseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">blaze::VectorAccessProxy&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for sparse, N-dimensional vectors.The <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> provides safe access to the elements of a non-const sparse vector.<br />
The proxied access to the elements of a sparse vector is necessary since it may be possible that several insertion operations happen in the same statement. The following code illustrates this with two examples by means of the <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">CompressedVector</a> class:  <a href="../../df/de3/classblaze_1_1VectorAccessProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../de/dd2/classblaze_1_1DVecSVecMultExpr.html">DVecSVecMultExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gab3fbcd035fcb7ffda672fbc102afb585">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab3fbcd035fcb7ffda672fbc102afb585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_107.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gab3fbcd035fcb7ffda672fbc102afb585">More...</a><br /></td></tr>
<tr class="separator:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fb4b558abb822b9cad9398d200a81b9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2fb4b558abb822b9cad9398d200a81b9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T1 &gt;, <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt; &gt;, <a class="el" href="../../d6/dbf/classblaze_1_1SMatSVecMultExpr.html">SMatSVecMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga2fb4b558abb822b9cad9398d200a81b9">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga2fb4b558abb822b9cad9398d200a81b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=B*\vec{c} $" src="../../form_114.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga2fb4b558abb822b9cad9398d200a81b9">More...</a><br /></td></tr>
<tr class="separator:ga2fb4b558abb822b9cad9398d200a81b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a6f7e07f63ad66b6eb51e0f905b262"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga16a6f7e07f63ad66b6eb51e0f905b262"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/d84/classblaze_1_1SVecDVecDivExpr.html">SVecDVecDivExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga16a6f7e07f63ad66b6eb51e0f905b262">blaze::operator/</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga16a6f7e07f63ad66b6eb51e0f905b262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the componentwise division of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/\vec{c} $" src="../../form_106.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga16a6f7e07f63ad66b6eb51e0f905b262">More...</a><br /></td></tr>
<tr class="separator:ga16a6f7e07f63ad66b6eb51e0f905b262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/dd1/classblaze_1_1SVecDVecMultExpr.html">SVecDVecMultExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga931bca871bc8961db7f2a7b5d9892b3c">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_107.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga931bca871bc8961db7f2a7b5d9892b3c">More...</a><br /></td></tr>
<tr class="separator:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a411c9688799b2ef0f334c98f216cf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gac9a411c9688799b2ef0f334c98f216cf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d7/d39/classblaze_1_1SVecEvalExpr.html">SVecEvalExpr</a>&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gac9a411c9688799b2ef0f334c98f216cf">blaze::eval</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gac9a411c9688799b2ef0f334c98f216cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given sparse vector expression <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gac9a411c9688799b2ef0f334c98f216cf">More...</a><br /></td></tr>
<tr class="separator:gac9a411c9688799b2ef0f334c98f216cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5335cfd53f63e8ffb35b5fe2ffc25aea"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename OP &gt; </td></tr>
<tr class="memitem:ga5335cfd53f63e8ffb35b5fe2ffc25aea"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, OP, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga5335cfd53f63e8ffb35b5fe2ffc25aea">blaze::forEach</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv, OP op)</td></tr>
<tr class="memdesc:ga5335cfd53f63e8ffb35b5fe2ffc25aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga5335cfd53f63e8ffb35b5fe2ffc25aea">More...</a><br /></td></tr>
<tr class="separator:ga5335cfd53f63e8ffb35b5fe2ffc25aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12bf426f167f5481c4feebc43a9a8482"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga12bf426f167f5481c4feebc43a9a8482"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d6/dae/structblaze_1_1Abs.html">Abs</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga12bf426f167f5481c4feebc43a9a8482">blaze::abs</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga12bf426f167f5481c4feebc43a9a8482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga12bf426f167f5481c4feebc43a9a8482">More...</a><br /></td></tr>
<tr class="separator:ga12bf426f167f5481c4feebc43a9a8482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4476803c0078f250cf58c75988b3300"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gae4476803c0078f250cf58c75988b3300"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d2/d67/structblaze_1_1Floor.html">Floor</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gae4476803c0078f250cf58c75988b3300">blaze::floor</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gae4476803c0078f250cf58c75988b3300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gae4476803c0078f250cf58c75988b3300">More...</a><br /></td></tr>
<tr class="separator:gae4476803c0078f250cf58c75988b3300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58bf3f2280518d504484e73bec2f2aac"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga58bf3f2280518d504484e73bec2f2aac"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../da/d9f/structblaze_1_1Ceil.html">Ceil</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga58bf3f2280518d504484e73bec2f2aac">blaze::ceil</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga58bf3f2280518d504484e73bec2f2aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga58bf3f2280518d504484e73bec2f2aac">More...</a><br /></td></tr>
<tr class="separator:ga58bf3f2280518d504484e73bec2f2aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b59758cfaf20aab089ccef01a0aff5"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa9b59758cfaf20aab089ccef01a0aff5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d23/structblaze_1_1Trunc.html">Trunc</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa9b59758cfaf20aab089ccef01a0aff5">blaze::trunc</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa9b59758cfaf20aab089ccef01a0aff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaa9b59758cfaf20aab089ccef01a0aff5">More...</a><br /></td></tr>
<tr class="separator:gaa9b59758cfaf20aab089ccef01a0aff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a477b6462fa4487d576cee6d29c4647"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4a477b6462fa4487d576cee6d29c4647"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d83/structblaze_1_1Round.html">Round</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga4a477b6462fa4487d576cee6d29c4647">blaze::round</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga4a477b6462fa4487d576cee6d29c4647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga4a477b6462fa4487d576cee6d29c4647">More...</a><br /></td></tr>
<tr class="separator:ga4a477b6462fa4487d576cee6d29c4647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239740b57eef26f1c51149555e42cdf6"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga239740b57eef26f1c51149555e42cdf6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../db/ddf/structblaze_1_1Conj.html">Conj</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga239740b57eef26f1c51149555e42cdf6">blaze::conj</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga239740b57eef26f1c51149555e42cdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the complex conjugate of each single element of <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga239740b57eef26f1c51149555e42cdf6">More...</a><br /></td></tr>
<tr class="separator:ga239740b57eef26f1c51149555e42cdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34b56aa4ff0b88f6007de1b8d4325e66"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga34b56aa4ff0b88f6007de1b8d4325e66"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">CTransExprTrait_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga34b56aa4ff0b88f6007de1b8d4325e66">blaze::ctrans</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga34b56aa4ff0b88f6007de1b8d4325e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate transpose vector of <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga34b56aa4ff0b88f6007de1b8d4325e66">More...</a><br /></td></tr>
<tr class="separator:ga34b56aa4ff0b88f6007de1b8d4325e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga594d9851390c1868273c0c96ba597148"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga594d9851390c1868273c0c96ba597148"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../dd/df4/structblaze_1_1Real.html">Real</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga594d9851390c1868273c0c96ba597148">blaze::real</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga594d9851390c1868273c0c96ba597148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the real parts of each single element of <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga594d9851390c1868273c0c96ba597148">More...</a><br /></td></tr>
<tr class="separator:ga594d9851390c1868273c0c96ba597148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c533177d921d01b6de1379197887bd9"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga6c533177d921d01b6de1379197887bd9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d3/d61/structblaze_1_1Imag.html">Imag</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga6c533177d921d01b6de1379197887bd9">blaze::imag</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga6c533177d921d01b6de1379197887bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the imaginary parts of each single element of <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga6c533177d921d01b6de1379197887bd9">More...</a><br /></td></tr>
<tr class="separator:ga6c533177d921d01b6de1379197887bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d268b55675338442e09c1793b9babaf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga8d268b55675338442e09c1793b9babaf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d0/d06/structblaze_1_1Sqrt.html">Sqrt</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga8d268b55675338442e09c1793b9babaf">blaze::sqrt</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga8d268b55675338442e09c1793b9babaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga8d268b55675338442e09c1793b9babaf">More...</a><br /></td></tr>
<tr class="separator:ga8d268b55675338442e09c1793b9babaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a4edc5deb886e04bc4370a17288ebda"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga1a4edc5deb886e04bc4370a17288ebda"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../df/d20/structblaze_1_1InvSqrt.html">InvSqrt</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga1a4edc5deb886e04bc4370a17288ebda">blaze::invsqrt</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga1a4edc5deb886e04bc4370a17288ebda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse square root of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga1a4edc5deb886e04bc4370a17288ebda">More...</a><br /></td></tr>
<tr class="separator:ga1a4edc5deb886e04bc4370a17288ebda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63114862aa4525da36987abcac3f988e"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga63114862aa4525da36987abcac3f988e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d6/d4c/structblaze_1_1Cbrt.html">Cbrt</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga63114862aa4525da36987abcac3f988e">blaze::cbrt</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga63114862aa4525da36987abcac3f988e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cubic root of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga63114862aa4525da36987abcac3f988e">More...</a><br /></td></tr>
<tr class="separator:ga63114862aa4525da36987abcac3f988e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5230ab98b6b5b74dddc967c3cb5cd4"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7b5230ab98b6b5b74dddc967c3cb5cd4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d2/d2f/structblaze_1_1InvCbrt.html">InvCbrt</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga7b5230ab98b6b5b74dddc967c3cb5cd4">blaze::invcbrt</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga7b5230ab98b6b5b74dddc967c3cb5cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cubic root of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga7b5230ab98b6b5b74dddc967c3cb5cd4">More...</a><br /></td></tr>
<tr class="separator:ga7b5230ab98b6b5b74dddc967c3cb5cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61fb60e6fbe2723159a9b552f8950104"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename DT &gt; </td></tr>
<tr class="memitem:ga61fb60e6fbe2723159a9b552f8950104"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d0/d65/structblaze_1_1Clip.html">Clip</a>&lt; DT &gt;, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga61fb60e6fbe2723159a9b552f8950104">blaze::clip</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>)</td></tr>
<tr class="memdesc:ga61fb60e6fbe2723159a9b552f8950104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts each single element of the sparse vector <em>sv</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_94.png"/>.  <a href="../../d6/d2f/group__sparse__vector.html#ga61fb60e6fbe2723159a9b552f8950104">More...</a><br /></td></tr>
<tr class="separator:ga61fb60e6fbe2723159a9b552f8950104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7e6f523449f9aad9b21fb6f9230482"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename ET &gt; </td></tr>
<tr class="memitem:gafc7e6f523449f9aad9b21fb6f9230482"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d3/d41/structblaze_1_1Pow.html">Pow</a>&lt; ET &gt;, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gafc7e6f523449f9aad9b21fb6f9230482">blaze::pow</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv, ET <a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">exp</a>)</td></tr>
<tr class="memdesc:gafc7e6f523449f9aad9b21fb6f9230482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponential value for each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gafc7e6f523449f9aad9b21fb6f9230482">More...</a><br /></td></tr>
<tr class="separator:gafc7e6f523449f9aad9b21fb6f9230482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5a1c951e51200ce5aa27bd4e524513"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaef5a1c951e51200ce5aa27bd4e524513"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d4/d45/structblaze_1_1Exp.html">Exp</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaef5a1c951e51200ce5aa27bd4e524513">blaze::exp</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaef5a1c951e51200ce5aa27bd4e524513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaef5a1c951e51200ce5aa27bd4e524513">More...</a><br /></td></tr>
<tr class="separator:gaef5a1c951e51200ce5aa27bd4e524513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e15e57286f3d65931a995aa8c507763"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7e15e57286f3d65931a995aa8c507763"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../df/dbb/structblaze_1_1Exp2.html">Exp2</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga7e15e57286f3d65931a995aa8c507763">blaze::exp2</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga7e15e57286f3d65931a995aa8c507763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga7e15e57286f3d65931a995aa8c507763">More...</a><br /></td></tr>
<tr class="separator:ga7e15e57286f3d65931a995aa8c507763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7454714c18c2e09d74208439ce23329c"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7454714c18c2e09d74208439ce23329c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../db/dc8/structblaze_1_1Exp10.html">Exp10</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga7454714c18c2e09d74208439ce23329c">blaze::exp10</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga7454714c18c2e09d74208439ce23329c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga7454714c18c2e09d74208439ce23329c">More...</a><br /></td></tr>
<tr class="separator:ga7454714c18c2e09d74208439ce23329c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58630c948cf33ddbb0357b413b762da0"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga58630c948cf33ddbb0357b413b762da0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d3/d9c/structblaze_1_1Log.html">Log</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga58630c948cf33ddbb0357b413b762da0">blaze::log</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga58630c948cf33ddbb0357b413b762da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga58630c948cf33ddbb0357b413b762da0">More...</a><br /></td></tr>
<tr class="separator:ga58630c948cf33ddbb0357b413b762da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9755aee62b7f897ca4b989a68941f62d"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga9755aee62b7f897ca4b989a68941f62d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d5/dc7/structblaze_1_1Log2.html">Log2</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga9755aee62b7f897ca4b989a68941f62d">blaze::log2</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga9755aee62b7f897ca4b989a68941f62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary logarithm of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga9755aee62b7f897ca4b989a68941f62d">More...</a><br /></td></tr>
<tr class="separator:ga9755aee62b7f897ca4b989a68941f62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e412d9508a0e2a11db2a06b2bae9139"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7e412d9508a0e2a11db2a06b2bae9139"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d33/structblaze_1_1Log10.html">Log10</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga7e412d9508a0e2a11db2a06b2bae9139">blaze::log10</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga7e412d9508a0e2a11db2a06b2bae9139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the common logarithm of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga7e412d9508a0e2a11db2a06b2bae9139">More...</a><br /></td></tr>
<tr class="separator:ga7e412d9508a0e2a11db2a06b2bae9139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05688072c6eb9dd3fa320436e4f7454b"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga05688072c6eb9dd3fa320436e4f7454b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d56/structblaze_1_1Sin.html">Sin</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga05688072c6eb9dd3fa320436e4f7454b">blaze::sin</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga05688072c6eb9dd3fa320436e4f7454b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga05688072c6eb9dd3fa320436e4f7454b">More...</a><br /></td></tr>
<tr class="separator:ga05688072c6eb9dd3fa320436e4f7454b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6bbcafad45cfd32de71c639302dc2d2"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa6bbcafad45cfd32de71c639302dc2d2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d3/dde/structblaze_1_1Asin.html">Asin</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa6bbcafad45cfd32de71c639302dc2d2">blaze::asin</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa6bbcafad45cfd32de71c639302dc2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse sine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaa6bbcafad45cfd32de71c639302dc2d2">More...</a><br /></td></tr>
<tr class="separator:gaa6bbcafad45cfd32de71c639302dc2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78ff3907a282c8c9d2a3504f47ff2e88"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga78ff3907a282c8c9d2a3504f47ff2e88"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d4/d59/structblaze_1_1Sinh.html">Sinh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga78ff3907a282c8c9d2a3504f47ff2e88">blaze::sinh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga78ff3907a282c8c9d2a3504f47ff2e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga78ff3907a282c8c9d2a3504f47ff2e88">More...</a><br /></td></tr>
<tr class="separator:ga78ff3907a282c8c9d2a3504f47ff2e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacba48bd0943ed4a3cfdac37783181901"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gacba48bd0943ed4a3cfdac37783181901"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d0/d08/structblaze_1_1Asinh.html">Asinh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gacba48bd0943ed4a3cfdac37783181901">blaze::asinh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gacba48bd0943ed4a3cfdac37783181901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gacba48bd0943ed4a3cfdac37783181901">More...</a><br /></td></tr>
<tr class="separator:gacba48bd0943ed4a3cfdac37783181901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd003f585a00dbd748b1f3b032248ac3"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gabd003f585a00dbd748b1f3b032248ac3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../df/d0a/structblaze_1_1Cos.html">Cos</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gabd003f585a00dbd748b1f3b032248ac3">blaze::cos</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gabd003f585a00dbd748b1f3b032248ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gabd003f585a00dbd748b1f3b032248ac3">More...</a><br /></td></tr>
<tr class="separator:gabd003f585a00dbd748b1f3b032248ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga908a6a95de702b8f46bb094996561ff2"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga908a6a95de702b8f46bb094996561ff2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d4/db3/structblaze_1_1Acos.html">Acos</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga908a6a95de702b8f46bb094996561ff2">blaze::acos</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga908a6a95de702b8f46bb094996561ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cosine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga908a6a95de702b8f46bb094996561ff2">More...</a><br /></td></tr>
<tr class="separator:ga908a6a95de702b8f46bb094996561ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33373deb5e0df60b71d771203ac4e258"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga33373deb5e0df60b71d771203ac4e258"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/db2/structblaze_1_1Cosh.html">Cosh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga33373deb5e0df60b71d771203ac4e258">blaze::cosh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga33373deb5e0df60b71d771203ac4e258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga33373deb5e0df60b71d771203ac4e258">More...</a><br /></td></tr>
<tr class="separator:ga33373deb5e0df60b71d771203ac4e258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2744d46900d42eb6dba263d22e609c70"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga2744d46900d42eb6dba263d22e609c70"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../dd/d35/structblaze_1_1Acosh.html">Acosh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga2744d46900d42eb6dba263d22e609c70">blaze::acosh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga2744d46900d42eb6dba263d22e609c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga2744d46900d42eb6dba263d22e609c70">More...</a><br /></td></tr>
<tr class="separator:ga2744d46900d42eb6dba263d22e609c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga347939d6d6ba192be1e180d147114b5d"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga347939d6d6ba192be1e180d147114b5d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../db/d5e/structblaze_1_1Tan.html">Tan</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga347939d6d6ba192be1e180d147114b5d">blaze::tan</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga347939d6d6ba192be1e180d147114b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga347939d6d6ba192be1e180d147114b5d">More...</a><br /></td></tr>
<tr class="separator:ga347939d6d6ba192be1e180d147114b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe8b24bb897deadf6d721884552aa91b"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gabe8b24bb897deadf6d721884552aa91b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d4/dfc/structblaze_1_1Atan.html">Atan</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gabe8b24bb897deadf6d721884552aa91b">blaze::atan</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gabe8b24bb897deadf6d721884552aa91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse tangent of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gabe8b24bb897deadf6d721884552aa91b">More...</a><br /></td></tr>
<tr class="separator:gabe8b24bb897deadf6d721884552aa91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffb58728bf05e0f93d41e1d92cedb87a"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaffb58728bf05e0f93d41e1d92cedb87a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../df/db7/structblaze_1_1Tanh.html">Tanh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaffb58728bf05e0f93d41e1d92cedb87a">blaze::tanh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaffb58728bf05e0f93d41e1d92cedb87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaffb58728bf05e0f93d41e1d92cedb87a">More...</a><br /></td></tr>
<tr class="separator:gaffb58728bf05e0f93d41e1d92cedb87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14450639e7ef92fb69d60fe7b96c634a"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga14450639e7ef92fb69d60fe7b96c634a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d4d/structblaze_1_1Atanh.html">Atanh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga14450639e7ef92fb69d60fe7b96c634a">blaze::atanh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga14450639e7ef92fb69d60fe7b96c634a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga14450639e7ef92fb69d60fe7b96c634a">More...</a><br /></td></tr>
<tr class="separator:ga14450639e7ef92fb69d60fe7b96c634a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79dd61da5c22c4ecd148dad78b808a39"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga79dd61da5c22c4ecd148dad78b808a39"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../dd/d2c/structblaze_1_1Erf.html">Erf</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga79dd61da5c22c4ecd148dad78b808a39">blaze::erf</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga79dd61da5c22c4ecd148dad78b808a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga79dd61da5c22c4ecd148dad78b808a39">More...</a><br /></td></tr>
<tr class="separator:ga79dd61da5c22c4ecd148dad78b808a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69a6ea271abeafac0ffd43c9c2a14c2"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa69a6ea271abeafac0ffd43c9c2a14c2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d5a/structblaze_1_1Erfc.html">Erfc</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa69a6ea271abeafac0ffd43c9c2a14c2">blaze::erfc</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa69a6ea271abeafac0ffd43c9c2a14c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complementary error function of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaa69a6ea271abeafac0ffd43c9c2a14c2">More...</a><br /></td></tr>
<tr class="separator:gaa69a6ea271abeafac0ffd43c9c2a14c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7ac67053f35e26f45e7b8db4844333"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga0c7ac67053f35e26f45e7b8db4844333"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">DivExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga0c7ac67053f35e26f45e7b8db4844333">blaze::operator/</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga0c7ac67053f35e26f45e7b8db4844333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the divison of a sparse vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_109.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga0c7ac67053f35e26f45e7b8db4844333">More...</a><br /></td></tr>
<tr class="separator:ga0c7ac67053f35e26f45e7b8db4844333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga108e929136114735b41e82824fcf1d98"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga108e929136114735b41e82824fcf1d98"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d7/dc2/classblaze_1_1SVecScalarMultExpr.html">SVecScalarMultExpr</a>&lt; VT, <a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">UnderlyingBuiltin_</a>&lt; VT &gt;, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga108e929136114735b41e82824fcf1d98">blaze::operator-</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga108e929136114735b41e82824fcf1d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a sparse vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_110.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga108e929136114735b41e82824fcf1d98">More...</a><br /></td></tr>
<tr class="separator:ga108e929136114735b41e82824fcf1d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga568fe866cdb766ef08e4696b675cc697"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga568fe866cdb766ef08e4696b675cc697"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga568fe866cdb766ef08e4696b675cc697">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga568fe866cdb766ef08e4696b675cc697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_51.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga568fe866cdb766ef08e4696b675cc697">More...</a><br /></td></tr>
<tr class="separator:ga568fe866cdb766ef08e4696b675cc697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31f12956746f757f22c89e9460732ed0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga31f12956746f757f22c89e9460732ed0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga31f12956746f757f22c89e9460732ed0">blaze::operator*</a> (T1 scalar, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga31f12956746f757f22c89e9460732ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_111.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga31f12956746f757f22c89e9460732ed0">More...</a><br /></td></tr>
<tr class="separator:ga31f12956746f757f22c89e9460732ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43666f6cb23c23f8cff15a5195ce2852"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga43666f6cb23c23f8cff15a5195ce2852"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/ddd/classblaze_1_1SVecSerialExpr.html">SVecSerialExpr</a>&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga43666f6cb23c23f8cff15a5195ce2852">blaze::serial</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga43666f6cb23c23f8cff15a5195ce2852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the serial evaluation of the given sparse vector expression <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga43666f6cb23c23f8cff15a5195ce2852">More...</a><br /></td></tr>
<tr class="separator:ga43666f6cb23c23f8cff15a5195ce2852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3012773ba555712c006466a901f2b7b6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga3012773ba555712c006466a901f2b7b6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d63/classblaze_1_1SVecSVecAddExpr.html">SVecSVecAddExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga3012773ba555712c006466a901f2b7b6">blaze::operator+</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3012773ba555712c006466a901f2b7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_103.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga3012773ba555712c006466a901f2b7b6">More...</a><br /></td></tr>
<tr class="separator:ga3012773ba555712c006466a901f2b7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccf01f6322bcd426a734b284aa123b8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaaccf01f6322bcd426a734b284aa123b8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/ddb/classblaze_1_1SVecSVecMultExpr.html">SVecSVecMultExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaaccf01f6322bcd426a734b284aa123b8">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaaccf01f6322bcd426a734b284aa123b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise multiplication of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_107.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gaaccf01f6322bcd426a734b284aa123b8">More...</a><br /></td></tr>
<tr class="separator:gaaccf01f6322bcd426a734b284aa123b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../de/d48/classblaze_1_1SVecSVecSubExpr.html">SVecSVecSubExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga1a9bad0a58b194a184fa8b9e14618a4f">blaze::operator-</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_108.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga1a9bad0a58b194a184fa8b9e14618a4f">More...</a><br /></td></tr>
<tr class="separator:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24d22f5812d106f439ea9d7e72cd78d8"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga24d22f5812d106f439ea9d7e72cd78d8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dd7/classblaze_1_1SVecTransExpr.html">SVecTransExpr</a>&lt; VT,!TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga24d22f5812d106f439ea9d7e72cd78d8">blaze::trans</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga24d22f5812d106f439ea9d7e72cd78d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given sparse vector.  <a href="../../d6/d2f/group__sparse__vector.html#ga24d22f5812d106f439ea9d7e72cd78d8">More...</a><br /></td></tr>
<tr class="separator:ga24d22f5812d106f439ea9d7e72cd78d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa10c43fbf3fd4cb8d559a4800006de9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gafa10c43fbf3fd4cb8d559a4800006de9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gafa10c43fbf3fd4cb8d559a4800006de9">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gafa10c43fbf3fd4cb8d559a4800006de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of a dense and a sparse vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_119.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gafa10c43fbf3fd4cb8d559a4800006de9">More...</a><br /></td></tr>
<tr class="separator:gafa10c43fbf3fd4cb8d559a4800006de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d224a32415cdc958195e6232074795d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0d224a32415cdc958195e6232074795d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;, <a class="el" href="../../de/d16/classblaze_1_1TSMatSVecMultExpr.html">TSMatSVecMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga0d224a32415cdc958195e6232074795d">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga0d224a32415cdc958195e6232074795d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_88.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga0d224a32415cdc958195e6232074795d">More...</a><br /></td></tr>
<tr class="separator:ga0d224a32415cdc958195e6232074795d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d15f54904aeb15d1fd91c7fa8845f8d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9d15f54904aeb15d1fd91c7fa8845f8d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga9d15f54904aeb15d1fd91c7fa8845f8d">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga9d15f54904aeb15d1fd91c7fa8845f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of a sparse and a dense vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_119.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga9d15f54904aeb15d1fd91c7fa8845f8d">More...</a><br /></td></tr>
<tr class="separator:ga9d15f54904aeb15d1fd91c7fa8845f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0de5eb385b83bb7bc876dd563de01e99"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0de5eb385b83bb7bc876dd563de01e99"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;, <a class="el" href="../../d1/da7/classblaze_1_1TSVecSMatMultExpr.html">TSVecSMatMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga0de5eb385b83bb7bc876dd563de01e99">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga0de5eb385b83bb7bc876dd563de01e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga0de5eb385b83bb7bc876dd563de01e99">More...</a><br /></td></tr>
<tr class="separator:ga0de5eb385b83bb7bc876dd563de01e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1293580b64ed52a65885fd4e4355e15f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga1293580b64ed52a65885fd4e4355e15f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga1293580b64ed52a65885fd4e4355e15f">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga1293580b64ed52a65885fd4e4355e15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a sparse matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_117.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga1293580b64ed52a65885fd4e4355e15f">More...</a><br /></td></tr>
<tr class="separator:ga1293580b64ed52a65885fd4e4355e15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e9d01a4510e70baec3884409a1e5c0a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0e9d01a4510e70baec3884409a1e5c0a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga0e9d01a4510e70baec3884409a1e5c0a">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0e9d01a4510e70baec3884409a1e5c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of two sparse vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_119.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga0e9d01a4510e70baec3884409a1e5c0a">More...</a><br /></td></tr>
<tr class="separator:ga0e9d01a4510e70baec3884409a1e5c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c8233b9db1f47343d52c4002bf9c512"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga6c8233b9db1f47343d52c4002bf9c512"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T2 &gt;, <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt; &gt;, <a class="el" href="../../df/d31/classblaze_1_1TSVecTSMatMultExpr.html">TSVecTSMatMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga6c8233b9db1f47343d52c4002bf9c512">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga6c8233b9db1f47343d52c4002bf9c512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga6c8233b9db1f47343d52c4002bf9c512">More...</a><br /></td></tr>
<tr class="separator:ga6c8233b9db1f47343d52c4002bf9c512"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseVector operators</h2></td></tr>
<tr class="memitem:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga3abacbc4a4ecdb439384f1ce2ae38246">blaze::operator==</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two sparse vectors.  <a href="../../d6/d2f/group__sparse__vector.html#ga3abacbc4a4ecdb439384f1ce2ae38246">More...</a><br /></td></tr>
<tr class="separator:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga47bd825d8a1516cf16134c4dc9ac918a">blaze::operator!=</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two sparse vectors.  <a href="../../d6/d2f/group__sparse__vector.html#ga47bd825d8a1516cf16134c4dc9ac918a">More...</a><br /></td></tr>
<tr class="separator:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseVector functions</h2></td></tr>
<tr class="memitem:ga4490b16f3da675eb29db391adcf46f98"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4490b16f3da675eb29db391adcf46f98"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga4490b16f3da675eb29db391adcf46f98">blaze::isnan</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga4490b16f3da675eb29db391adcf46f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given sparse vector for not-a-number elements.  <a href="../../d6/d2f/group__sparse__vector.html#ga4490b16f3da675eb29db391adcf46f98">More...</a><br /></td></tr>
<tr class="separator:ga4490b16f3da675eb29db391adcf46f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa58862b9f216db8c76842cd7c649d092"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa58862b9f216db8c76842cd7c649d092"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa58862b9f216db8c76842cd7c649d092">blaze::isUniform</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa58862b9f216db8c76842cd7c649d092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse vector is a uniform vector.  <a href="../../d6/d2f/group__sparse__vector.html#gaa58862b9f216db8c76842cd7c649d092">More...</a><br /></td></tr>
<tr class="separator:gaa58862b9f216db8c76842cd7c649d092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26eb8f27519826300e4c6e05540f4f7a"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga26eb8f27519826300e4c6e05540f4f7a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga26eb8f27519826300e4c6e05540f4f7a">blaze::sqrLength</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga26eb8f27519826300e4c6e05540f4f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the sparse vector square length <img class="formulaInl" alt="$|\vec{a}|^2$" src="../../form_63.png"/>.  <a href="../../d6/d2f/group__sparse__vector.html#ga26eb8f27519826300e4c6e05540f4f7a">More...</a><br /></td></tr>
<tr class="separator:ga26eb8f27519826300e4c6e05540f4f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69b4ec965b7288218a79549c50b51db"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa69b4ec965b7288218a79549c50b51db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa69b4ec965b7288218a79549c50b51db">blaze::length</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv) -&gt; decltype(<a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">sqrt</a>(<a class="el" href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32">sqrLength</a>(~sv)))</td></tr>
<tr class="memdesc:gaa69b4ec965b7288218a79549c50b51db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the sparse vector length <img class="formulaInl" alt="$|\vec{a}|$" src="../../form_64.png"/>.  <a href="../../d6/d2f/group__sparse__vector.html#gaa69b4ec965b7288218a79549c50b51db">More...</a><br /></td></tr>
<tr class="separator:gaa69b4ec965b7288218a79549c50b51db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1c42aadfa3bdbe0be24df9ecd47c222"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa1c42aadfa3bdbe0be24df9ecd47c222"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa1c42aadfa3bdbe0be24df9ecd47c222">blaze::min</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa1c42aadfa3bdbe0be24df9ecd47c222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the sparse vector.  <a href="../../d6/d2f/group__sparse__vector.html#gaa1c42aadfa3bdbe0be24df9ecd47c222">More...</a><br /></td></tr>
<tr class="separator:gaa1c42aadfa3bdbe0be24df9ecd47c222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f496dbc22cefdf5b31975f57271caf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gad7f496dbc22cefdf5b31975f57271caf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gad7f496dbc22cefdf5b31975f57271caf">blaze::max</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gad7f496dbc22cefdf5b31975f57271caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the sparse vector.  <a href="../../d6/d2f/group__sparse__vector.html#gad7f496dbc22cefdf5b31975f57271caf">More...</a><br /></td></tr>
<tr class="separator:gad7f496dbc22cefdf5b31975f57271caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
VectorAccessProxy global functions</h2></td></tr>
<tr class="memitem:ga4ccb520d1605428c703fb1e231984b8a"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga4ccb520d1605428c703fb1e231984b8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga4ccb520d1605428c703fb1e231984b8a">blaze::reset</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga4ccb520d1605428c703fb1e231984b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../d6/d2f/group__sparse__vector.html#ga4ccb520d1605428c703fb1e231984b8a">More...</a><br /></td></tr>
<tr class="separator:ga4ccb520d1605428c703fb1e231984b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga548f8ae65fde704870019a244c4aa68d"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga548f8ae65fde704870019a244c4aa68d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga548f8ae65fde704870019a244c4aa68d">blaze::clear</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga548f8ae65fde704870019a244c4aa68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../d6/d2f/group__sparse__vector.html#ga548f8ae65fde704870019a244c4aa68d">More...</a><br /></td></tr>
<tr class="separator:ga548f8ae65fde704870019a244c4aa68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb3ad1af3a538107952f5d3f03dab8d5"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gacb3ad1af3a538107952f5d3f03dab8d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gacb3ad1af3a538107952f5d3f03dab8d5">blaze::isDefault</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gacb3ad1af3a538107952f5d3f03dab8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../d6/d2f/group__sparse__vector.html#gacb3ad1af3a538107952f5d3f03dab8d5">More...</a><br /></td></tr>
<tr class="separator:gacb3ad1af3a538107952f5d3f03dab8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6615fb157a5b5d597f371c749618b73"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gac6615fb157a5b5d597f371c749618b73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gac6615fb157a5b5d597f371c749618b73">blaze::isReal</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gac6615fb157a5b5d597f371c749618b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector element represents a real number.  <a href="../../d6/d2f/group__sparse__vector.html#gac6615fb157a5b5d597f371c749618b73">More...</a><br /></td></tr>
<tr class="separator:gac6615fb157a5b5d597f371c749618b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab97eab0b10c2649a287c00702bb79cd"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gaab97eab0b10c2649a287c00702bb79cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaab97eab0b10c2649a287c00702bb79cd">blaze::isZero</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaab97eab0b10c2649a287c00702bb79cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../d6/d2f/group__sparse__vector.html#gaab97eab0b10c2649a287c00702bb79cd">More...</a><br /></td></tr>
<tr class="separator:gaab97eab0b10c2649a287c00702bb79cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3437d191e9f05d5c256bf363ccb36e4"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gac3437d191e9f05d5c256bf363ccb36e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gac3437d191e9f05d5c256bf363ccb36e4">blaze::isOne</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gac3437d191e9f05d5c256bf363ccb36e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../d6/d2f/group__sparse__vector.html#gac3437d191e9f05d5c256bf363ccb36e4">More...</a><br /></td></tr>
<tr class="separator:gac3437d191e9f05d5c256bf363ccb36e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga577795ebd00f8faab87d16b964d158cc"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga577795ebd00f8faab87d16b964d158cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga577795ebd00f8faab87d16b964d158cc">blaze::isnan</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga577795ebd00f8faab87d16b964d158cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../d6/d2f/group__sparse__vector.html#ga577795ebd00f8faab87d16b964d158cc">More...</a><br /></td></tr>
<tr class="separator:ga577795ebd00f8faab87d16b964d158cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a932337ccd811dc6d27859066a47b4"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gad2a932337ccd811dc6d27859066a47b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gad2a932337ccd811dc6d27859066a47b4">blaze::swap</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;a, const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gad2a932337ccd811dc6d27859066a47b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two access proxies.  <a href="../../d6/d2f/group__sparse__vector.html#gad2a932337ccd811dc6d27859066a47b4">More...</a><br /></td></tr>
<tr class="separator:gad2a932337ccd811dc6d27859066a47b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga533b968699a6e37d569137d4481bcef4"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename T &gt; </td></tr>
<tr class="memitem:ga533b968699a6e37d569137d4481bcef4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga533b968699a6e37d569137d4481bcef4">blaze::swap</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;a, T &amp;b) noexcept</td></tr>
<tr class="memdesc:ga533b968699a6e37d569137d4481bcef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="../../d6/d2f/group__sparse__vector.html#ga533b968699a6e37d569137d4481bcef4">More...</a><br /></td></tr>
<tr class="separator:ga533b968699a6e37d569137d4481bcef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ec20cc3a5938208cd23728631130f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename VT &gt; </td></tr>
<tr class="memitem:gae1ec20cc3a5938208cd23728631130f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gae1ec20cc3a5938208cd23728631130f0">blaze::swap</a> (T &amp;a, const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gae1ec20cc3a5938208cd23728631130f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="../../d6/d2f/group__sparse__vector.html#gae1ec20cc3a5938208cd23728631130f0">More...</a><br /></td></tr>
<tr class="separator:gae1ec20cc3a5938208cd23728631130f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga12bf426f167f5481c4feebc43a9a8482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12bf426f167f5481c4feebc43a9a8482">&sect;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d6/dae/structblaze_1_1Abs.html">Abs</a>,TF&gt; blaze::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5">abs</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga908a6a95de702b8f46bb094996561ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga908a6a95de702b8f46bb094996561ff2">&sect;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d4/db3/structblaze_1_1Acos.html">Acos</a>,TF&gt; blaze::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse cosine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cosine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gabbea0b8e061ed390f6c7767c9104e40e" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a></em> function computes the inverse cosine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gabbea0b8e061ed390f6c7767c9104e40e" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gabbea0b8e061ed390f6c7767c9104e40e">acos</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga2744d46900d42eb6dba263d22e609c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2744d46900d42eb6dba263d22e609c70">&sect;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../dd/d35/structblaze_1_1Acosh.html">Acosh</a>,TF&gt; blaze::acosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic cosine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[1..\infty)$" src="../../form_99.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic cosine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gafdfd453cc8c85f2c9d65bc5d82eb52e5" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a></em> function computes the inverse hyperbolic cosine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gafdfd453cc8c85f2c9d65bc5d82eb52e5" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gafdfd453cc8c85f2c9d65bc5d82eb52e5">acosh</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[1..\infty)$" src="../../form_99.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gaa6bbcafad45cfd32de71c639302dc2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6bbcafad45cfd32de71c639302dc2d2">&sect;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d3/dde/structblaze_1_1Asin.html">Asin</a>,TF&gt; blaze::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse sine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse sine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab4eed6b2d7c8e03d3ba69de01a1e54ff" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a></em> function computes the inverse sine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab4eed6b2d7c8e03d3ba69de01a1e54ff" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gab4eed6b2d7c8e03d3ba69de01a1e54ff">asin</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gacba48bd0943ed4a3cfdac37783181901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacba48bd0943ed4a3cfdac37783181901">&sect;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d0/d08/structblaze_1_1Asinh.html">Asinh</a>,TF&gt; blaze::asinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic sine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic sine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga974e5ff97f8d4c431684ca167bf5be3b" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a></em> function computes the inverse hyperbolic sine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga974e5ff97f8d4c431684ca167bf5be3b" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga974e5ff97f8d4c431684ca167bf5be3b">asinh</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gabe8b24bb897deadf6d721884552aa91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe8b24bb897deadf6d721884552aa91b">&sect;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d4/dfc/structblaze_1_1Atan.html">Atan</a>,TF&gt; blaze::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse tangent of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse tangent of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab63e8615abfd73eea11c190846d8f14b" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a></em> function computes the inverse tangent for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab63e8615abfd73eea11c190846d8f14b" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gab63e8615abfd73eea11c190846d8f14b">atan</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga14450639e7ef92fb69d60fe7b96c634a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14450639e7ef92fb69d60fe7b96c634a">&sect;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../de/d4d/structblaze_1_1Atanh.html">Atanh</a>,TF&gt; blaze::atanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic tangent of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic tangent of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaf39e95469abfd502a43219461590266a" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a></em> function computes the inverse hyperbolic tangent for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaf39e95469abfd502a43219461590266a" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaf39e95469abfd502a43219461590266a">atanh</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga63114862aa4525da36987abcac3f988e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63114862aa4525da36987abcac3f988e">&sect;&nbsp;</a></span>cbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d6/d4c/structblaze_1_1Cbrt.html">Cbrt</a>,TF&gt; blaze::cbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cubic root of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cubic root of each single element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></em> function computes the cubic root of each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62">cbrt</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga58bf3f2280518d504484e73bec2f2aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58bf3f2280518d504484e73bec2f2aac">&sect;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../da/d9f/structblaze_1_1Ceil.html">Ceil</a>,TF&gt; blaze::ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b">ceil</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga548f8ae65fde704870019a244c4aa68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga548f8ae65fde704870019a244c4aa68d">&sect;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clearing the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ga61fb60e6fbe2723159a9b552f8950104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61fb60e6fbe2723159a9b552f8950104">&sect;&nbsp;</a></span>clip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF, typename DT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d0/d65/structblaze_1_1Clip.html">Clip</a>&lt;DT&gt;,TF&gt; blaze::clip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restricts each single element of the sparse vector <em>sv</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_94.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
    <tr><td class="paramname">min</td><td>The lower delimiter. </td></tr>
    <tr><td class="paramname">max</td><td>The upper delimiter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector with restricted elements.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gadebfde9b2a5daf6d821e81ac96aa0b94" title="Restricts each single element of the dense matrix dm to the range . ">clip()</a></em> function resetricts each element of the input vector <em>sv</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_94.png"/>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gadebfde9b2a5daf6d821e81ac96aa0b94" title="Restricts each single element of the dense matrix dm to the range . ">clip()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gadebfde9b2a5daf6d821e81ac96aa0b94">clip</a>( a, -1.0, 1.0 );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga239740b57eef26f1c51149555e42cdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga239740b57eef26f1c51149555e42cdf6">&sect;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../db/ddf/structblaze_1_1Conj.html">Conj</a>,TF&gt; blaze::conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the complex conjugate of each single element of <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The integral sparse input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complex conjugate of each single element of <em>sv</em>.</dd></dl>
<p>The <em>conj</em> function calculates the complex conjugate of each element of the sparse input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>conj</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga23b5c9bdbb7e7ea2c008808d235f7055">conj</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gabd003f585a00dbd748b1f3b032248ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd003f585a00dbd748b1f3b032248ac3">&sect;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../df/d0a/structblaze_1_1Cos.html">Cos</a>,TF&gt; blaze::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cosine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cosine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6179f49533c111d0c1ed6b9181aabbe7" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a></em> function computes the cosine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6179f49533c111d0c1ed6b9181aabbe7" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6179f49533c111d0c1ed6b9181aabbe7">cos</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga33373deb5e0df60b71d771203ac4e258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33373deb5e0df60b71d771203ac4e258">&sect;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../de/db2/structblaze_1_1Cosh.html">Cosh</a>,TF&gt; blaze::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cosine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga3cb0cfa3ce6e0ca00ef6edf910149858" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a></em> function computes the hyperbolic cosine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga3cb0cfa3ce6e0ca00ef6edf910149858" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga3cb0cfa3ce6e0ca00ef6edf910149858">cosh</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga34b56aa4ff0b88f6007de1b8d4325e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34b56aa4ff0b88f6007de1b8d4325e66">&sect;&nbsp;</a></span>ctrans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">CTransExprTrait_</a>&lt;VT&gt; blaze::ctrans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the conjugate transpose vector of <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conjugate transpose of <em>sv</em>.</dd></dl>
<p>The <em>ctrans</em> function returns an expression representing the conjugate transpose (also called adjoint matrix, Hermitian conjugate matrix or transjugate matrix) of the given input vector <em>sv</em>.<br />
The following example demonstrates the use of the <em>ctrans</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt; complex&lt;double&gt;</a> &gt; a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga48020f64de98036286379dacfa444750">ctrans</a>( a );</div></div><!-- fragment --><p>Note that the <em>ctrans</em> function has the same effect as manually applying the <em>conj</em> and <em>trans</em> function in any order:</p>
<div class="fragment"><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga23b5c9bdbb7e7ea2c008808d235f7055">conj</a>( a ) );  <span class="comment">// Computing the conjugate transpose vector</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga23b5c9bdbb7e7ea2c008808d235f7055">conj</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( a ) );  <span class="comment">// Computing the conjugate transpose vector</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga79dd61da5c22c4ecd148dad78b808a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79dd61da5c22c4ecd148dad78b808a39">&sect;&nbsp;</a></span>erf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../dd/d2c/structblaze_1_1Erf.html">Erf</a>,TF&gt; blaze::erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error function of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab93959cccb52b78dccb927b9ea0afafe" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></em> function computes the error function for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab93959cccb52b78dccb927b9ea0afafe" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gab93959cccb52b78dccb927b9ea0afafe">erf</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa69a6ea271abeafac0ffd43c9c2a14c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa69a6ea271abeafac0ffd43c9c2a14c2">&sect;&nbsp;</a></span>erfc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../de/d5a/structblaze_1_1Erfc.html">Erfc</a>,TF&gt; blaze::erfc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the complementary error function of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complementary error function of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8444088c1f7a23fe9ca5d44f8b736b6a" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></em> function computes the complementary error function for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8444088c1f7a23fe9ca5d44f8b736b6a" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga8444088c1f7a23fe9ca5d44f8b736b6a">erfc</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gac9a411c9688799b2ef0f334c98f216cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9a411c9688799b2ef0f334c98f216cf">&sect;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d7/d39/classblaze_1_1SVecEvalExpr.html">SVecEvalExpr</a>&lt;VT,TF&gt; blaze::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the evaluation of the given sparse vector expression <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated sparse vector.</dd></dl>
<p>The <em>eval</em> function forces the evaluation of the given sparse vector expression <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>eval</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gacb9f8190d38edb0e52d9c376da5486d6">eval</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaef5a1c951e51200ce5aa27bd4e524513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef5a1c951e51200ce5aa27bd4e524513">&sect;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d4/d45/structblaze_1_1Exp.html">Exp</a>,TF&gt; blaze::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4" title="Computes  for each single element of the dense matrix dm. ">exp()</a></em> function computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4" title="Computes  for each single element of the dense matrix dm. ">exp()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">exp</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7454714c18c2e09d74208439ce23329c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7454714c18c2e09d74208439ce23329c">&sect;&nbsp;</a></span>exp10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../db/dc8/structblaze_1_1Exp10.html">Exp10</a>,TF&gt; blaze::exp10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></em> function computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2">exp10</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7e15e57286f3d65931a995aa8c507763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e15e57286f3d65931a995aa8c507763">&sect;&nbsp;</a></span>exp2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../df/dbb/structblaze_1_1Exp2.html">Exp2</a>,TF&gt; blaze::exp2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></em> function computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576">exp2</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gae4476803c0078f250cf58c75988b3300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4476803c0078f250cf58c75988b3300">&sect;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d2/d67/structblaze_1_1Floor.html">Floor</a>,TF&gt; blaze::floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60">floor</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga5335cfd53f63e8ffb35b5fe2ffc25aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5335cfd53f63e8ffb35b5fe2ffc25aea">&sect;&nbsp;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF, typename OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, OP, TF &gt; blaze::forEach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the given custom operation on each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
    <tr><td class="paramname">op</td><td>The custom operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The custom operation applied to each single element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></em> function evaluates the given custom operation on each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb">forEach</a>( a, []( <span class="keywordtype">double</span> a ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">std::sqrt</a>( a ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6c533177d921d01b6de1379197887bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c533177d921d01b6de1379197887bd9">&sect;&nbsp;</a></span>imag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d3/d61/structblaze_1_1Imag.html">Imag</a>,TF&gt; blaze::imag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the imaginary parts of each single element of <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The integral sparse input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The imaginary part of each single element of <em>sv</em>.</dd></dl>
<p>The <em>imag</em> function calculates the imaginary part of each element of the sparse input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>imag</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga801fe45f59d396249b21d1e4f686f427">imag</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7b5230ab98b6b5b74dddc967c3cb5cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b5230ab98b6b5b74dddc967c3cb5cd4">&sect;&nbsp;</a></span>invcbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d2/d2f/structblaze_1_1InvCbrt.html">InvCbrt</a>,TF&gt; blaze::invcbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse cubic root of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_93.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cubic root of each single element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga683192b628e107e6082a6b6876d62614" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></em> function computes the inverse cubic root of each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga683192b628e107e6082a6b6876d62614" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga683192b628e107e6082a6b6876d62614">invcbrt</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_93.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga1a4edc5deb886e04bc4370a17288ebda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a4edc5deb886e04bc4370a17288ebda">&sect;&nbsp;</a></span>invsqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../df/d20/structblaze_1_1InvSqrt.html">InvSqrt</a>,TF&gt; blaze::invsqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse square root of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_93.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse square root of each single element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e33f65ba5d0b7f32fe15b818d6914e6" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></em> function computes the inverse square root of each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e33f65ba5d0b7f32fe15b818d6914e6" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga8e33f65ba5d0b7f32fe15b818d6914e6">invsqrt</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_93.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gacb3ad1af3a538107952f5d3f03dab8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb3ad1af3a538107952f5d3f03dab8d5">&sect;&nbsp;</a></span>isDefault()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isDefault </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is in default state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is in default state, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy is in default state. In case it is in default state, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="ga4490b16f3da675eb29db391adcf46f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4490b16f3da675eb29db391adcf46f98">&sect;&nbsp;</a></span>isnan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the given sparse vector for not-a-number elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse vector to be checked for not-a-number elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the vector is not-a-number, <em>false</em> otherwise.</dd></dl>
<p>This function checks the N-dimensional sparse vector for not-a-number (NaN) elements. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> at least one element of the vector is not-a-number, the function returns <em>true</em>, otherwise it returns <em>false</em>.</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga88d643a61cd9e3b87852233e13973f08">isnan</a>( a ) ) { ... }</div></div><!-- fragment --><p>Note that this function only works for vectors with floating point elements. The attempt to use it for a vector with a non-floating point element type results in a compile time error. </p>

</div>
</div>
<a id="ga577795ebd00f8faab87d16b964d158cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga577795ebd00f8faab87d16b964d158cc">&sect;&nbsp;</a></span>isnan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is not a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is in not a number, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy is not a number (NaN). In case it is not a number, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="gac3437d191e9f05d5c256bf363ccb36e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3437d191e9f05d5c256bf363ccb36e4">&sect;&nbsp;</a></span>isOne()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isOne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is 1, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy represents the numeric value 1. In case it is 1, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="gac6615fb157a5b5d597f371c749618b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6615fb157a5b5d597f371c749618b73">&sect;&nbsp;</a></span>isReal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isReal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector element represents a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the vector element represents a real number, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy represents the a real number. In case the element is of built-in type, the function returns <em>true</em>. In case the element is of complex type, the function returns <em>true</em> if the imaginary part is equal to 0. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="gaa58862b9f216db8c76842cd7c649d092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa58862b9f216db8c76842cd7c649d092">&sect;&nbsp;</a></span>isUniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse vector is a uniform vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the vector is a uniform vector, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse vector is a uniform vector. The vector is considered to be uniform if all its elements are identical. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;int,blaze::columnVector&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7aafd1dd369f715e523850f4adb36696">isUniform</a>( a ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a vector expression results in a uniform vector:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7aafd1dd369f715e523850f4adb36696">isUniform</a>( a + b ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary vector. </p>

</div>
</div>
<a id="gaab97eab0b10c2649a287c00702bb79cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab97eab0b10c2649a287c00702bb79cd">&sect;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is 0, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy represents the numeric value 0. In case it is 0, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="gaa69b4ec965b7288218a79549c50b51db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa69b4ec965b7288218a79549c50b51db">&sect;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto blaze::length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td> -&gt;  decltype(<a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">sqrt</a>(<a class="el" href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32">sqrLength</a>(~sv)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the sparse vector length <img class="formulaInl" alt="$|\vec{a}|$" src="../../form_64.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The given sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the sparse vector.</dd></dl>
<p>This function calculates the actual length of the sparse vector. The return type of the <a class="el" href="../../de/d90/group__dense__vector.html#ga3585e479887969c9f815c0223fe5284f" title="Calculation of the dense vector length . ">length()</a> function depends on the actual element type of the vector instance:</p>
<table border="0" cellspacing="0" cellpadding="1">
<tr>
<td width="250px"><b>Type</b>  </td><td width="100px"><b>LengthType</b>   </td></tr>
<tr>
<td>float </td><td>float  </td></tr>
<tr>
<td>integral data types and double </td><td>double  </td></tr>
<tr>
<td>long double </td><td>long double  </td></tr>
<tr>
<td>complex&lt;T&gt; </td><td>complex&lt;T&gt;  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This operation is only defined for numeric data types. In case the element type is not a numeric data type (i.e. a user defined data type or boolean) the attempt to use the <a class="el" href="../../de/d90/group__dense__vector.html#ga3585e479887969c9f815c0223fe5284f" title="Calculation of the dense vector length . ">length()</a> function results in a compile time error! </dd></dl>

</div>
</div>
<a id="ga58630c948cf33ddbb0357b413b762da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58630c948cf33ddbb0357b413b762da0">&sect;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d3/d9c/structblaze_1_1Log.html">Log</a>,TF&gt; blaze::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logaritm of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8359ccb837055c7056c1eae56c45eb1a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function computes the natural logarithm for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8359ccb837055c7056c1eae56c45eb1a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga8359ccb837055c7056c1eae56c45eb1a">log</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga7e412d9508a0e2a11db2a06b2bae9139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e412d9508a0e2a11db2a06b2bae9139">&sect;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../de/d33/structblaze_1_1Log10.html">Log10</a>,TF&gt; blaze::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the common logarithm of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The common logaritm of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga979d59d108165583def861daf609d8ca" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></em> function computes the common logarithm for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga979d59d108165583def861daf609d8ca" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga979d59d108165583def861daf609d8ca">log10</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga9755aee62b7f897ca4b989a68941f62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9755aee62b7f897ca4b989a68941f62d">&sect;&nbsp;</a></span>log2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d5/dc7/structblaze_1_1Log2.html">Log2</a>,TF&gt; blaze::log2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary logarithm of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary logaritm of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaba8707d555ca3ec8c6394d9724e2b504" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></em> function computes the binary logarithm for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaba8707d555ca3ec8c6394d9724e2b504" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaba8707d555ca3ec8c6394d9724e2b504">log2</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gad7f496dbc22cefdf5b31975f57271caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7f496dbc22cefdf5b31975f57271caf">&sect;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt; blaze::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest element of the sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The given sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest sparse vector element.</dd></dl>
<p>This function returns the largest element of the given sparse vector. This function can only be used for element types that support the smaller-than relationship. In case the vector currently has a size of 0, the returned value is the default value (e.g. 0 in case of fundamental data types).</p>
<dl class="section note"><dt>Note</dt><dd>In case the compressed vector is not completely filled, the zero elements are also taken into account. Example: the following compressed vector has only 2 non-zero elements. However, the maximum of this vector is 0:</dd></dl>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\begin{array}{*{4}{c}} -1 &amp; 0 &amp; -3 &amp; 0 \\ \end{array}\right) \]" src="../../form_166.png"/>
</p>
 
</div>
</div>
<a id="gaa1c42aadfa3bdbe0be24df9ecd47c222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1c42aadfa3bdbe0be24df9ecd47c222">&sect;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt; blaze::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest element of the sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The given sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest sparse vector element.</dd></dl>
<p>This function returns the smallest element of the given sparse vector. This function can only be used for element types that support the smaller-than relationship. In case the vector currently has a size of 0, the returned value is the default value (e.g. 0 in case of fundamental data types).</p>
<dl class="section note"><dt>Note</dt><dd>In case the sparse vector is not completely filled, the zero elements are also taken into account. Example: the following compressed vector has only 2 non-zero elements. However, the minimum of this vector is 0:</dd></dl>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\begin{array}{*{4}{c}} 1 &amp; 0 &amp; 3 &amp; 0 \\ \end{array}\right) \]" src="../../form_165.png"/>
</p>
 
</div>
</div>
<a id="ga47bd825d8a1516cf16134c4dc9ac918a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47bd825d8a1516cf16134c4dc9ac918a">&sect;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of two sparse vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a id="ga0e9d01a4510e70baec3884409a1e5c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e9d01a4510e70baec3884409a1e5c0a">&sect;&nbsp;</a></span>operator*() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt;T1&gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt;T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the scalar product (inner product) of two sparse vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_119.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of two sparse vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> a, b;</div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga146e7401b84cc73dc213edc50bf3a236">blaze::real</a> res;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">res = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>(a) * b;</div></div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gafa10c43fbf3fd4cb8d559a4800006de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa10c43fbf3fd4cb8d559a4800006de9">&sect;&nbsp;</a></span>operator*() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt;T1&gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt;T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the scalar product (inner product) of a dense and a sparse vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_119.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a> a;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> b;</div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga146e7401b84cc73dc213edc50bf3a236">blaze::real</a> res;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">res = a * b;</div></div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga9d15f54904aeb15d1fd91c7fa8845f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d15f54904aeb15d1fd91c7fa8845f8d">&sect;&nbsp;</a></span>operator*() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt;T1&gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt;T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the scalar product (inner product) of a sparse and a dense vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_119.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> a;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> b;</div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga146e7401b84cc73dc213edc50bf3a236">blaze::real</a> res;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">res = a * b;</div></div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaaccf01f6322bcd426a734b284aa123b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaccf01f6322bcd426a734b284aa123b8">&sect;&nbsp;</a></span>operator*() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/ddb/classblaze_1_1SVecSVecMultExpr.html">SVecSVecMultExpr</a>&lt;T1,T2,TF&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise multiplication of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_107.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the componentwise multiplication of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a * b;</div></div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga931bca871bc8961db7f2a7b5d9892b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga931bca871bc8961db7f2a7b5d9892b3c">&sect;&nbsp;</a></span>operator*() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/dd1/classblaze_1_1SVecDVecMultExpr.html">SVecDVecMultExpr</a>&lt;T1,T2,TF&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_107.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the componentwise multiplication of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, c;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a * b;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gab3fbcd035fcb7ffda672fbc102afb585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3fbcd035fcb7ffda672fbc102afb585">&sect;&nbsp;</a></span>operator*() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../de/dd2/classblaze_1_1DVecSVecMultExpr.html">DVecSVecMultExpr</a>&lt;T1,T2,TF&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_107.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the componentwise multiplication of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a * b;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga0de5eb385b83bb7bc876dd563de01e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0de5eb385b83bb7bc876dd563de01e99">&sect;&nbsp;</a></span>operator*() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt;T2&gt;, <a class="el" href="../../d1/da7/classblaze_1_1TSVecSMatMultExpr.html">TSVecSMatMultExpr</a>&lt;T1,T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side row-major sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse vector and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> x, y;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = x * A;</div></div><!-- fragment --><p>The operator returns an expression representing a transpose sparse vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse vector type <em>T1</em> and the sparse matrix type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga0d224a32415cdc958195e6232074795d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d224a32415cdc958195e6232074795d">&sect;&nbsp;</a></span>operator*() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt;T1&gt;, <a class="el" href="../../de/d16/classblaze_1_1TSMatSVecMultExpr.html">TSMatSVecMultExpr</a>&lt;T1,T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_88.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse matrix and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> x, y;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = A * x;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse matrix type <em>T1</em> and the sparse vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga568fe866cdb766ef08e4696b675cc697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga568fe866cdb766ef08e4696b675cc697">&sect;&nbsp;</a></span>operator*() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T2&gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt;T1,T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a sparse vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_51.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the multiplication between a sparse vector and a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = a * 1.25;</div></div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a id="ga1293580b64ed52a65885fd4e4355e15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1293580b64ed52a65885fd4e4355e15f">&sect;&nbsp;</a></span>operator*() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt;T2&gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt;T1,T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a sparse matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_117.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side sparse matrix-matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a sparse vector and a sparse matrix-matrix multiplication expression. It restructures the expression <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_117.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}^T=(\vec{x}^T*A)*B $" src="../../form_118.png"/>. </p>

</div>
</div>
<a id="ga31f12956746f757f22c89e9460732ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31f12956746f757f22c89e9460732ed0">&sect;&nbsp;</a></span>operator*() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T1&gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt;T1,T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a scalar value and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the multiplication between a a scalar value and sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = 1.25 * a;</div></div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the involved data types <em>T1</em> and <em>T2::ElementType</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a id="ga2fb4b558abb822b9cad9398d200a81b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fb4b558abb822b9cad9398d200a81b9">&sect;&nbsp;</a></span>operator*() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;T1&gt;, <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt;T1&gt; &gt;, <a class="el" href="../../d6/dbf/classblaze_1_1SMatSVecMultExpr.html">SMatSVecMultExpr</a>&lt;T1,T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=B*\vec{c} $" src="../../form_114.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a row-major sparse matrix and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> x, y;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = A * x;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse matrix type <em>T1</em> and the sparse vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga6c8233b9db1f47343d52c4002bf9c512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c8233b9db1f47343d52c4002bf9c512">&sect;&nbsp;</a></span>operator*() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;T2&gt;, <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt;T2&gt; &gt;, <a class="el" href="../../df/d31/classblaze_1_1TSVecTSMatMultExpr.html">TSVecTSMatMultExpr</a>&lt;T1,T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side column-major sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse vector and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> x, y;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = x * A;</div></div><!-- fragment --><p>The operator returns an expression representing a transpose sparse vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse vector type <em>T1</em> and the sparse matrix type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga3012773ba555712c006466a901f2b7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3012773ba555712c006466a901f2b7b6">&sect;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/d63/classblaze_1_1SVecSVecAddExpr.html">SVecSVecAddExpr</a>&lt;T1,T2,TF&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_103.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the vector addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the vector addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a + b;</div></div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga1a9bad0a58b194a184fa8b9e14618a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a9bad0a58b194a184fa8b9e14618a4f">&sect;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../de/d48/classblaze_1_1SVecSVecSubExpr.html">SVecSVecSubExpr</a>&lt;T1,T2,TF&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_108.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the vector subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted from the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a - b;</div></div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga108e929136114735b41e82824fcf1d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga108e929136114735b41e82824fcf1d98">&sect;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d7/dc2/classblaze_1_1SVecScalarMultExpr.html">SVecScalarMultExpr</a>&lt;VT,<a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">UnderlyingBuiltin_</a>&lt;VT&gt;,TF&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus operator for the negation of a sparse vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_110.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse vector to be negated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The negation of the vector.</dd></dl>
<p>This operator represents the negation of a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = -a;</div></div><!-- fragment --><p>The operator returns an expression representing the negation of the given sparse vector. </p>

</div>
</div>
<a id="ga16a6f7e07f63ad66b6eb51e0f905b262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16a6f7e07f63ad66b6eb51e0f905b262">&sect;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/d84/classblaze_1_1SVecDVecDivExpr.html">SVecDVecDivExpr</a>&lt;T1,T2,TF&gt; blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for the componentwise division of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/\vec{c} $" src="../../form_106.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quotient of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the component quotient of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, c;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a / b;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class. ">DivTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga0c7ac67053f35e26f45e7b8db4844333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c7ac67053f35e26f45e7b8db4844333">&sect;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T2&gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">DivExprTrait_</a>&lt;T1,T2&gt; &gt; blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for the divison of a sparse vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_109.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side sparse vector for the division. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the division of a sparse vector by a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = a / 0.24;</div></div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Note that this operator only works for scalar values of built-in data type.</p>
<dl class="section note"><dt>Note</dt><dd>A division by zero is only checked by an user assert. </dd></dl>

</div>
</div>
<a id="ga3abacbc4a4ecdb439384f1ce2ae38246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3abacbc4a4ecdb439384f1ce2ae38246">&sect;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two sparse vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two sparse vectors are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="gafc7e6f523449f9aad9b21fb6f9230482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc7e6f523449f9aad9b21fb6f9230482">&sect;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF, typename ET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d3/d41/structblaze_1_1Pow.html">Pow</a>&lt;ET&gt;,TF&gt; blaze::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ET&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the exponential value for each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
    <tr><td class="paramname">exp</td><td>The exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponential value of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga04b65a79150f5e9e3118257b2f77a0ed" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></em> function computes the exponential value for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga04b65a79150f5e9e3118257b2f77a0ed" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga04b65a79150f5e9e3118257b2f77a0ed">pow</a>( A, 4.2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga594d9851390c1868273c0c96ba597148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga594d9851390c1868273c0c96ba597148">&sect;&nbsp;</a></span>real()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../dd/df4/structblaze_1_1Real.html">Real</a>,TF&gt; blaze::real </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the real parts of each single element of <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The integral sparse input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The real part of each single element of <em>sv</em>.</dd></dl>
<p>The <em>real</em> function calculates the real part of each element of the sparse input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>real</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga146e7401b84cc73dc213edc50bf3a236">real</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4ccb520d1605428c703fb1e231984b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ccb520d1605428c703fb1e231984b8a">&sect;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resetting the represented element to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ga4a477b6462fa4487d576cee6d29c4647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a477b6462fa4487d576cee6d29c4647">&sect;&nbsp;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../de/d83/structblaze_1_1Round.html">Round</a>,TF&gt; blaze::round </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc">round</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga43666f6cb23c23f8cff15a5195ce2852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43666f6cb23c23f8cff15a5195ce2852">&sect;&nbsp;</a></span>serial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../df/ddd/classblaze_1_1SVecSerialExpr.html">SVecSerialExpr</a>&lt; VT, TF &gt; blaze::serial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the serial evaluation of the given sparse vector expression <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated sparse vector.</dd></dl>
<p>The <em>serial</em> function forces the serial evaluation of the given sparse vector expression <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>serial</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaeac3b9aff5df5e547819e485321f4762">serial</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga05688072c6eb9dd3fa320436e4f7454b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05688072c6eb9dd3fa320436e4f7454b">&sect;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../de/d56/structblaze_1_1Sin.html">Sin</a>,TF&gt; blaze::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga0a06568d5cd7314f4a0995a051d68062" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a></em> function computes the sine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga0a06568d5cd7314f4a0995a051d68062" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga0a06568d5cd7314f4a0995a051d68062">sin</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga78ff3907a282c8c9d2a3504f47ff2e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78ff3907a282c8c9d2a3504f47ff2e88">&sect;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d4/d59/structblaze_1_1Sinh.html">Sinh</a>,TF&gt; blaze::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic sine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga4111317de20c08c0a40b10182eee2539" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a></em> function computes the hyperbolic sine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga4111317de20c08c0a40b10182eee2539" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga4111317de20c08c0a40b10182eee2539">sinh</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga26eb8f27519826300e4c6e05540f4f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26eb8f27519826300e4c6e05540f4f7a">&sect;&nbsp;</a></span>sqrLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt; blaze::sqrLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the sparse vector square length <img class="formulaInl" alt="$|\vec{a}|^2$" src="../../form_63.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The given sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square length of the vector.</dd></dl>
<p>This function calculates the actual square length of the sparse vector.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is only defined for numeric data types. In case the element type is not a numeric data type (i.e. a user defined data type or boolean) the attempt to use the <a class="el" href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32" title="Calculation of the dense vector square length . ">sqrLength()</a> function results in a compile time error! </dd></dl>

</div>
</div>
<a id="ga8d268b55675338442e09c1793b9babaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d268b55675338442e09c1793b9babaf">&sect;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../d0/d06/structblaze_1_1Sqrt.html">Sqrt</a>,TF&gt; blaze::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of each single element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></em> function computes the square root of each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">sqrt</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gad2a932337ccd811dc6d27859066a47b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2a932337ccd811dc6d27859066a47b4">&sect;&nbsp;</a></span>swap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two access proxies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first access proxy to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The second access proxy to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ga533b968699a6e37d569137d4481bcef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga533b968699a6e37d569137d4481bcef4">&sect;&nbsp;</a></span>swap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of an access proxy with another element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The access proxy to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The other element to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="gae1ec20cc3a5938208cd23728631130f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1ec20cc3a5938208cd23728631130f0">&sect;&nbsp;</a></span>swap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of an access proxy with another element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The other element to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The access proxy to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ga347939d6d6ba192be1e180d147114b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga347939d6d6ba192be1e180d147114b5d">&sect;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../db/d5e/structblaze_1_1Tan.html">Tan</a>,TF&gt; blaze::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tangent of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga90be532925f9874efae43a23918194ce" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a></em> function computes the tangent for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga90be532925f9874efae43a23918194ce" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga90be532925f9874efae43a23918194ce">tan</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaffb58728bf05e0f93d41e1d92cedb87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffb58728bf05e0f93d41e1d92cedb87a">&sect;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../df/db7/structblaze_1_1Tanh.html">Tanh</a>,TF&gt; blaze::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic tangent of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac3e7dda64b4203c08bf00bc0813b4d05" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a></em> function computes the hyperbolic tangent for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac3e7dda64b4203c08bf00bc0813b4d05" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gac3e7dda64b4203c08bf00bc0813b4d05">tanh</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga24d22f5812d106f439ea9d7e72cd78d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24d22f5812d106f439ea9d7e72cd78d8">&sect;&nbsp;</a></span>trans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/dd7/classblaze_1_1SVecTransExpr.html">SVecTransExpr</a>&lt; VT,!TF &gt; blaze::trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the transpose of the given sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse vector to be transposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of the sparse vector.</dd></dl>
<p>This function returns an expression representing the transpose of the given sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> a;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa9b59758cfaf20aab089ccef01a0aff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9b59758cfaf20aab089ccef01a0aff5">&sect;&nbsp;</a></span>trunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt;VT,<a class="el" href="../../de/d23/structblaze_1_1Trunc.html">Trunc</a>,TF&gt; blaze::trunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40">trunc</a>( a );</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 31 2016 17:17:01 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
