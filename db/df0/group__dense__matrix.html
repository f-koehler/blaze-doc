<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dense Matrices</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Dense Matrices<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../dd/d7a/group__matrix.html">Matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:d2/d77/group__custom__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d77/group__custom__matrix.html">CustomMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/dfc/group__dynamic__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html">DynamicMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d0f/group__hybrid__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0f/group__hybrid__matrix.html">HybridMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d5/def/group__static__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/def/group__static__matrix.html">StaticMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/d7c/group__dense__matrix__expression"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d7c/group__dense__matrix__expression.html">Expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">blaze::DenseMatrix&lt; MT, SO &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dense matrices.The <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html" title="Base class for dense matrices.The DenseMatrix class is a base class for all dense matrix classes...">DenseMatrix</a> class is a base class for all dense matrix classes. It provides an abstraction from the actual type of the dense matrix, but enables a conversion back to this type via the <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> base class.  <a href="../../d0/d89/structblaze_1_1DenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga629e225abfa7be1f41cff40ecd17d5d5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga629e225abfa7be1f41cff40ecd17d5d5">blaze::InversionFlag</a> { <br />
&#160;&#160;<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5ac3740319e28f275c1b9fd29e1ac4f402">blaze::byLU</a> = 0, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a0a5e1212ca55699fbc1c19afad9afee6">blaze::byLDLT</a> = 1, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a9566686fdaf93d13a7905489fd7a53eb">blaze::byLDLH</a> = 2, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5ad05ff6d0175d8cf4a91ea39ddb7c67a2">blaze::byLLH</a> = 3, 
<br />
&#160;&#160;<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5adaef4901b1d62c57b7ecaef9fa0fdbce">blaze::asGeneral</a> = 4, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a53f1e0df9a2bb46e6e44b79cb7f37ca1">blaze::asSymmetric</a> = 5, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a0b79760c443ca06f987410e9db671090">blaze::asHermitian</a> = 6, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a2037964c1bde635a44bec66e041f460e">blaze::asLower</a> = 7, 
<br />
&#160;&#160;<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a1a71074238192f97c566b0de0a2ef232">blaze::asUniLower</a> = 8, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a422d84660adc423063d501b5dc8e8f97">blaze::asUpper</a> = 9, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a59dbf6f76744b544df87274e70c9d826">blaze::asUniUpper</a> = 10, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5ab9559c7c7f5240b394de2072ef9c3de5">blaze::asDiagonal</a> = 11
<br />
 }<tr class="memdesc:ga629e225abfa7be1f41cff40ecd17d5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversion flag.The InversionFlag type enumeration represents the different types of matrix inversion algorithms that are available within the Blaze library. The following flags are available:  <a href="../../db/df0/group__dense__matrix.html#ga629e225abfa7be1f41cff40ecd17d5d5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga629e225abfa7be1f41cff40ecd17d5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga25855a1d3c48eb1cb6f3f5a66842a85e">blaze::operator==</a> (T1 scalar, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a scalar value and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga25855a1d3c48eb1cb6f3f5a66842a85e">More...</a><br /></td></tr>
<tr class="separator:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8ab1683cf0ef1f675329a4d27d45751c">blaze::operator!=</a> (T1 scalar, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a scalar value and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga8ab1683cf0ef1f675329a4d27d45751c">More...</a><br /></td></tr>
<tr class="separator:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b169a4b41e240ee939d6027dcf61c52"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga5b169a4b41e240ee939d6027dcf61c52"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d2d/classblaze_1_1DMatDMatAddExpr.html">DMatDMatAddExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga5b169a4b41e240ee939d6027dcf61c52">blaze::operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5b169a4b41e240ee939d6027dcf61c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two dense matrices with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga5b169a4b41e240ee939d6027dcf61c52">More...</a><br /></td></tr>
<tr class="separator:ga5b169a4b41e240ee939d6027dcf61c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade2ef15ea991616b38c3ffa80834ae5c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gade2ef15ea991616b38c3ffa80834ae5c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d40/classblaze_1_1DMatDMatMultExpr.html">DMatDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gade2ef15ea991616b38c3ffa80834ae5c">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gade2ef15ea991616b38c3ffa80834ae5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two row-major dense matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gade2ef15ea991616b38c3ffa80834ae5c">More...</a><br /></td></tr>
<tr class="separator:gade2ef15ea991616b38c3ffa80834ae5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7b2dabfa699f5714783cf446221758"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga1d7b2dabfa699f5714783cf446221758"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/ddb/classblaze_1_1DMatDMatSubExpr.html">DMatDMatSubExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1d7b2dabfa699f5714783cf446221758">blaze::operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1d7b2dabfa699f5714783cf446221758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two dense matrices with identical storage order ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga1d7b2dabfa699f5714783cf446221758">More...</a><br /></td></tr>
<tr class="separator:ga1d7b2dabfa699f5714783cf446221758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9f8190d38edb0e52d9c376da5486d6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gacb9f8190d38edb0e52d9c376da5486d6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d9a/classblaze_1_1DMatEvalExpr.html">DMatEvalExpr</a>&lt; MT, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gacb9f8190d38edb0e52d9c376da5486d6">blaze::eval</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gacb9f8190d38edb0e52d9c376da5486d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given dense matrix expression <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gacb9f8190d38edb0e52d9c376da5486d6">More...</a><br /></td></tr>
<tr class="separator:gacb9f8190d38edb0e52d9c376da5486d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbb0c018752c3e955e7ffbee96c415eb"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename OP &gt; </td></tr>
<tr class="memitem:gacbb0c018752c3e955e7ffbee96c415eb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, OP, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb">blaze::forEach</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm, OP op)</td></tr>
<tr class="memdesc:gacbb0c018752c3e955e7ffbee96c415eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb">More...</a><br /></td></tr>
<tr class="separator:gacbb0c018752c3e955e7ffbee96c415eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e4e90c6e2ed37ddea6203417c5596f5"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga8e4e90c6e2ed37ddea6203417c5596f5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d6/dae/structblaze_1_1Abs.html">Abs</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5">blaze::abs</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga8e4e90c6e2ed37ddea6203417c5596f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5">More...</a><br /></td></tr>
<tr class="separator:ga8e4e90c6e2ed37ddea6203417c5596f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7076fab6e413abbb8914e97c63c6ec60"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7076fab6e413abbb8914e97c63c6ec60"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d2/d67/structblaze_1_1Floor.html">Floor</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60">blaze::floor</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga7076fab6e413abbb8914e97c63c6ec60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60">More...</a><br /></td></tr>
<tr class="separator:ga7076fab6e413abbb8914e97c63c6ec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38cb77691633d93f6b0b2fc55146a04b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga38cb77691633d93f6b0b2fc55146a04b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../da/d9f/structblaze_1_1Ceil.html">Ceil</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b">blaze::ceil</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga38cb77691633d93f6b0b2fc55146a04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b">More...</a><br /></td></tr>
<tr class="separator:ga38cb77691633d93f6b0b2fc55146a04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69688d5359655080afd417a1d7fdbf40"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga69688d5359655080afd417a1d7fdbf40"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d23/structblaze_1_1Trunc.html">Trunc</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40">blaze::trunc</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga69688d5359655080afd417a1d7fdbf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40">More...</a><br /></td></tr>
<tr class="separator:ga69688d5359655080afd417a1d7fdbf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeda0fbc301f6a9849bd1aedb24e3c4bc"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaeda0fbc301f6a9849bd1aedb24e3c4bc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d83/structblaze_1_1Round.html">Round</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc">blaze::round</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaeda0fbc301f6a9849bd1aedb24e3c4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc">More...</a><br /></td></tr>
<tr class="separator:gaeda0fbc301f6a9849bd1aedb24e3c4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b5c9bdbb7e7ea2c008808d235f7055"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga23b5c9bdbb7e7ea2c008808d235f7055"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../db/ddf/structblaze_1_1Conj.html">Conj</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga23b5c9bdbb7e7ea2c008808d235f7055">blaze::conj</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga23b5c9bdbb7e7ea2c008808d235f7055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the complex conjugate of each single element of <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga23b5c9bdbb7e7ea2c008808d235f7055">More...</a><br /></td></tr>
<tr class="separator:ga23b5c9bdbb7e7ea2c008808d235f7055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48020f64de98036286379dacfa444750"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga48020f64de98036286379dacfa444750"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">CTransExprTrait_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga48020f64de98036286379dacfa444750">blaze::ctrans</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga48020f64de98036286379dacfa444750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate transpose matrix of <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga48020f64de98036286379dacfa444750">More...</a><br /></td></tr>
<tr class="separator:ga48020f64de98036286379dacfa444750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146e7401b84cc73dc213edc50bf3a236"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga146e7401b84cc73dc213edc50bf3a236"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../dd/df4/structblaze_1_1Real.html">Real</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga146e7401b84cc73dc213edc50bf3a236">blaze::real</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga146e7401b84cc73dc213edc50bf3a236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the real part of each single element of <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga146e7401b84cc73dc213edc50bf3a236">More...</a><br /></td></tr>
<tr class="separator:ga146e7401b84cc73dc213edc50bf3a236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga801fe45f59d396249b21d1e4f686f427"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga801fe45f59d396249b21d1e4f686f427"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/d61/structblaze_1_1Imag.html">Imag</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga801fe45f59d396249b21d1e4f686f427">blaze::imag</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga801fe45f59d396249b21d1e4f686f427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the imaginary part of each single element of <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga801fe45f59d396249b21d1e4f686f427">More...</a><br /></td></tr>
<tr class="separator:ga801fe45f59d396249b21d1e4f686f427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga660a4e2de4b63aac4181af49ac9160d8"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga660a4e2de4b63aac4181af49ac9160d8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d0/d06/structblaze_1_1Sqrt.html">Sqrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">blaze::sqrt</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga660a4e2de4b63aac4181af49ac9160d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">More...</a><br /></td></tr>
<tr class="separator:ga660a4e2de4b63aac4181af49ac9160d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e33f65ba5d0b7f32fe15b818d6914e6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga8e33f65ba5d0b7f32fe15b818d6914e6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/d20/structblaze_1_1InvSqrt.html">InvSqrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e33f65ba5d0b7f32fe15b818d6914e6">blaze::invsqrt</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga8e33f65ba5d0b7f32fe15b818d6914e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse square root of each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga8e33f65ba5d0b7f32fe15b818d6914e6">More...</a><br /></td></tr>
<tr class="separator:ga8e33f65ba5d0b7f32fe15b818d6914e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62c4f8c97f9e6fde1781a9ed1c0a1a62"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga62c4f8c97f9e6fde1781a9ed1c0a1a62"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d6/d4c/structblaze_1_1Cbrt.html">Cbrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62">blaze::cbrt</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga62c4f8c97f9e6fde1781a9ed1c0a1a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cubic root of each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62">More...</a><br /></td></tr>
<tr class="separator:ga62c4f8c97f9e6fde1781a9ed1c0a1a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga683192b628e107e6082a6b6876d62614"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga683192b628e107e6082a6b6876d62614"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d2/d2f/structblaze_1_1InvCbrt.html">InvCbrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga683192b628e107e6082a6b6876d62614">blaze::invcbrt</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga683192b628e107e6082a6b6876d62614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cubic root of each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga683192b628e107e6082a6b6876d62614">More...</a><br /></td></tr>
<tr class="separator:ga683192b628e107e6082a6b6876d62614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadebfde9b2a5daf6d821e81ac96aa0b94"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename DT &gt; </td></tr>
<tr class="memitem:gadebfde9b2a5daf6d821e81ac96aa0b94"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d0/d65/structblaze_1_1Clip.html">Clip</a>&lt; DT &gt;, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gadebfde9b2a5daf6d821e81ac96aa0b94">blaze::clip</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>)</td></tr>
<tr class="memdesc:gadebfde9b2a5daf6d821e81ac96aa0b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts each single element of the dense matrix <em>dm</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_94.png"/>.  <a href="../../db/df0/group__dense__matrix.html#gadebfde9b2a5daf6d821e81ac96aa0b94">More...</a><br /></td></tr>
<tr class="separator:gadebfde9b2a5daf6d821e81ac96aa0b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b65a79150f5e9e3118257b2f77a0ed"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename ET &gt; </td></tr>
<tr class="memitem:ga04b65a79150f5e9e3118257b2f77a0ed"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/d41/structblaze_1_1Pow.html">Pow</a>&lt; ET &gt;, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga04b65a79150f5e9e3118257b2f77a0ed">blaze::pow</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm, ET <a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">exp</a>)</td></tr>
<tr class="memdesc:ga04b65a79150f5e9e3118257b2f77a0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponential value for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga04b65a79150f5e9e3118257b2f77a0ed">More...</a><br /></td></tr>
<tr class="separator:ga04b65a79150f5e9e3118257b2f77a0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3face2f497ce3065754db58ce162d4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gace3face2f497ce3065754db58ce162d4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/d45/structblaze_1_1Exp.html">Exp</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">blaze::exp</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gace3face2f497ce3065754db58ce162d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">More...</a><br /></td></tr>
<tr class="separator:gace3face2f497ce3065754db58ce162d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb31fcefbc91f1a5ec339dab928b5576"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gabb31fcefbc91f1a5ec339dab928b5576"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/dbb/structblaze_1_1Exp2.html">Exp2</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576">blaze::exp2</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gabb31fcefbc91f1a5ec339dab928b5576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576">More...</a><br /></td></tr>
<tr class="separator:gabb31fcefbc91f1a5ec339dab928b5576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad36748177b43e944319b880e50f238f2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad36748177b43e944319b880e50f238f2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../db/dc8/structblaze_1_1Exp10.html">Exp10</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2">blaze::exp10</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gad36748177b43e944319b880e50f238f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2">More...</a><br /></td></tr>
<tr class="separator:gad36748177b43e944319b880e50f238f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8359ccb837055c7056c1eae56c45eb1a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga8359ccb837055c7056c1eae56c45eb1a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/d9c/structblaze_1_1Log.html">Log</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8359ccb837055c7056c1eae56c45eb1a">blaze::log</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga8359ccb837055c7056c1eae56c45eb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga8359ccb837055c7056c1eae56c45eb1a">More...</a><br /></td></tr>
<tr class="separator:ga8359ccb837055c7056c1eae56c45eb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba8707d555ca3ec8c6394d9724e2b504"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaba8707d555ca3ec8c6394d9724e2b504"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d5/dc7/structblaze_1_1Log2.html">Log2</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaba8707d555ca3ec8c6394d9724e2b504">blaze::log2</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaba8707d555ca3ec8c6394d9724e2b504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary logarithm for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gaba8707d555ca3ec8c6394d9724e2b504">More...</a><br /></td></tr>
<tr class="separator:gaba8707d555ca3ec8c6394d9724e2b504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979d59d108165583def861daf609d8ca"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga979d59d108165583def861daf609d8ca"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d33/structblaze_1_1Log10.html">Log10</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga979d59d108165583def861daf609d8ca">blaze::log10</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga979d59d108165583def861daf609d8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the common logarithm for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga979d59d108165583def861daf609d8ca">More...</a><br /></td></tr>
<tr class="separator:ga979d59d108165583def861daf609d8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a06568d5cd7314f4a0995a051d68062"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga0a06568d5cd7314f4a0995a051d68062"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d56/structblaze_1_1Sin.html">Sin</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga0a06568d5cd7314f4a0995a051d68062">blaze::sin</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga0a06568d5cd7314f4a0995a051d68062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga0a06568d5cd7314f4a0995a051d68062">More...</a><br /></td></tr>
<tr class="separator:ga0a06568d5cd7314f4a0995a051d68062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4eed6b2d7c8e03d3ba69de01a1e54ff"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gab4eed6b2d7c8e03d3ba69de01a1e54ff"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/dde/structblaze_1_1Asin.html">Asin</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab4eed6b2d7c8e03d3ba69de01a1e54ff">blaze::asin</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gab4eed6b2d7c8e03d3ba69de01a1e54ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse sine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gab4eed6b2d7c8e03d3ba69de01a1e54ff">More...</a><br /></td></tr>
<tr class="separator:gab4eed6b2d7c8e03d3ba69de01a1e54ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4111317de20c08c0a40b10182eee2539"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4111317de20c08c0a40b10182eee2539"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/d59/structblaze_1_1Sinh.html">Sinh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4111317de20c08c0a40b10182eee2539">blaze::sinh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga4111317de20c08c0a40b10182eee2539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga4111317de20c08c0a40b10182eee2539">More...</a><br /></td></tr>
<tr class="separator:ga4111317de20c08c0a40b10182eee2539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga974e5ff97f8d4c431684ca167bf5be3b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga974e5ff97f8d4c431684ca167bf5be3b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d0/d08/structblaze_1_1Asinh.html">Asinh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga974e5ff97f8d4c431684ca167bf5be3b">blaze::asinh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga974e5ff97f8d4c431684ca167bf5be3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga974e5ff97f8d4c431684ca167bf5be3b">More...</a><br /></td></tr>
<tr class="separator:ga974e5ff97f8d4c431684ca167bf5be3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6179f49533c111d0c1ed6b9181aabbe7"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga6179f49533c111d0c1ed6b9181aabbe7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/d0a/structblaze_1_1Cos.html">Cos</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga6179f49533c111d0c1ed6b9181aabbe7">blaze::cos</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga6179f49533c111d0c1ed6b9181aabbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga6179f49533c111d0c1ed6b9181aabbe7">More...</a><br /></td></tr>
<tr class="separator:ga6179f49533c111d0c1ed6b9181aabbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbea0b8e061ed390f6c7767c9104e40e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gabbea0b8e061ed390f6c7767c9104e40e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/db3/structblaze_1_1Acos.html">Acos</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gabbea0b8e061ed390f6c7767c9104e40e">blaze::acos</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gabbea0b8e061ed390f6c7767c9104e40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cosine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gabbea0b8e061ed390f6c7767c9104e40e">More...</a><br /></td></tr>
<tr class="separator:gabbea0b8e061ed390f6c7767c9104e40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb0cfa3ce6e0ca00ef6edf910149858"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga3cb0cfa3ce6e0ca00ef6edf910149858"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/db2/structblaze_1_1Cosh.html">Cosh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga3cb0cfa3ce6e0ca00ef6edf910149858">blaze::cosh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga3cb0cfa3ce6e0ca00ef6edf910149858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga3cb0cfa3ce6e0ca00ef6edf910149858">More...</a><br /></td></tr>
<tr class="separator:ga3cb0cfa3ce6e0ca00ef6edf910149858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdfd453cc8c85f2c9d65bc5d82eb52e5"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gafdfd453cc8c85f2c9d65bc5d82eb52e5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../dd/d35/structblaze_1_1Acosh.html">Acosh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gafdfd453cc8c85f2c9d65bc5d82eb52e5">blaze::acosh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gafdfd453cc8c85f2c9d65bc5d82eb52e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gafdfd453cc8c85f2c9d65bc5d82eb52e5">More...</a><br /></td></tr>
<tr class="separator:gafdfd453cc8c85f2c9d65bc5d82eb52e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90be532925f9874efae43a23918194ce"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga90be532925f9874efae43a23918194ce"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../db/d5e/structblaze_1_1Tan.html">Tan</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga90be532925f9874efae43a23918194ce">blaze::tan</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga90be532925f9874efae43a23918194ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga90be532925f9874efae43a23918194ce">More...</a><br /></td></tr>
<tr class="separator:ga90be532925f9874efae43a23918194ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab63e8615abfd73eea11c190846d8f14b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gab63e8615abfd73eea11c190846d8f14b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/dfc/structblaze_1_1Atan.html">Atan</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab63e8615abfd73eea11c190846d8f14b">blaze::atan</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gab63e8615abfd73eea11c190846d8f14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse tangent for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gab63e8615abfd73eea11c190846d8f14b">More...</a><br /></td></tr>
<tr class="separator:gab63e8615abfd73eea11c190846d8f14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3e7dda64b4203c08bf00bc0813b4d05"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac3e7dda64b4203c08bf00bc0813b4d05"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/db7/structblaze_1_1Tanh.html">Tanh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gac3e7dda64b4203c08bf00bc0813b4d05">blaze::tanh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gac3e7dda64b4203c08bf00bc0813b4d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gac3e7dda64b4203c08bf00bc0813b4d05">More...</a><br /></td></tr>
<tr class="separator:gac3e7dda64b4203c08bf00bc0813b4d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf39e95469abfd502a43219461590266a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf39e95469abfd502a43219461590266a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d4d/structblaze_1_1Atanh.html">Atanh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaf39e95469abfd502a43219461590266a">blaze::atanh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaf39e95469abfd502a43219461590266a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gaf39e95469abfd502a43219461590266a">More...</a><br /></td></tr>
<tr class="separator:gaf39e95469abfd502a43219461590266a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab93959cccb52b78dccb927b9ea0afafe"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gab93959cccb52b78dccb927b9ea0afafe"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../dd/d2c/structblaze_1_1Erf.html">Erf</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab93959cccb52b78dccb927b9ea0afafe">blaze::erf</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gab93959cccb52b78dccb927b9ea0afafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gab93959cccb52b78dccb927b9ea0afafe">More...</a><br /></td></tr>
<tr class="separator:gab93959cccb52b78dccb927b9ea0afafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8444088c1f7a23fe9ca5d44f8b736b6a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga8444088c1f7a23fe9ca5d44f8b736b6a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d5a/structblaze_1_1Erfc.html">Erfc</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8444088c1f7a23fe9ca5d44f8b736b6a">blaze::erfc</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga8444088c1f7a23fe9ca5d44f8b736b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complementary error function for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga8444088c1f7a23fe9ca5d44f8b736b6a">More...</a><br /></td></tr>
<tr class="separator:ga8444088c1f7a23fe9ca5d44f8b736b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f1c5357c878446236a3b6b3d0e107c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad2f1c5357c878446236a3b6b3d0e107c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d92/classblaze_1_1DMatInvExpr.html">DMatInvExpr</a>&lt; MT, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gad2f1c5357c878446236a3b6b3d0e107c">blaze::inv</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gad2f1c5357c878446236a3b6b3d0e107c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the inverse of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#gad2f1c5357c878446236a3b6b3d0e107c">More...</a><br /></td></tr>
<tr class="separator:gad2f1c5357c878446236a3b6b3d0e107c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3cd8bdcaaf316731c036deba11f2caa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:gaf3cd8bdcaaf316731c036deba11f2caa"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">DivExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaf3cd8bdcaaf316731c036deba11f2caa">blaze::operator/</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:gaf3cd8bdcaaf316731c036deba11f2caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the division of a dense matrix by a scalar value ( <img class="formulaInl" alt="$ A=B/s $" src="../../form_100.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaf3cd8bdcaaf316731c036deba11f2caa">More...</a><br /></td></tr>
<tr class="separator:gaf3cd8bdcaaf316731c036deba11f2caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3651e36c48fc68d45e799bef5163ea2e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga3651e36c48fc68d45e799bef5163ea2e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d8b/classblaze_1_1DMatScalarMultExpr.html">DMatScalarMultExpr</a>&lt; MT, <a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">UnderlyingBuiltin_</a>&lt; MT &gt;, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga3651e36c48fc68d45e799bef5163ea2e">blaze::operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga3651e36c48fc68d45e799bef5163ea2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a dense matrix ( <img class="formulaInl" alt="$ A = -B $" src="../../form_101.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga3651e36c48fc68d45e799bef5163ea2e">More...</a><br /></td></tr>
<tr class="separator:ga3651e36c48fc68d45e799bef5163ea2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9c6c94ca79de19a79b899e9bd4fe64"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga6c9c6c94ca79de19a79b899e9bd4fe64"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga6c9c6c94ca79de19a79b899e9bd4fe64">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga6c9c6c94ca79de19a79b899e9bd4fe64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense matrix and a scalar value ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_43.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga6c9c6c94ca79de19a79b899e9bd4fe64">More...</a><br /></td></tr>
<tr class="separator:ga6c9c6c94ca79de19a79b899e9bd4fe64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f085717ded20508025d1f1e1f753cdb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga4f085717ded20508025d1f1e1f753cdb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4f085717ded20508025d1f1e1f753cdb">blaze::operator*</a> (T1 scalar, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga4f085717ded20508025d1f1e1f753cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a dense matrix ( <img class="formulaInl" alt="$ A=s*B $" src="../../form_102.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga4f085717ded20508025d1f1e1f753cdb">More...</a><br /></td></tr>
<tr class="separator:ga4f085717ded20508025d1f1e1f753cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeac3b9aff5df5e547819e485321f4762"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaeac3b9aff5df5e547819e485321f4762"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dec/classblaze_1_1DMatSerialExpr.html">DMatSerialExpr</a>&lt; MT, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaeac3b9aff5df5e547819e485321f4762">blaze::serial</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaeac3b9aff5df5e547819e485321f4762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the serial evaluation of the given dense matrix expression <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gaeac3b9aff5df5e547819e485321f4762">More...</a><br /></td></tr>
<tr class="separator:gaeac3b9aff5df5e547819e485321f4762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694fc9c7f56eeb00d82c413d5d94cf77"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga694fc9c7f56eeb00d82c413d5d94cf77"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d65/classblaze_1_1DMatSMatAddExpr.html">DMatSMatAddExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga694fc9c7f56eeb00d82c413d5d94cf77">blaze::operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga694fc9c7f56eeb00d82c413d5d94cf77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a dense matrix and a sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga694fc9c7f56eeb00d82c413d5d94cf77">More...</a><br /></td></tr>
<tr class="separator:ga694fc9c7f56eeb00d82c413d5d94cf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39f46fd8e099778f075cef873b15947c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga39f46fd8e099778f075cef873b15947c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d65/classblaze_1_1DMatSMatAddExpr.html">DMatSMatAddExpr</a>&lt; T2, T1, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga39f46fd8e099778f075cef873b15947c">blaze::operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga39f46fd8e099778f075cef873b15947c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a sparse matrix and a dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga39f46fd8e099778f075cef873b15947c">More...</a><br /></td></tr>
<tr class="separator:ga39f46fd8e099778f075cef873b15947c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a69a009d857b36f4b607edbeede502a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2a69a009d857b36f4b607edbeede502a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/d2b/classblaze_1_1DMatSMatMultExpr.html">DMatSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga2a69a009d857b36f4b607edbeede502a">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga2a69a009d857b36f4b607edbeede502a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga2a69a009d857b36f4b607edbeede502a">More...</a><br /></td></tr>
<tr class="separator:ga2a69a009d857b36f4b607edbeede502a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f1afd8e1de67f79795d150708931b9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga02f1afd8e1de67f79795d150708931b9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/deb/classblaze_1_1DMatSMatSubExpr.html">DMatSMatSubExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga02f1afd8e1de67f79795d150708931b9">blaze::operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga02f1afd8e1de67f79795d150708931b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a dense matrix and a sparse matrix with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga02f1afd8e1de67f79795d150708931b9">More...</a><br /></td></tr>
<tr class="separator:ga02f1afd8e1de67f79795d150708931b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a4fe8ed77e301a17800b299a83f5fa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga08a4fe8ed77e301a17800b299a83f5fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T1 &gt; &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T2 &gt; &gt; &gt;, const <a class="el" href="../../df/dbe/classblaze_1_1DMatTDMatAddExpr.html">DMatTDMatAddExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga08a4fe8ed77e301a17800b299a83f5fa">blaze::operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga08a4fe8ed77e301a17800b299a83f5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major and a colum-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga08a4fe8ed77e301a17800b299a83f5fa">More...</a><br /></td></tr>
<tr class="separator:ga08a4fe8ed77e301a17800b299a83f5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe0f6bf94d6ac4714cd7258a456140f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1fe0f6bf94d6ac4714cd7258a456140f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T1 &gt; &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T2 &gt; &gt; &gt;, const <a class="el" href="../../df/dbe/classblaze_1_1DMatTDMatAddExpr.html">DMatTDMatAddExpr</a>&lt; T2, T1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1fe0f6bf94d6ac4714cd7258a456140f">blaze::operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1fe0f6bf94d6ac4714cd7258a456140f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga1fe0f6bf94d6ac4714cd7258a456140f">More...</a><br /></td></tr>
<tr class="separator:ga1fe0f6bf94d6ac4714cd7258a456140f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5707ef23374bab4bee818b45edff483f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5707ef23374bab4bee818b45edff483f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d8a/classblaze_1_1DMatTDMatMultExpr.html">DMatTDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga5707ef23374bab4bee818b45edff483f">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5707ef23374bab4bee818b45edff483f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga5707ef23374bab4bee818b45edff483f">More...</a><br /></td></tr>
<tr class="separator:ga5707ef23374bab4bee818b45edff483f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b78e6b3967de95f80bb323923a38de4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5b78e6b3967de95f80bb323923a38de4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T1 &gt; &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T2 &gt; &gt; &gt;, const <a class="el" href="../../d8/d16/classblaze_1_1DMatTDMatSubExpr.html">DMatTDMatSubExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga5b78e6b3967de95f80bb323923a38de4">blaze::operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5b78e6b3967de95f80bb323923a38de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga5b78e6b3967de95f80bb323923a38de4">More...</a><br /></td></tr>
<tr class="separator:ga5b78e6b3967de95f80bb323923a38de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f4aef71c7832d132164838d3abad54c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2f4aef71c7832d132164838d3abad54c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T1 &gt; &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T2 &gt; &gt; &gt;, const <a class="el" href="../../d8/d16/classblaze_1_1DMatTDMatSubExpr.html">DMatTDMatSubExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga2f4aef71c7832d132164838d3abad54c">blaze::operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga2f4aef71c7832d132164838d3abad54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga2f4aef71c7832d132164838d3abad54c">More...</a><br /></td></tr>
<tr class="separator:ga2f4aef71c7832d132164838d3abad54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33cedfb37c70d3758406251f2389ecac"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga33cedfb37c70d3758406251f2389ecac"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/d86/classblaze_1_1DMatTransExpr.html">DMatTransExpr</a>&lt; MT,!SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">blaze::trans</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga33cedfb37c70d3758406251f2389ecac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">More...</a><br /></td></tr>
<tr class="separator:ga33cedfb37c70d3758406251f2389ecac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9b2e3869791221577cba8ab897ad68"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gacb9b2e3869791221577cba8ab897ad68"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d61/classblaze_1_1DMatTSMatAddExpr.html">DMatTSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gacb9b2e3869791221577cba8ab897ad68">blaze::operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacb9b2e3869791221577cba8ab897ad68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gacb9b2e3869791221577cba8ab897ad68">More...</a><br /></td></tr>
<tr class="separator:gacb9b2e3869791221577cba8ab897ad68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1119e6cc68946e48a0620679bd6d06"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7f1119e6cc68946e48a0620679bd6d06"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d61/classblaze_1_1DMatTSMatAddExpr.html">DMatTSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7f1119e6cc68946e48a0620679bd6d06">blaze::operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7f1119e6cc68946e48a0620679bd6d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga7f1119e6cc68946e48a0620679bd6d06">More...</a><br /></td></tr>
<tr class="separator:ga7f1119e6cc68946e48a0620679bd6d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82218827b4f2e2748e9fec868b66690"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gad82218827b4f2e2748e9fec868b66690"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/ddc/classblaze_1_1DMatTSMatMultExpr.html">DMatTSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gad82218827b4f2e2748e9fec868b66690">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad82218827b4f2e2748e9fec868b66690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gad82218827b4f2e2748e9fec868b66690">More...</a><br /></td></tr>
<tr class="separator:gad82218827b4f2e2748e9fec868b66690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a348f4c6ca1ff497f56003dd22cb66"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gad2a348f4c6ca1ff497f56003dd22cb66"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/d76/classblaze_1_1DMatTSMatSubExpr.html">DMatTSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gad2a348f4c6ca1ff497f56003dd22cb66">blaze::operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad2a348f4c6ca1ff497f56003dd22cb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gad2a348f4c6ca1ff497f56003dd22cb66">More...</a><br /></td></tr>
<tr class="separator:gad2a348f4c6ca1ff497f56003dd22cb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga282c791c739c8c0d1d8e7c82bf0391ad"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga282c791c739c8c0d1d8e7c82bf0391ad"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/dcd/classblaze_1_1DVecTDVecMultExpr.html">DVecTDVecMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga282c791c739c8c0d1d8e7c82bf0391ad">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga282c791c739c8c0d1d8e7c82bf0391ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the outer product of two dense vectors ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_113.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga282c791c739c8c0d1d8e7c82bf0391ad">More...</a><br /></td></tr>
<tr class="separator:ga282c791c739c8c0d1d8e7c82bf0391ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2332eeb931fe442419745885fc0bac"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaff2332eeb931fe442419745885fc0bac"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/dc5/classblaze_1_1SMatDMatMultExpr.html">SMatDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaff2332eeb931fe442419745885fc0bac">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaff2332eeb931fe442419745885fc0bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaff2332eeb931fe442419745885fc0bac">More...</a><br /></td></tr>
<tr class="separator:gaff2332eeb931fe442419745885fc0bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7889e29abeda750915b8c5a2fc061242"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga7889e29abeda750915b8c5a2fc061242"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/db6/classblaze_1_1SMatDMatSubExpr.html">SMatDMatSubExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7889e29abeda750915b8c5a2fc061242">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7889e29abeda750915b8c5a2fc061242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a sparse matrix and a dense matrix with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga7889e29abeda750915b8c5a2fc061242">More...</a><br /></td></tr>
<tr class="separator:ga7889e29abeda750915b8c5a2fc061242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd88fb6252c24b32b19dcf37f3c79196"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gafd88fb6252c24b32b19dcf37f3c79196"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d43/classblaze_1_1SMatTDMatMultExpr.html">SMatTDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gafd88fb6252c24b32b19dcf37f3c79196">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gafd88fb6252c24b32b19dcf37f3c79196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gafd88fb6252c24b32b19dcf37f3c79196">More...</a><br /></td></tr>
<tr class="separator:gafd88fb6252c24b32b19dcf37f3c79196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1720d2f0702c0f77bc4991a287d98d1e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1720d2f0702c0f77bc4991a287d98d1e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/de7/classblaze_1_1SMatTDMatSubExpr.html">SMatTDMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1720d2f0702c0f77bc4991a287d98d1e">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1720d2f0702c0f77bc4991a287d98d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga1720d2f0702c0f77bc4991a287d98d1e">More...</a><br /></td></tr>
<tr class="separator:ga1720d2f0702c0f77bc4991a287d98d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab99703844f7b1351016e47780277efb7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gab99703844f7b1351016e47780277efb7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/dc9/classblaze_1_1TDMatDMatMultExpr.html">TDMatDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab99703844f7b1351016e47780277efb7">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab99703844f7b1351016e47780277efb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gab99703844f7b1351016e47780277efb7">More...</a><br /></td></tr>
<tr class="separator:gab99703844f7b1351016e47780277efb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b0a2b26e02f2ca345af2094585db4be"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga4b0a2b26e02f2ca345af2094585db4be"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d0c/classblaze_1_1TDMatSMatAddExpr.html">TDMatSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4b0a2b26e02f2ca345af2094585db4be">blaze::operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4b0a2b26e02f2ca345af2094585db4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga4b0a2b26e02f2ca345af2094585db4be">More...</a><br /></td></tr>
<tr class="separator:ga4b0a2b26e02f2ca345af2094585db4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d0526756a2befd345af87726c5014e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga72d0526756a2befd345af87726c5014e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d0c/classblaze_1_1TDMatSMatAddExpr.html">TDMatSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga72d0526756a2befd345af87726c5014e">blaze::operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga72d0526756a2befd345af87726c5014e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga72d0526756a2befd345af87726c5014e">More...</a><br /></td></tr>
<tr class="separator:ga72d0526756a2befd345af87726c5014e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fc6107dda539d41695e8f9f2ebf005c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7fc6107dda539d41695e8f9f2ebf005c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/dfb/classblaze_1_1TDMatSMatMultExpr.html">TDMatSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7fc6107dda539d41695e8f9f2ebf005c">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7fc6107dda539d41695e8f9f2ebf005c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga7fc6107dda539d41695e8f9f2ebf005c">More...</a><br /></td></tr>
<tr class="separator:ga7fc6107dda539d41695e8f9f2ebf005c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa31b65149566c26b3f8d9d75ca24c6e5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa31b65149566c26b3f8d9d75ca24c6e5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/d5b/classblaze_1_1TDMatSMatSubExpr.html">TDMatSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa31b65149566c26b3f8d9d75ca24c6e5">blaze::operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa31b65149566c26b3f8d9d75ca24c6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaa31b65149566c26b3f8d9d75ca24c6e5">More...</a><br /></td></tr>
<tr class="separator:gaa31b65149566c26b3f8d9d75ca24c6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaebf997f6e7e5fa0809d404ee89c2d7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gabaebf997f6e7e5fa0809d404ee89c2d7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6f/classblaze_1_1TDMatTDMatMultExpr.html">TDMatTDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gabaebf997f6e7e5fa0809d404ee89c2d7">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabaebf997f6e7e5fa0809d404ee89c2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two column-major dense matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gabaebf997f6e7e5fa0809d404ee89c2d7">More...</a><br /></td></tr>
<tr class="separator:gabaebf997f6e7e5fa0809d404ee89c2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55603ebcaa45b68183c06b156040cabb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga55603ebcaa45b68183c06b156040cabb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d9c/classblaze_1_1TDMatTSMatMultExpr.html">TDMatTSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga55603ebcaa45b68183c06b156040cabb">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga55603ebcaa45b68183c06b156040cabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga55603ebcaa45b68183c06b156040cabb">More...</a><br /></td></tr>
<tr class="separator:ga55603ebcaa45b68183c06b156040cabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga209020467da5fef99d7cb44d22094e19"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga209020467da5fef99d7cb44d22094e19"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;, <a class="el" href="../../db/de4/classblaze_1_1TDVecTDMatMultExpr.html">TDVecTDMatMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga209020467da5fef99d7cb44d22094e19">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga209020467da5fef99d7cb44d22094e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a column-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga209020467da5fef99d7cb44d22094e19">More...</a><br /></td></tr>
<tr class="separator:ga209020467da5fef99d7cb44d22094e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac91fac7612d334d056573a01255a42f5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gac91fac7612d334d056573a01255a42f5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/ddb/classblaze_1_1TSMatDMatMultExpr.html">TSMatDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gac91fac7612d334d056573a01255a42f5">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac91fac7612d334d056573a01255a42f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gac91fac7612d334d056573a01255a42f5">More...</a><br /></td></tr>
<tr class="separator:gac91fac7612d334d056573a01255a42f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a19e16624e4520852a11d2a443d1ba5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2a19e16624e4520852a11d2a443d1ba5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d71/classblaze_1_1TSMatDMatSubExpr.html">TSMatDMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga2a19e16624e4520852a11d2a443d1ba5">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga2a19e16624e4520852a11d2a443d1ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga2a19e16624e4520852a11d2a443d1ba5">More...</a><br /></td></tr>
<tr class="separator:ga2a19e16624e4520852a11d2a443d1ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61db726d567fb847824781084a1a04a8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga61db726d567fb847824781084a1a04a8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d9f/classblaze_1_1TSMatTDMatMultExpr.html">TSMatTDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga61db726d567fb847824781084a1a04a8">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga61db726d567fb847824781084a1a04a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga61db726d567fb847824781084a1a04a8">More...</a><br /></td></tr>
<tr class="separator:ga61db726d567fb847824781084a1a04a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5432998c612b5dc4e417cea2fecaa2fb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5432998c612b5dc4e417cea2fecaa2fb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;, <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga5432998c612b5dc4e417cea2fecaa2fb">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga5432998c612b5dc4e417cea2fecaa2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a row-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga5432998c612b5dc4e417cea2fecaa2fb">More...</a><br /></td></tr>
<tr class="separator:ga5432998c612b5dc4e417cea2fecaa2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseMatrix operators</h2></td></tr>
<tr class="memitem:ga7120542028164e84f57b2bd0daf1ed07"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7120542028164e84f57b2bd0daf1ed07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7120542028164e84f57b2bd0daf1ed07">blaze::operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7120542028164e84f57b2bd0daf1ed07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two rwo-major dense matrices.  <a href="../../db/df0/group__dense__matrix.html#ga7120542028164e84f57b2bd0daf1ed07">More...</a><br /></td></tr>
<tr class="separator:ga7120542028164e84f57b2bd0daf1ed07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e85fa1492d985e034b7ca152d69dac2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga3e85fa1492d985e034b7ca152d69dac2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga3e85fa1492d985e034b7ca152d69dac2">blaze::operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3e85fa1492d985e034b7ca152d69dac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two column-major dense matrices.  <a href="../../db/df0/group__dense__matrix.html#ga3e85fa1492d985e034b7ca152d69dac2">More...</a><br /></td></tr>
<tr class="separator:ga3e85fa1492d985e034b7ca152d69dac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gacff1ea4c8128a09b47db0c324da5c2f0">blaze::operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two dense matrices with different storage order.  <a href="../../db/df0/group__dense__matrix.html#gacff1ea4c8128a09b47db0c324da5c2f0">More...</a><br /></td></tr>
<tr class="separator:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga192685ae7dfdfa74ee94a9d6c51d1809">blaze::operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense matrix and a row-major sparse matrix.  <a href="../../db/df0/group__dense__matrix.html#ga192685ae7dfdfa74ee94a9d6c51d1809">More...</a><br /></td></tr>
<tr class="separator:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8212c8f46b5a2e31e355922f8fc2e3fc">blaze::operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense matrix and a column-major sparse matrix.  <a href="../../db/df0/group__dense__matrix.html#ga8212c8f46b5a2e31e355922f8fc2e3fc">More...</a><br /></td></tr>
<tr class="separator:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242470c706af7ba3a96eb35a1816b4cf"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga242470c706af7ba3a96eb35a1816b4cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga242470c706af7ba3a96eb35a1816b4cf">blaze::operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga242470c706af7ba3a96eb35a1816b4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a sparse matrix and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga242470c706af7ba3a96eb35a1816b4cf">More...</a><br /></td></tr>
<tr class="separator:ga242470c706af7ba3a96eb35a1816b4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11775fe4d60690cbdc76e71ccb71c545"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga11775fe4d60690cbdc76e71ccb71c545"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga11775fe4d60690cbdc76e71ccb71c545">blaze::operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga11775fe4d60690cbdc76e71ccb71c545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a row-major dense matrix and a scalar value.  <a href="../../db/df0/group__dense__matrix.html#ga11775fe4d60690cbdc76e71ccb71c545">More...</a><br /></td></tr>
<tr class="separator:ga11775fe4d60690cbdc76e71ccb71c545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3947c9d43314d45fb4e000ff4a08859"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gab3947c9d43314d45fb4e000ff4a08859"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab3947c9d43314d45fb4e000ff4a08859">blaze::operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:gab3947c9d43314d45fb4e000ff4a08859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a column-major dense matrix and a scalar value.  <a href="../../db/df0/group__dense__matrix.html#gab3947c9d43314d45fb4e000ff4a08859">More...</a><br /></td></tr>
<tr class="separator:gab3947c9d43314d45fb4e000ff4a08859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga52848b40fa0e5a7f72bdcdd92d68f032">blaze::operator!=</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two dense matrices.  <a href="../../db/df0/group__dense__matrix.html#ga52848b40fa0e5a7f72bdcdd92d68f032">More...</a><br /></td></tr>
<tr class="separator:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174d0a369968b438ed23725b3361283c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga174d0a369968b438ed23725b3361283c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga174d0a369968b438ed23725b3361283c">blaze::operator!=</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga174d0a369968b438ed23725b3361283c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense matrix and a sparse matrix.  <a href="../../db/df0/group__dense__matrix.html#ga174d0a369968b438ed23725b3361283c">More...</a><br /></td></tr>
<tr class="separator:ga174d0a369968b438ed23725b3361283c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa83dce66f3d82b99bb0dd83aa3efb7a4">blaze::operator!=</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a sparse matrix and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#gaa83dce66f3d82b99bb0dd83aa3efb7a4">More...</a><br /></td></tr>
<tr class="separator:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bb8b9fb92ead32a2907a21c4bd81a91"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga5bb8b9fb92ead32a2907a21c4bd81a91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga5bb8b9fb92ead32a2907a21c4bd81a91">blaze::operator!=</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga5bb8b9fb92ead32a2907a21c4bd81a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense matrix and a scalar value.  <a href="../../db/df0/group__dense__matrix.html#ga5bb8b9fb92ead32a2907a21c4bd81a91">More...</a><br /></td></tr>
<tr class="separator:ga5bb8b9fb92ead32a2907a21c4bd81a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseMatrix functions</h2></td></tr>
<tr class="memitem:ga99ba6a5b32152077ba7d013be1add4dc"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga99ba6a5b32152077ba7d013be1add4dc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga99ba6a5b32152077ba7d013be1add4dc">blaze::isnan</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga99ba6a5b32152077ba7d013be1add4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given dense matrix for not-a-number elements.  <a href="../../db/df0/group__dense__matrix.html#ga99ba6a5b32152077ba7d013be1add4dc">More...</a><br /></td></tr>
<tr class="separator:ga99ba6a5b32152077ba7d013be1add4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c4333a5647750c5cd126ef9ca5d25b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga54c4333a5647750c5cd126ef9ca5d25b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga54c4333a5647750c5cd126ef9ca5d25b">blaze::isSymmetric</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga54c4333a5647750c5cd126ef9ca5d25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is symmetric.  <a href="../../db/df0/group__dense__matrix.html#ga54c4333a5647750c5cd126ef9ca5d25b">More...</a><br /></td></tr>
<tr class="separator:ga54c4333a5647750c5cd126ef9ca5d25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c4d4b151827b6e300cd949fc33a707a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga2c4d4b151827b6e300cd949fc33a707a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga2c4d4b151827b6e300cd949fc33a707a">blaze::isHermitian</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga2c4d4b151827b6e300cd949fc33a707a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is Hermitian.  <a href="../../db/df0/group__dense__matrix.html#ga2c4d4b151827b6e300cd949fc33a707a">More...</a><br /></td></tr>
<tr class="separator:ga2c4d4b151827b6e300cd949fc33a707a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aafd1dd369f715e523850f4adb36696"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7aafd1dd369f715e523850f4adb36696"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7aafd1dd369f715e523850f4adb36696">blaze::isUniform</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga7aafd1dd369f715e523850f4adb36696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a uniform matrix.  <a href="../../db/df0/group__dense__matrix.html#ga7aafd1dd369f715e523850f4adb36696">More...</a><br /></td></tr>
<tr class="separator:ga7aafd1dd369f715e523850f4adb36696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78ee9a691c9a59c3883f458866f9b76f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga78ee9a691c9a59c3883f458866f9b76f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga78ee9a691c9a59c3883f458866f9b76f">blaze::isLower</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga78ee9a691c9a59c3883f458866f9b76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a lower triangular matrix.  <a href="../../db/df0/group__dense__matrix.html#ga78ee9a691c9a59c3883f458866f9b76f">More...</a><br /></td></tr>
<tr class="separator:ga78ee9a691c9a59c3883f458866f9b76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72556b3671610da96aea635f41d166a1"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga72556b3671610da96aea635f41d166a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga72556b3671610da96aea635f41d166a1">blaze::isUniLower</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga72556b3671610da96aea635f41d166a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a lower unitriangular matrix.  <a href="../../db/df0/group__dense__matrix.html#ga72556b3671610da96aea635f41d166a1">More...</a><br /></td></tr>
<tr class="separator:ga72556b3671610da96aea635f41d166a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a77d7fdc4319a6e74bd6eae4d1c71c1"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7a77d7fdc4319a6e74bd6eae4d1c71c1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7a77d7fdc4319a6e74bd6eae4d1c71c1">blaze::isStrictlyLower</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga7a77d7fdc4319a6e74bd6eae4d1c71c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a strictly lower triangular matrix.  <a href="../../db/df0/group__dense__matrix.html#ga7a77d7fdc4319a6e74bd6eae4d1c71c1">More...</a><br /></td></tr>
<tr class="separator:ga7a77d7fdc4319a6e74bd6eae4d1c71c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e03c886fd6538a6f10dbdbbd4faacd"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac2e03c886fd6538a6f10dbdbbd4faacd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gac2e03c886fd6538a6f10dbdbbd4faacd">blaze::isUpper</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gac2e03c886fd6538a6f10dbdbbd4faacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is an upper triangular matrix.  <a href="../../db/df0/group__dense__matrix.html#gac2e03c886fd6538a6f10dbdbbd4faacd">More...</a><br /></td></tr>
<tr class="separator:gac2e03c886fd6538a6f10dbdbbd4faacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d3d32d95705421514aa1de3da0ef48d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga0d3d32d95705421514aa1de3da0ef48d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga0d3d32d95705421514aa1de3da0ef48d">blaze::isUniUpper</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga0d3d32d95705421514aa1de3da0ef48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is an upper unitriangular matrix.  <a href="../../db/df0/group__dense__matrix.html#ga0d3d32d95705421514aa1de3da0ef48d">More...</a><br /></td></tr>
<tr class="separator:ga0d3d32d95705421514aa1de3da0ef48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1b4b55a81a85ee76379ab19a1a75d64"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa1b4b55a81a85ee76379ab19a1a75d64"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa1b4b55a81a85ee76379ab19a1a75d64">blaze::isStrictlyUpper</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaa1b4b55a81a85ee76379ab19a1a75d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a strictly upper triangular matrix.  <a href="../../db/df0/group__dense__matrix.html#gaa1b4b55a81a85ee76379ab19a1a75d64">More...</a><br /></td></tr>
<tr class="separator:gaa1b4b55a81a85ee76379ab19a1a75d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga144e15e7b1f40485ed2dac1f51ba5083"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga144e15e7b1f40485ed2dac1f51ba5083"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga144e15e7b1f40485ed2dac1f51ba5083">blaze::isDiagonal</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga144e15e7b1f40485ed2dac1f51ba5083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the give dense matrix is diagonal.  <a href="../../db/df0/group__dense__matrix.html#ga144e15e7b1f40485ed2dac1f51ba5083">More...</a><br /></td></tr>
<tr class="separator:ga144e15e7b1f40485ed2dac1f51ba5083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3674413b281f83fcc81e3a6b2dea188"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa3674413b281f83fcc81e3a6b2dea188"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa3674413b281f83fcc81e3a6b2dea188">blaze::isIdentity</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaa3674413b281f83fcc81e3a6b2dea188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the give dense matrix is an identity matrix.  <a href="../../db/df0/group__dense__matrix.html#gaa3674413b281f83fcc81e3a6b2dea188">More...</a><br /></td></tr>
<tr class="separator:gaa3674413b281f83fcc81e3a6b2dea188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1147d0f93d7cc6fad33935048f2b058e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga1147d0f93d7cc6fad33935048f2b058e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">blaze::min</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga1147d0f93d7cc6fad33935048f2b058e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">More...</a><br /></td></tr>
<tr class="separator:ga1147d0f93d7cc6fad33935048f2b058e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ae2749f3a298c7927a4f7f85407e2c4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga6ae2749f3a298c7927a4f7f85407e2c4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">blaze::max</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga6ae2749f3a298c7927a4f7f85407e2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">More...</a><br /></td></tr>
<tr class="separator:ga6ae2749f3a298c7927a4f7f85407e2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Inversion functions</h2></td></tr>
<tr class="memitem:ga1703390e63b9cb5b805ab5b4718ddda3"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga1703390e63b9cb5b805ab5b4718ddda3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1703390e63b9cb5b805ab5b4718ddda3">blaze::invert</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga1703390e63b9cb5b805ab5b4718ddda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga1703390e63b9cb5b805ab5b4718ddda3">More...</a><br /></td></tr>
<tr class="separator:ga1703390e63b9cb5b805ab5b4718ddda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0fd934e9c1b84cc2588cfe142c55a4"><td class="memTemplParams" colspan="2">template&lt;InversionFlag IF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4c0fd934e9c1b84cc2588cfe142c55a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4c0fd934e9c1b84cc2588cfe142c55a4">blaze::invert</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga4c0fd934e9c1b84cc2588cfe142c55a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga4c0fd934e9c1b84cc2588cfe142c55a4">More...</a><br /></td></tr>
<tr class="separator:ga4c0fd934e9c1b84cc2588cfe142c55a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
LLH decomposition functions</h2></td></tr>
<tr class="memitem:ga63e7f6efe504ec8f7416decef5446662"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga63e7f6efe504ec8f7416decef5446662"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga63e7f6efe504ec8f7416decef5446662">blaze::llh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;L)</td></tr>
<tr class="memdesc:ga63e7f6efe504ec8f7416decef5446662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cholesky (LLH) decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga63e7f6efe504ec8f7416decef5446662">More...</a><br /></td></tr>
<tr class="separator:ga63e7f6efe504ec8f7416decef5446662"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
LQ decomposition functions</h2></td></tr>
<tr class="memitem:ga797f2c71d569b9abf5784ff118a308f2"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:ga797f2c71d569b9abf5784ff118a308f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga797f2c71d569b9abf5784ff118a308f2">blaze::lq</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;L, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;Q)</td></tr>
<tr class="memdesc:ga797f2c71d569b9abf5784ff118a308f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">LQ decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga797f2c71d569b9abf5784ff118a308f2">More...</a><br /></td></tr>
<tr class="separator:ga797f2c71d569b9abf5784ff118a308f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
LU decomposition functions</h2></td></tr>
<tr class="memitem:ga10d699031e948b83afcc0ffc68853d65"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , typename MT3 , typename MT4 , bool SO2&gt; </td></tr>
<tr class="memitem:ga10d699031e948b83afcc0ffc68853d65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65">blaze::lu</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO1 &gt; &amp;L, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO1 &gt; &amp;U, <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT4, SO2 &gt; &amp;P)</td></tr>
<tr class="memdesc:ga10d699031e948b83afcc0ffc68853d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">LU decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65">More...</a><br /></td></tr>
<tr class="separator:ga10d699031e948b83afcc0ffc68853d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
QL decomposition functions</h2></td></tr>
<tr class="memitem:gab7c1c25d32e228f167f4544cc950bf1f"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:gab7c1c25d32e228f167f4544cc950bf1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab7c1c25d32e228f167f4544cc950bf1f">blaze::ql</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;Q, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;L)</td></tr>
<tr class="memdesc:gab7c1c25d32e228f167f4544cc950bf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">QL decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#gab7c1c25d32e228f167f4544cc950bf1f">More...</a><br /></td></tr>
<tr class="separator:gab7c1c25d32e228f167f4544cc950bf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
QR decomposition functions</h2></td></tr>
<tr class="memitem:ga92d7e3366b2e5020229aba1e123235d6"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:ga92d7e3366b2e5020229aba1e123235d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga92d7e3366b2e5020229aba1e123235d6">blaze::qr</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;Q, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;R)</td></tr>
<tr class="memdesc:ga92d7e3366b2e5020229aba1e123235d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">QR decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga92d7e3366b2e5020229aba1e123235d6">More...</a><br /></td></tr>
<tr class="separator:ga92d7e3366b2e5020229aba1e123235d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
RQ decomposition functions</h2></td></tr>
<tr class="memitem:ga28d8769f4cf3189184544ab620949dba"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:ga28d8769f4cf3189184544ab620949dba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga28d8769f4cf3189184544ab620949dba">blaze::rq</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;R, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;Q)</td></tr>
<tr class="memdesc:ga28d8769f4cf3189184544ab620949dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">RQ decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga28d8769f4cf3189184544ab620949dba">More...</a><br /></td></tr>
<tr class="separator:ga28d8769f4cf3189184544ab620949dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Determinant functions</h2></td></tr>
<tr class="memitem:ga152576fa391bcb9a2892063bdf3953f7"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga152576fa391bcb9a2892063bdf3953f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga152576fa391bcb9a2892063bdf3953f7">blaze::det</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga152576fa391bcb9a2892063bdf3953f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> of the determinant of the given dense square matrix.  <a href="../../db/df0/group__dense__matrix.html#ga152576fa391bcb9a2892063bdf3953f7">More...</a><br /></td></tr>
<tr class="separator:ga152576fa391bcb9a2892063bdf3953f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga629e225abfa7be1f41cff40ecd17d5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga629e225abfa7be1f41cff40ecd17d5d5">&sect;&nbsp;</a></span>InversionFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../db/df0/group__dense__matrix.html#ga629e225abfa7be1f41cff40ecd17d5d5">blaze::InversionFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inversion flag.The InversionFlag type enumeration represents the different types of matrix inversion algorithms that are available within the Blaze library. The following flags are available: </p>
<ul>
<li><code>byLU:</code> The default inversion algorithm for general square matrices. It uses the LU algorithm to decompose a matrix into a lower unitriangular matrix <code>L</code>, an upper triangular matrix <code>U</code>, and a permutation matrix <code>P</code> ( <img class="formulaInl" alt="$ A = P L U $" src="../../form_124.png"/>). <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> no permutations are required, <code>P</code> is the identity matrix.</li>
<li><code>byLDLT:</code> The Bunch-Kaufman inversion algorithm for symmetric indefinite matrices. It decomposes the given matrix into either <img class="formulaInl" alt="$ A = U D U^{T} $" src="../../form_125.png"/> or <img class="formulaInl" alt="$ A = L D L^{T} $" src="../../form_126.png"/>, where <code>U</code> (or <code>L</code>) is a product of permutation and unit upper (lower) triangular matrices, and <code>D</code> is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.</li>
<li><code>byLDLH:</code> The Bunch-Kaufman inversion algorithm for Hermitian indefinite matrices. It decomposes the given matrix into either <img class="formulaInl" alt="$ A = U D U^{H} $" src="../../form_127.png"/> or <img class="formulaInl" alt="$ A = L D L^{H} $" src="../../form_128.png"/>, where <code>U</code> (or <code>L</code>) is a product of permutation and unit upper (lower) triangular matrices, and <code>D</code> is Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.</li>
<li><code>byLLH:</code> The Cholesky inversion algorithm for Hermitian positive definite matrices. It decomposes a given matrix into either <img class="formulaInl" alt="$ A = L L^H $" src="../../form_129.png"/>, where <code>L</code> is a lower triangular matrix, or <img class="formulaInl" alt="$ A = U^H U $" src="../../form_130.png"/>, where <code>U</code> is an upper triangular matrix.</li>
</ul>
<p>Alternatively, the type of the matrix can be specified, leaving it to the Blaze library to select the appropriate matrix inversion algorithm. The following flags are available:</p>
<ul>
<li><code>asGeneral:</code> This flag selects the best suited inversion algorithm for general square matrices. In case no further compile time information is available, this will imply the use of the LU decomposition algorithm (see the <code>byLU</code> flag).</li>
<li><code>asSymmetric:</code> This flag selects the most suited inversion algorithm for symmetric matrices. In case no further compile time information is available, the Bunch-Kaufman matrix decomposition algorithm will be used (see the <code>byLDLT</code> flag).</li>
<li><code>asHermitian:</code> This flag selects the most suited inversion algorithm for Hermitian matrices. In case no further compile time information is available, the Bunch-Kaufman matrix decomposition algorithm will be used (see the <code>byLDLH</code> flag).</li>
<li><code>asLower:</code> This flag selects the most suited inversion algorithm for lower triangular matrices. In case no further compile time information is available, the inversion will be performed by a forward substitution. No matrix decomposition will be performed.</li>
<li><code>asUniLower:</code> This flag selects the most suited inversion algorithm for lower unitriangular matrices. In case no further compile time information is available, the inversion will be performed by a forward substitution. No matrix decomposition will be performed.</li>
<li><code>asUpper:</code> This flag selects the most suited inversion algorithm for upper triangular matrices. In case no further compile time information is available, the inversion will be performed by a back substitution. No matrix decomposition will be performed.</li>
<li><code>asUniUpper:</code> This flag selects the most suited inversion algorithm for upper unitriangular matrices. In case no further compile time information is available, the inversion will be performed by a back substitution. No matrix decomposition will be performed.</li>
<li><code>asDiagonal:</code> This flag selects the most suited inversion algorithm for diagonal matrices. In case no further compile time information is available, the inversion will be performed by directly computing the reciprocal of each diagonal element. No matrix decomposition will be performed. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5ac3740319e28f275c1b9fd29e1ac4f402"></a>byLU&#160;</td><td class="fielddoc"><p>Flag for the LU-based matrix inversion. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a0a5e1212ca55699fbc1c19afad9afee6"></a>byLDLT&#160;</td><td class="fielddoc"><p>Flag for the Bunch-Kaufman-based inversion for symmetric matrices. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a9566686fdaf93d13a7905489fd7a53eb"></a>byLDLH&#160;</td><td class="fielddoc"><p>Flag for the Bunch-Kaufman-based inversion for Hermitian matrices. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5ad05ff6d0175d8cf4a91ea39ddb7c67a2"></a>byLLH&#160;</td><td class="fielddoc"><p>Flag for the Cholesky-based inversion for positive-definite matrices. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5adaef4901b1d62c57b7ecaef9fa0fdbce"></a>asGeneral&#160;</td><td class="fielddoc"><p>Flag for the inversion of a general matrix (same as byLU). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a53f1e0df9a2bb46e6e44b79cb7f37ca1"></a>asSymmetric&#160;</td><td class="fielddoc"><p>Flag for the inversion of a symmetric matrix (same as byLDLT). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a0b79760c443ca06f987410e9db671090"></a>asHermitian&#160;</td><td class="fielddoc"><p>Flag for the inversion of a Hermitian matrix (same as byLDLH). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a2037964c1bde635a44bec66e041f460e"></a>asLower&#160;</td><td class="fielddoc"><p>Flag for the inversion of a lower triangular matrix. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a1a71074238192f97c566b0de0a2ef232"></a>asUniLower&#160;</td><td class="fielddoc"><p>Flag for the inversion of a lower unitriangular matrix. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a422d84660adc423063d501b5dc8e8f97"></a>asUpper&#160;</td><td class="fielddoc"><p>Flag for the inversion of a upper triangular matrix. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a59dbf6f76744b544df87274e70c9d826"></a>asUniUpper&#160;</td><td class="fielddoc"><p>Flag for the inversion of a upper unitriangular matrix. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5ab9559c7c7f5240b394de2072ef9c3de5"></a>asDiagonal&#160;</td><td class="fielddoc"><p>Flag for the inversion of a diagonal matrix. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8e4e90c6e2ed37ddea6203417c5596f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e4e90c6e2ed37ddea6203417c5596f5">&sect;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d6/dae/structblaze_1_1Abs.html">Abs</a>,SO&gt; blaze::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5">abs</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gabbea0b8e061ed390f6c7767c9104e40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbea0b8e061ed390f6c7767c9104e40e">&sect;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d4/db3/structblaze_1_1Acos.html">Acos</a>,SO&gt; blaze::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse cosine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cosine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gabbea0b8e061ed390f6c7767c9104e40e" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a></em> function computes the inverse cosine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gabbea0b8e061ed390f6c7767c9104e40e" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gabbea0b8e061ed390f6c7767c9104e40e">acos</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gafdfd453cc8c85f2c9d65bc5d82eb52e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdfd453cc8c85f2c9d65bc5d82eb52e5">&sect;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../dd/d35/structblaze_1_1Acosh.html">Acosh</a>,SO&gt; blaze::acosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic cosine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[1..\infty)$" src="../../form_99.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic cosine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gafdfd453cc8c85f2c9d65bc5d82eb52e5" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a></em> function computes the inverse hyperbolic cosine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gafdfd453cc8c85f2c9d65bc5d82eb52e5" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gafdfd453cc8c85f2c9d65bc5d82eb52e5">acosh</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[1..\infty)$" src="../../form_99.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gab4eed6b2d7c8e03d3ba69de01a1e54ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4eed6b2d7c8e03d3ba69de01a1e54ff">&sect;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d3/dde/structblaze_1_1Asin.html">Asin</a>,SO&gt; blaze::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse sine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse sine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab4eed6b2d7c8e03d3ba69de01a1e54ff" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a></em> function computes the inverse sine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab4eed6b2d7c8e03d3ba69de01a1e54ff" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gab4eed6b2d7c8e03d3ba69de01a1e54ff">asin</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga974e5ff97f8d4c431684ca167bf5be3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga974e5ff97f8d4c431684ca167bf5be3b">&sect;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d0/d08/structblaze_1_1Asinh.html">Asinh</a>,SO&gt; blaze::asinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic sine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic sine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga974e5ff97f8d4c431684ca167bf5be3b" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a></em> function computes the inverse hyperbolic sine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga974e5ff97f8d4c431684ca167bf5be3b" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga974e5ff97f8d4c431684ca167bf5be3b">asinh</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gab63e8615abfd73eea11c190846d8f14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab63e8615abfd73eea11c190846d8f14b">&sect;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d4/dfc/structblaze_1_1Atan.html">Atan</a>,SO&gt; blaze::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse tangent for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse tangent of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab63e8615abfd73eea11c190846d8f14b" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a></em> function computes the inverse tangent for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab63e8615abfd73eea11c190846d8f14b" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gab63e8615abfd73eea11c190846d8f14b">atan</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf39e95469abfd502a43219461590266a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf39e95469abfd502a43219461590266a">&sect;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../de/d4d/structblaze_1_1Atanh.html">Atanh</a>,SO&gt; blaze::atanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic tangent for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic tangent of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaf39e95469abfd502a43219461590266a" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a></em> function computes the inverse hyperbolic tangent for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaf39e95469abfd502a43219461590266a" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaf39e95469abfd502a43219461590266a">atanh</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga62c4f8c97f9e6fde1781a9ed1c0a1a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62c4f8c97f9e6fde1781a9ed1c0a1a62">&sect;&nbsp;</a></span>cbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d6/d4c/structblaze_1_1Cbrt.html">Cbrt</a>,SO&gt; blaze::cbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cubic root of each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cubic root of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></em> function computes the cubic root of each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62">cbrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga38cb77691633d93f6b0b2fc55146a04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38cb77691633d93f6b0b2fc55146a04b">&sect;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../da/d9f/structblaze_1_1Ceil.html">Ceil</a>,SO&gt; blaze::ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b">ceil</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gadebfde9b2a5daf6d821e81ac96aa0b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadebfde9b2a5daf6d821e81ac96aa0b94">&sect;&nbsp;</a></span>clip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename DT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d0/d65/structblaze_1_1Clip.html">Clip</a>&lt;DT&gt;,SO&gt; blaze::clip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restricts each single element of the dense matrix <em>dm</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_94.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">min</td><td>The lower delimiter. </td></tr>
    <tr><td class="paramname">max</td><td>The upper delimiter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix with restricted elements.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gadebfde9b2a5daf6d821e81ac96aa0b94" title="Restricts each single element of the dense matrix dm to the range . ">clip()</a></em> function restricts each element of the input matrix <em>dm</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_94.png"/>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gadebfde9b2a5daf6d821e81ac96aa0b94" title="Restricts each single element of the dense matrix dm to the range . ">clip()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gadebfde9b2a5daf6d821e81ac96aa0b94">clip</a>( A, -1.0, 1.0 );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga23b5c9bdbb7e7ea2c008808d235f7055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23b5c9bdbb7e7ea2c008808d235f7055">&sect;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../db/ddf/structblaze_1_1Conj.html">Conj</a>,SO&gt; blaze::conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix containing the complex conjugate of each single element of <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conjugate complex of each single element of <em>dm</em>.</dd></dl>
<p>The <em>conj</em> function calculates the complex conjugate of each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>conj</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt; complex&lt;double&gt;</a> &gt; A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga23b5c9bdbb7e7ea2c008808d235f7055">conj</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6179f49533c111d0c1ed6b9181aabbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6179f49533c111d0c1ed6b9181aabbe7">&sect;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../df/d0a/structblaze_1_1Cos.html">Cos</a>,SO&gt; blaze::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cosine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cosine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6179f49533c111d0c1ed6b9181aabbe7" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a></em> function computes the cosine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6179f49533c111d0c1ed6b9181aabbe7" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6179f49533c111d0c1ed6b9181aabbe7">cos</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3cb0cfa3ce6e0ca00ef6edf910149858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cb0cfa3ce6e0ca00ef6edf910149858">&sect;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../de/db2/structblaze_1_1Cosh.html">Cosh</a>,SO&gt; blaze::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cosine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga3cb0cfa3ce6e0ca00ef6edf910149858" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a></em> function computes the hyperbolic cosine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga3cb0cfa3ce6e0ca00ef6edf910149858" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga3cb0cfa3ce6e0ca00ef6edf910149858">cosh</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga48020f64de98036286379dacfa444750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48020f64de98036286379dacfa444750">&sect;&nbsp;</a></span>ctrans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">CTransExprTrait_</a>&lt;MT&gt; blaze::ctrans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the conjugate transpose matrix of <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conjugate transpose of <em>dm</em>.</dd></dl>
<p>The <em>ctrans</em> function returns an expression representing the conjugate transpose (also called adjoint matrix, Hermitian conjugate matrix or transjugate matrix) of the given input matrix <em>dm</em>.<br />
The following example demonstrates the use of the <em>ctrans</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt; complex&lt;double&gt;</a> &gt; A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga48020f64de98036286379dacfa444750">ctrans</a>( A );</div></div><!-- fragment --><p>Note that the <em>ctrans</em> function has the same effect as manually applying the <em>conj</em> and <em>trans</em> function in any order:</p>
<div class="fragment"><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga23b5c9bdbb7e7ea2c008808d235f7055">conj</a>( A ) );  <span class="comment">// Computing the conjugate transpose matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga23b5c9bdbb7e7ea2c008808d235f7055">conj</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( A ) );  <span class="comment">// Computing the conjugate transpose matrix</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga152576fa391bcb9a2892063bdf3953f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga152576fa391bcb9a2892063bdf3953f7">&sect;&nbsp;</a></span>det()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; blaze::det </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> of the determinant of the given dense square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The given dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant of the given matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid non-square matrix provided.</td></tr>
  </table>
  </dd>
</dl>
<p>This function computes the determinant of the given dense square matrix. The computation fails if the given matrix is not a square matrix. In this case either a compilation error is created (if possible) or a <em>std::invalid_argument</em> exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>The computation of the determinant is numerically unreliable since especially for large matrices the value can overflow during the computation. Please note that this function does not guarantee that it is possible to compute the determinant with the given matrix! </dd>
<dd>
This function can only be used if the fitting LAPACK library is available and linked to the executable. Otherwise a linker error will be created. </dd></dl>

</div>
</div>
<a id="gab93959cccb52b78dccb927b9ea0afafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab93959cccb52b78dccb927b9ea0afafe">&sect;&nbsp;</a></span>erf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../dd/d2c/structblaze_1_1Erf.html">Erf</a>,SO&gt; blaze::erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error function of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab93959cccb52b78dccb927b9ea0afafe" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></em> function computes the error function for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab93959cccb52b78dccb927b9ea0afafe" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gab93959cccb52b78dccb927b9ea0afafe">erf</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga8444088c1f7a23fe9ca5d44f8b736b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8444088c1f7a23fe9ca5d44f8b736b6a">&sect;&nbsp;</a></span>erfc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../de/d5a/structblaze_1_1Erfc.html">Erfc</a>,SO&gt; blaze::erfc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the complementary error function for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complementary error function of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8444088c1f7a23fe9ca5d44f8b736b6a" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></em> function computes the complementary error function for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8444088c1f7a23fe9ca5d44f8b736b6a" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga8444088c1f7a23fe9ca5d44f8b736b6a">erfc</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gacb9f8190d38edb0e52d9c376da5486d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb9f8190d38edb0e52d9c376da5486d6">&sect;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d9a/classblaze_1_1DMatEvalExpr.html">DMatEvalExpr</a>&lt;MT,SO&gt; blaze::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the evaluation of the given dense matrix expression <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated dense matrix.</dd></dl>
<p>The <em>eval</em> function forces the evaluation of the given dense matrix expression <em>dm</em>. The function returns an expression representing the operation.<br />
The following example demonstrates the use of the <em>eval</em> function</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gacb9f8190d38edb0e52d9c376da5486d6">eval</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gace3face2f497ce3065754db58ce162d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace3face2f497ce3065754db58ce162d4">&sect;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d4/d45/structblaze_1_1Exp.html">Exp</a>,SO&gt; blaze::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4" title="Computes  for each single element of the dense matrix dm. ">exp()</a></em> function computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4" title="Computes  for each single element of the dense matrix dm. ">exp()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">exp</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gad36748177b43e944319b880e50f238f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad36748177b43e944319b880e50f238f2">&sect;&nbsp;</a></span>exp10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../db/dc8/structblaze_1_1Exp10.html">Exp10</a>,SO&gt; blaze::exp10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></em> function computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2">exp10</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gabb31fcefbc91f1a5ec339dab928b5576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb31fcefbc91f1a5ec339dab928b5576">&sect;&nbsp;</a></span>exp2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../df/dbb/structblaze_1_1Exp2.html">Exp2</a>,SO&gt; blaze::exp2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></em> function computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576">exp2</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7076fab6e413abbb8914e97c63c6ec60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7076fab6e413abbb8914e97c63c6ec60">&sect;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d2/d67/structblaze_1_1Floor.html">Floor</a>,SO&gt; blaze::floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60">floor</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gacbb0c018752c3e955e7ffbee96c415eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbb0c018752c3e955e7ffbee96c415eb">&sect;&nbsp;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, OP, SO &gt; blaze::forEach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the given custom operation on each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">op</td><td>The custom operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The custom operation applied to each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></em> function evaluates the given custom operation on each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb">forEach</a>( A, []( <span class="keywordtype">double</span> a ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">std::sqrt</a>( a ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga801fe45f59d396249b21d1e4f686f427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga801fe45f59d396249b21d1e4f686f427">&sect;&nbsp;</a></span>imag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d3/d61/structblaze_1_1Imag.html">Imag</a>,SO&gt; blaze::imag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix containing the imaginary part of each single element of <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The imaginary part of each single element of <em>dm</em>.</dd></dl>
<p>The <em>imag</em> function calculates the imaginary part of each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>imag</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga801fe45f59d396249b21d1e4f686f427">imag</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gad2f1c5357c878446236a3b6b3d0e107c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2f1c5357c878446236a3b6b3d0e107c">&sect;&nbsp;</a></span>inv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d3/d92/classblaze_1_1DMatInvExpr.html">DMatInvExpr</a>&lt;MT,SO&gt; blaze::inv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the inverse of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be inverted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse of the matrix.</dd></dl>
<p>This function returns an expression representing the inverse of the given dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gad2f1c5357c878446236a3b6b3d0e107c">inv</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The matrix inversion can only be used for dense matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code> or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
It is not possible to use any kind of view on the expression object returned by the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gad2f1c5357c878446236a3b6b3d0e107c" title="Calculation of the inverse of the given dense matrix. ">inv()</a></code> function. Also, it is not possible to access individual elements via the function call operator on the expression object:</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="../../d0/d48/group__views.html#gaac41793bbb88121e4f8d6fd60754d4f5">row</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#gad2f1c5357c878446236a3b6b3d0e107c">inv</a>( A ), 2UL );  <span class="comment">// Compilation error: Views cannot be used on an inv() expression!</span></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gad2f1c5357c878446236a3b6b3d0e107c">inv</a>( A )(1,2);         <span class="comment">// Compilation error: It is not possible to access individual elements!</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga683192b628e107e6082a6b6876d62614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga683192b628e107e6082a6b6876d62614">&sect;&nbsp;</a></span>invcbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d2/d2f/structblaze_1_1InvCbrt.html">InvCbrt</a>,SO&gt; blaze::invcbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse cubic root of each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_93.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cubic root of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga683192b628e107e6082a6b6876d62614" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></em> function computes the inverse cubic root of each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga683192b628e107e6082a6b6876d62614" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga683192b628e107e6082a6b6876d62614">invcbrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_93.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga1703390e63b9cb5b805ab5b4718ddda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1703390e63b9cb5b805ab5b4718ddda3">&sect;&nbsp;</a></span>invert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place inversion of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be inverted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid non-square matrix provided. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Inversion of singular matrix failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function inverts the given dense square matrix. The matrix inversion fails if ...</p>
<ul>
<li>... the given matrix is not a square matrix;</li>
<li>... the given matrix is singular and not invertible.</li>
</ul>
<p>In all failure cases an exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>The matrix inversion can only be used for dense matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code> or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if the fitting LAPACK library is available and linked to the executable. Otherwise a linker error will be created.</dd>
<dd>
This function does only provide the basic exception safety guarantee, i.e. in case of an exception <em>dm</em> may already have been modified. </dd></dl>

</div>
</div>
<a id="ga4c0fd934e9c1b84cc2588cfe142c55a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c0fd934e9c1b84cc2588cfe142c55a4">&sect;&nbsp;</a></span>invert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;InversionFlag IF, typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place inversion of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be inverted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid non-square matrix provided. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Inversion of singular matrix failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function inverts the given dense matrix by means of the specified matrix type or matrix inversion algorithm <code>IF</code> (see the InversionFlag documentation):</p>
<div class="fragment"><div class="line">invert&lt;asLower&gt;( A );     <span class="comment">// Inversion of a lower triangular matrix</span></div><div class="line">invert&lt;asUniUpper&gt;( A );  <span class="comment">// Inversion of an upper unitriangular matrix</span></div><div class="line">invert&lt;byLU&gt;( A );        <span class="comment">// Inversion by means of an LU decomposition</span></div><div class="line">invert&lt;byLLH&gt;( A );       <span class="comment">// Inversion by means of a Cholesky decomposition</span></div><div class="line">...</div></div><!-- fragment --><p>The matrix inversion fails if ...</p>
<ul>
<li>... the given matrix is not a square matrix;</li>
<li>... the given matrix is singular and not invertible.</li>
</ul>
<p>In all failure cases either a compilation error is created if the failure can be predicted at compile time or an exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>The matrix inversion can only be used for dense matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code> or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if the fitting LAPACK library is available and linked to the executable. Otherwise a linker error will be created.</dd>
<dd>
This function does only provide the basic exception safety guarantee, i.e. in case of an exception <em>dm</em> may already have been modified. </dd></dl>

</div>
</div>
<a id="ga8e33f65ba5d0b7f32fe15b818d6914e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e33f65ba5d0b7f32fe15b818d6914e6">&sect;&nbsp;</a></span>invsqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../df/d20/structblaze_1_1InvSqrt.html">InvSqrt</a>,SO&gt; blaze::invsqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse square root of each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_93.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse square root of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e33f65ba5d0b7f32fe15b818d6914e6" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></em> function computes the inverse square root of each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e33f65ba5d0b7f32fe15b818d6914e6" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga8e33f65ba5d0b7f32fe15b818d6914e6">invsqrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_93.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga144e15e7b1f40485ed2dac1f51ba5083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga144e15e7b1f40485ed2dac1f51ba5083">&sect;&nbsp;</a></span>isDiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isDiagonal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the give dense matrix is diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is diagonal, <em>false</em> if not.</dd></dl>
<p>This function tests whether the matrix is diagonal, i.e. if the non-diagonal elements are default elements. In case of integral or floating point data types, a diagonal matrix has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} aa &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; bb &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 0 &amp; cc &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; xx \\ \end{array}\right)\]" src="../../form_61.png"/>
</p>
<p><img class="formulaInl" alt="$ 0 \times 0 $" src="../../form_54.png"/> or <img class="formulaInl" alt="$ 1 \times 1 $" src="../../form_55.png"/> matrices are considered as trivially diagonal. The following example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga144e15e7b1f40485ed2dac1f51ba5083">isDiagonal</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a diagonal matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga144e15e7b1f40485ed2dac1f51ba5083">isDiagonal</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga2c4d4b151827b6e300cd949fc33a707a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c4d4b151827b6e300cd949fc33a707a">&sect;&nbsp;</a></span>isHermitian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isHermitian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is Hermitian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is Hermitian, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is an Hermitian matrix. The matrix is considered to be an Hermitian matrix if it is a square matrix whose conjugate transpose is equal to itself ( <img class="formulaInl" alt="$ A = \overline{A^T} $" src="../../form_22.png"/>), i.e. each matrix element <img class="formulaInl" alt="$ a_{ij} $" src="../../form_24.png"/> is equal to the complex conjugate of the element <img class="formulaInl" alt="$ a_{ji} $" src="../../form_25.png"/>. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga2c4d4b151827b6e300cd949fc33a707a">isHermitian</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an Hermitian matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga2c4d4b151827b6e300cd949fc33a707a">isHermitian</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gaa3674413b281f83fcc81e3a6b2dea188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3674413b281f83fcc81e3a6b2dea188">&sect;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isIdentity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the give dense matrix is an identity matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is an identity matrix, <em>false</em> if not.</dd></dl>
<p>This function tests whether the matrix is an identity matrix, i.e. if the diagonal elements are 1 and the non-diagonal elements are 0. In case of integral or floating point data types, an identity matrix has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{array}\right)\]" src="../../form_62.png"/>
</p>
<p>The following example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaa3674413b281f83fcc81e3a6b2dea188">isIdentity</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an identity matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaa3674413b281f83fcc81e3a6b2dea188">isIdentity</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga78ee9a691c9a59c3883f458866f9b76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78ee9a691c9a59c3883f458866f9b76f">&sect;&nbsp;</a></span>isLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isLower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is a lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a lower triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is a lower triangular matrix. The matrix is considered to be lower triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} l_{0,0} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{1,0} &amp; l_{1,1} &amp; 0 &amp; \cdots &amp; 0 \\ l_{2,0} &amp; l_{2,1} &amp; l_{2,2} &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ l_{N,0} &amp; l_{N,1} &amp; l_{N,2} &amp; \cdots &amp; l_{N,N} \\ \end{array}\right).\]" src="../../form_53.png"/>
</p>
<p><img class="formulaInl" alt="$ 0 \times 0 $" src="../../form_54.png"/> or <img class="formulaInl" alt="$ 1 \times 1 $" src="../../form_55.png"/> matrices are considered as trivially lower triangular. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga78ee9a691c9a59c3883f458866f9b76f">isLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a lower triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga78ee9a691c9a59c3883f458866f9b76f">isLower</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga99ba6a5b32152077ba7d013be1add4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ba6a5b32152077ba7d013be1add4dc">&sect;&nbsp;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the given dense matrix for not-a-number elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The matrix to be checked for not-a-number elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the matrix is not-a-number, <em>false</em> otherwise.</dd></dl>
<p>This function checks the dense matrix for not-a-number (NaN) elements. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> at least one element of the matrix is not-a-number, the function returns <em>true</em>, otherwise it returns <em>false</em>.</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A( 3UL, 4UL );</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga88d643a61cd9e3b87852233e13973f08">isnan</a>( A ) ) { ... }</div></div><!-- fragment --><p>Note that this function only works for matrices with floating point elements. The attempt to use it for a matrix with a non-floating point element type results in a compile time error. </p>

</div>
</div>
<a id="ga7a77d7fdc4319a6e74bd6eae4d1c71c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a77d7fdc4319a6e74bd6eae4d1c71c1">&sect;&nbsp;</a></span>isStrictlyLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isStrictlyLower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is a strictly lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a strictly lower triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is a strictly lower triangular matrix. The matrix is considered to be strictly lower triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{1,0} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{2,0} &amp; l_{2,1} &amp; 0 &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ l_{N,0} &amp; l_{N,1} &amp; l_{N,2} &amp; \cdots &amp; 0 \\ \end{array}\right).\]" src="../../form_57.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7a77d7fdc4319a6e74bd6eae4d1c71c1">isStrictlyLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a strictly lower triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7a77d7fdc4319a6e74bd6eae4d1c71c1">isStrictlyLower</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gaa1b4b55a81a85ee76379ab19a1a75d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1b4b55a81a85ee76379ab19a1a75d64">&sect;&nbsp;</a></span>isStrictlyUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isStrictlyUpper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is a strictly upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a strictly upper triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is a strictly upper triangular matrix. The matrix is considered to be strictly upper triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; u_{0,1} &amp; u_{0,2} &amp; \cdots &amp; u_{0,N} \\ 0 &amp; 0 &amp; u_{1,2} &amp; \cdots &amp; u_{1,N} \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; u_{2,N} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ \end{array}\right).\]" src="../../form_60.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaa1b4b55a81a85ee76379ab19a1a75d64">isStrictlyUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a strictly upper triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaa1b4b55a81a85ee76379ab19a1a75d64">isStrictlyUpper</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga54c4333a5647750c5cd126ef9ca5d25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54c4333a5647750c5cd126ef9ca5d25b">&sect;&nbsp;</a></span>isSymmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isSymmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is symmetric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is symmetric, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is symmetric. The matrix is considered to be symmetric if it is a square matrix whose transpose is equal to itself ( <img class="formulaInl" alt="$ A = A^T $" src="../../form_23.png"/>). The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga54c4333a5647750c5cd126ef9ca5d25b">isSymmetric</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a symmetric matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga54c4333a5647750c5cd126ef9ca5d25b">isSymmetric</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga7aafd1dd369f715e523850f4adb36696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aafd1dd369f715e523850f4adb36696">&sect;&nbsp;</a></span>isUniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is a uniform matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a uniform matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is a uniform matrix. The matrix is considered to be uniform if all its elements are identical. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7aafd1dd369f715e523850f4adb36696">isUniform</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a uniform matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7aafd1dd369f715e523850f4adb36696">isUniform</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga72556b3671610da96aea635f41d166a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72556b3671610da96aea635f41d166a1">&sect;&nbsp;</a></span>isUniLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniLower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is a lower unitriangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a lower unitriangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is a lower unitriangular matrix. The matrix is considered to be lower unitriangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{1,0} &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\ l_{2,0} &amp; l_{2,1} &amp; 1 &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ l_{N,0} &amp; l_{N,1} &amp; l_{N,2} &amp; \cdots &amp; 1 \\ \end{array}\right).\]" src="../../form_56.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga72556b3671610da96aea635f41d166a1">isUniLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a lower unitriangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga72556b3671610da96aea635f41d166a1">isUniLower</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga0d3d32d95705421514aa1de3da0ef48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d3d32d95705421514aa1de3da0ef48d">&sect;&nbsp;</a></span>isUniUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniUpper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is an upper unitriangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is an upper unitriangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is an upper unitriangular matrix. The matrix is considered to be upper unitriangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 1 &amp; u_{0,1} &amp; u_{0,2} &amp; \cdots &amp; u_{0,N} \\ 0 &amp; 1 &amp; u_{1,2} &amp; \cdots &amp; u_{1,N} \\ 0 &amp; 0 &amp; 1 &amp; \cdots &amp; u_{2,N} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1 \\ \end{array}\right).\]" src="../../form_59.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga0d3d32d95705421514aa1de3da0ef48d">isUniUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an upper unitriangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga0d3d32d95705421514aa1de3da0ef48d">isUniUpper</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gac2e03c886fd6538a6f10dbdbbd4faacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2e03c886fd6538a6f10dbdbbd4faacd">&sect;&nbsp;</a></span>isUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUpper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is an upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is an upper triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is an upper triangular matrix. The matrix is considered to be upper triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} u_{0,0} &amp; u_{0,1} &amp; u_{0,2} &amp; \cdots &amp; u_{0,N} \\ 0 &amp; u_{1,1} &amp; u_{1,2} &amp; \cdots &amp; u_{1,N} \\ 0 &amp; 0 &amp; u_{2,2} &amp; \cdots &amp; u_{2,N} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; u_{N,N} \\ \end{array}\right).\]" src="../../form_58.png"/>
</p>
<p><img class="formulaInl" alt="$ 0 \times 0 $" src="../../form_54.png"/> or <img class="formulaInl" alt="$ 1 \times 1 $" src="../../form_55.png"/> matrices are considered as trivially upper triangular. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gac2e03c886fd6538a6f10dbdbbd4faacd">isUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an upper triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gac2e03c886fd6538a6f10dbdbbd4faacd">isUpper</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga63e7f6efe504ec8f7416decef5446662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63e7f6efe504ec8f7416decef5446662">&sect;&nbsp;</a></span>llh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::llh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cholesky (LLH) decomposition of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to be decomposed. </td></tr>
    <tr><td class="paramname">L</td><td>The resulting lower triangular matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid non-square matrix provided. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Decomposition of singular matrix failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the dense matrix Cholesky (LLH) decomposition of a positive definite n-by-n matrix. The resulting decomposition has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = L \cdot L^{H}, \]" src="../../form_73.png"/>
</p>
<p>where <code>L</code> is a lower triangular n-by-n matrix. The decomposition is written to the matrix <code>L</code>, which is resized to the correct dimensions (if possible and necessary).</p>
<p>The function fails if ...</p>
<ul>
<li>... <em>A</em> is not a square matrix;</li>
<li>... <em>L</em> is a fixed size matrix and the dimensions don't match <em>A</em>.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> A( 32, 32 );</div><div class="line"><span class="comment">// ... Initialization of A as positive definite matrix</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> L( 32, 32 );</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga63e7f6efe504ec8f7416decef5446662">llh</a>( A, L );</div><div class="line"></div><div class="line">assert( A == L * <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( L ) );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if the fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error.</dd>
<dd>
This function does only provide the basic exception safety guarantee, i.e. in case of an exception <em>L</em> may already have been modified. </dd></dl>

</div>
</div>
<a id="ga8359ccb837055c7056c1eae56c45eb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8359ccb837055c7056c1eae56c45eb1a">&sect;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d3/d9c/structblaze_1_1Log.html">Log</a>,SO&gt; blaze::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8359ccb837055c7056c1eae56c45eb1a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function computes natural logarithm for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8359ccb837055c7056c1eae56c45eb1a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga8359ccb837055c7056c1eae56c45eb1a">log</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga979d59d108165583def861daf609d8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga979d59d108165583def861daf609d8ca">&sect;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../de/d33/structblaze_1_1Log10.html">Log10</a>,SO&gt; blaze::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the common logarithm for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The common logarithm of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga979d59d108165583def861daf609d8ca" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></em> function computes common logarithm for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga979d59d108165583def861daf609d8ca" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga979d59d108165583def861daf609d8ca">log10</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gaba8707d555ca3ec8c6394d9724e2b504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba8707d555ca3ec8c6394d9724e2b504">&sect;&nbsp;</a></span>log2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d5/dc7/structblaze_1_1Log2.html">Log2</a>,SO&gt; blaze::log2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary logarithm for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary logarithm of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaba8707d555ca3ec8c6394d9724e2b504" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></em> function computes binary logarithm for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaba8707d555ca3ec8c6394d9724e2b504" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaba8707d555ca3ec8c6394d9724e2b504">log2</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga797f2c71d569b9abf5784ff118a308f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga797f2c71d569b9abf5784ff118a308f2">&sect;&nbsp;</a></span>lq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::lq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LQ decomposition of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to be decomposed. </td></tr>
    <tr><td class="paramname">L</td><td>The resulting <code>L</code> matrix. </td></tr>
    <tr><td class="paramname">Q</td><td>The resulting <code>Q</code> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Square matrix cannot be resized to <em>m-by-<em>n</em>.</em> </td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the dense matrix LQ decomposition of a general <em>m-by-<em>n</em> matrix</em>. The resulting decomposition has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = L \cdot Q, \]" src="../../form_74.png"/>
</p>
<p>where <code>L</code> is a lower trapezoidal <em>m-by-min</em>(<em>m</em>,<em>n</em>) matrix and <code>Q</code> is a general min(<em>m</em>,<em>n</em>)-by-<em>n</em> matrix. The decomposition is written to the two distinct matrices <code>L</code> and <code>Q</code>, which are resized to the correct dimensions (if possible and necessary).</p>
<p>The function fails if ...</p>
<ul>
<li>... either <em>L</em> or <em>Q</em> are fixed size matrices and the dimensions don't match;</li>
<li>... <em>L</em> is a compile time square matrix, but is required to be non-square.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> A( 32, 16 );</div><div class="line"><span class="comment">// ... Initialization of A</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> L( 32, 16 );</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> Q( 16, 16 );</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga797f2c71d569b9abf5784ff118a308f2">lq</a>( A, L, Q );</div><div class="line"></div><div class="line">assert( A == L * Q );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if the fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error. </dd></dl>

</div>
</div>
<a id="ga10d699031e948b83afcc0ffc68853d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10d699031e948b83afcc0ffc68853d65">&sect;&nbsp;</a></span>lu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , typename MT3 , typename MT4 , bool SO2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::lu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT4, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LU decomposition of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to be decomposed. </td></tr>
    <tr><td class="paramname">L</td><td>The resulting lower triangular matrix. </td></tr>
    <tr><td class="paramname">U</td><td>The resulting upper triangular matrix. </td></tr>
    <tr><td class="paramname">P</td><td>The resulting permutation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Square matrix cannot be resized to <em>m-by-<em>n</em>.</em> </td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the dense matrix (P)LU decomposition of a general <em>m-by-<em>n</em> matrix</em>. The resulting decomposition is written to the three distinct matrices <code>L</code>, <code>U</code>, and <code>P</code>, which are resized to the correct dimensions (if possible and necessary).</p>
<p>In case of a column-major matrix the algorithm performs the decomposition using partial pivoting with row interchanges. The resulting decomposition has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = P \cdot L \cdot U, \]" src="../../form_75.png"/>
</p>
<p>where <code>P</code> is an m-by-m permutation matrix, which represents the pivoting indices for the applied row interchanges, <code>L</code> is a lower triangular matrix (lower trapezoidal if <em>m</em> &gt; <em>n</em>), and <code>U</code> is an upper triangular matrix (upper trapezoidal if <em>m</em> &lt; <em>n</em>).</p>
<p>In case of a row-major matrix the algorithm performs the decomposition using partial pivoting with column interchanges. The resulting decomposition has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = L \cdot U \cdot P, \]" src="../../form_76.png"/>
</p>
<p>where <code>L</code> is a lower triangular matrix (lower trapezoidal if <em>m</em> &gt; <em>n</em>), <code>U</code> is an upper triangular matrix (upper trapezoidal if <em>m</em> &lt; <em>n</em>), and <code>P</code> is an n-by-n permutation matrix, which represents the pivoting indices for the applied column interchanges.</p>
<p>The function fails if ...</p>
<ul>
<li>... either <em>L</em>, <em>U</em>, and <em>P</em> are fixed size matrices and the dimensions don't match;</li>
<li>... <em>A</em> is a non-square m-by-n matrix, but <em>L</em> or <em>U</em> is a compile time square matrix.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> L, U, P;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65">lu</a>( A, L, U, P );  <span class="comment">// LU decomposition of a row-major matrix</span></div><div class="line"></div><div class="line">assert( A == L * U * P );</div></div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> L, U, P;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65">lu</a>( A, L, U, P );  <span class="comment">// LU decomposition of a column-major matrix</span></div><div class="line"></div><div class="line">assert( A == P * L * U );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if the fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error.</dd>
<dd>
The LU decomposition will never fail, even for singular matrices. However, in case of a singular matrix the resulting decomposition cannot be used for a matrix inversion or solving a linear system of equations. </dd></dl>

</div>
</div>
<a id="ga6ae2749f3a298c7927a4f7f85407e2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ae2749f3a298c7927a4f7f85407e2c4">&sect;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; blaze::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest element of the dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The given dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest dense matrix element.</dd></dl>
<p>This function returns the largest element of the given dense matrix. This function can only be used for element types that support the smaller-than relationship. In case the matrix currently has either 0 rows or 0 columns, the returned value is the default value (e.g. 0 in case of fundamental data types). </p>

</div>
</div>
<a id="ga1147d0f93d7cc6fad33935048f2b058e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1147d0f93d7cc6fad33935048f2b058e">&sect;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; blaze::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest element of the dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The given dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest dense matrix element.</dd></dl>
<p>This function returns the smallest element of the given dense matrix. This function can only be used for element types that support the smaller-than relationship. In case the matrix currently has either 0 rows or 0 columns, the returned value is the default value (e.g. 0 in case of fundamental data types). </p>

</div>
</div>
<a id="ga52848b40fa0e5a7f72bdcdd92d68f032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52848b40fa0e5a7f72bdcdd92d68f032">&sect;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of two dense matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a id="ga174d0a369968b438ed23725b3361283c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga174d0a369968b438ed23725b3361283c">&sect;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a dense matrix and a sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a id="gaa83dce66f3d82b99bb0dd83aa3efb7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa83dce66f3d82b99bb0dd83aa3efb7a4">&sect;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a sparse matrix and a dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a id="ga5bb8b9fb92ead32a2907a21c4bd81a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bb8b9fb92ead32a2907a21c4bd81a91">&sect;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt; blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a dense matrix and a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side dense matrix for the comparison. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the matrix is different from the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> one value of the matrix is inequal to the scalar value, the inequality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a id="ga8ab1683cf0ef1f675329a4d27d45751c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ab1683cf0ef1f675329a4d27d45751c">&sect;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;<a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T1&gt;, bool &gt; blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a scalar value and a dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the comparison. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side dense matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the matrix is different from the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> one value of the matrix is inequal to the scalar value, the inequality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a id="ga6c9c6c94ca79de19a79b899e9bd4fe64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c9c6c94ca79de19a79b899e9bd4fe64">&sect;&nbsp;</a></span>operator*() <span class="overload">[1/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T2&gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt;T1,T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a dense matrix and a scalar value ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_43.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result matrix.</dd></dl>
<p>This operator represents the multiplication between a dense matrix and a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = A * 1.25;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a id="ga4f085717ded20508025d1f1e1f753cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f085717ded20508025d1f1e1f753cdb">&sect;&nbsp;</a></span>operator*() <span class="overload">[2/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T1&gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt;T1,T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a scalar value and a dense matrix ( <img class="formulaInl" alt="$ A=s*B $" src="../../form_102.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result matrix.</dd></dl>
<p>This operator represents the multiplication between a a scalar value and dense matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = 1.25 * A;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the involved data types <em>T1</em> and <em>T2::ElementType</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a id="ga2a69a009d857b36f4b607edbeede502a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a69a009d857b36f4b607edbeede502a">&sect;&nbsp;</a></span>operator*() <span class="overload">[3/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/d2b/classblaze_1_1DMatSMatMultExpr.html">DMatSMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a row-major dense matrix and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga282c791c739c8c0d1d8e7c82bf0391ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga282c791c739c8c0d1d8e7c82bf0391ad">&sect;&nbsp;</a></span>operator*() <span class="overload">[4/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/dcd/classblaze_1_1DVecTDVecMultExpr.html">DVecTDVecMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the outer product of two dense vectors ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the outer product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side transpose dense vector for the outer product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>This operator represents the outer product between a dense vector and a transpose dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> a, b;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">A = a * <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>(b);</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both dense vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. </p>

</div>
</div>
<a id="ga55603ebcaa45b68183c06b156040cabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55603ebcaa45b68183c06b156040cabb">&sect;&nbsp;</a></span>operator*() <span class="overload">[5/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/d9c/classblaze_1_1TDMatTSMatMultExpr.html">TDMatTSMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a column-major dense matrix and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaff2332eeb931fe442419745885fc0bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff2332eeb931fe442419745885fc0bac">&sect;&nbsp;</a></span>operator*() <span class="overload">[6/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d6/dc5/classblaze_1_1SMatDMatMultExpr.html">SMatDMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a row-major sparse matrix and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga5432998c612b5dc4e417cea2fecaa2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5432998c612b5dc4e417cea2fecaa2fb">&sect;&nbsp;</a></span>operator*() <span class="overload">[7/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt;T2&gt;, <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt;T1,T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a row-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side row-major dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse vector and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> x, y;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = x * A;</div></div><!-- fragment --><p>The operator returns an expression representing a transpose sparse vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the dense matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gad82218827b4f2e2748e9fec868b66690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad82218827b4f2e2748e9fec868b66690">&sect;&nbsp;</a></span>operator*() <span class="overload">[8/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/ddc/classblaze_1_1DMatTSMatMultExpr.html">DMatTSMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a row-major dense matrix and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gac91fac7612d334d056573a01255a42f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac91fac7612d334d056573a01255a42f5">&sect;&nbsp;</a></span>operator*() <span class="overload">[9/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../df/ddb/classblaze_1_1TSMatDMatMultExpr.html">TSMatDMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a column-major sparse matrix and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gafd88fb6252c24b32b19dcf37f3c79196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd88fb6252c24b32b19dcf37f3c79196">&sect;&nbsp;</a></span>operator*() <span class="overload">[10/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d43/classblaze_1_1SMatTDMatMultExpr.html">SMatTDMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a row-major sparse matrix and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga61db726d567fb847824781084a1a04a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61db726d567fb847824781084a1a04a8">&sect;&nbsp;</a></span>operator*() <span class="overload">[11/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/d9f/classblaze_1_1TSMatTDMatMultExpr.html">TSMatTDMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a column-major sparse matrix and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga7fc6107dda539d41695e8f9f2ebf005c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fc6107dda539d41695e8f9f2ebf005c">&sect;&nbsp;</a></span>operator*() <span class="overload">[12/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/dfb/classblaze_1_1TDMatSMatMultExpr.html">TDMatSMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a column-major dense matrix and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga209020467da5fef99d7cb44d22094e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga209020467da5fef99d7cb44d22094e19">&sect;&nbsp;</a></span>operator*() <span class="overload">[13/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt;T2&gt;, <a class="el" href="../../db/de4/classblaze_1_1TDVecTDMatMultExpr.html">TDVecTDMatMultExpr</a>&lt;T1,T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose dense vector and a column-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side column-major dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose dense vector and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a> x, y;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = x * A;</div></div><!-- fragment --><p>The operator returns an expression representing a transpose dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the dense matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gade2ef15ea991616b38c3ffa80834ae5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade2ef15ea991616b38c3ffa80834ae5c">&sect;&nbsp;</a></span>operator*() <span class="overload">[14/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d3/d40/classblaze_1_1DMatDMatMultExpr.html">DMatDMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of two row-major dense matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix.</dd></dl>
<p>This operator represents the multiplication of two row-major dense matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of columns of <em>lhs</em> and the current number of rows of <em>rhs</em> don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gabaebf997f6e7e5fa0809d404ee89c2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaebf997f6e7e5fa0809d404ee89c2d7">&sect;&nbsp;</a></span>operator*() <span class="overload">[15/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6f/classblaze_1_1TDMatTDMatMultExpr.html">TDMatTDMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of two column-major dense matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix.</dd></dl>
<p>This operator represents the multiplication of two column-major dense matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of columns of <em>lhs</em> and the current number of rows of <em>rhs</em> don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga5707ef23374bab4bee818b45edff483f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5707ef23374bab4bee818b45edff483f">&sect;&nbsp;</a></span>operator*() <span class="overload">[16/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d3/d8a/classblaze_1_1DMatTDMatMultExpr.html">DMatTDMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major dense matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix.</dd></dl>
<p>This operator represents the multiplication of a row-major dense matrix and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of columns of <em>lhs</em> and the current number of rows of <em>rhs</em> don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gab99703844f7b1351016e47780277efb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab99703844f7b1351016e47780277efb7">&sect;&nbsp;</a></span>operator*() <span class="overload">[17/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/dc9/classblaze_1_1TDMatDMatMultExpr.html">TDMatDMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major dense matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix.</dd></dl>
<p>This operator represents the multiplication of a column-major dense matrix and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of columns of <em>lhs</em> and the current number of rows of <em>rhs</em> don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga694fc9c7f56eeb00d82c413d5d94cf77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga694fc9c7f56eeb00d82c413d5d94cf77">&sect;&nbsp;</a></span>operator+() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../df/d65/classblaze_1_1DMatSMatAddExpr.html">DMatSMatAddExpr</a>&lt;T1,T2,SO&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a dense matrix and a sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a dense matrix and a sparse matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gacb9b2e3869791221577cba8ab897ad68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb9b2e3869791221577cba8ab897ad68">&sect;&nbsp;</a></span>operator+() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../df/d61/classblaze_1_1DMatTSMatAddExpr.html">DMatTSMatAddExpr</a>&lt;T1,T2&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition operator for the addition of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a row-major dense matrix and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga4b0a2b26e02f2ca345af2094585db4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b0a2b26e02f2ca345af2094585db4be">&sect;&nbsp;</a></span>operator+() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/d0c/classblaze_1_1TDMatSMatAddExpr.html">TDMatSMatAddExpr</a>&lt;T1,T2&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition operator for the addition of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a column-major dense matrix and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga39f46fd8e099778f075cef873b15947c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39f46fd8e099778f075cef873b15947c">&sect;&nbsp;</a></span>operator+() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../df/d65/classblaze_1_1DMatSMatAddExpr.html">DMatSMatAddExpr</a>&lt;T2,T1,SO&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a sparse matrix and a dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a sparse matrix and a dense matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga7f1119e6cc68946e48a0620679bd6d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f1119e6cc68946e48a0620679bd6d06">&sect;&nbsp;</a></span>operator+() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../df/d61/classblaze_1_1DMatTSMatAddExpr.html">DMatTSMatAddExpr</a>&lt;T1,T2&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition operator for the addition of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a column-major sparse matrix and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga72d0526756a2befd345af87726c5014e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72d0526756a2befd345af87726c5014e">&sect;&nbsp;</a></span>operator+() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/d0c/classblaze_1_1TDMatSMatAddExpr.html">TDMatSMatAddExpr</a>&lt;T1,T2&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition operator for the addition of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a row-major sparse matrix and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga08a4fe8ed77e301a17800b299a83f5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08a4fe8ed77e301a17800b299a83f5fa">&sect;&nbsp;</a></span>operator+() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;T1&gt; &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;T2&gt; &gt; &gt; , const <a class="el" href="../../df/dbe/classblaze_1_1DMatTDMatAddExpr.html">DMatTDMatAddExpr</a>&lt;T1,T2&gt; &gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a row-major and a colum-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a row-major and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga1fe0f6bf94d6ac4714cd7258a456140f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fe0f6bf94d6ac4714cd7258a456140f">&sect;&nbsp;</a></span>operator+() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;T1&gt; &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;T2&gt; &gt; &gt; , const <a class="el" href="../../df/dbe/classblaze_1_1DMatTDMatAddExpr.html">DMatTDMatAddExpr</a>&lt;T2,T1&gt; &gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a column-major and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a column-major and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga5b169a4b41e240ee939d6027dcf61c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b169a4b41e240ee939d6027dcf61c52">&sect;&nbsp;</a></span>operator+() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/d2d/classblaze_1_1DMatDMatAddExpr.html">DMatDMatAddExpr</a>&lt;T1,T2,SO&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of two dense matrices with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of two dense matrices with identical storage order:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga7889e29abeda750915b8c5a2fc061242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7889e29abeda750915b8c5a2fc061242">&sect;&nbsp;</a></span>operator-() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../df/db6/classblaze_1_1SMatDMatSubExpr.html">SMatDMatSubExpr</a>&lt;T1,T2,SO&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a sparse matrix and a dense matrix with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted from the sparse matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a sparse matrix and a dense matrix with identical storage order:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga2a19e16624e4520852a11d2a443d1ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a19e16624e4520852a11d2a443d1ba5">&sect;&nbsp;</a></span>operator-() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../df/d71/classblaze_1_1TSMatDMatSubExpr.html">TSMatDMatSubExpr</a>&lt;T1,T2&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted from the sparse matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a column-major sparse matrix and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga1720d2f0702c0f77bc4991a287d98d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1720d2f0702c0f77bc4991a287d98d1e">&sect;&nbsp;</a></span>operator-() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/de7/classblaze_1_1SMatTDMatSubExpr.html">SMatTDMatSubExpr</a>&lt;T1,T2&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted from the sparse matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a row-major sparse matrix and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga02f1afd8e1de67f79795d150708931b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02f1afd8e1de67f79795d150708931b9">&sect;&nbsp;</a></span>operator-() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d3/deb/classblaze_1_1DMatSMatSubExpr.html">DMatSMatSubExpr</a>&lt;T1,T2,SO&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a dense matrix and a sparse matrix with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted from the dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a dense matrix and a sparse matrix with identical storage order:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gad2a348f4c6ca1ff497f56003dd22cb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2a348f4c6ca1ff497f56003dd22cb66">&sect;&nbsp;</a></span>operator-() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/d76/classblaze_1_1DMatTSMatSubExpr.html">DMatTSMatSubExpr</a>&lt;T1,T2&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted from the dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a row-major dense matrix and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaa31b65149566c26b3f8d9d75ca24c6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa31b65149566c26b3f8d9d75ca24c6e5">&sect;&nbsp;</a></span>operator-() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../da/d5b/classblaze_1_1TDMatSMatSubExpr.html">TDMatSMatSubExpr</a>&lt;T1,T2&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted from the dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a column-major dense matrix and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga5b78e6b3967de95f80bb323923a38de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b78e6b3967de95f80bb323923a38de4">&sect;&nbsp;</a></span>operator-() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;T1&gt; &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;T2&gt; &gt; &gt; , const <a class="el" href="../../d8/d16/classblaze_1_1DMatTDMatSubExpr.html">DMatTDMatSubExpr</a>&lt;T1,T2&gt; &gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a row-major and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted from the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a row-major and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga2f4aef71c7832d132164838d3abad54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f4aef71c7832d132164838d3abad54c">&sect;&nbsp;</a></span>operator-() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;T1&gt; &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;T2&gt; &gt; &gt; , const <a class="el" href="../../d8/d16/classblaze_1_1DMatTDMatSubExpr.html">DMatTDMatSubExpr</a>&lt;T1,T2&gt; &gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a column-major and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted from the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a column-major and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga3651e36c48fc68d45e799bef5163ea2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3651e36c48fc68d45e799bef5163ea2e">&sect;&nbsp;</a></span>operator-() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/d8b/classblaze_1_1DMatScalarMultExpr.html">DMatScalarMultExpr</a>&lt;MT,<a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">UnderlyingBuiltin_</a>&lt;MT&gt;,SO&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus operator for the negation of a dense matrix ( <img class="formulaInl" alt="$ A = -B $" src="../../form_101.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be negated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The negation of the matrix.</dd></dl>
<p>This operator represents the negation of a dense matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = -A;</div></div><!-- fragment --><p>The operator returns an expression representing the negation of the given dense matrix. </p>

</div>
</div>
<a id="ga1d7b2dabfa699f5714783cf446221758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d7b2dabfa699f5714783cf446221758">&sect;&nbsp;</a></span>operator-() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/ddb/classblaze_1_1DMatDMatSubExpr.html">DMatDMatSubExpr</a>&lt;T1,T2,SO&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of two dense matrices with identical storage order ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted from the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of two dense matrices with identical storage order:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaf3cd8bdcaaf316731c036deba11f2caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3cd8bdcaaf316731c036deba11f2caa">&sect;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T2&gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">DivExprTrait_</a>&lt;T1,T2&gt; &gt; blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for the division of a dense matrix by a scalar value ( <img class="formulaInl" alt="$ A=B/s $" src="../../form_100.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side dense matrix for the division. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result matrix.</dd></dl>
<p>This operator represents the division of a dense matrix by a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = A / 0.24;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Note that this operator only works for scalar values of built-in data type.</p>
<dl class="section note"><dt>Note</dt><dd>A division by zero is only checked by an user assert. </dd></dl>

</div>
</div>
<a id="ga7120542028164e84f57b2bd0daf1ed07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7120542028164e84f57b2bd0daf1ed07">&sect;&nbsp;</a></span>operator==() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two rwo-major dense matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga3e85fa1492d985e034b7ca152d69dac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e85fa1492d985e034b7ca152d69dac2">&sect;&nbsp;</a></span>operator==() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two column-major dense matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="gacff1ea4c8128a09b47db0c324da5c2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacff1ea4c8128a09b47db0c324da5c2f0">&sect;&nbsp;</a></span>operator==() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two dense matrices with different storage order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga192685ae7dfdfa74ee94a9d6c51d1809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga192685ae7dfdfa74ee94a9d6c51d1809">&sect;&nbsp;</a></span>operator==() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a dense matrix and a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side row-major sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga8212c8f46b5a2e31e355922f8fc2e3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8212c8f46b5a2e31e355922f8fc2e3fc">&sect;&nbsp;</a></span>operator==() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a dense matrix and a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side column-major sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga242470c706af7ba3a96eb35a1816b4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242470c706af7ba3a96eb35a1816b4cf">&sect;&nbsp;</a></span>operator==() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a sparse matrix and a dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga11775fe4d60690cbdc76e71ccb71c545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11775fe4d60690cbdc76e71ccb71c545">&sect;&nbsp;</a></span>operator==() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt; blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a row-major dense matrix and a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side row-major dense matrix for the comparison. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if all elements of the matrix are equal to the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> all values of the matrix are equal to the scalar value, the equality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a id="gab3947c9d43314d45fb4e000ff4a08859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3947c9d43314d45fb4e000ff4a08859">&sect;&nbsp;</a></span>operator==() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt; blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a column-major dense matrix and a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side column-major dense matrix for the comparison. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if all elements of the matrix are equal to the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> all values of the matrix are equal to the scalar value, the equality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a id="ga25855a1d3c48eb1cb6f3f5a66842a85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25855a1d3c48eb1cb6f3f5a66842a85e">&sect;&nbsp;</a></span>operator==() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;<a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T1&gt;, bool &gt; blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a scalar value and a dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the comparison. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side dense matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if all elements of the matrix are equal to the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> all values of the matrix are equal to the scalar value, the equality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a id="ga04b65a79150f5e9e3118257b2f77a0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04b65a79150f5e9e3118257b2f77a0ed">&sect;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename ET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d3/d41/structblaze_1_1Pow.html">Pow</a>&lt;ET&gt;,SO&gt; blaze::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ET&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the exponential value for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">exp</td><td>The exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponential value of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga04b65a79150f5e9e3118257b2f77a0ed" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></em> function computes the exponential value for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga04b65a79150f5e9e3118257b2f77a0ed" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga04b65a79150f5e9e3118257b2f77a0ed">pow</a>( A, 4.2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="gab7c1c25d32e228f167f4544cc950bf1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7c1c25d32e228f167f4544cc950bf1f">&sect;&nbsp;</a></span>ql()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::ql </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QL decomposition of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to be decomposed. </td></tr>
    <tr><td class="paramname">Q</td><td>The resulting <code>Q</code> matrix. </td></tr>
    <tr><td class="paramname">L</td><td>The resulting <code>L</code> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Square matrix cannot be resized to <em>m-by-<em>n</em>.</em> </td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the dense matrix QL decomposition of a general <em>m-by-<em>n</em> matrix</em>. The resulting decomposition has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = Q \cdot L, \]" src="../../form_77.png"/>
</p>
<p>where <code>Q</code> is a general <em>m-by-min</em>(<em>m</em>,<em>n</em>) matrix and <code>L</code> is a lower trapezoidal <em>min</em>(<em>m</em>,<em>n</em>)-by-<em>n</em> matrix. The decomposition is written to the two distinct matrices <code>Q</code> and <code>L</code>, which are resized to the correct dimensions (if possible and necessary).</p>
<p>The function fails if ...</p>
<ul>
<li>... either <em>Q</em> or <em>L</em> are fixed size matrices and the dimensions don't match;</li>
<li>... <em>L</em> is a compile time square matrix, but is required to be non-square.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> A( 32, 16 );</div><div class="line"><span class="comment">// ... Initialization of A</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> Q( 32, 16 );</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> L( 16, 16 );</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gab7c1c25d32e228f167f4544cc950bf1f">ql</a>( A, Q, L );</div><div class="line"></div><div class="line">assert( A == Q * L );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if the fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error. </dd></dl>

</div>
</div>
<a id="ga92d7e3366b2e5020229aba1e123235d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92d7e3366b2e5020229aba1e123235d6">&sect;&nbsp;</a></span>qr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::qr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QR decomposition of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to be decomposed. </td></tr>
    <tr><td class="paramname">Q</td><td>The resulting <code>Q</code> matrix. </td></tr>
    <tr><td class="paramname">R</td><td>The resulting <code>R</code> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Square matrix cannot be resized to m-by-n.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the dense matrix QR decomposition of a general <em>m-by-<em>n</em> matrix</em>. The resulting decomposition has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = Q \cdot R, \]" src="../../form_78.png"/>
</p>
<p>where <code>Q</code> is a general <em>m-by-min</em>(<em>m</em>,<em>n</em>) matrix and <code>R</code> is an upper trapezoidal min(<em>m</em>,<em>n</em>)-by-<em>n</em> matrix. The decomposition is written to the two distinct matrices <code>Q</code> and <code>R</code>, which are resized to the correct dimensions (if possible and necessary).</p>
<p>The function fails if ...</p>
<ul>
<li>... either <em>Q</em> or <em>R</em> are fixed size matrices and the dimensions don't match;</li>
<li>... <em>R</em> is a compile time square matrix, but is required to be non-square.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> A( 32, 16 );</div><div class="line"><span class="comment">// ... Initialization of A</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> Q( 32, 16 );</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> R( 16, 16 );</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga92d7e3366b2e5020229aba1e123235d6">qr</a>( A, Q, R );</div><div class="line"></div><div class="line">assert( A == Q * R );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if the fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error. </dd></dl>

</div>
</div>
<a id="ga146e7401b84cc73dc213edc50bf3a236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga146e7401b84cc73dc213edc50bf3a236">&sect;&nbsp;</a></span>real()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../dd/df4/structblaze_1_1Real.html">Real</a>,SO&gt; blaze::real </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix containing the real part of each single element of <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The real part of each single element of <em>dm</em>.</dd></dl>
<p>The <em>real</em> function calculates the real part of each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>real</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga146e7401b84cc73dc213edc50bf3a236">real</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaeda0fbc301f6a9849bd1aedb24e3c4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeda0fbc301f6a9849bd1aedb24e3c4bc">&sect;&nbsp;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../de/d83/structblaze_1_1Round.html">Round</a>,SO&gt; blaze::round </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc">round</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga28d8769f4cf3189184544ab620949dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28d8769f4cf3189184544ab620949dba">&sect;&nbsp;</a></span>rq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::rq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RQ decomposition of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to be decomposed. </td></tr>
    <tr><td class="paramname">R</td><td>The resulting <code>R</code> matrix. </td></tr>
    <tr><td class="paramname">Q</td><td>The resulting <code>Q</code> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Square matrix cannot be resized to <em>m-by-<em>n</em>.</em> </td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the dense matrix RQ decomposition of a general <em>m-by-<em>n</em> matrix</em>. The resulting decomposition has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = R \cdot Q, \]" src="../../form_79.png"/>
</p>
<p>where <code>R</code> is an upper trapezoidal <em>m-by-min</em>(<em>m</em>,<em>n</em>) matrix and <code>Q</code> is a general min(<em>m</em>,<em>n</em>)-by-<em>n</em> matrix. The decomposition is written to the two distinct matrices <code>R</code> and <code>Q</code>, which are resized to the correct dimensions (if possible and necessary).</p>
<p>The function fails if ...</p>
<ul>
<li>... either <em>R</em> or <em>Q</em> are fixed size matrices and the dimensions don't match;</li>
<li>... <em>R</em> is a compile time square matrix, but is required to be non-square.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> A( 32, 16 );</div><div class="line"><span class="comment">// ... Initialization of A</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> R( 32, 16 );</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> Q( 16, 16 );</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga28d8769f4cf3189184544ab620949dba">rq</a>( A, R, Q );</div><div class="line"></div><div class="line">assert( A == R * Q );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if the fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error. </dd></dl>

</div>
</div>
<a id="gaeac3b9aff5df5e547819e485321f4762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeac3b9aff5df5e547819e485321f4762">&sect;&nbsp;</a></span>serial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/dec/classblaze_1_1DMatSerialExpr.html">DMatSerialExpr</a>&lt; MT, SO &gt; blaze::serial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the serial evaluation of the given dense matrix expression <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated dense matrix.</dd></dl>
<p>The <em>serial</em> function forces the serial evaluation of the given dense matrix expression <em>dm</em>. The function returns an expression representing the operation.<br />
The following example demonstrates the use of the <em>serial</em> function</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaeac3b9aff5df5e547819e485321f4762">serial</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga0a06568d5cd7314f4a0995a051d68062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a06568d5cd7314f4a0995a051d68062">&sect;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../de/d56/structblaze_1_1Sin.html">Sin</a>,SO&gt; blaze::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga0a06568d5cd7314f4a0995a051d68062" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a></em> function computes the sine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga0a06568d5cd7314f4a0995a051d68062" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga0a06568d5cd7314f4a0995a051d68062">sin</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4111317de20c08c0a40b10182eee2539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4111317de20c08c0a40b10182eee2539">&sect;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d4/d59/structblaze_1_1Sinh.html">Sinh</a>,SO&gt; blaze::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic sine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga4111317de20c08c0a40b10182eee2539" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a></em> function computes the hyperbolic sine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga4111317de20c08c0a40b10182eee2539" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga4111317de20c08c0a40b10182eee2539">sinh</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga660a4e2de4b63aac4181af49ac9160d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga660a4e2de4b63aac4181af49ac9160d8">&sect;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../d0/d06/structblaze_1_1Sqrt.html">Sqrt</a>,SO&gt; blaze::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></em> function computes the square root of each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">sqrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga90be532925f9874efae43a23918194ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90be532925f9874efae43a23918194ce">&sect;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../db/d5e/structblaze_1_1Tan.html">Tan</a>,SO&gt; blaze::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tangent of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga90be532925f9874efae43a23918194ce" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a></em> function computes the tangent for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga90be532925f9874efae43a23918194ce" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga90be532925f9874efae43a23918194ce">tan</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gac3e7dda64b4203c08bf00bc0813b4d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3e7dda64b4203c08bf00bc0813b4d05">&sect;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../df/db7/structblaze_1_1Tanh.html">Tanh</a>,SO&gt; blaze::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic tangent of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac3e7dda64b4203c08bf00bc0813b4d05" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a></em> function computes the hyperbolic tangent for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac3e7dda64b4203c08bf00bc0813b4d05" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gac3e7dda64b4203c08bf00bc0813b4d05">tanh</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga33cedfb37c70d3758406251f2389ecac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33cedfb37c70d3758406251f2389ecac">&sect;&nbsp;</a></span>trans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/d86/classblaze_1_1DMatTransExpr.html">DMatTransExpr</a>&lt; MT,!SO &gt; blaze::trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the transpose of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be transposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of the matrix.</dd></dl>
<p>This function returns an expression representing the transpose of the given dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga69688d5359655080afd417a1d7fdbf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69688d5359655080afd417a1d7fdbf40">&sect;&nbsp;</a></span>trunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt;MT,<a class="el" href="../../de/d23/structblaze_1_1Trunc.html">Trunc</a>,SO&gt; blaze::trunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40">trunc</a>( A );</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Oct 8 2016 16:45:03 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
