<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sparse Matrices</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sparse Matrices<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../dd/d7a/group__matrix.html">Matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:da/d08/group__sparse__matrix__expression"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d08/group__sparse__matrix__expression.html">Expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/d6e/group__compressed__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6e/group__compressed__matrix.html">CompressedMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">blaze::SparseMatrix&lt; MT, SO &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sparse matrices.The <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html" title="Base class for sparse matrices.The SparseMatrix class is a base class for all sparse matrix classes...">SparseMatrix</a> class is a base class for all sparse matrix classes. It provides an abstraction from the actual type of the sparse matrix, but enables a conversion back to this type via the <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> base class.  <a href="../../d7/d5d/structblaze_1_1SparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">blaze::MatrixAccessProxy&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for sparse, <img class="formulaInl" alt="$ M \times N $" src="../../form_37.png"/> matrices.The <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> provides safe access to the elements of a non-const sparse matrices.<br />
The proxied access to the elements of a sparse matrix is necessary since it may be possible that several insertion operations happen in the same statement. The following code illustrates this with two examples by means of the <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">CompressedMatrix</a> class:  <a href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaebd2a470dd21fec4c42c12135e2bcbb4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaebd2a470dd21fec4c42c12135e2bcbb4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/da5/classblaze_1_1DVecTSVecMultExpr.html">DVecTSVecMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaebd2a470dd21fec4c42c12135e2bcbb4">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaebd2a470dd21fec4c42c12135e2bcbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the dense vector-sparse vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_113.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaebd2a470dd21fec4c42c12135e2bcbb4">More...</a><br /></td></tr>
<tr class="separator:gaebd2a470dd21fec4c42c12135e2bcbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d22caf00780add553e8ef31199bbc6d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4d22caf00780add553e8ef31199bbc6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT &gt;, const <a class="el" href="../../d1/d98/classblaze_1_1SMatDeclDiagExpr.html">SMatDeclDiagExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4d22caf00780add553e8ef31199bbc6d">blaze::decldiag</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga4d22caf00780add553e8ef31199bbc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-diagonal sparse matrix expression <em>sm</em> as diagonal.  <a href="../../d0/d45/group__sparse__matrix.html#ga4d22caf00780add553e8ef31199bbc6d">More...</a><br /></td></tr>
<tr class="separator:ga4d22caf00780add553e8ef31199bbc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648c564eb671f51f21076710551b20f4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga648c564eb671f51f21076710551b20f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/daf/structblaze_1_1IsHermitian.html">IsHermitian</a>&lt; MT &gt;, const <a class="el" href="../../d9/d8a/classblaze_1_1SMatDeclHermExpr.html">SMatDeclHermExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga648c564eb671f51f21076710551b20f4">blaze::declherm</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga648c564eb671f51f21076710551b20f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-Hermitian sparse matrix expression <em>sm</em> as Hermitian.  <a href="../../d0/d45/group__sparse__matrix.html#ga648c564eb671f51f21076710551b20f4">More...</a><br /></td></tr>
<tr class="separator:ga648c564eb671f51f21076710551b20f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae87fc98150845d427d4f991b02e29d6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaae87fc98150845d427d4f991b02e29d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT &gt;, const <a class="el" href="../../d3/d3c/classblaze_1_1SMatDeclLowExpr.html">SMatDeclLowExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaae87fc98150845d427d4f991b02e29d6">blaze::decllow</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaae87fc98150845d427d4f991b02e29d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-lower sparse matrix expression <em>sm</em> as lower.  <a href="../../d0/d45/group__sparse__matrix.html#gaae87fc98150845d427d4f991b02e29d6">More...</a><br /></td></tr>
<tr class="separator:gaae87fc98150845d427d4f991b02e29d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae57991e440a9182c47df1bdb5a7b3777"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae57991e440a9182c47df1bdb5a7b3777"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; MT &gt;, const <a class="el" href="../../da/da0/classblaze_1_1SMatDeclSymExpr.html">SMatDeclSymExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gae57991e440a9182c47df1bdb5a7b3777">blaze::declsym</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gae57991e440a9182c47df1bdb5a7b3777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-symmetric sparse matrix expression <em>sm</em> as symmetric.  <a href="../../d0/d45/group__sparse__matrix.html#gae57991e440a9182c47df1bdb5a7b3777">More...</a><br /></td></tr>
<tr class="separator:gae57991e440a9182c47df1bdb5a7b3777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2bcedc4df50276d86ae996d5e14db46"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf2bcedc4df50276d86ae996d5e14db46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT &gt;, const <a class="el" href="../../d5/df5/classblaze_1_1SMatDeclUppExpr.html">SMatDeclUppExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaf2bcedc4df50276d86ae996d5e14db46">blaze::declupp</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaf2bcedc4df50276d86ae996d5e14db46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-upper sparse matrix expression <em>sm</em> as upper.  <a href="../../d0/d45/group__sparse__matrix.html#gaf2bcedc4df50276d86ae996d5e14db46">More...</a><br /></td></tr>
<tr class="separator:gaf2bcedc4df50276d86ae996d5e14db46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae18cc9f2429336161ac3cdc8087b0fd2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae18cc9f2429336161ac3cdc8087b0fd2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/da4/classblaze_1_1SMatEvalExpr.html">SMatEvalExpr</a>&lt; MT, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gae18cc9f2429336161ac3cdc8087b0fd2">blaze::eval</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gae18cc9f2429336161ac3cdc8087b0fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given sparse matrix expression <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gae18cc9f2429336161ac3cdc8087b0fd2">More...</a><br /></td></tr>
<tr class="separator:gae18cc9f2429336161ac3cdc8087b0fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22ca357aeee42c5e4177238755fc158f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename OP &gt; </td></tr>
<tr class="memitem:ga22ca357aeee42c5e4177238755fc158f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, OP, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga22ca357aeee42c5e4177238755fc158f">blaze::forEach</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm, OP op)</td></tr>
<tr class="memdesc:ga22ca357aeee42c5e4177238755fc158f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga22ca357aeee42c5e4177238755fc158f">More...</a><br /></td></tr>
<tr class="separator:ga22ca357aeee42c5e4177238755fc158f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1e7ea11bb8081ffe32dd392262fa5a6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa1e7ea11bb8081ffe32dd392262fa5a6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d6/dae/structblaze_1_1Abs.html">Abs</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa1e7ea11bb8081ffe32dd392262fa5a6">blaze::abs</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaa1e7ea11bb8081ffe32dd392262fa5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaa1e7ea11bb8081ffe32dd392262fa5a6">More...</a><br /></td></tr>
<tr class="separator:gaa1e7ea11bb8081ffe32dd392262fa5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga358be78cf8b2a53deada8c0c8ae6f8a5"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga358be78cf8b2a53deada8c0c8ae6f8a5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d2/d67/structblaze_1_1Floor.html">Floor</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga358be78cf8b2a53deada8c0c8ae6f8a5">blaze::floor</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga358be78cf8b2a53deada8c0c8ae6f8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga358be78cf8b2a53deada8c0c8ae6f8a5">More...</a><br /></td></tr>
<tr class="separator:ga358be78cf8b2a53deada8c0c8ae6f8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaada72ea153bb5e043f70d41581d27a82"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaada72ea153bb5e043f70d41581d27a82"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../da/d9f/structblaze_1_1Ceil.html">Ceil</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaada72ea153bb5e043f70d41581d27a82">blaze::ceil</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaada72ea153bb5e043f70d41581d27a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaada72ea153bb5e043f70d41581d27a82">More...</a><br /></td></tr>
<tr class="separator:gaada72ea153bb5e043f70d41581d27a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029ccca19a29c1a54b6715de4a5b4982"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga029ccca19a29c1a54b6715de4a5b4982"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d23/structblaze_1_1Trunc.html">Trunc</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga029ccca19a29c1a54b6715de4a5b4982">blaze::trunc</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga029ccca19a29c1a54b6715de4a5b4982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga029ccca19a29c1a54b6715de4a5b4982">More...</a><br /></td></tr>
<tr class="separator:ga029ccca19a29c1a54b6715de4a5b4982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf00020b2c03a0c9c62f5ddb682d2765d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf00020b2c03a0c9c62f5ddb682d2765d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d83/structblaze_1_1Round.html">Round</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaf00020b2c03a0c9c62f5ddb682d2765d">blaze::round</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaf00020b2c03a0c9c62f5ddb682d2765d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaf00020b2c03a0c9c62f5ddb682d2765d">More...</a><br /></td></tr>
<tr class="separator:gaf00020b2c03a0c9c62f5ddb682d2765d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34213ece5d2649ff1eed14be29160671"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga34213ece5d2649ff1eed14be29160671"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../db/ddf/structblaze_1_1Conj.html">Conj</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga34213ece5d2649ff1eed14be29160671">blaze::conj</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga34213ece5d2649ff1eed14be29160671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the complex conjugate of each single element of <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga34213ece5d2649ff1eed14be29160671">More...</a><br /></td></tr>
<tr class="separator:ga34213ece5d2649ff1eed14be29160671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2bd5f850fb678bdc31e41d840de9510"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad2bd5f850fb678bdc31e41d840de9510"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">CTransExprTrait_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gad2bd5f850fb678bdc31e41d840de9510">blaze::ctrans</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gad2bd5f850fb678bdc31e41d840de9510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate transpose matrix of <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gad2bd5f850fb678bdc31e41d840de9510">More...</a><br /></td></tr>
<tr class="separator:gad2bd5f850fb678bdc31e41d840de9510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8c02698aee64e2916bb86755d6a98cc"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf8c02698aee64e2916bb86755d6a98cc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../dd/df4/structblaze_1_1Real.html">Real</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaf8c02698aee64e2916bb86755d6a98cc">blaze::real</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaf8c02698aee64e2916bb86755d6a98cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the real parts of each single element of <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaf8c02698aee64e2916bb86755d6a98cc">More...</a><br /></td></tr>
<tr class="separator:gaf8c02698aee64e2916bb86755d6a98cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd3250ab45273ee41e204887b67542d6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gacd3250ab45273ee41e204887b67542d6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/d61/structblaze_1_1Imag.html">Imag</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gacd3250ab45273ee41e204887b67542d6">blaze::imag</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gacd3250ab45273ee41e204887b67542d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the imaginary parts of each single element of <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gacd3250ab45273ee41e204887b67542d6">More...</a><br /></td></tr>
<tr class="separator:gacd3250ab45273ee41e204887b67542d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeb91b0d7402619f999384384217328a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gafeb91b0d7402619f999384384217328a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d0/d06/structblaze_1_1Sqrt.html">Sqrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gafeb91b0d7402619f999384384217328a">blaze::sqrt</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gafeb91b0d7402619f999384384217328a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gafeb91b0d7402619f999384384217328a">More...</a><br /></td></tr>
<tr class="separator:gafeb91b0d7402619f999384384217328a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9c7ceebe89f74089dae4fc14ec0b4e9"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa9c7ceebe89f74089dae4fc14ec0b4e9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/d20/structblaze_1_1InvSqrt.html">InvSqrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa9c7ceebe89f74089dae4fc14ec0b4e9">blaze::invsqrt</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaa9c7ceebe89f74089dae4fc14ec0b4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse square root of each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaa9c7ceebe89f74089dae4fc14ec0b4e9">More...</a><br /></td></tr>
<tr class="separator:gaa9c7ceebe89f74089dae4fc14ec0b4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a8595eb108e7db65b840639c1876f29"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4a8595eb108e7db65b840639c1876f29"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d6/d4c/structblaze_1_1Cbrt.html">Cbrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4a8595eb108e7db65b840639c1876f29">blaze::cbrt</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga4a8595eb108e7db65b840639c1876f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cubic root of each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga4a8595eb108e7db65b840639c1876f29">More...</a><br /></td></tr>
<tr class="separator:ga4a8595eb108e7db65b840639c1876f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bcce93825df78b16f67a4e987165066"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4bcce93825df78b16f67a4e987165066"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d2/d2f/structblaze_1_1InvCbrt.html">InvCbrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4bcce93825df78b16f67a4e987165066">blaze::invcbrt</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga4bcce93825df78b16f67a4e987165066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cubic root of each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga4bcce93825df78b16f67a4e987165066">More...</a><br /></td></tr>
<tr class="separator:ga4bcce93825df78b16f67a4e987165066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37c9b2975d69391340b27767a56addc"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename DT &gt; </td></tr>
<tr class="memitem:gab37c9b2975d69391340b27767a56addc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../da/d15/structblaze_1_1Clamp.html">Clamp</a>&lt; DT &gt;, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gab37c9b2975d69391340b27767a56addc">blaze::clamp</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>)</td></tr>
<tr class="memdesc:gab37c9b2975d69391340b27767a56addc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts each single element of the sparse matrix <em>sm</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_94.png"/>.  <a href="../../d0/d45/group__sparse__matrix.html#gab37c9b2975d69391340b27767a56addc">More...</a><br /></td></tr>
<tr class="separator:gab37c9b2975d69391340b27767a56addc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d48ddafc58459876471f1cd1400660"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename ET &gt; </td></tr>
<tr class="memitem:ga39d48ddafc58459876471f1cd1400660"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/d41/structblaze_1_1Pow.html">Pow</a>&lt; ET &gt;, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga39d48ddafc58459876471f1cd1400660">blaze::pow</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm, ET <a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">exp</a>)</td></tr>
<tr class="memdesc:ga39d48ddafc58459876471f1cd1400660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponential value for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga39d48ddafc58459876471f1cd1400660">More...</a><br /></td></tr>
<tr class="separator:ga39d48ddafc58459876471f1cd1400660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f88b09a654056d8c02f29e886884485"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7f88b09a654056d8c02f29e886884485"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/d45/structblaze_1_1Exp.html">Exp</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga7f88b09a654056d8c02f29e886884485">blaze::exp</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga7f88b09a654056d8c02f29e886884485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga7f88b09a654056d8c02f29e886884485">More...</a><br /></td></tr>
<tr class="separator:ga7f88b09a654056d8c02f29e886884485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d6c42bcba2324f95299765cfa4eaedd"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga6d6c42bcba2324f95299765cfa4eaedd"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/dbb/structblaze_1_1Exp2.html">Exp2</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga6d6c42bcba2324f95299765cfa4eaedd">blaze::exp2</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga6d6c42bcba2324f95299765cfa4eaedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga6d6c42bcba2324f95299765cfa4eaedd">More...</a><br /></td></tr>
<tr class="separator:ga6d6c42bcba2324f95299765cfa4eaedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa173a14545cd73289534917fc96ff7cb"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa173a14545cd73289534917fc96ff7cb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../db/dc8/structblaze_1_1Exp10.html">Exp10</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa173a14545cd73289534917fc96ff7cb">blaze::exp10</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaa173a14545cd73289534917fc96ff7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaa173a14545cd73289534917fc96ff7cb">More...</a><br /></td></tr>
<tr class="separator:gaa173a14545cd73289534917fc96ff7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10cff4f15dda50d6b49aa1f7bc032282"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga10cff4f15dda50d6b49aa1f7bc032282"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/d9c/structblaze_1_1Log.html">Log</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga10cff4f15dda50d6b49aa1f7bc032282">blaze::log</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga10cff4f15dda50d6b49aa1f7bc032282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga10cff4f15dda50d6b49aa1f7bc032282">More...</a><br /></td></tr>
<tr class="separator:ga10cff4f15dda50d6b49aa1f7bc032282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44459bed8c0394e623f85e7060736f1f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga44459bed8c0394e623f85e7060736f1f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d33/structblaze_1_1Log10.html">Log10</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga44459bed8c0394e623f85e7060736f1f">blaze::log10</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga44459bed8c0394e623f85e7060736f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary logarithm for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga44459bed8c0394e623f85e7060736f1f">More...</a><br /></td></tr>
<tr class="separator:ga44459bed8c0394e623f85e7060736f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7d576f2bca1424a5fd5f57da21a85c3"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad7d576f2bca1424a5fd5f57da21a85c3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d5/dc7/structblaze_1_1Log2.html">Log2</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gad7d576f2bca1424a5fd5f57da21a85c3">blaze::log2</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gad7d576f2bca1424a5fd5f57da21a85c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the common logarithm for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gad7d576f2bca1424a5fd5f57da21a85c3">More...</a><br /></td></tr>
<tr class="separator:gad7d576f2bca1424a5fd5f57da21a85c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a45f5774abd4565a54493af5d233260"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7a45f5774abd4565a54493af5d233260"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d56/structblaze_1_1Sin.html">Sin</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga7a45f5774abd4565a54493af5d233260">blaze::sin</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga7a45f5774abd4565a54493af5d233260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga7a45f5774abd4565a54493af5d233260">More...</a><br /></td></tr>
<tr class="separator:ga7a45f5774abd4565a54493af5d233260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68febffb11ae18361479f5af5ac38b19"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga68febffb11ae18361479f5af5ac38b19"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/dde/structblaze_1_1Asin.html">Asin</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga68febffb11ae18361479f5af5ac38b19">blaze::asin</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga68febffb11ae18361479f5af5ac38b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse sine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga68febffb11ae18361479f5af5ac38b19">More...</a><br /></td></tr>
<tr class="separator:ga68febffb11ae18361479f5af5ac38b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73fb5d6b6ea84ae2d5598f78e55553d2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga73fb5d6b6ea84ae2d5598f78e55553d2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/d59/structblaze_1_1Sinh.html">Sinh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga73fb5d6b6ea84ae2d5598f78e55553d2">blaze::sinh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga73fb5d6b6ea84ae2d5598f78e55553d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga73fb5d6b6ea84ae2d5598f78e55553d2">More...</a><br /></td></tr>
<tr class="separator:ga73fb5d6b6ea84ae2d5598f78e55553d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd7d165a5bf6c8dd5c2ba42f43d9970"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaffd7d165a5bf6c8dd5c2ba42f43d9970"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d0/d08/structblaze_1_1Asinh.html">Asinh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaffd7d165a5bf6c8dd5c2ba42f43d9970">blaze::asinh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaffd7d165a5bf6c8dd5c2ba42f43d9970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaffd7d165a5bf6c8dd5c2ba42f43d9970">More...</a><br /></td></tr>
<tr class="separator:gaffd7d165a5bf6c8dd5c2ba42f43d9970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4acdc829fc0fae8ec14bf6e1f862519c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4acdc829fc0fae8ec14bf6e1f862519c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/d0a/structblaze_1_1Cos.html">Cos</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4acdc829fc0fae8ec14bf6e1f862519c">blaze::cos</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga4acdc829fc0fae8ec14bf6e1f862519c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga4acdc829fc0fae8ec14bf6e1f862519c">More...</a><br /></td></tr>
<tr class="separator:ga4acdc829fc0fae8ec14bf6e1f862519c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82409239e21c5f9625391762bf7e068b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga82409239e21c5f9625391762bf7e068b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/db3/structblaze_1_1Acos.html">Acos</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga82409239e21c5f9625391762bf7e068b">blaze::acos</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga82409239e21c5f9625391762bf7e068b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cosine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga82409239e21c5f9625391762bf7e068b">More...</a><br /></td></tr>
<tr class="separator:ga82409239e21c5f9625391762bf7e068b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21427441f4e8fc6f208f7e3cb6ed7160"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga21427441f4e8fc6f208f7e3cb6ed7160"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/db2/structblaze_1_1Cosh.html">Cosh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga21427441f4e8fc6f208f7e3cb6ed7160">blaze::cosh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga21427441f4e8fc6f208f7e3cb6ed7160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga21427441f4e8fc6f208f7e3cb6ed7160">More...</a><br /></td></tr>
<tr class="separator:ga21427441f4e8fc6f208f7e3cb6ed7160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69eacda66e1bcfa22a3e8e6f9df8b748"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga69eacda66e1bcfa22a3e8e6f9df8b748"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../dd/d35/structblaze_1_1Acosh.html">Acosh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga69eacda66e1bcfa22a3e8e6f9df8b748">blaze::acosh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga69eacda66e1bcfa22a3e8e6f9df8b748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga69eacda66e1bcfa22a3e8e6f9df8b748">More...</a><br /></td></tr>
<tr class="separator:ga69eacda66e1bcfa22a3e8e6f9df8b748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d261d1a314d04ac889f8d2255cc8ee"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga86d261d1a314d04ac889f8d2255cc8ee"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../db/d5e/structblaze_1_1Tan.html">Tan</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga86d261d1a314d04ac889f8d2255cc8ee">blaze::tan</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga86d261d1a314d04ac889f8d2255cc8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga86d261d1a314d04ac889f8d2255cc8ee">More...</a><br /></td></tr>
<tr class="separator:ga86d261d1a314d04ac889f8d2255cc8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3b6d1c85c3210ff3aa8cfe70e1e2c39"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa3b6d1c85c3210ff3aa8cfe70e1e2c39"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/dfc/structblaze_1_1Atan.html">Atan</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa3b6d1c85c3210ff3aa8cfe70e1e2c39">blaze::atan</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaa3b6d1c85c3210ff3aa8cfe70e1e2c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse tangent for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaa3b6d1c85c3210ff3aa8cfe70e1e2c39">More...</a><br /></td></tr>
<tr class="separator:gaa3b6d1c85c3210ff3aa8cfe70e1e2c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga096a2c65eccc14ba47e321c6f371e609"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga096a2c65eccc14ba47e321c6f371e609"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/db7/structblaze_1_1Tanh.html">Tanh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga096a2c65eccc14ba47e321c6f371e609">blaze::tanh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga096a2c65eccc14ba47e321c6f371e609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga096a2c65eccc14ba47e321c6f371e609">More...</a><br /></td></tr>
<tr class="separator:ga096a2c65eccc14ba47e321c6f371e609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a297caa44dd4912432dff03822ddb6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf7a297caa44dd4912432dff03822ddb6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d4d/structblaze_1_1Atanh.html">Atanh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaf7a297caa44dd4912432dff03822ddb6">blaze::atanh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaf7a297caa44dd4912432dff03822ddb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaf7a297caa44dd4912432dff03822ddb6">More...</a><br /></td></tr>
<tr class="separator:gaf7a297caa44dd4912432dff03822ddb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcea433c7ecf6b394f3d4d00ba3bb92a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gadcea433c7ecf6b394f3d4d00ba3bb92a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../dd/d2c/structblaze_1_1Erf.html">Erf</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gadcea433c7ecf6b394f3d4d00ba3bb92a">blaze::erf</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gadcea433c7ecf6b394f3d4d00ba3bb92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gadcea433c7ecf6b394f3d4d00ba3bb92a">More...</a><br /></td></tr>
<tr class="separator:gadcea433c7ecf6b394f3d4d00ba3bb92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ae8c92dafa626cb72f234fabfb239c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga99ae8c92dafa626cb72f234fabfb239c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d5a/structblaze_1_1Erfc.html">Erfc</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga99ae8c92dafa626cb72f234fabfb239c">blaze::erfc</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga99ae8c92dafa626cb72f234fabfb239c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complementary error function for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga99ae8c92dafa626cb72f234fabfb239c">More...</a><br /></td></tr>
<tr class="separator:ga99ae8c92dafa626cb72f234fabfb239c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcdfd60edc63a07bdb86e1592fbdcd41"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:gadcdfd60edc63a07bdb86e1592fbdcd41"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">DivExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gadcdfd60edc63a07bdb86e1592fbdcd41">blaze::operator/</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:gadcdfd60edc63a07bdb86e1592fbdcd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the division of a sparse matrix by a scalar value ( <img class="formulaInl" alt="$ A=B/s $" src="../../form_100.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gadcdfd60edc63a07bdb86e1592fbdcd41">More...</a><br /></td></tr>
<tr class="separator:gadcdfd60edc63a07bdb86e1592fbdcd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6030a90ba2a81dd899d35c9de718a662"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga6030a90ba2a81dd899d35c9de718a662"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d6e/classblaze_1_1SMatScalarMultExpr.html">SMatScalarMultExpr</a>&lt; MT, <a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">UnderlyingBuiltin_</a>&lt; MT &gt;, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga6030a90ba2a81dd899d35c9de718a662">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga6030a90ba2a81dd899d35c9de718a662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a sparse matrix ( <img class="formulaInl" alt="$ A = -B $" src="../../form_101.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga6030a90ba2a81dd899d35c9de718a662">More...</a><br /></td></tr>
<tr class="separator:ga6030a90ba2a81dd899d35c9de718a662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga290b0b2bbf69a2061d54e62b7ca6d842"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga290b0b2bbf69a2061d54e62b7ca6d842"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga290b0b2bbf69a2061d54e62b7ca6d842">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga290b0b2bbf69a2061d54e62b7ca6d842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse matrix and a scalar value ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_43.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga290b0b2bbf69a2061d54e62b7ca6d842">More...</a><br /></td></tr>
<tr class="separator:ga290b0b2bbf69a2061d54e62b7ca6d842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7863549ad292599fbd054279d31b743"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gaa7863549ad292599fbd054279d31b743"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa7863549ad292599fbd054279d31b743">blaze::operator*</a> (T1 scalar, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:gaa7863549ad292599fbd054279d31b743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a sparse matrix ( <img class="formulaInl" alt="$ A=s*B $" src="../../form_102.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaa7863549ad292599fbd054279d31b743">More...</a><br /></td></tr>
<tr class="separator:gaa7863549ad292599fbd054279d31b743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ccba470284d1a9e137ff88b09be550e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga5ccba470284d1a9e137ff88b09be550e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/dc8/classblaze_1_1SMatSerialExpr.html">SMatSerialExpr</a>&lt; MT, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga5ccba470284d1a9e137ff88b09be550e">blaze::serial</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga5ccba470284d1a9e137ff88b09be550e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the serial evaluation of the given sparse matrix expression <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga5ccba470284d1a9e137ff88b09be550e">More...</a><br /></td></tr>
<tr class="separator:ga5ccba470284d1a9e137ff88b09be550e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6d0bef279f8d41722214ba0a93c191"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9d6d0bef279f8d41722214ba0a93c191"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d18/classblaze_1_1SMatSMatAddExpr.html">SMatSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga9d6d0bef279f8d41722214ba0a93c191">blaze::operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga9d6d0bef279f8d41722214ba0a93c191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga9d6d0bef279f8d41722214ba0a93c191">More...</a><br /></td></tr>
<tr class="separator:ga9d6d0bef279f8d41722214ba0a93c191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7be5ba7d99f09441c139d426c172ad7f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7be5ba7d99f09441c139d426c172ad7f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d13/classblaze_1_1SMatSMatMultExpr.html">SMatSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga7be5ba7d99f09441c139d426c172ad7f">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7be5ba7d99f09441c139d426c172ad7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga7be5ba7d99f09441c139d426c172ad7f">More...</a><br /></td></tr>
<tr class="separator:ga7be5ba7d99f09441c139d426c172ad7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b71cdd1a878c14f672b47a3522575e1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1b71cdd1a878c14f672b47a3522575e1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d92/classblaze_1_1SMatSMatSubExpr.html">SMatSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga1b71cdd1a878c14f672b47a3522575e1">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1b71cdd1a878c14f672b47a3522575e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga1b71cdd1a878c14f672b47a3522575e1">More...</a><br /></td></tr>
<tr class="separator:ga1b71cdd1a878c14f672b47a3522575e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c5bf80756338642cfcaff18b96ff7e6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga9c5bf80756338642cfcaff18b96ff7e6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/d09/classblaze_1_1SMatTransExpr.html">SMatTransExpr</a>&lt; MT,!SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga9c5bf80756338642cfcaff18b96ff7e6">blaze::trans</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga9c5bf80756338642cfcaff18b96ff7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given sparse matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga9c5bf80756338642cfcaff18b96ff7e6">More...</a><br /></td></tr>
<tr class="separator:ga9c5bf80756338642cfcaff18b96ff7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga112e886e84bf2d9155a12623fa1131a9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga112e886e84bf2d9155a12623fa1131a9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d9c/classblaze_1_1SMatTSMatAddExpr.html">SMatTSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga112e886e84bf2d9155a12623fa1131a9">blaze::operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga112e886e84bf2d9155a12623fa1131a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga112e886e84bf2d9155a12623fa1131a9">More...</a><br /></td></tr>
<tr class="separator:ga112e886e84bf2d9155a12623fa1131a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf69176ce01c8deed13b6288d04e7fb4e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaf69176ce01c8deed13b6288d04e7fb4e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d9c/classblaze_1_1SMatTSMatAddExpr.html">SMatTSMatAddExpr</a>&lt; T2, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaf69176ce01c8deed13b6288d04e7fb4e">blaze::operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf69176ce01c8deed13b6288d04e7fb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaf69176ce01c8deed13b6288d04e7fb4e">More...</a><br /></td></tr>
<tr class="separator:gaf69176ce01c8deed13b6288d04e7fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fc17104bcd6eac213fcc2574e68eff7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga4fc17104bcd6eac213fcc2574e68eff7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/dc8/classblaze_1_1SMatTSMatMultExpr.html">SMatTSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4fc17104bcd6eac213fcc2574e68eff7">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4fc17104bcd6eac213fcc2574e68eff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga4fc17104bcd6eac213fcc2574e68eff7">More...</a><br /></td></tr>
<tr class="separator:ga4fc17104bcd6eac213fcc2574e68eff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f555464ba008c823eab85d659a2abe"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gac7f555464ba008c823eab85d659a2abe"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/dad/classblaze_1_1SMatTSMatSubExpr.html">SMatTSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gac7f555464ba008c823eab85d659a2abe">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac7f555464ba008c823eab85d659a2abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gac7f555464ba008c823eab85d659a2abe">More...</a><br /></td></tr>
<tr class="separator:gac7f555464ba008c823eab85d659a2abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa25c477c724abcfb4503afc172a51c3f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa25c477c724abcfb4503afc172a51c3f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d3b/classblaze_1_1SVecTDVecMultExpr.html">SVecTDVecMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa25c477c724abcfb4503afc172a51c3f">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa25c477c724abcfb4503afc172a51c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the sparse vector-dense vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_113.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaa25c477c724abcfb4503afc172a51c3f">More...</a><br /></td></tr>
<tr class="separator:gaa25c477c724abcfb4503afc172a51c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab41594bee8f746276b88e56b2b92051"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaab41594bee8f746276b88e56b2b92051"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d04/classblaze_1_1SVecTSVecMultExpr.html">SVecTSVecMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaab41594bee8f746276b88e56b2b92051">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaab41594bee8f746276b88e56b2b92051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the sparse vector-sparse vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_113.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaab41594bee8f746276b88e56b2b92051">More...</a><br /></td></tr>
<tr class="separator:gaab41594bee8f746276b88e56b2b92051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9687234a3702cb5d47a825d51809e923"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9687234a3702cb5d47a825d51809e923"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;, <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga9687234a3702cb5d47a825d51809e923">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga9687234a3702cb5d47a825d51809e923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga9687234a3702cb5d47a825d51809e923">More...</a><br /></td></tr>
<tr class="separator:ga9687234a3702cb5d47a825d51809e923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d0ec5eb55760f5c13f4f3311c7c8db"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa8d0ec5eb55760f5c13f4f3311c7c8db"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/dc3/classblaze_1_1TSMatSMatMultExpr.html">TSMatSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa8d0ec5eb55760f5c13f4f3311c7c8db">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa8d0ec5eb55760f5c13f4f3311c7c8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaa8d0ec5eb55760f5c13f4f3311c7c8db">More...</a><br /></td></tr>
<tr class="separator:gaa8d0ec5eb55760f5c13f4f3311c7c8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62ef8d85c5124466413b19db53823068"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga62ef8d85c5124466413b19db53823068"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d0d/classblaze_1_1TSMatSMatSubExpr.html">TSMatSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga62ef8d85c5124466413b19db53823068">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga62ef8d85c5124466413b19db53823068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga62ef8d85c5124466413b19db53823068">More...</a><br /></td></tr>
<tr class="separator:ga62ef8d85c5124466413b19db53823068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1672d9c402ae8df5b15063e9905e9b1d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1672d9c402ae8df5b15063e9905e9b1d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d90/classblaze_1_1TSMatTSMatAddExpr.html">TSMatTSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga1672d9c402ae8df5b15063e9905e9b1d">blaze::operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1672d9c402ae8df5b15063e9905e9b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga1672d9c402ae8df5b15063e9905e9b1d">More...</a><br /></td></tr>
<tr class="separator:ga1672d9c402ae8df5b15063e9905e9b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69ea4f1b211288029950a99e1e109971"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga69ea4f1b211288029950a99e1e109971"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/dec/classblaze_1_1TSMatTSMatMultExpr.html">TSMatTSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga69ea4f1b211288029950a99e1e109971">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga69ea4f1b211288029950a99e1e109971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga69ea4f1b211288029950a99e1e109971">More...</a><br /></td></tr>
<tr class="separator:ga69ea4f1b211288029950a99e1e109971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01d7793334fbcfec19fae5365a921d4a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga01d7793334fbcfec19fae5365a921d4a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d3f/classblaze_1_1TSMatTSMatSubExpr.html">TSMatTSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga01d7793334fbcfec19fae5365a921d4a">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga01d7793334fbcfec19fae5365a921d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga01d7793334fbcfec19fae5365a921d4a">More...</a><br /></td></tr>
<tr class="separator:ga01d7793334fbcfec19fae5365a921d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga5be271299bf9d21d79adbc98fefc7c73">blaze::operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5be271299bf9d21d79adbc98fefc7c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two row-major sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#ga5be271299bf9d21d79adbc98fefc7c73">More...</a><br /></td></tr>
<tr class="separator:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8fe418ba6e1d414a1915677cd42a034"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gad8fe418ba6e1d414a1915677cd42a034"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gad8fe418ba6e1d414a1915677cd42a034">blaze::operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad8fe418ba6e1d414a1915677cd42a034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two column-major sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#gad8fe418ba6e1d414a1915677cd42a034">More...</a><br /></td></tr>
<tr class="separator:gad8fe418ba6e1d414a1915677cd42a034"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
MatrixAccessProxy global functions</h2></td></tr>
<tr class="memitem:gaa329d4ff44a8780cb8f29343ffc32790"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaa329d4ff44a8780cb8f29343ffc32790"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa329d4ff44a8780cb8f29343ffc32790">blaze::reset</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa329d4ff44a8780cb8f29343ffc32790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../d0/d45/group__sparse__matrix.html#gaa329d4ff44a8780cb8f29343ffc32790">More...</a><br /></td></tr>
<tr class="separator:gaa329d4ff44a8780cb8f29343ffc32790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga3d9a939b2471f71e81d8eee8c22a5ae4">blaze::clear</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../d0/d45/group__sparse__matrix.html#ga3d9a939b2471f71e81d8eee8c22a5ae4">More...</a><br /></td></tr>
<tr class="separator:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga045077f88b05d5f5fa13c4ef1eaf0161"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga045077f88b05d5f5fa13c4ef1eaf0161"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga045077f88b05d5f5fa13c4ef1eaf0161">blaze::isDefault</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga045077f88b05d5f5fa13c4ef1eaf0161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../d0/d45/group__sparse__matrix.html#ga045077f88b05d5f5fa13c4ef1eaf0161">More...</a><br /></td></tr>
<tr class="separator:ga045077f88b05d5f5fa13c4ef1eaf0161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e93d386f385481def668d7a6edc03b"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga87e93d386f385481def668d7a6edc03b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga87e93d386f385481def668d7a6edc03b">blaze::isReal</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga87e93d386f385481def668d7a6edc03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix element represents a real number.  <a href="../../d0/d45/group__sparse__matrix.html#ga87e93d386f385481def668d7a6edc03b">More...</a><br /></td></tr>
<tr class="separator:ga87e93d386f385481def668d7a6edc03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4459ccfdf53dffab841e1a7ea2b3833"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gad4459ccfdf53dffab841e1a7ea2b3833"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gad4459ccfdf53dffab841e1a7ea2b3833">blaze::isZero</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad4459ccfdf53dffab841e1a7ea2b3833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../d0/d45/group__sparse__matrix.html#gad4459ccfdf53dffab841e1a7ea2b3833">More...</a><br /></td></tr>
<tr class="separator:gad4459ccfdf53dffab841e1a7ea2b3833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab379db74bff9739a4b1d7dcf7594766a"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gab379db74bff9739a4b1d7dcf7594766a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gab379db74bff9739a4b1d7dcf7594766a">blaze::isOne</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gab379db74bff9739a4b1d7dcf7594766a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../d0/d45/group__sparse__matrix.html#gab379db74bff9739a4b1d7dcf7594766a">More...</a><br /></td></tr>
<tr class="separator:gab379db74bff9739a4b1d7dcf7594766a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272972206a96bceac26706156979ddc0"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga272972206a96bceac26706156979ddc0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga272972206a96bceac26706156979ddc0">blaze::isnan</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga272972206a96bceac26706156979ddc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../d0/d45/group__sparse__matrix.html#ga272972206a96bceac26706156979ddc0">More...</a><br /></td></tr>
<tr class="separator:ga272972206a96bceac26706156979ddc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48b3ef0a633565ae5ae8d03422150d66"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga48b3ef0a633565ae5ae8d03422150d66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga48b3ef0a633565ae5ae8d03422150d66">blaze::swap</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;a, const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga48b3ef0a633565ae5ae8d03422150d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two access proxies.  <a href="../../d0/d45/group__sparse__matrix.html#ga48b3ef0a633565ae5ae8d03422150d66">More...</a><br /></td></tr>
<tr class="separator:ga48b3ef0a633565ae5ae8d03422150d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e363bb9d02dc099d3d52ba6ad93373"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga56e363bb9d02dc099d3d52ba6ad93373"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga56e363bb9d02dc099d3d52ba6ad93373">blaze::swap</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;a, T &amp;b) noexcept</td></tr>
<tr class="memdesc:ga56e363bb9d02dc099d3d52ba6ad93373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="../../d0/d45/group__sparse__matrix.html#ga56e363bb9d02dc099d3d52ba6ad93373">More...</a><br /></td></tr>
<tr class="separator:ga56e363bb9d02dc099d3d52ba6ad93373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba7ff15d755e738537539e75ec37072"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:ga1ba7ff15d755e738537539e75ec37072"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga1ba7ff15d755e738537539e75ec37072">blaze::swap</a> (T &amp;a, const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga1ba7ff15d755e738537539e75ec37072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="../../d0/d45/group__sparse__matrix.html#ga1ba7ff15d755e738537539e75ec37072">More...</a><br /></td></tr>
<tr class="separator:ga1ba7ff15d755e738537539e75ec37072"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseMatrix operators</h2></td></tr>
<tr class="memitem:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga52adc17fd1c3cf58857e4bbe59d5215a">blaze::operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two sparse matrices with different storage order.  <a href="../../d0/d45/group__sparse__matrix.html#ga52adc17fd1c3cf58857e4bbe59d5215a">More...</a><br /></td></tr>
<tr class="separator:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23358313c28966ce20d3e636914c151f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga23358313c28966ce20d3e636914c151f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga23358313c28966ce20d3e636914c151f">blaze::operator!=</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga23358313c28966ce20d3e636914c151f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#ga23358313c28966ce20d3e636914c151f">More...</a><br /></td></tr>
<tr class="separator:ga23358313c28966ce20d3e636914c151f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3f69b34e146551053564a5ddba4469c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gac3f69b34e146551053564a5ddba4469c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gac3f69b34e146551053564a5ddba4469c">blaze::operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac3f69b34e146551053564a5ddba4469c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two column-major sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#gac3f69b34e146551053564a5ddba4469c">More...</a><br /></td></tr>
<tr class="separator:gac3f69b34e146551053564a5ddba4469c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseMatrix functions</h2></td></tr>
<tr class="memitem:ga5fd7ae64eff3d41879d3fc8a138daa7d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga5fd7ae64eff3d41879d3fc8a138daa7d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga5fd7ae64eff3d41879d3fc8a138daa7d">blaze::isnan</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga5fd7ae64eff3d41879d3fc8a138daa7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given sparse matrix for not-a-number elements.  <a href="../../d0/d45/group__sparse__matrix.html#ga5fd7ae64eff3d41879d3fc8a138daa7d">More...</a><br /></td></tr>
<tr class="separator:ga5fd7ae64eff3d41879d3fc8a138daa7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf68c6f947e934a922cdd9b332bd1d06"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaaf68c6f947e934a922cdd9b332bd1d06"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaaf68c6f947e934a922cdd9b332bd1d06">blaze::isSymmetric</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaaf68c6f947e934a922cdd9b332bd1d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is symmetric.  <a href="../../d0/d45/group__sparse__matrix.html#gaaf68c6f947e934a922cdd9b332bd1d06">More...</a><br /></td></tr>
<tr class="separator:gaaf68c6f947e934a922cdd9b332bd1d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c0fd85aab1d79528022abb07c8e9839"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga5c0fd85aab1d79528022abb07c8e9839"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga5c0fd85aab1d79528022abb07c8e9839">blaze::isHermitian</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga5c0fd85aab1d79528022abb07c8e9839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is Hermitian.  <a href="../../d0/d45/group__sparse__matrix.html#ga5c0fd85aab1d79528022abb07c8e9839">More...</a><br /></td></tr>
<tr class="separator:ga5c0fd85aab1d79528022abb07c8e9839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e0ca7a0d5a81488e6edf5ff596331a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga47e0ca7a0d5a81488e6edf5ff596331a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga47e0ca7a0d5a81488e6edf5ff596331a">blaze::isUniform</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga47e0ca7a0d5a81488e6edf5ff596331a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a uniform matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga47e0ca7a0d5a81488e6edf5ff596331a">More...</a><br /></td></tr>
<tr class="separator:ga47e0ca7a0d5a81488e6edf5ff596331a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57a4918696d365b52a9e35935be3b3b6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga57a4918696d365b52a9e35935be3b3b6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga57a4918696d365b52a9e35935be3b3b6">blaze::isLower</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga57a4918696d365b52a9e35935be3b3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a lower triangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga57a4918696d365b52a9e35935be3b3b6">More...</a><br /></td></tr>
<tr class="separator:ga57a4918696d365b52a9e35935be3b3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4917d0546e6bcde7ed986fa6ae72cf25"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4917d0546e6bcde7ed986fa6ae72cf25"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4917d0546e6bcde7ed986fa6ae72cf25">blaze::isUniLower</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga4917d0546e6bcde7ed986fa6ae72cf25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a lower unitriangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga4917d0546e6bcde7ed986fa6ae72cf25">More...</a><br /></td></tr>
<tr class="separator:ga4917d0546e6bcde7ed986fa6ae72cf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2707785425307e33a2950873b56ac70"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae2707785425307e33a2950873b56ac70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gae2707785425307e33a2950873b56ac70">blaze::isStrictlyLower</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gae2707785425307e33a2950873b56ac70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a strictly lower triangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#gae2707785425307e33a2950873b56ac70">More...</a><br /></td></tr>
<tr class="separator:gae2707785425307e33a2950873b56ac70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ded972e027174cb24eeb360addd187f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga1ded972e027174cb24eeb360addd187f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga1ded972e027174cb24eeb360addd187f">blaze::isUpper</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga1ded972e027174cb24eeb360addd187f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is an upper triangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga1ded972e027174cb24eeb360addd187f">More...</a><br /></td></tr>
<tr class="separator:ga1ded972e027174cb24eeb360addd187f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4449cb73b43824d7f82352816237a1be"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4449cb73b43824d7f82352816237a1be"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4449cb73b43824d7f82352816237a1be">blaze::isUniUpper</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga4449cb73b43824d7f82352816237a1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is an upper unitriangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga4449cb73b43824d7f82352816237a1be">More...</a><br /></td></tr>
<tr class="separator:ga4449cb73b43824d7f82352816237a1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f046512b938b1f2377975ff3b1060d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga67f046512b938b1f2377975ff3b1060d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga67f046512b938b1f2377975ff3b1060d">blaze::isStrictlyUpper</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga67f046512b938b1f2377975ff3b1060d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a strictly upper triangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga67f046512b938b1f2377975ff3b1060d">More...</a><br /></td></tr>
<tr class="separator:ga67f046512b938b1f2377975ff3b1060d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cde1c159ec32c203e73427e98de26c8"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga9cde1c159ec32c203e73427e98de26c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga9cde1c159ec32c203e73427e98de26c8">blaze::isDiagonal</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga9cde1c159ec32c203e73427e98de26c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the give sparse matrix is diagonal.  <a href="../../d0/d45/group__sparse__matrix.html#ga9cde1c159ec32c203e73427e98de26c8">More...</a><br /></td></tr>
<tr class="separator:ga9cde1c159ec32c203e73427e98de26c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f2b973088b1ae6f538c6fe66837b6d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga33f2b973088b1ae6f538c6fe66837b6d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga33f2b973088b1ae6f538c6fe66837b6d">blaze::isIdentity</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga33f2b973088b1ae6f538c6fe66837b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the give sparse matrix is an identity matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga33f2b973088b1ae6f538c6fe66837b6d">More...</a><br /></td></tr>
<tr class="separator:ga33f2b973088b1ae6f538c6fe66837b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga939c2915cf7e6cb391d024b4c90dca15"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga939c2915cf7e6cb391d024b4c90dca15"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga939c2915cf7e6cb391d024b4c90dca15">blaze::min</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga939c2915cf7e6cb391d024b4c90dca15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the sparse matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga939c2915cf7e6cb391d024b4c90dca15">More...</a><br /></td></tr>
<tr class="separator:ga939c2915cf7e6cb391d024b4c90dca15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a5f94e2e6c14eba8ca707b7a6b7d4b2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga9a5f94e2e6c14eba8ca707b7a6b7d4b2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga9a5f94e2e6c14eba8ca707b7a6b7d4b2">blaze::max</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga9a5f94e2e6c14eba8ca707b7a6b7d4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the sparse matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga9a5f94e2e6c14eba8ca707b7a6b7d4b2">More...</a><br /></td></tr>
<tr class="separator:ga9a5f94e2e6c14eba8ca707b7a6b7d4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa1e7ea11bb8081ffe32dd392262fa5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1e7ea11bb8081ffe32dd392262fa5a6">&sect;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d6/dae/structblaze_1_1Abs.html">Abs</a>,SO&gt; blaze::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This function applies the <a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a> function to each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5">abs</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga82409239e21c5f9625391762bf7e068b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82409239e21c5f9625391762bf7e068b">&sect;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d4/db3/structblaze_1_1Acos.html">Acos</a>,SO&gt; blaze::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse cosine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cosine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gabbea0b8e061ed390f6c7767c9104e40e" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a></em> function computes the inverse cosine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gabbea0b8e061ed390f6c7767c9104e40e" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gabbea0b8e061ed390f6c7767c9104e40e">acos</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga69eacda66e1bcfa22a3e8e6f9df8b748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69eacda66e1bcfa22a3e8e6f9df8b748">&sect;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../dd/d35/structblaze_1_1Acosh.html">Acosh</a>,SO&gt; blaze::acosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic cosine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[1..\infty)$" src="../../form_99.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic cosine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gafdfd453cc8c85f2c9d65bc5d82eb52e5" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a></em> function computes the inverse hyperbolic cosine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gafdfd453cc8c85f2c9d65bc5d82eb52e5" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gafdfd453cc8c85f2c9d65bc5d82eb52e5">acosh</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[1..\infty)$" src="../../form_99.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga68febffb11ae18361479f5af5ac38b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68febffb11ae18361479f5af5ac38b19">&sect;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d3/dde/structblaze_1_1Asin.html">Asin</a>,SO&gt; blaze::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse sine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse sine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab4eed6b2d7c8e03d3ba69de01a1e54ff" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a></em> function computes the inverse sine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab4eed6b2d7c8e03d3ba69de01a1e54ff" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gab4eed6b2d7c8e03d3ba69de01a1e54ff">asin</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gaffd7d165a5bf6c8dd5c2ba42f43d9970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffd7d165a5bf6c8dd5c2ba42f43d9970">&sect;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d0/d08/structblaze_1_1Asinh.html">Asinh</a>,SO&gt; blaze::asinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic sine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic sine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga974e5ff97f8d4c431684ca167bf5be3b" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a></em> function computes the inverse hyperbolic sine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga974e5ff97f8d4c431684ca167bf5be3b" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga974e5ff97f8d4c431684ca167bf5be3b">asinh</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa3b6d1c85c3210ff3aa8cfe70e1e2c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3b6d1c85c3210ff3aa8cfe70e1e2c39">&sect;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d4/dfc/structblaze_1_1Atan.html">Atan</a>,SO&gt; blaze::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse tangent for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse tangent of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab63e8615abfd73eea11c190846d8f14b" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a></em> function computes the inverse tangent for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab63e8615abfd73eea11c190846d8f14b" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gab63e8615abfd73eea11c190846d8f14b">atan</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf7a297caa44dd4912432dff03822ddb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7a297caa44dd4912432dff03822ddb6">&sect;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../de/d4d/structblaze_1_1Atanh.html">Atanh</a>,SO&gt; blaze::atanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic tangent for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic tangent of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaf39e95469abfd502a43219461590266a" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a></em> function computes the inverse hyperbolic tangent for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaf39e95469abfd502a43219461590266a" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaf39e95469abfd502a43219461590266a">atanh</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga4a8595eb108e7db65b840639c1876f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a8595eb108e7db65b840639c1876f29">&sect;&nbsp;</a></span>cbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d6/d4c/structblaze_1_1Cbrt.html">Cbrt</a>,SO&gt; blaze::cbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cubic root of each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cubic root of each single element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></em> function computes the cubic root of each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62">cbrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gaada72ea153bb5e043f70d41581d27a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaada72ea153bb5e043f70d41581d27a82">&sect;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../da/d9f/structblaze_1_1Ceil.html">Ceil</a>,SO&gt; blaze::ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This function applies the <a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a> function to each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b">ceil</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gab37c9b2975d69391340b27767a56addc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab37c9b2975d69391340b27767a56addc">&sect;&nbsp;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename DT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../da/d15/structblaze_1_1Clamp.html">Clamp</a>&lt;DT&gt;,SO&gt; blaze::clamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restricts each single element of the sparse matrix <em>sm</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_94.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">min</td><td>The lower delimiter. </td></tr>
    <tr><td class="paramname">max</td><td>The upper delimiter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix with restricted elements.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaed4231fbd9f5b6bf46307753b34f039c" title="Restricts each single element of the dense matrix dm to the range . ">clamp()</a></em> function restricts each element of the input matrix <em>sm</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_94.png"/>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaed4231fbd9f5b6bf46307753b34f039c" title="Restricts each single element of the dense matrix dm to the range . ">clamp()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaed4231fbd9f5b6bf46307753b34f039c">clamp</a>( A, -1.0, 1.0 );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3d9a939b2471f71e81d8eee8c22a5ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d9a939b2471f71e81d8eee8c22a5ae4">&sect;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clearing the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the element represented by the access proxy to its default initial state. In case the access proxy represents a vector- or matrix-like data structure that provides a <a class="el" href="../../d0/d90/group__diagonal__matrix.html#ga834f663e7bd7bad48600ec5b036269bb" title="Clearing the represented element. ">clear()</a> function, this function clears the vector/matrix to its default initial state. </p>

</div>
</div>
<a id="ga34213ece5d2649ff1eed14be29160671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34213ece5d2649ff1eed14be29160671">&sect;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../db/ddf/structblaze_1_1Conj.html">Conj</a>,SO&gt; blaze::conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix containing the complex conjugate of each single element of <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complex conjugate of each single element of <em>sm</em>.</dd></dl>
<p>The <em>conj</em> function calculates the complex conjugate of each element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>conj</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt; complex&lt;double&gt;</a> &gt; A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga23b5c9bdbb7e7ea2c008808d235f7055">conj</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4acdc829fc0fae8ec14bf6e1f862519c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4acdc829fc0fae8ec14bf6e1f862519c">&sect;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../df/d0a/structblaze_1_1Cos.html">Cos</a>,SO&gt; blaze::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cosine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cosine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6179f49533c111d0c1ed6b9181aabbe7" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a></em> function computes the cosine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6179f49533c111d0c1ed6b9181aabbe7" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6179f49533c111d0c1ed6b9181aabbe7">cos</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga21427441f4e8fc6f208f7e3cb6ed7160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21427441f4e8fc6f208f7e3cb6ed7160">&sect;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../de/db2/structblaze_1_1Cosh.html">Cosh</a>,SO&gt; blaze::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cosine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga3cb0cfa3ce6e0ca00ef6edf910149858" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a></em> function computes the hyperbolic cosine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga3cb0cfa3ce6e0ca00ef6edf910149858" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga3cb0cfa3ce6e0ca00ef6edf910149858">cosh</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gad2bd5f850fb678bdc31e41d840de9510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2bd5f850fb678bdc31e41d840de9510">&sect;&nbsp;</a></span>ctrans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">CTransExprTrait_</a>&lt;MT&gt; blaze::ctrans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the conjugate transpose matrix of <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conjugate transpose of <em>sm</em>.</dd></dl>
<p>The <em>ctrans</em> function returns an expression representing the conjugate transpose (also called adjoint matrix, Hermitian conjugate matrix or transjugate matrix) of the given input matrix <em>sm</em>.<br />
The following example demonstrates the use of the <em>ctrans</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt; complex&lt;double&gt;</a> &gt; A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga48020f64de98036286379dacfa444750">ctrans</a>( A );</div></div><!-- fragment --><p>Note that the <em>ctrans</em> function has the same effect as manually applying the <em>conj</em> and <em>trans</em> function in any order:</p>
<div class="fragment"><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga23b5c9bdbb7e7ea2c008808d235f7055">conj</a>( A ) );  <span class="comment">// Computing the conjugate transpose matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga23b5c9bdbb7e7ea2c008808d235f7055">conj</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( A ) );  <span class="comment">// Computing the conjugate transpose matrix</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga4d22caf00780add553e8ef31199bbc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d22caf00780add553e8ef31199bbc6d">&sect;&nbsp;</a></span>decldiag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT&gt;, const <a class="el" href="../../d1/d98/classblaze_1_1SMatDeclDiagExpr.html">SMatDeclDiagExpr</a>&lt;MT,SO&gt; &gt; blaze::decldiag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given non-diagonal sparse matrix expression <em>sm</em> as diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid diagonal matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>decldiag</em> function declares the given non-diagonal sparse matrix expression <em>sm</em> as diagonal. The function returns an expression representing the operation. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>decldiag</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga69a9b7ca9d7f7eb53ed37ddd2ee43874">decldiag</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga648c564eb671f51f21076710551b20f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga648c564eb671f51f21076710551b20f4">&sect;&nbsp;</a></span>declherm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/daf/structblaze_1_1IsHermitian.html">IsHermitian</a>&lt;MT&gt;, const <a class="el" href="../../d9/d8a/classblaze_1_1SMatDeclHermExpr.html">SMatDeclHermExpr</a>&lt;MT,SO&gt; &gt; blaze::declherm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given non-Hermitian sparse matrix expression <em>sm</em> as Hermitian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid Hermitian matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>declherm</em> function declares the given non-Hermitian sparse matrix expression <em>sm</em> as Hermitian. The function returns an expression representing the operation. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>declherm</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga7d1c7499ea0f5524b537273a98f3c09c">declherm</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaae87fc98150845d427d4f991b02e29d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae87fc98150845d427d4f991b02e29d6">&sect;&nbsp;</a></span>decllow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT&gt;, const <a class="el" href="../../d3/d3c/classblaze_1_1SMatDeclLowExpr.html">SMatDeclLowExpr</a>&lt;MT,SO&gt; &gt; blaze::decllow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given non-lower sparse matrix expression <em>sm</em> as lower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid lower matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>decllow</em> function declares the given non-lower sparse matrix expression <em>sm</em> as lower. The function returns an expression representing the operation. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>decllow</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gab7f9f220af2ef0545f54ff4b5c34b139">decllow</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gae57991e440a9182c47df1bdb5a7b3777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae57991e440a9182c47df1bdb5a7b3777">&sect;&nbsp;</a></span>declsym()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;MT&gt;, const <a class="el" href="../../da/da0/classblaze_1_1SMatDeclSymExpr.html">SMatDeclSymExpr</a>&lt;MT,SO&gt; &gt; blaze::declsym </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given non-symmetric sparse matrix expression <em>sm</em> as symmetric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid symmetric matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>declsym</em> function declares the given non-symmetric sparse matrix expression <em>sm</em> as symmetric. The function returns an expression representing the operation. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>declsym</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga8e0db5d90417a72a963f8dcbf3e3b6a2">declsym</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf2bcedc4df50276d86ae996d5e14db46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2bcedc4df50276d86ae996d5e14db46">&sect;&nbsp;</a></span>declupp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT&gt;, const <a class="el" href="../../d5/df5/classblaze_1_1SMatDeclUppExpr.html">SMatDeclUppExpr</a>&lt;MT,SO&gt; &gt; blaze::declupp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given non-upper sparse matrix expression <em>sm</em> as upper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid upper matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>declupp</em> function declares the given non-upper sparse matrix expression <em>sm</em> as upper. The function returns an expression representing the operation. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>declupp</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga8ebe177b75c6ea9edbd850b65591df1f">declupp</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gadcea433c7ecf6b394f3d4d00ba3bb92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcea433c7ecf6b394f3d4d00ba3bb92a">&sect;&nbsp;</a></span>erf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../dd/d2c/structblaze_1_1Erf.html">Erf</a>,SO&gt; blaze::erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error function of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab93959cccb52b78dccb927b9ea0afafe" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></em> function computes the error function for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gab93959cccb52b78dccb927b9ea0afafe" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gab93959cccb52b78dccb927b9ea0afafe">erf</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga99ae8c92dafa626cb72f234fabfb239c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ae8c92dafa626cb72f234fabfb239c">&sect;&nbsp;</a></span>erfc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../de/d5a/structblaze_1_1Erfc.html">Erfc</a>,SO&gt; blaze::erfc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the complementary error function for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complementary error function of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8444088c1f7a23fe9ca5d44f8b736b6a" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></em> function computes the complementary error function for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8444088c1f7a23fe9ca5d44f8b736b6a" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga8444088c1f7a23fe9ca5d44f8b736b6a">erfc</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gae18cc9f2429336161ac3cdc8087b0fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae18cc9f2429336161ac3cdc8087b0fd2">&sect;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../df/da4/classblaze_1_1SMatEvalExpr.html">SMatEvalExpr</a>&lt;MT,SO&gt; blaze::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the evaluation of the given sparse matrix expression <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated sparse matrix.</dd></dl>
<p>The <em>eval</em> function forces the evaluation of the given sparse matrix expression <em>sm</em>. The function returns an expression representing the operation.<br />
The following example demonstrates the use of the <em>eval</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gacb9f8190d38edb0e52d9c376da5486d6">eval</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7f88b09a654056d8c02f29e886884485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f88b09a654056d8c02f29e886884485">&sect;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d4/d45/structblaze_1_1Exp.html">Exp</a>,SO&gt; blaze::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4" title="Computes  for each single element of the dense matrix dm. ">exp()</a></em> function computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4" title="Computes  for each single element of the dense matrix dm. ">exp()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">exp</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa173a14545cd73289534917fc96ff7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa173a14545cd73289534917fc96ff7cb">&sect;&nbsp;</a></span>exp10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../db/dc8/structblaze_1_1Exp10.html">Exp10</a>,SO&gt; blaze::exp10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></em> function computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2">exp10</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6d6c42bcba2324f95299765cfa4eaedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d6c42bcba2324f95299765cfa4eaedd">&sect;&nbsp;</a></span>exp2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../df/dbb/structblaze_1_1Exp2.html">Exp2</a>,SO&gt; blaze::exp2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></em> function computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576">exp2</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga358be78cf8b2a53deada8c0c8ae6f8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga358be78cf8b2a53deada8c0c8ae6f8a5">&sect;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d2/d67/structblaze_1_1Floor.html">Floor</a>,SO&gt; blaze::floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This function applies the <a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a> function to each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60">floor</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga22ca357aeee42c5e4177238755fc158f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22ca357aeee42c5e4177238755fc158f">&sect;&nbsp;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, OP, SO &gt; blaze::forEach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the given custom operation on each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">op</td><td>The custom operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The custom operation applied to each single element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></em> function evaluates the given custom operation on each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb">forEach</a>( A, []( <span class="keywordtype">double</span> a ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">std::sqrt</a>( a ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="gacd3250ab45273ee41e204887b67542d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd3250ab45273ee41e204887b67542d6">&sect;&nbsp;</a></span>imag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d3/d61/structblaze_1_1Imag.html">Imag</a>,SO&gt; blaze::imag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix containing the imaginary parts of each single element of <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The imaginary part of each single element of <em>sm</em>.</dd></dl>
<p>The <em>imag</em> function calculates the imaginary part of each element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>imag</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga801fe45f59d396249b21d1e4f686f427">imag</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4bcce93825df78b16f67a4e987165066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bcce93825df78b16f67a4e987165066">&sect;&nbsp;</a></span>invcbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d2/d2f/structblaze_1_1InvCbrt.html">InvCbrt</a>,SO&gt; blaze::invcbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse cubic root of each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_93.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cubic root of each single element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga683192b628e107e6082a6b6876d62614" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></em> function computes the inverse cubic root of each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga683192b628e107e6082a6b6876d62614" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga683192b628e107e6082a6b6876d62614">invcbrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_93.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gaa9c7ceebe89f74089dae4fc14ec0b4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9c7ceebe89f74089dae4fc14ec0b4e9">&sect;&nbsp;</a></span>invsqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../df/d20/structblaze_1_1InvSqrt.html">InvSqrt</a>,SO&gt; blaze::invsqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse square root of each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_93.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse square root of each single element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e33f65ba5d0b7f32fe15b818d6914e6" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></em> function computes the inverse square root of each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e33f65ba5d0b7f32fe15b818d6914e6" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga8e33f65ba5d0b7f32fe15b818d6914e6">invsqrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_93.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga045077f88b05d5f5fa13c4ef1eaf0161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga045077f88b05d5f5fa13c4ef1eaf0161">&sect;&nbsp;</a></span>isDefault()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isDefault </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is in default state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is in default state, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy is in default state. In case it is in default state, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="ga9cde1c159ec32c203e73427e98de26c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cde1c159ec32c203e73427e98de26c8">&sect;&nbsp;</a></span>isDiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isDiagonal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the give sparse matrix is diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is diagonal, <em>false</em> if not.</dd></dl>
<p>This function tests whether the matrix is diagonal, i.e. if the non-diagonal elements are default elements. In case of integral or floating point data types, a diagonal matrix has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} aa &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; bb &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 0 &amp; cc &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; xx \\ \end{array}\right)\]" src="../../form_61.png"/>
</p>
<p>The following example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga144e15e7b1f40485ed2dac1f51ba5083">isDiagonal</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a diagonal matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga144e15e7b1f40485ed2dac1f51ba5083">isDiagonal</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga5c0fd85aab1d79528022abb07c8e9839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c0fd85aab1d79528022abb07c8e9839">&sect;&nbsp;</a></span>isHermitian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isHermitian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is Hermitian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is Hermitian, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is an Hermitian matrix. The matrix is considered to be an Hermitian matrix if it is a square matrix whose conjugate transpose is equal to itself ( <img class="formulaInl" alt="$ A = \overline{A^T} $" src="../../form_22.png"/>), i.e. each matrix element <img class="formulaInl" alt="$ a_{ij} $" src="../../form_24.png"/> is equal to the complex conjugate of the element <img class="formulaInl" alt="$ a_{ji} $" src="../../form_25.png"/>. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga2c4d4b151827b6e300cd949fc33a707a">isHermitian</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an Hermitian matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga2c4d4b151827b6e300cd949fc33a707a">isHermitian</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga33f2b973088b1ae6f538c6fe66837b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33f2b973088b1ae6f538c6fe66837b6d">&sect;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isIdentity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the give sparse matrix is an identity matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is an identity matrix, <em>false</em> if not.</dd></dl>
<p>This function tests whether the matrix is an identity matrix, i.e. if the diagonal elements are 1 and the non-diagonal elements are 0. In case of integral or floating point data types, an identity matrix has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{array}\right)\]" src="../../form_62.png"/>
</p>
<p>The following example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaa3674413b281f83fcc81e3a6b2dea188">isIdentity</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an identity matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaa3674413b281f83fcc81e3a6b2dea188">isIdentity</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga57a4918696d365b52a9e35935be3b3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57a4918696d365b52a9e35935be3b3b6">&sect;&nbsp;</a></span>isLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isLower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is a lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a lower triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is a lower triangular matrix. The matrix is considered to be lower triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} l_{0,0} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{1,0} &amp; l_{1,1} &amp; 0 &amp; \cdots &amp; 0 \\ l_{2,0} &amp; l_{2,1} &amp; l_{2,2} &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ l_{N,0} &amp; l_{N,1} &amp; l_{N,2} &amp; \cdots &amp; l_{N,N} \\ \end{array}\right).\]" src="../../form_53.png"/>
</p>
<p><img class="formulaInl" alt="$ 0 \times 0 $" src="../../form_54.png"/> or <img class="formulaInl" alt="$ 1 \times 1 $" src="../../form_55.png"/> matrices are considered as trivially lower triangular. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga78ee9a691c9a59c3883f458866f9b76f">isLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a lower triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga78ee9a691c9a59c3883f458866f9b76f">isLower</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga5fd7ae64eff3d41879d3fc8a138daa7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fd7ae64eff3d41879d3fc8a138daa7d">&sect;&nbsp;</a></span>isnan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the given sparse matrix for not-a-number elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked for not-a-number elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the sparse matrix is not-a-number, <em>false</em> otherwise.</dd></dl>
<p>This function checks the sparse matrix for not-a-number (NaN) elements. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> at least one element of the matrix is not-a-number, the function returns <em>true</em>, otherwise it returns <em>false</em>.</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A( 3UL, 4UL );</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga88d643a61cd9e3b87852233e13973f08">isnan</a>( A ) ) { ... }</div></div><!-- fragment --><p>Note that this function only works for matrices with floating point elements. The attempt to use it for a matrix with a non-floating point element type results in a compile time error. </p>

</div>
</div>
<a id="ga272972206a96bceac26706156979ddc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga272972206a96bceac26706156979ddc0">&sect;&nbsp;</a></span>isnan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is not a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is in not a number, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy is not a number (NaN). In case it is not a number, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="gab379db74bff9739a4b1d7dcf7594766a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab379db74bff9739a4b1d7dcf7594766a">&sect;&nbsp;</a></span>isOne()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isOne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is 1, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy represents the numeric value 1. In case it is 1, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="ga87e93d386f385481def668d7a6edc03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e93d386f385481def668d7a6edc03b">&sect;&nbsp;</a></span>isReal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isReal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix element represents a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the matrix element represents a real number, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy represents the a real number. In case the element is of built-in type, the function returns <em>true</em>. In case the element is of complex type, the function returns <em>true</em> if the imaginary part is equal to 0. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="gae2707785425307e33a2950873b56ac70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2707785425307e33a2950873b56ac70">&sect;&nbsp;</a></span>isStrictlyLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isStrictlyLower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is a strictly lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a strictly lower triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is a strictly lower triangular matrix. The matrix is considered to be strictly lower triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{1,0} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{2,0} &amp; l_{2,1} &amp; 0 &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ l_{N,0} &amp; l_{N,1} &amp; l_{N,2} &amp; \cdots &amp; 0 \\ \end{array}\right).\]" src="../../form_57.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7a77d7fdc4319a6e74bd6eae4d1c71c1">isStrictlyLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a strictly lower triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7a77d7fdc4319a6e74bd6eae4d1c71c1">isStrictlyLower</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga67f046512b938b1f2377975ff3b1060d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67f046512b938b1f2377975ff3b1060d">&sect;&nbsp;</a></span>isStrictlyUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isStrictlyUpper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is a strictly upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a strictly upper triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is a strictly upper triangular matrix. The matrix is considered to be strictly upper triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; u_{0,1} &amp; u_{0,2} &amp; \cdots &amp; u_{0,N} \\ 0 &amp; 0 &amp; u_{1,2} &amp; \cdots &amp; u_{1,N} \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; u_{2,N} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ \end{array}\right).\]" src="../../form_60.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaa1b4b55a81a85ee76379ab19a1a75d64">isStrictlyUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a strictly upper triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaa1b4b55a81a85ee76379ab19a1a75d64">isStrictlyUpper</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gaaf68c6f947e934a922cdd9b332bd1d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf68c6f947e934a922cdd9b332bd1d06">&sect;&nbsp;</a></span>isSymmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isSymmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is symmetric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is symmetric, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is symmetric. The matrix is considered to be symmetric if it is a square matrix whose transpose is equal to itself ( <img class="formulaInl" alt="$ A = A^T $" src="../../form_23.png"/>). The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga54c4333a5647750c5cd126ef9ca5d25b">isSymmetric</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a symmetric matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga54c4333a5647750c5cd126ef9ca5d25b">isSymmetric</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga47e0ca7a0d5a81488e6edf5ff596331a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47e0ca7a0d5a81488e6edf5ff596331a">&sect;&nbsp;</a></span>isUniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is a uniform matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a uniform matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is a uniform matrix. The matrix is considered to be uniform if all its elements are identical. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7aafd1dd369f715e523850f4adb36696">isUniform</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a uniform matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7aafd1dd369f715e523850f4adb36696">isUniform</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga4917d0546e6bcde7ed986fa6ae72cf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4917d0546e6bcde7ed986fa6ae72cf25">&sect;&nbsp;</a></span>isUniLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniLower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is a lower unitriangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a lower unitriangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is a lower unitriangular matrix. The matrix is considered to be lower unitriangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{1,0} &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\ l_{2,0} &amp; l_{2,1} &amp; 1 &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ l_{N,0} &amp; l_{N,1} &amp; l_{N,2} &amp; \cdots &amp; 1 \\ \end{array}\right).\]" src="../../form_56.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga72556b3671610da96aea635f41d166a1">isUniLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a lower unitriangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga72556b3671610da96aea635f41d166a1">isUniLower</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga4449cb73b43824d7f82352816237a1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4449cb73b43824d7f82352816237a1be">&sect;&nbsp;</a></span>isUniUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniUpper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is an upper unitriangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is an upper unitriangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is an upper unitriangular matrix. The matrix is considered to be upper unitriangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 1 &amp; u_{0,1} &amp; u_{0,2} &amp; \cdots &amp; u_{0,N} \\ 0 &amp; 1 &amp; u_{1,2} &amp; \cdots &amp; u_{1,N} \\ 0 &amp; 0 &amp; 1 &amp; \cdots &amp; u_{2,N} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1 \\ \end{array}\right).\]" src="../../form_59.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga0d3d32d95705421514aa1de3da0ef48d">isUniUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an upper unitriangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga0d3d32d95705421514aa1de3da0ef48d">isUniUpper</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga1ded972e027174cb24eeb360addd187f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ded972e027174cb24eeb360addd187f">&sect;&nbsp;</a></span>isUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUpper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is an upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is an upper triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is an upper triangular matrix. The matrix is considered to be upper triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} u_{0,0} &amp; u_{0,1} &amp; u_{0,2} &amp; \cdots &amp; u_{0,N} \\ 0 &amp; u_{1,1} &amp; u_{1,2} &amp; \cdots &amp; u_{1,N} \\ 0 &amp; 0 &amp; u_{2,2} &amp; \cdots &amp; u_{2,N} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; u_{N,N} \\ \end{array}\right).\]" src="../../form_58.png"/>
</p>
<p><img class="formulaInl" alt="$ 0 \times 0 $" src="../../form_54.png"/> or <img class="formulaInl" alt="$ 1 \times 1 $" src="../../form_55.png"/> matrices are considered as trivially upper triangular. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gac2e03c886fd6538a6f10dbdbbd4faacd">isUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an upper triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gac2e03c886fd6538a6f10dbdbbd4faacd">isUpper</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gad4459ccfdf53dffab841e1a7ea2b3833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4459ccfdf53dffab841e1a7ea2b3833">&sect;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is 0, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy represents the numeric value 0. In case it is 0, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="ga10cff4f15dda50d6b49aa1f7bc032282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10cff4f15dda50d6b49aa1f7bc032282">&sect;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d3/d9c/structblaze_1_1Log.html">Log</a>,SO&gt; blaze::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8359ccb837055c7056c1eae56c45eb1a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function computes the natural logarithm for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8359ccb837055c7056c1eae56c45eb1a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga8359ccb837055c7056c1eae56c45eb1a">log</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga44459bed8c0394e623f85e7060736f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44459bed8c0394e623f85e7060736f1f">&sect;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../de/d33/structblaze_1_1Log10.html">Log10</a>,SO&gt; blaze::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary logarithm for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary logarithm of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga979d59d108165583def861daf609d8ca" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></em> function computes the binary logarithm for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga979d59d108165583def861daf609d8ca" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga979d59d108165583def861daf609d8ca">log10</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gad7d576f2bca1424a5fd5f57da21a85c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7d576f2bca1424a5fd5f57da21a85c3">&sect;&nbsp;</a></span>log2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d5/dc7/structblaze_1_1Log2.html">Log2</a>,SO&gt; blaze::log2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the common logarithm for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The common logarithm of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaba8707d555ca3ec8c6394d9724e2b504" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></em> function computes the common logarithm for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaba8707d555ca3ec8c6394d9724e2b504" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaba8707d555ca3ec8c6394d9724e2b504">log2</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga9a5f94e2e6c14eba8ca707b7a6b7d4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a5f94e2e6c14eba8ca707b7a6b7d4b2">&sect;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; blaze::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest element of the sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The given sparse matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest sparse matrix element.</dd></dl>
<p>This function returns the largest element of the given sparse matrix. This function can only be used for element types that support the smaller-than relationship. In case the matrix currently has either 0 rows or 0 columns, the returned value is the default value (e.g. 0 in case of fundamental data types). </p>

</div>
</div>
<a id="ga939c2915cf7e6cb391d024b4c90dca15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga939c2915cf7e6cb391d024b4c90dca15">&sect;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; blaze::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest element of the sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The given sparse matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest sparse matrix element.</dd></dl>
<p>This function returns the smallest element of the given sparse matrix. This function can only be used for element types that support the smaller-than relationship. In case the matrix currently has either 0 rows or 0 columns, the returned value is the default value (e.g. 0 in case of fundamental data types). </p>

</div>
</div>
<a id="ga23358313c28966ce20d3e636914c151f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23358313c28966ce20d3e636914c151f">&sect;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of two sparse matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two sparse matrices are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a id="gaab41594bee8f746276b88e56b2b92051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab41594bee8f746276b88e56b2b92051">&sect;&nbsp;</a></span>operator*() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/d04/classblaze_1_1SVecTSVecMultExpr.html">SVecTSVecMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the sparse vector-sparse vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the outer product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side transpose sparse vector for the outer product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This operator represents the outer product between a sparse vector and a transpose sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> a, b;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">A = a * <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>(b);</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. </p>

</div>
</div>
<a id="ga9687234a3702cb5d47a825d51809e923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9687234a3702cb5d47a825d51809e923">&sect;&nbsp;</a></span>operator*() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt;T2&gt;, <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt;T1,T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose dense vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side column-major sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose dense vector and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a> x, y;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = x * A;</div></div><!-- fragment --><p>The operator returns an expression representing a transpose dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the dense matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga290b0b2bbf69a2061d54e62b7ca6d842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga290b0b2bbf69a2061d54e62b7ca6d842">&sect;&nbsp;</a></span>operator*() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T2&gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt;T1,T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a sparse matrix and a scalar value ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_43.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result matrix.</dd></dl>
<p>This operator represents the multiplication between a sparse matrix and a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = A * 1.25;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a id="gaa7863549ad292599fbd054279d31b743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7863549ad292599fbd054279d31b743">&sect;&nbsp;</a></span>operator*() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T1&gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt;T1,T2&gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a scalar value and a sparse matrix ( <img class="formulaInl" alt="$ A=s*B $" src="../../form_102.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result matrix.</dd></dl>
<p>This operator represents the multiplication between a scalar value and a sparse matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = 1.25 * A;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a id="ga4fc17104bcd6eac213fcc2574e68eff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fc17104bcd6eac213fcc2574e68eff7">&sect;&nbsp;</a></span>operator*() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d3/dc8/classblaze_1_1SMatTSMatMultExpr.html">SMatTSMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major sparse matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a row-major sparse matrix and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga7be5ba7d99f09441c139d426c172ad7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7be5ba7d99f09441c139d426c172ad7f">&sect;&nbsp;</a></span>operator*() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d13/classblaze_1_1SMatSMatMultExpr.html">SMatSMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of two row-major sparse matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga69ea4f1b211288029950a99e1e109971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69ea4f1b211288029950a99e1e109971">&sect;&nbsp;</a></span>operator*() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d0/dec/classblaze_1_1TSMatTSMatMultExpr.html">TSMatTSMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of two column-major sparse matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaebd2a470dd21fec4c42c12135e2bcbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebd2a470dd21fec4c42c12135e2bcbb4">&sect;&nbsp;</a></span>operator*() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/da5/classblaze_1_1DVecTSVecMultExpr.html">DVecTSVecMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the dense vector-sparse vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the outer product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side transpose sparse vector for the outer product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This operator represents the outer product between a dense vector and a transpose sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> a;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> b;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">A = a * b;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. </p>

</div>
</div>
<a id="gaa25c477c724abcfb4503afc172a51c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa25c477c724abcfb4503afc172a51c3f">&sect;&nbsp;</a></span>operator*() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d3b/classblaze_1_1SVecTDVecMultExpr.html">SVecTDVecMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the sparse vector-dense vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the outer product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side transpose dense vector for the outer product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This operator represents the outer product between a sparse vector and a transpose dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> a;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a> b;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&lt;rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">A = a * b;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. </p>

</div>
</div>
<a id="gaa8d0ec5eb55760f5c13f4f3311c7c8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8d0ec5eb55760f5c13f4f3311c7c8db">&sect;&nbsp;</a></span>operator*() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/dc3/classblaze_1_1TSMatSMatMultExpr.html">TSMatSMatMultExpr</a>&lt;T1,T2&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major sparse matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a column-major sparse matrix and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix</a>,double,<a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a>&gt; B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga9d6d0bef279f8d41722214ba0a93c191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d6d0bef279f8d41722214ba0a93c191">&sect;&nbsp;</a></span>operator+() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d18/classblaze_1_1SMatSMatAddExpr.html">SMatSMatAddExpr</a>&lt;T1,T2&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of two row-major sparse matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga112e886e84bf2d9155a12623fa1131a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga112e886e84bf2d9155a12623fa1131a9">&sect;&nbsp;</a></span>operator+() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d6/d9c/classblaze_1_1SMatTSMatAddExpr.html">SMatTSMatAddExpr</a>&lt;T1,T2&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a row-major and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a row-major and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga1672d9c402ae8df5b15063e9905e9b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1672d9c402ae8df5b15063e9905e9b1d">&sect;&nbsp;</a></span>operator+() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/d90/classblaze_1_1TSMatTSMatAddExpr.html">TSMatTSMatAddExpr</a>&lt;T1,T2&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of two column-major sparse matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaf69176ce01c8deed13b6288d04e7fb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf69176ce01c8deed13b6288d04e7fb4e">&sect;&nbsp;</a></span>operator+() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d6/d9c/classblaze_1_1SMatTSMatAddExpr.html">SMatTSMatAddExpr</a>&lt;T2,T1&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a column-major and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a column-major and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga6030a90ba2a81dd899d35c9de718a662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6030a90ba2a81dd899d35c9de718a662">&sect;&nbsp;</a></span>operator-() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/d6e/classblaze_1_1SMatScalarMultExpr.html">SMatScalarMultExpr</a>&lt;MT,<a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">UnderlyingBuiltin_</a>&lt;MT&gt;,SO&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus operator for the negation of a sparse matrix ( <img class="formulaInl" alt="$ A = -B $" src="../../form_101.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be negated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The negation of the matrix.</dd></dl>
<p>This operator represents the negation of a sparse matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = -A;</div></div><!-- fragment --><p>The operator returns an expression representing the negation of the given sparse matrix. </p>

</div>
</div>
<a id="ga1b71cdd1a878c14f672b47a3522575e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b71cdd1a878c14f672b47a3522575e1">&sect;&nbsp;</a></span>operator-() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d0/d92/classblaze_1_1SMatSMatSubExpr.html">SMatSMatSubExpr</a>&lt;T1,T2&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted from the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of two row-major sparse matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gac7f555464ba008c823eab85d659a2abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7f555464ba008c823eab85d659a2abe">&sect;&nbsp;</a></span>operator-() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../da/dad/classblaze_1_1SMatTSMatSubExpr.html">SMatTSMatSubExpr</a>&lt;T1,T2&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a row-major and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted from the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a row-major and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga62ef8d85c5124466413b19db53823068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62ef8d85c5124466413b19db53823068">&sect;&nbsp;</a></span>operator-() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d0/d0d/classblaze_1_1TSMatSMatSubExpr.html">TSMatSMatSubExpr</a>&lt;T1,T2&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a column-major and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a column-major and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga01d7793334fbcfec19fae5365a921d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01d7793334fbcfec19fae5365a921d4a">&sect;&nbsp;</a></span>operator-() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/d3f/classblaze_1_1TSMatTSMatSubExpr.html">TSMatTSMatSubExpr</a>&lt;T1,T2&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted from the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of two column-major sparse matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both matrix types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gadcdfd60edc63a07bdb86e1592fbdcd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcdfd60edc63a07bdb86e1592fbdcd41">&sect;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T2&gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">DivExprTrait_</a>&lt;T1,T2&gt; &gt; blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for the division of a sparse matrix by a scalar value ( <img class="formulaInl" alt="$ A=B/s $" src="../../form_100.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix for the division. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result matrix.</dd></dl>
<p>This operator represents the division of a sparse matrix by a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = A / 0.24;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Note that this operator only works for scalar values of built-in data type.</p>
<dl class="section note"><dt>Note</dt><dd>A division by zero is only checked by a user assert. </dd></dl>

</div>
</div>
<a id="gac3f69b34e146551053564a5ddba4469c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3f69b34e146551053564a5ddba4469c">&sect;&nbsp;</a></span>operator==() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two column-major sparse matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two sparse matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga52adc17fd1c3cf58857e4bbe59d5215a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52adc17fd1c3cf58857e4bbe59d5215a">&sect;&nbsp;</a></span>operator==() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two sparse matrices with different storage order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two sparse matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga5be271299bf9d21d79adbc98fefc7c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5be271299bf9d21d79adbc98fefc7c73">&sect;&nbsp;</a></span>operator==() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two row-major sparse matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two sparse matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="gad8fe418ba6e1d414a1915677cd42a034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8fe418ba6e1d414a1915677cd42a034">&sect;&nbsp;</a></span>operator==() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two column-major sparse matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two sparse matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga39d48ddafc58459876471f1cd1400660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39d48ddafc58459876471f1cd1400660">&sect;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename ET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d3/d41/structblaze_1_1Pow.html">Pow</a>&lt;ET&gt;,SO&gt; blaze::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ET&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the exponential value for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">exp</td><td>The exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponential value of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga04b65a79150f5e9e3118257b2f77a0ed" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></em> function computes the exponential value for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga04b65a79150f5e9e3118257b2f77a0ed" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga04b65a79150f5e9e3118257b2f77a0ed">pow</a>( A, 4.2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf8c02698aee64e2916bb86755d6a98cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8c02698aee64e2916bb86755d6a98cc">&sect;&nbsp;</a></span>real()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../dd/df4/structblaze_1_1Real.html">Real</a>,SO&gt; blaze::real </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix containing the real parts of each single element of <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The real part of each single element of <em>sm</em>.</dd></dl>
<p>The <em>real</em> function calculates the real part of each element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>real</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga146e7401b84cc73dc213edc50bf3a236">real</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa329d4ff44a8780cb8f29343ffc32790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa329d4ff44a8780cb8f29343ffc32790">&sect;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resetting the represented element to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets the element represented by the access proxy to its default initial value. In case the access proxy represents a vector- or matrix-like data structure that provides a <a class="el" href="../../d0/d90/group__diagonal__matrix.html#gab1218387fdd76e3eead49086d7fdc5e7" title="Resetting the represented element to the default initial values. ">reset()</a> function, this function resets all elements of the vector/matrix to the default initial values. </p>

</div>
</div>
<a id="gaf00020b2c03a0c9c62f5ddb682d2765d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf00020b2c03a0c9c62f5ddb682d2765d">&sect;&nbsp;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../de/d83/structblaze_1_1Round.html">Round</a>,SO&gt; blaze::round </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This function applies the <a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a> function to each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc">round</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga5ccba470284d1a9e137ff88b09be550e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ccba470284d1a9e137ff88b09be550e">&sect;&nbsp;</a></span>serial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/dc8/classblaze_1_1SMatSerialExpr.html">SMatSerialExpr</a>&lt; MT, SO &gt; blaze::serial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the serial evaluation of the given sparse matrix expression <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated sparse matrix.</dd></dl>
<p>The <em>serial</em> function forces the serial evaluation of the given sparse matrix expression <em>sm</em>. The function returns an expression representing the operation.<br />
The following example demonstrates the use of the <em>serial</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaeac3b9aff5df5e547819e485321f4762">serial</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7a45f5774abd4565a54493af5d233260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a45f5774abd4565a54493af5d233260">&sect;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../de/d56/structblaze_1_1Sin.html">Sin</a>,SO&gt; blaze::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga0a06568d5cd7314f4a0995a051d68062" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a></em> function computes the sine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga0a06568d5cd7314f4a0995a051d68062" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga0a06568d5cd7314f4a0995a051d68062">sin</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga73fb5d6b6ea84ae2d5598f78e55553d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73fb5d6b6ea84ae2d5598f78e55553d2">&sect;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d4/d59/structblaze_1_1Sinh.html">Sinh</a>,SO&gt; blaze::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic sine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga4111317de20c08c0a40b10182eee2539" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a></em> function computes the hyperbolic sine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga4111317de20c08c0a40b10182eee2539" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga4111317de20c08c0a40b10182eee2539">sinh</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gafeb91b0d7402619f999384384217328a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafeb91b0d7402619f999384384217328a">&sect;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../d0/d06/structblaze_1_1Sqrt.html">Sqrt</a>,SO&gt; blaze::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of each single element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></em> function computes the square root of each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">sqrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga48b3ef0a633565ae5ae8d03422150d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48b3ef0a633565ae5ae8d03422150d66">&sect;&nbsp;</a></span>swap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two access proxies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first access proxy to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The second access proxy to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ga56e363bb9d02dc099d3d52ba6ad93373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56e363bb9d02dc099d3d52ba6ad93373">&sect;&nbsp;</a></span>swap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of an access proxy with another element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The access proxy to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The other element to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ga1ba7ff15d755e738537539e75ec37072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ba7ff15d755e738537539e75ec37072">&sect;&nbsp;</a></span>swap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of an access proxy with another element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The other element to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The access proxy to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ga86d261d1a314d04ac889f8d2255cc8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86d261d1a314d04ac889f8d2255cc8ee">&sect;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../db/d5e/structblaze_1_1Tan.html">Tan</a>,SO&gt; blaze::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tangent of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga90be532925f9874efae43a23918194ce" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a></em> function computes the tangent for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga90be532925f9874efae43a23918194ce" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga90be532925f9874efae43a23918194ce">tan</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga096a2c65eccc14ba47e321c6f371e609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga096a2c65eccc14ba47e321c6f371e609">&sect;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../df/db7/structblaze_1_1Tanh.html">Tanh</a>,SO&gt; blaze::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic tangent of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac3e7dda64b4203c08bf00bc0813b4d05" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a></em> function computes the hyperbolic tangent for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac3e7dda64b4203c08bf00bc0813b4d05" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gac3e7dda64b4203c08bf00bc0813b4d05">tanh</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_98.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga9c5bf80756338642cfcaff18b96ff7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c5bf80756338642cfcaff18b96ff7e6">&sect;&nbsp;</a></span>trans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../da/d09/classblaze_1_1SMatTransExpr.html">SMatTransExpr</a>&lt; MT,!SO &gt; blaze::trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the transpose of the given sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be transposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of the matrix.</dd></dl>
<p>This function returns an expression representing the transpose of the given sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga029ccca19a29c1a54b6715de4a5b4982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga029ccca19a29c1a54b6715de4a5b4982">&sect;&nbsp;</a></span>trunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt;MT,<a class="el" href="../../de/d23/structblaze_1_1Trunc.html">Trunc</a>,SO&gt; blaze::trunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This function applies the <a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a> function to each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40">trunc</a>( A );</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 8 2016 01:03:46 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
