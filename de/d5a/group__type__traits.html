<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Type traits</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Type traits<div class="ingroups"><a class="el" href="../../d4/d3a/group__util.html">Utility module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da6/structblaze_1_1AddConst.html">blaze::AddConst&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level 'const' qualifier.The <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html" title="Addition of a top level &#39;const&#39; qualifier.The AddConst type trait adds a top level &#39;const&#39; qualifier ...">AddConst</a> type trait adds a top level 'const' qualifier to the given type <em>T</em>.  <a href="../../d7/da6/structblaze_1_1AddConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d58/structblaze_1_1AddCV.html">blaze::AddCV&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level 'const' and 'volatile' qualifier.The <a class="el" href="../../df/d58/structblaze_1_1AddCV.html" title="Addition of a top level &#39;const&#39; and &#39;volatile&#39; qualifier.The AddCV type trait adds both a top level &#39;...">AddCV</a> type trait adds both a top level 'const' and 'volatile' qualifier to the given type <em>T</em>.  <a href="../../df/d58/structblaze_1_1AddCV.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html">blaze::AddPointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level pointer.The <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html" title="Addition of a top level pointer.The AddPointer type trait adds a top level pointer to the given type ...">AddPointer</a> type trait adds a top level pointer to the given type <em>T</em>. It has the same effect as <code>blaze::RemovePointer&lt;T&gt;::Type*</code>.  <a href="../../d4/da6/structblaze_1_1AddPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d30/structblaze_1_1AddReference.html">blaze::AddReference&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level reference.In case the given type <em>T</em> is not a reference type, the <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html" title="Addition of a top level reference.In case the given type T is not a reference type, the AddReference type trait adds a top level reference to the given type T. Else the resulting type Type is T. ">AddReference</a> type trait adds a top level reference to the given type <em>T</em>. Else the resulting type <em>Type</em> is <em>T</em>.  <a href="../../dd/d30/structblaze_1_1AddReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html">blaze::AddVolatile&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level 'volatile' qualifier.The <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html" title="Addition of a top level &#39;volatile&#39; qualifier.The AddVolatile type trait adds a top level &#39;volatile&#39; q...">AddVolatile</a> type trait adds a top level 'volatile' qualifier to the given type <em>T</em>.  <a href="../../d2/df0/structblaze_1_1AddVolatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/structblaze_1_1AlignmentOf.html">blaze::AlignmentOf&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the required alignment of the given data type.The <a class="el" href="../../d5/dc6/structblaze_1_1AlignmentOf.html" title="Evaluation of the required alignment of the given data type.The AlignmentOf type trait template evalu...">AlignmentOf</a> type trait template evaluates the required alignment for the given data type. For instance, for fundamental data types that can be vectorized via SSE or AVX instructions, the proper alignment is 16 or 32 bytes, respectively. For all other data types, a multiple of the alignment chosen by the compiler is returned. The evaluated alignment can be queried via the nested <em>value</em> member.  <a href="../../d5/dc6/structblaze_1_1AlignmentOf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/de6/structblaze_1_1All.html">blaze::All&lt; TypeTrait, Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This type trait determines whether the given type trait <em>TypeTrait</em> evaluates to <em>true</em> for all given types <em>Ts</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the expression.  <a href="../../d9/de6/structblaze_1_1All.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dfd/structblaze_1_1Any.html">blaze::Any&lt; TypeTrait, Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This type trait determines whether the given type trait <em>TypeTrait</em> evaluates to <em>true</em> for at least one of the given types <em>Ts</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the expression.  <a href="../../d9/dfd/structblaze_1_1Any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html">blaze::CommonType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction of a type common to several types.The <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html" title="Deduction of a type common to several types.The CommonType type trait deduces the result type of a mi...">CommonType</a> type trait deduces the result type of a mixed-mode arithmetic expression between all types T..., that is the type all T... can be implicitly converted to. Note that cv and reference qualifiers are generally ignored.  <a href="../../dd/d1c/structblaze_1_1CommonType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbe/structblaze_1_1Decay.html">blaze::Decay&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the type conversions for by-value function arguments.This type trait applies the type conversions that are used for by-value function arguments. This conversions include lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type <code>T</code>, and the removal of top level cv-qualifiers.  <a href="../../df/dbe/structblaze_1_1Decay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d50/structblaze_1_1Extent.html">blaze::Extent&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the size of array bounds.Via this type trait it is possible to query at compile time for the size of a particular array extent. In case the given template argument is an array type with a rank greater than N, the <em>value</em> member constant is set to the number of elements of the N'th array dimension. In all other cases, and especially in case the N'th array dimension is incomplete, <em>value</em> is set to 0.  <a href="../../d2/d50/structblaze_1_1Extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d90/structblaze_1_1HasSize.html">blaze::HasSize&lt; T, Size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This class offers the possibility to test the size of a type at compile time. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> is exactly <em><a class="el" href="../../df/d5d/structblaze_1_1Size.html" title="Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...">Size</a></em> bytes large, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d90/structblaze_1_1HasSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d94/structblaze_1_1Has1Byte.html">blaze::Has1Byte&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly one byte. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has one byte, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d94/structblaze_1_1Has1Byte.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d49/structblaze_1_1Has2Bytes.html">blaze::Has2Bytes&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly two bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has two bytes, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d49/structblaze_1_1Has2Bytes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d99/structblaze_1_1Has4Bytes.html">blaze::Has4Bytes&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly four bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has four bytes, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d99/structblaze_1_1Has4Bytes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/structblaze_1_1Has8Bytes.html">blaze::Has8Bytes&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly four bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has four bytes, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from<em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the classderives from <em>FalseType</em>.  <a href="../../d4/df1/structblaze_1_1Has8Bytes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d76/classblaze_1_1HaveSameSize.html">blaze::HaveSameSize&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This class offers the possibility to test the size of two types at compile time. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> an object of type <em>T1</em> has the same size as an object of type <em>T2</em>, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d76/classblaze_1_1HaveSameSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/daf/structblaze_1_1IsArithmetic.html">blaze::IsArithmetic&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for arithmetic data types.This type trait tests whether or not the given template parameter is a (possibly cv-qualified) arithmetic (integral or floating point) data type. In case the type is an arithmetic type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../dc/daf/structblaze_1_1IsArithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d2c/structblaze_1_1IsArray.html">blaze::IsArray&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d9/d2c/structblaze_1_1IsArray.html" title="Compile time type check.The IsArray type trait tests whether or not the given template parameter is a...">IsArray</a> type trait tests whether or not the given template parameter is an array type. In case the given data type is an array type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is set to <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../d9/d2c/structblaze_1_1IsArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd9/structblaze_1_1IsAssignable.html">blaze::IsAssignable&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../df/dd9/structblaze_1_1IsAssignable.html" title="Compile time type check.The IsAssignable type trait tests whether the expression. ...">IsAssignable</a> type trait tests whether the expression.  <a href="../../df/dd9/structblaze_1_1IsAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html">blaze::IsNothrowAssignable&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html" title="Compile time type check.The IsNothrowAssignable type trait tests whether the expression. ">IsNothrowAssignable</a> type trait tests whether the expression.  <a href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d54/structblaze_1_1IsCopyAssignable.html">blaze::IsCopyAssignable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../da/d54/structblaze_1_1IsCopyAssignable.html" title="Compile time type check.The IsCopyAssignable type trait tests whether the expression. ">IsCopyAssignable</a> type trait tests whether the expression.  <a href="../../da/d54/structblaze_1_1IsCopyAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html">blaze::IsNothrowCopyAssignable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html" title="Compile time type check.The IsNothrowCopyAssignable type trait tests whether the expression. ">IsNothrowCopyAssignable</a> type trait tests whether the expression.  <a href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d39/structblaze_1_1IsMoveAssignable.html">blaze::IsMoveAssignable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d6/d39/structblaze_1_1IsMoveAssignable.html" title="Compile time type check.The IsMoveAssignable type trait tests whether the expression. ">IsMoveAssignable</a> type trait tests whether the expression.  <a href="../../d6/d39/structblaze_1_1IsMoveAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html">blaze::IsNothrowMoveAssignable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html" title="Compile time type check.The IsNothrowMoveAssignable type trait tests whether the expression. ">IsNothrowMoveAssignable</a> type trait tests whether the expression.  <a href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d07/classblaze_1_1IsBaseOf.html">blaze::IsBaseOf&lt; Base, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time analysis of an inheritance relationship.This type trait tests for an inheritance relationship between the two types <em>Base</em> and <em>Derived</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>Derived</em> is a type derived from <em>Base</em> or the same type as <em>Base</em> the <em>value</em> member contant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d07/classblaze_1_1IsBaseOf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d48/structblaze_1_1IsBoolean.html">blaze::IsBoolean&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for boolean types.This type trait tests whether or not the given template parameter is of boolean type. In case the type is a boolean (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d48/structblaze_1_1IsBoolean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">blaze::IsBuiltin&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for built-in data types.This type trait tests whether or not the given template parameter is a built-in/fundamental data type. In case the type is a built-in type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d1c/structblaze_1_1IsBuiltin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/structblaze_1_1IsCharacter.html">blaze::IsCharacter&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for character types.This type trait tests whether or not the given template parameter is a character type (i.e., either char, signed char, unsigned char, or wchar_t, possibly cv-qualified). In case the type is a character type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d32/structblaze_1_1IsCharacter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d97/structblaze_1_1IsClass.html">blaze::IsClass&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dd/d97/structblaze_1_1IsClass.html" title="Compile time type check.The IsClass type trait tests whether or not the given template parameter is a...">IsClass</a> type trait tests whether or not the given template parameter is a (possibly cv-qualified) class type. In case the given data type is a class type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is set to <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../dd/d97/structblaze_1_1IsClass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da9/structblaze_1_1IsComplex.html">blaze::IsComplex&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for complex types.This type trait tests whether or not the given template parameter is a complex data type. In case the type is a complex data type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/da9/structblaze_1_1IsComplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d5e/structblaze_1_1IsComplexDouble.html">blaze::IsComplexDouble&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for single precision complex types.This type trait tests whether or not the given template parameter is of type <code>complex&lt;double&gt;</code>. In case the type is <code>complex&lt;double&gt;</code> (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/d5e/structblaze_1_1IsComplexDouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d20/structblaze_1_1IsComplexFloat.html">blaze::IsComplexFloat&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for single precision complex types.This type trait tests whether or not the given template parameter is of type <code>complex&lt;float&gt;</code>. In case the type is <code>complex&lt;float&gt;</code> (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d20/structblaze_1_1IsComplexFloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html">blaze::IsConst&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for constant data types.The <a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html" title="Compile time check for constant data types.The IsConst type trait tests whether or not the given temp...">IsConst</a> type trait tests whether or not the given template parameter is a (top level) const-qualified data type. In case the given data type is const-qualified, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d5f/structblaze_1_1IsConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dc8/structblaze_1_1IsConstructible.html">blaze::IsConstructible&lt; T, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d9/dc8/structblaze_1_1IsConstructible.html" title="Compile time type check.The IsConstructible type trait tests whether the expression. ">IsConstructible</a> type trait tests whether the expression.  <a href="../../d9/dc8/structblaze_1_1IsConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html">blaze::IsNothrowConstructible&lt; T, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html" title="Compile time type check.The IsNothrowConstructible type trait tests whether the expression. ">IsNothrowConstructible</a> type trait tests whether the expression.  <a href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html">blaze::IsDefaultConstructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html" title="Compile time type check.The IsDefaultConstructible type trait tests whether the expression. ">IsDefaultConstructible</a> type trait tests whether the expression.  <a href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html">blaze::IsNothrowDefaultConstructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html" title="Compile time type check.The IsNothrowDefaultConstructible type trait tests whether the expression...">IsNothrowDefaultConstructible</a> type trait tests whether the expression.  <a href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d1e/structblaze_1_1IsCopyConstructible.html">blaze::IsCopyConstructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../df/d1e/structblaze_1_1IsCopyConstructible.html" title="Compile time type check.The IsCopyConstructible type trait tests whether the expression. ">IsCopyConstructible</a> type trait tests whether the expression.  <a href="../../df/d1e/structblaze_1_1IsCopyConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html">blaze::IsNothrowCopyConstructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html" title="Compile time type check.The IsNothrowCopyConstructible type trait tests whether the expression...">IsNothrowCopyConstructible</a> type trait tests whether the expression.  <a href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/structblaze_1_1IsMoveConstructible.html">blaze::IsMoveConstructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d1/d17/structblaze_1_1IsMoveConstructible.html" title="Compile time type check.The IsMoveConstructible type trait tests whether the expression. ">IsMoveConstructible</a> type trait tests whether the expression.  <a href="../../d1/d17/structblaze_1_1IsMoveConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html">blaze::IsNothrowMoveConstructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html" title="Compile time type check.The IsNothrowMoveConstructible type trait tests whether the expression...">IsNothrowMoveConstructible</a> type trait tests whether the expression.  <a href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d98/structblaze_1_1IsConvertible.html">blaze::IsConvertible&lt; From, To &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time pointer relationship constraint.This type traits tests whether the first given template argument can be converted to the second template argument via copy construction. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the first argument can be converted to the second argument, the <em>value</em> member constnt is set to <em>true</em>, the nested type definition <em>type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/d98/structblaze_1_1IsConvertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html">blaze::IsDestructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html" title="Compile time type check.The IsDestructible type trait tests whether the expression. ">IsDestructible</a> type trait tests whether the expression.  <a href="../../dc/d64/structblaze_1_1IsDestructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d8b/structblaze_1_1IsNothrowDestructible.html">blaze::IsNothrowDestructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html" title="Compile time type check.The IsDestructible type trait tests whether the expression. ">IsDestructible</a> type trait tests whether the expression.  <a href="../../dc/d8b/structblaze_1_1IsNothrowDestructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d60/structblaze_1_1IsDouble.html">blaze::IsDouble&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for double precision floating point types.This type trait tests whether or not the given template parameter is of double type. In case the type is double (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d60/structblaze_1_1IsDouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d47/structblaze_1_1IsEmpty.html">blaze::IsEmpty&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter is an empty class type, i.e. a type without member data and virtual functions. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> it is an empty class type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d47/structblaze_1_1IsEmpty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d07/structblaze_1_1IsFloat.html">blaze::IsFloat&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for single precision floating point types.This type trait tests whether or not the given template parameter is of float type. In case the type is float (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d07/structblaze_1_1IsFloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html">blaze::IsFloatingPoint&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for floating point data types.This type trait tests whether or not the given template parameter is a floating point data type (ignoring the cv-qualifiers). In case the type is a floating point data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5e/structblaze_1_1IsInteger.html">blaze::IsInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for integer types.This type trait tests whether or not the given template parameter is an integer type (i.e., either (signed) int or unsigned int, possibly cv-qualified). In case the type is an integer type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d5e/structblaze_1_1IsInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">blaze::IsIntegral&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for integral data types.This type trait tests whether or not the given template parameter is an integral data type. In case the type is an integral data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d73/structblaze_1_1IsIntegral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d40/structblaze_1_1IsLong.html">blaze::IsLong&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for long integer types.This type trait tests whether or not the given template parameter is a long integer type (i.e., either (signed) long or unsigned long, possibly cv-qualified). In case the type is a long integer type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d40/structblaze_1_1IsLong.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d34/structblaze_1_1IsLongDouble.html">blaze::IsLongDouble&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for extended precision floating point types.This type trait tests whether or not the given template parameter is of long double type. In case the type is long double (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d34/structblaze_1_1IsLongDouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">blaze::IsNumeric&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for numeric types.This type trait tests whether or not the given template parameter is a numeric data type. Blaze considers all integral (except <em>bool</em>), floating point, and complex data types as numeric data types. In case the type is a numeric type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/dea/structblaze_1_1IsNumeric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db8/structblaze_1_1IsObject.html">blaze::IsObject&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter <em>T</em> is an object type. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> types are considered object types except references, <em>void</em>, and function types. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>T</em> is an object type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/db8/structblaze_1_1IsObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db0/structblaze_1_1IsPod.html">blaze::IsPod&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for pod data types.This type trait tests whether or not the given template parameter is a POD (Plain Old Data). In case the type is a POD, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/db0/structblaze_1_1IsPod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0f/structblaze_1_1IsPointer.html">blaze::IsPointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter is a pointer type (including function pointers, but excluding pointers to members) or not. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> it is a pointer type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d0f/structblaze_1_1IsPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dad/structblaze_1_1IsReference.html">blaze::IsReference&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter <em>T</em> is a reference type (including references to functions). <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> it is a reference type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/dad/structblaze_1_1IsReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/structblaze_1_1IsStrictlySame.html">blaze::IsStrictlySame&lt; A, B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type relationship analysis.This class tests if the two data types <em>A</em> and <em>B</em> are equal. For this type comparison, the cv-qualifiers of both data types are not ignored. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>A</em> and <em>B</em> are the same data type, then the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/df1/structblaze_1_1IsStrictlySame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d89/structblaze_1_1IsSame.html">blaze::IsSame&lt; A, B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type relationship analysis.This class tests if the two data types <em>A</em> and <em>B</em> are equal. For this type comparison, the cv-qualifiers of both data types are ignored. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>A</em> and <em>B</em> are the same data type (ignoring the cv-qualifiers), then the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d89/structblaze_1_1IsSame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d59/structblaze_1_1IsShort.html">blaze::IsShort&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for short integer types.This type trait tests whether or not the given template parameter is a short integer type (i.e., either (signed) short or unsigned short, possibly cv-qualified). In case the type is a short integer type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d59/structblaze_1_1IsShort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/def/structblaze_1_1IsSigned.html">blaze::IsSigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for signed data types.This type trait tests whether or not the given template parameter is a signed integral or a floating point data type. In case the type is a signed (possibly cv-qualified) data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/def/structblaze_1_1IsSigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc7/structblaze_1_1IsUnion.html">blaze::IsUnion&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for union data types.This type trait tests whether or not the given template parameter is a union data type. In case the type is a union, the <em>value</em> member constant is set o <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/dc7/structblaze_1_1IsUnion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d8c/structblaze_1_1IsUnsigned.html">blaze::IsUnsigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for unsigned data types.This type trait tests whether or not the given template parameter is an unsigned, integral data type. In case the type is an unsigned (possibly cv-qualified) data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d8c/structblaze_1_1IsUnsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6e/structblaze_1_1IsValid.html">blaze::IsValid&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter is a valid or invalid data type (i.e. if the type is the INVALID_TYPE). <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>T</em> is not the INVALID_TYPE class type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/d6e/structblaze_1_1IsValid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0e/structblaze_1_1IsVectorizable.html">blaze::IsVectorizable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for vectorizable types.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...), this type trait tests whether or not the given template parameter is a vectorizable type, i.e. a type for which intrinsic vector operations and optimizations can be used. Currently, all built-in data types except <code>bool</code> and the according complex numbers are considered to be vectorizable types. In case the type is vectorizable, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d0e/structblaze_1_1IsVectorizable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6b/structblaze_1_1IsVoid.html">blaze::IsVoid&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the <em>void</em> data type.This type trait tests whether or not the given template parameter is of type <em>void</em> (ignoring the cv-qualifiers). In case the type is of type <em>void</em>, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d6b/structblaze_1_1IsVoid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html">blaze::IsVolatile&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for volatile data types.The <a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html" title="Compile time check for volatile data types.The IsVolatile type trait tests whether or not the given t...">IsVolatile</a> type trait tests whether or not the given template parameter is a (top level) volatile-qualified data type. In case the given data type is volatile, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/db9/structblaze_1_1IsVolatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html">blaze::MakeSigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type conversion into a signed integral type.This type trait provides the feature to convert the given integral or constant type <em>T</em> to the corresponding signed integral data type with the same size and with the same cv-qualifiers. Note that in case <em>T</em> is bool or a non-integral data type, a compilation error is created.  <a href="../../da/da3/structblaze_1_1MakeSigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html">blaze::MakeUnsigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type conversion into an unsigned integral type.This type trait provides the feature to convert the given integral or constant type <em>T</em> to the corresponding unsigned integral data type with the same size and with the same cv-qualifiers. Note that in case <em>T</em> is bool or a non-integral data type, a compilation error is created.  <a href="../../d9/dd7/structblaze_1_1MakeUnsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db0/structblaze_1_1Rank.html">blaze::Rank&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for array ranks.This type trait determines the rank of the given template argument. In case the given type is an array type, the nested <em>value</em> member constant is set to the number of dimensions of <em>T</em>. Otherwise <em>value</em> is set to 0.  <a href="../../df/db0/structblaze_1_1Rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html">blaze::RemoveAllExtents&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of all array extents.The <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html" title="Removal of all array extents.The RemoveAllExtents type trait removes all array extents from the given...">RemoveAllExtents</a> type trait removes all array extents from the given type <em>T</em>.  <a href="../../de/d59/structblaze_1_1RemoveAllExtents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html">blaze::RemoveConst&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of const-qualifiers.The <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> type trait removes all top level 'const' qualifiers from the given type <em>T</em>.  <a href="../../d9/d25/structblaze_1_1RemoveConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html">blaze::RemoveCV&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of top level cv-qualifiers.The <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait removes all top level cv-qualifiers from the given type <em>T</em>.  <a href="../../d0/d1c/structblaze_1_1RemoveCV.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html">blaze::RemoveExtent&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of the top level array extent.The <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html" title="Removal of the top level array extent.The RemoveExtent type trait removes the top level array extent ...">RemoveExtent</a> type trait removes the top level array extent from the given type <em>T</em>.  <a href="../../d7/d88/structblaze_1_1RemoveExtent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html">blaze::RemovePointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of pointer modifiers.The <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html" title="Removal of pointer modifiers.The RemovePointer type trait removes any pointer modifiers from the give...">RemovePointer</a> type trait removes any pointer modifiers from the given type <em>T</em>.  <a href="../../df/d04/structblaze_1_1RemovePointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html">blaze::RemoveReference&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of reference modifiers.The <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html" title="Removal of reference modifiers.The RemoveReference type trait removes any reference modifiers from th...">RemoveReference</a> type trait removes any reference modifiers from the given type <em>T</em>.  <a href="../../d5/df4/structblaze_1_1RemoveReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html">blaze::RemoveVolatile&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of volatile-qualifiers.The <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> type trait removes all top level 'volatile' qualifiers from the given type <em>T</em>.  <a href="../../d9/de6/structblaze_1_1RemoveVolatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1054a603bf1d73c443e374227954a9b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1054a603bf1d73c443e374227954a9b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga1054a603bf1d73c443e374227954a9b5">blaze::RemoveAdaptor_</a> = typename <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html">RemoveAdaptor</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga1054a603bf1d73c443e374227954a9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html" title="Removal of top level adaptor types.In case the given type is an adaptor type (SymmetricMatrix, LowerMatrix, UpperMatrix, ...), the RemoveAdaptor type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved. ">RemoveAdaptor</a> type trait.The RemoveAdaptor_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html" title="Removal of top level adaptor types.In case the given type is an adaptor type (SymmetricMatrix, LowerMatrix, UpperMatrix, ...), the RemoveAdaptor type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved. ">RemoveAdaptor</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga1054a603bf1d73c443e374227954a9b5">More...</a><br /></td></tr>
<tr class="separator:ga1054a603bf1d73c443e374227954a9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21ed6b57b46e4eb4a400f581bca0f616"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga21ed6b57b46e4eb4a400f581bca0f616"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">blaze::UnderlyingBuiltin_</a> = typename <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html">UnderlyingBuiltin</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga21ed6b57b46e4eb4a400f581bca0f616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html" title="Evaluation of the underlying builtin element type of a given data type.Via this type trait it is poss...">UnderlyingBuiltin</a> type trait.The UnderlyingBuiltin_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html" title="Evaluation of the underlying builtin element type of a given data type.Via this type trait it is poss...">UnderlyingBuiltin</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">More...</a><br /></td></tr>
<tr class="separator:ga21ed6b57b46e4eb4a400f581bca0f616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d099d4d07f45ddddd62de3908b3be2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa1d099d4d07f45ddddd62de3908b3be2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaa1d099d4d07f45ddddd62de3908b3be2">blaze::UnderlyingElement_</a> = typename <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html">UnderlyingElement</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gaa1d099d4d07f45ddddd62de3908b3be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html" title="Evaluation of the element type of a given data type.Via this type trait it is possible to evaluate th...">UnderlyingElement</a> type trait.The UnderlyingElement_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html" title="Evaluation of the element type of a given data type.Via this type trait it is possible to evaluate th...">UnderlyingElement</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gaa1d099d4d07f45ddddd62de3908b3be2">More...</a><br /></td></tr>
<tr class="separator:gaa1d099d4d07f45ddddd62de3908b3be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e3f75bd557307b815516615471dc20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga11e3f75bd557307b815516615471dc20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga11e3f75bd557307b815516615471dc20">blaze::UnderlyingNumeric_</a> = typename <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html">UnderlyingNumeric</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga11e3f75bd557307b815516615471dc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html" title="Evaluation of the underlying numeric element type of a given data type.Via this type trait it is poss...">UnderlyingNumeric</a> type trait.The UnderlyingNumeric_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html" title="Evaluation of the underlying numeric element type of a given data type.Via this type trait it is poss...">UnderlyingNumeric</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga11e3f75bd557307b815516615471dc20">More...</a><br /></td></tr>
<tr class="separator:ga11e3f75bd557307b815516615471dc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4d07e6853705c0c77730625effda54f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa4d07e6853705c0c77730625effda54f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaa4d07e6853705c0c77730625effda54f">blaze::AddConst_</a> = typename <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html">AddConst</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gaa4d07e6853705c0c77730625effda54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html" title="Addition of a top level &#39;const&#39; qualifier.The AddConst type trait adds a top level &#39;const&#39; qualifier ...">AddConst</a> type trait.The AddConst_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html" title="Addition of a top level &#39;const&#39; qualifier.The AddConst type trait adds a top level &#39;const&#39; qualifier ...">AddConst</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gaa4d07e6853705c0c77730625effda54f">More...</a><br /></td></tr>
<tr class="separator:gaa4d07e6853705c0c77730625effda54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929fa7c8723465e3db2d609625ca92cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga929fa7c8723465e3db2d609625ca92cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga929fa7c8723465e3db2d609625ca92cb">blaze::AddCV_</a> = typename <a class="el" href="../../df/d58/structblaze_1_1AddCV.html">AddCV</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga929fa7c8723465e3db2d609625ca92cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d58/structblaze_1_1AddCV.html" title="Addition of a top level &#39;const&#39; and &#39;volatile&#39; qualifier.The AddCV type trait adds both a top level &#39;...">AddCV</a> type trait.The AddCV_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d58/structblaze_1_1AddCV.html" title="Addition of a top level &#39;const&#39; and &#39;volatile&#39; qualifier.The AddCV type trait adds both a top level &#39;...">AddCV</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga929fa7c8723465e3db2d609625ca92cb">More...</a><br /></td></tr>
<tr class="separator:ga929fa7c8723465e3db2d609625ca92cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad44dfb9fe9000add409150fa4b7e9d63"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad44dfb9fe9000add409150fa4b7e9d63"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gad44dfb9fe9000add409150fa4b7e9d63">blaze::AddPointer_</a> = typename <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html">AddPointer</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gad44dfb9fe9000add409150fa4b7e9d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html" title="Addition of a top level pointer.The AddPointer type trait adds a top level pointer to the given type ...">AddPointer</a> type trait.The AddPointer_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html" title="Addition of a top level pointer.The AddPointer type trait adds a top level pointer to the given type ...">AddPointer</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gad44dfb9fe9000add409150fa4b7e9d63">More...</a><br /></td></tr>
<tr class="separator:gad44dfb9fe9000add409150fa4b7e9d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3a003331b1147d9cb4991a46b9ea37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1c3a003331b1147d9cb4991a46b9ea37"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga1c3a003331b1147d9cb4991a46b9ea37">blaze::AddReference_</a> = typename <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html">AddReference</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga1c3a003331b1147d9cb4991a46b9ea37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html" title="Addition of a top level reference.In case the given type T is not a reference type, the AddReference type trait adds a top level reference to the given type T. Else the resulting type Type is T. ">AddReference</a> type trait.The AddReference_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html" title="Addition of a top level reference.In case the given type T is not a reference type, the AddReference type trait adds a top level reference to the given type T. Else the resulting type Type is T. ">AddReference</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga1c3a003331b1147d9cb4991a46b9ea37">More...</a><br /></td></tr>
<tr class="separator:ga1c3a003331b1147d9cb4991a46b9ea37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8cbfccf4f9d689a42e5d670499911f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6a8cbfccf4f9d689a42e5d670499911f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga6a8cbfccf4f9d689a42e5d670499911f">blaze::AddVolatile_</a> = typename <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html">AddVolatile</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga6a8cbfccf4f9d689a42e5d670499911f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html" title="Addition of a top level &#39;volatile&#39; qualifier.The AddVolatile type trait adds a top level &#39;volatile&#39; q...">AddVolatile</a> type trait.The AddVolatile_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html" title="Addition of a top level &#39;volatile&#39; qualifier.The AddVolatile type trait adds a top level &#39;volatile&#39; q...">AddVolatile</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga6a8cbfccf4f9d689a42e5d670499911f">More...</a><br /></td></tr>
<tr class="separator:ga6a8cbfccf4f9d689a42e5d670499911f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c7cd3125c6a710a8e69ca26f4ea5b9"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga08c7cd3125c6a710a8e69ca26f4ea5b9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">blaze::CommonType_</a> = typename <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html">CommonType</a>&lt; T... &gt;::Type</td></tr>
<tr class="memdesc:ga08c7cd3125c6a710a8e69ca26f4ea5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html" title="Deduction of a type common to several types.The CommonType type trait deduces the result type of a mi...">CommonType</a> type trait.The CommonType_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html" title="Deduction of a type common to several types.The CommonType type trait deduces the result type of a mi...">CommonType</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">More...</a><br /></td></tr>
<tr class="separator:ga08c7cd3125c6a710a8e69ca26f4ea5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dc48f717dd98041ce6ebfb5a3642541"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1dc48f717dd98041ce6ebfb5a3642541"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga1dc48f717dd98041ce6ebfb5a3642541">blaze::Decay_</a> = typename <a class="el" href="../../df/dbe/structblaze_1_1Decay.html">Decay</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga1dc48f717dd98041ce6ebfb5a3642541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/dbe/structblaze_1_1Decay.html" title="Applies the type conversions for by-value function arguments.This type trait applies the type convers...">Decay</a> type trait.The Decay_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/dbe/structblaze_1_1Decay.html" title="Applies the type conversions for by-value function arguments.This type trait applies the type convers...">Decay</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga1dc48f717dd98041ce6ebfb5a3642541">More...</a><br /></td></tr>
<tr class="separator:ga1dc48f717dd98041ce6ebfb5a3642541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a76caf184ea9b940528ac368da1b577"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4a76caf184ea9b940528ac368da1b577"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga4a76caf184ea9b940528ac368da1b577">blaze::MakeSigned_</a> = typename <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html">MakeSigned</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga4a76caf184ea9b940528ac368da1b577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html" title="Compile time type conversion into a signed integral type.This type trait provides the feature to conv...">MakeSigned</a> type trait.The MakeSigned_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html" title="Compile time type conversion into a signed integral type.This type trait provides the feature to conv...">MakeSigned</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga4a76caf184ea9b940528ac368da1b577">More...</a><br /></td></tr>
<tr class="separator:ga4a76caf184ea9b940528ac368da1b577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d8cacb214951110d862d4183532c7d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7d8cacb214951110d862d4183532c7d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga7d8cacb214951110d862d4183532c7d7">blaze::MakeUnsigned_</a> = typename <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html">MakeUnsigned</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga7d8cacb214951110d862d4183532c7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html" title="Compile time type conversion into an unsigned integral type.This type trait provides the feature to c...">MakeUnsigned</a> type trait.The MakeUnsigned_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html" title="Compile time type conversion into an unsigned integral type.This type trait provides the feature to c...">MakeUnsigned</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga7d8cacb214951110d862d4183532c7d7">More...</a><br /></td></tr>
<tr class="separator:ga7d8cacb214951110d862d4183532c7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c53798803a90d594d0ef14e1481f1aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0c53798803a90d594d0ef14e1481f1aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga0c53798803a90d594d0ef14e1481f1aa">blaze::RemoveAllExtents_</a> = typename <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html">RemoveAllExtents</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga0c53798803a90d594d0ef14e1481f1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html" title="Removal of all array extents.The RemoveAllExtents type trait removes all array extents from the given...">RemoveAllExtents</a> type trait.The RemoveAllExtents_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html" title="Removal of all array extents.The RemoveAllExtents type trait removes all array extents from the given...">RemoveAllExtents</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga0c53798803a90d594d0ef14e1481f1aa">More...</a><br /></td></tr>
<tr class="separator:ga0c53798803a90d594d0ef14e1481f1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13fccfb14d335ce408ceab9457bf4df0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga13fccfb14d335ce408ceab9457bf4df0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga13fccfb14d335ce408ceab9457bf4df0">blaze::RemoveConst_</a> = typename <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html">RemoveConst</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga13fccfb14d335ce408ceab9457bf4df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> type trait.The RemoveConst_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga13fccfb14d335ce408ceab9457bf4df0">More...</a><br /></td></tr>
<tr class="separator:ga13fccfb14d335ce408ceab9457bf4df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf21820cc9ce037667f76051caf920c2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf21820cc9ce037667f76051caf920c2e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaf21820cc9ce037667f76051caf920c2e">blaze::RemoveCV_</a> = typename <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html">RemoveCV</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gaf21820cc9ce037667f76051caf920c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait.The RemoveCV_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gaf21820cc9ce037667f76051caf920c2e">More...</a><br /></td></tr>
<tr class="separator:gaf21820cc9ce037667f76051caf920c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbcd0119d3bddd693ffdb292c6e1a3a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacfbcd0119d3bddd693ffdb292c6e1a3a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gacfbcd0119d3bddd693ffdb292c6e1a3a">blaze::RemoveExtent_</a> = typename <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html">RemoveExtent</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gacfbcd0119d3bddd693ffdb292c6e1a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html" title="Removal of the top level array extent.The RemoveExtent type trait removes the top level array extent ...">RemoveExtent</a> type trait.The RemoveExtent_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html" title="Removal of the top level array extent.The RemoveExtent type trait removes the top level array extent ...">RemoveExtent</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gacfbcd0119d3bddd693ffdb292c6e1a3a">More...</a><br /></td></tr>
<tr class="separator:gacfbcd0119d3bddd693ffdb292c6e1a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6e489fdde969ad7931b740b73da1a97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac6e489fdde969ad7931b740b73da1a97"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gac6e489fdde969ad7931b740b73da1a97">blaze::RemovePointer_</a> = typename <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html">RemovePointer</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gac6e489fdde969ad7931b740b73da1a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html" title="Removal of pointer modifiers.The RemovePointer type trait removes any pointer modifiers from the give...">RemovePointer</a> type trait.The RemovePointer_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html" title="Removal of pointer modifiers.The RemovePointer type trait removes any pointer modifiers from the give...">RemovePointer</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gac6e489fdde969ad7931b740b73da1a97">More...</a><br /></td></tr>
<tr class="separator:gac6e489fdde969ad7931b740b73da1a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0beac6880fd0f492a1166e1c254e4cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa0beac6880fd0f492a1166e1c254e4cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaa0beac6880fd0f492a1166e1c254e4cb">blaze::RemoveReference_</a> = typename <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html">RemoveReference</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gaa0beac6880fd0f492a1166e1c254e4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html" title="Removal of reference modifiers.The RemoveReference type trait removes any reference modifiers from th...">RemoveReference</a> type trait.The RemoveReference_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html" title="Removal of reference modifiers.The RemoveReference type trait removes any reference modifiers from th...">RemoveReference</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gaa0beac6880fd0f492a1166e1c254e4cb">More...</a><br /></td></tr>
<tr class="separator:gaa0beac6880fd0f492a1166e1c254e4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada49326a8f411400855a3b6e376ab62d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gada49326a8f411400855a3b6e376ab62d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gada49326a8f411400855a3b6e376ab62d">blaze::RemoveVolatile_</a> = typename <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html">RemoveVolatile</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gada49326a8f411400855a3b6e376ab62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> type trait.The RemoveVolatile_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gada49326a8f411400855a3b6e376ab62d">More...</a><br /></td></tr>
<tr class="separator:gada49326a8f411400855a3b6e376ab62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad9e57614da25f41b86dd909f1d639c6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad9e57614da25f41b86dd909f1d639c6a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gad9e57614da25f41b86dd909f1d639c6a">blaze::AlignmentOf_</a> = <a class="el" href="../../d5/dc6/structblaze_1_1AlignmentOf.html">AlignmentOf</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gad9e57614da25f41b86dd909f1d639c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/dc6/structblaze_1_1AlignmentOf.html" title="Evaluation of the required alignment of the given data type.The AlignmentOf type trait template evalu...">AlignmentOf</a> type trait.The AlignmentOf_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d5/dc6/structblaze_1_1AlignmentOf.html" title="Evaluation of the required alignment of the given data type.The AlignmentOf type trait template evalu...">AlignmentOf</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gad9e57614da25f41b86dd909f1d639c6a">More...</a><br /></td></tr>
<tr class="separator:gad9e57614da25f41b86dd909f1d639c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga178ed97e2dfe95a87bc1753f3bcf37ff"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class TypeTrait, typename... Ts&gt; </td></tr>
<tr class="memitem:ga178ed97e2dfe95a87bc1753f3bcf37ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga178ed97e2dfe95a87bc1753f3bcf37ff">blaze::All_</a> = <a class="el" href="../../d9/de6/structblaze_1_1All.html">All</a>&lt;TypeTrait,Ts...&gt;::value</td></tr>
<tr class="memdesc:ga178ed97e2dfe95a87bc1753f3bcf37ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> type trait.The All_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> class template. For instance, given the types <em>T1</em>, <em>T2</em>, and <em>T3</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga178ed97e2dfe95a87bc1753f3bcf37ff">More...</a><br /></td></tr>
<tr class="separator:ga178ed97e2dfe95a87bc1753f3bcf37ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad25819e65d6692296453436ba24fee76"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class TypeTrait, typename... Ts&gt; </td></tr>
<tr class="memitem:gad25819e65d6692296453436ba24fee76"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gad25819e65d6692296453436ba24fee76">blaze::Any_</a> = <a class="el" href="../../d9/dfd/structblaze_1_1Any.html">Any</a>&lt;TypeTrait,Ts...&gt;::value</td></tr>
<tr class="memdesc:gad25819e65d6692296453436ba24fee76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/dfd/structblaze_1_1Any.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">Any</a> type trait.The Any_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d9/dfd/structblaze_1_1Any.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">Any</a> class template. For instance, given the types <em>T1</em>, <em>T2</em>, and <em>T3</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gad25819e65d6692296453436ba24fee76">More...</a><br /></td></tr>
<tr class="separator:gad25819e65d6692296453436ba24fee76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f4176cdebd2a47b98024c29a9f76b31"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N&gt; </td></tr>
<tr class="memitem:ga2f4176cdebd2a47b98024c29a9f76b31"><td class="memTemplItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga2f4176cdebd2a47b98024c29a9f76b31">blaze::Extent_</a> = <a class="el" href="../../d2/d50/structblaze_1_1Extent.html">Extent</a>&lt;T,N&gt;::value</td></tr>
<tr class="memdesc:ga2f4176cdebd2a47b98024c29a9f76b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d50/structblaze_1_1Extent.html" title="Compile time check for the size of array bounds.Via this type trait it is possible to query at compil...">Extent</a> type trait.The Extent_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d2/d50/structblaze_1_1Extent.html" title="Compile time check for the size of array bounds.Via this type trait it is possible to query at compil...">Extent</a> class template. For instance, given the type <em>T</em> and the index <em>N</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga2f4176cdebd2a47b98024c29a9f76b31">More...</a><br /></td></tr>
<tr class="separator:ga2f4176cdebd2a47b98024c29a9f76b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6860f7b7cb730f79dc823ee7d4cb475a"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Size&gt; </td></tr>
<tr class="memitem:ga6860f7b7cb730f79dc823ee7d4cb475a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga6860f7b7cb730f79dc823ee7d4cb475a">blaze::HasSize_</a> = <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,<a class="el" href="../../df/d5d/structblaze_1_1Size.html">Size</a>&gt;::value</td></tr>
<tr class="memdesc:ga6860f7b7cb730f79dc823ee7d4cb475a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d90/structblaze_1_1HasSize.html" title="Compile time size check.This class offers the possibility to test the size of a type at compile time...">HasSize</a> type trait.The HasSize_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../df/d90/structblaze_1_1HasSize.html" title="Compile time size check.This class offers the possibility to test the size of a type at compile time...">HasSize</a> class template. For instance, given the type <em>T</em> and the value <em>N</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga6860f7b7cb730f79dc823ee7d4cb475a">More...</a><br /></td></tr>
<tr class="separator:ga6860f7b7cb730f79dc823ee7d4cb475a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b20422550073cad222edced2cc8b1f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2b20422550073cad222edced2cc8b1f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga2b20422550073cad222edced2cc8b1f0">blaze::Has1Byte_</a> = <a class="el" href="../../d7/d94/structblaze_1_1Has1Byte.html">Has1Byte</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga2b20422550073cad222edced2cc8b1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d94/structblaze_1_1Has1Byte.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has1Byte</a> type trait.The Has1Byte_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d7/d94/structblaze_1_1Has1Byte.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has1Byte</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga2b20422550073cad222edced2cc8b1f0">More...</a><br /></td></tr>
<tr class="separator:ga2b20422550073cad222edced2cc8b1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32deb8bb1539df79800276342f5229b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf32deb8bb1539df79800276342f5229b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaf32deb8bb1539df79800276342f5229b">blaze::Has2Bytes_</a> = <a class="el" href="../../d9/d49/structblaze_1_1Has2Bytes.html">Has2Bytes</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gaf32deb8bb1539df79800276342f5229b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/d49/structblaze_1_1Has2Bytes.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has2Bytes</a> type trait.The Has2Bytes_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d9/d49/structblaze_1_1Has2Bytes.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has2Bytes</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gaf32deb8bb1539df79800276342f5229b">More...</a><br /></td></tr>
<tr class="separator:gaf32deb8bb1539df79800276342f5229b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf417d49d38b92393836cb425efd5032d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf417d49d38b92393836cb425efd5032d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaf417d49d38b92393836cb425efd5032d">blaze::Has4Bytes_</a> = <a class="el" href="../../d2/d99/structblaze_1_1Has4Bytes.html">Has4Bytes</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gaf417d49d38b92393836cb425efd5032d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d99/structblaze_1_1Has4Bytes.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has4Bytes</a> type trait.The Has4Bytes_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d2/d99/structblaze_1_1Has4Bytes.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has4Bytes</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gaf417d49d38b92393836cb425efd5032d">More...</a><br /></td></tr>
<tr class="separator:gaf417d49d38b92393836cb425efd5032d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59b161229656399634b0f8f2bcb46a6d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga59b161229656399634b0f8f2bcb46a6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga59b161229656399634b0f8f2bcb46a6d">blaze::Has8Bytes_</a> = <a class="el" href="../../d4/df1/structblaze_1_1Has8Bytes.html">Has8Bytes</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga59b161229656399634b0f8f2bcb46a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/df1/structblaze_1_1Has8Bytes.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has8Bytes</a> type trait.The Has8Bytes_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d4/df1/structblaze_1_1Has8Bytes.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has8Bytes</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga59b161229656399634b0f8f2bcb46a6d">More...</a><br /></td></tr>
<tr class="separator:ga59b161229656399634b0f8f2bcb46a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac1e2dd0b8cdbc4c176e03342ed715ed"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaac1e2dd0b8cdbc4c176e03342ed715ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaac1e2dd0b8cdbc4c176e03342ed715ed">blaze::HaveSameSize_</a> = <a class="el" href="../../d7/d76/classblaze_1_1HaveSameSize.html">HaveSameSize</a>&lt;T1,T2&gt;::value</td></tr>
<tr class="memdesc:gaac1e2dd0b8cdbc4c176e03342ed715ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d76/classblaze_1_1HaveSameSize.html" title="Compile time size check.This class offers the possibility to test the size of two types at compile ti...">HaveSameSize</a> type trait.The HaveSameSize_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d7/d76/classblaze_1_1HaveSameSize.html" title="Compile time size check.This class offers the possibility to test the size of two types at compile ti...">HaveSameSize</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gaac1e2dd0b8cdbc4c176e03342ed715ed">More...</a><br /></td></tr>
<tr class="separator:gaac1e2dd0b8cdbc4c176e03342ed715ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc503cc31b387d2b5fbc37e4466edd4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadc503cc31b387d2b5fbc37e4466edd4a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gadc503cc31b387d2b5fbc37e4466edd4a">blaze::IsArithmetic_</a> = <a class="el" href="../../dc/daf/structblaze_1_1IsArithmetic.html">IsArithmetic</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gadc503cc31b387d2b5fbc37e4466edd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/daf/structblaze_1_1IsArithmetic.html" title="Compile time check for arithmetic data types.This type trait tests whether or not the given template ...">IsArithmetic</a> type trait.The IsArithmetic_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/daf/structblaze_1_1IsArithmetic.html" title="Compile time check for arithmetic data types.This type trait tests whether or not the given template ...">IsArithmetic</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gadc503cc31b387d2b5fbc37e4466edd4a">More...</a><br /></td></tr>
<tr class="separator:gadc503cc31b387d2b5fbc37e4466edd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7551547873ed5663bfee3448a9237497"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7551547873ed5663bfee3448a9237497"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga7551547873ed5663bfee3448a9237497">blaze::IsArray_</a> = <a class="el" href="../../d9/d2c/structblaze_1_1IsArray.html">IsArray</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga7551547873ed5663bfee3448a9237497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/d2c/structblaze_1_1IsArray.html" title="Compile time type check.The IsArray type trait tests whether or not the given template parameter is a...">IsArray</a> type trait.The IsArray_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d9/d2c/structblaze_1_1IsArray.html" title="Compile time type check.The IsArray type trait tests whether or not the given template parameter is a...">IsArray</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga7551547873ed5663bfee3448a9237497">More...</a><br /></td></tr>
<tr class="separator:ga7551547873ed5663bfee3448a9237497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d1509c151d861bd067980786495ed25"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga3d1509c151d861bd067980786495ed25"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga3d1509c151d861bd067980786495ed25">blaze::IsAssignable_</a> = <a class="el" href="../../df/dd9/structblaze_1_1IsAssignable.html">IsAssignable</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:ga3d1509c151d861bd067980786495ed25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/dd9/structblaze_1_1IsAssignable.html" title="Compile time type check.The IsAssignable type trait tests whether the expression. ...">IsAssignable</a> type trait.The IsAssignable_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../df/dd9/structblaze_1_1IsAssignable.html" title="Compile time type check.The IsAssignable type trait tests whether the expression. ...">IsAssignable</a> class template. For instance, given the types <em>T</em> and <em>U</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga3d1509c151d861bd067980786495ed25">More...</a><br /></td></tr>
<tr class="separator:ga3d1509c151d861bd067980786495ed25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a031d9df18f8212acadf2b3fc50e609"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga4a031d9df18f8212acadf2b3fc50e609"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga4a031d9df18f8212acadf2b3fc50e609">blaze::IsNothrowAssignable_</a> = <a class="el" href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html">IsNothrowAssignable</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:ga4a031d9df18f8212acadf2b3fc50e609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html" title="Compile time type check.The IsNothrowAssignable type trait tests whether the expression. ">IsNothrowAssignable</a> type trait.The IsNothrowAssignable_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html" title="Compile time type check.The IsNothrowAssignable type trait tests whether the expression. ">IsNothrowAssignable</a> class template. For instance, given the types <em>T</em> and <em>U</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga4a031d9df18f8212acadf2b3fc50e609">More...</a><br /></td></tr>
<tr class="separator:ga4a031d9df18f8212acadf2b3fc50e609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7519d0b8bb5a808895127448861a5906"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7519d0b8bb5a808895127448861a5906"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga7519d0b8bb5a808895127448861a5906">blaze::IsCopyAssignable_</a> = <a class="el" href="../../da/d54/structblaze_1_1IsCopyAssignable.html">IsCopyAssignable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga7519d0b8bb5a808895127448861a5906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/d54/structblaze_1_1IsCopyAssignable.html" title="Compile time type check.The IsCopyAssignable type trait tests whether the expression. ">IsCopyAssignable</a> type trait.The IsCopyAssignable_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../da/d54/structblaze_1_1IsCopyAssignable.html" title="Compile time type check.The IsCopyAssignable type trait tests whether the expression. ">IsCopyAssignable</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga7519d0b8bb5a808895127448861a5906">More...</a><br /></td></tr>
<tr class="separator:ga7519d0b8bb5a808895127448861a5906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae050197c31248d663cca9013a7ce3fe2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae050197c31248d663cca9013a7ce3fe2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gae050197c31248d663cca9013a7ce3fe2">blaze::IsNothrowCopyAssignable_</a> = <a class="el" href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html">IsNothrowCopyAssignable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gae050197c31248d663cca9013a7ce3fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html" title="Compile time type check.The IsNothrowCopyAssignable type trait tests whether the expression. ">IsNothrowCopyAssignable</a> type trait.The IsNothrowCopyAssignable_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html" title="Compile time type check.The IsNothrowCopyAssignable type trait tests whether the expression. ">IsNothrowCopyAssignable</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gae050197c31248d663cca9013a7ce3fe2">More...</a><br /></td></tr>
<tr class="separator:gae050197c31248d663cca9013a7ce3fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b5b95fb1d784888d6b6097c0396ea02"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0b5b95fb1d784888d6b6097c0396ea02"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga0b5b95fb1d784888d6b6097c0396ea02">blaze::IsMoveAssignable_</a> = <a class="el" href="../../d6/d39/structblaze_1_1IsMoveAssignable.html">IsMoveAssignable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga0b5b95fb1d784888d6b6097c0396ea02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d6/d39/structblaze_1_1IsMoveAssignable.html" title="Compile time type check.The IsMoveAssignable type trait tests whether the expression. ">IsMoveAssignable</a> type trait.The IsMoveAssignable_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d6/d39/structblaze_1_1IsMoveAssignable.html" title="Compile time type check.The IsMoveAssignable type trait tests whether the expression. ">IsMoveAssignable</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga0b5b95fb1d784888d6b6097c0396ea02">More...</a><br /></td></tr>
<tr class="separator:ga0b5b95fb1d784888d6b6097c0396ea02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b352cc8798abd497fa0ac05f7fe1507"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8b352cc8798abd497fa0ac05f7fe1507"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga8b352cc8798abd497fa0ac05f7fe1507">blaze::IsNothrowMoveAssignable_</a> = <a class="el" href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html">IsNothrowMoveAssignable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga8b352cc8798abd497fa0ac05f7fe1507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html" title="Compile time type check.The IsNothrowMoveAssignable type trait tests whether the expression. ">IsNothrowMoveAssignable</a> type trait.The IsNothrowMoveAssignable_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html" title="Compile time type check.The IsNothrowMoveAssignable type trait tests whether the expression. ">IsNothrowMoveAssignable</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga8b352cc8798abd497fa0ac05f7fe1507">More...</a><br /></td></tr>
<tr class="separator:ga8b352cc8798abd497fa0ac05f7fe1507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadceff818bfc2128c84cca2e663c69f7e"><td class="memTemplParams" colspan="2">template&lt;typename Base , typename Derived &gt; </td></tr>
<tr class="memitem:gadceff818bfc2128c84cca2e663c69f7e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gadceff818bfc2128c84cca2e663c69f7e">blaze::IsBaseOf_</a> = <a class="el" href="../../da/d07/classblaze_1_1IsBaseOf.html">IsBaseOf</a>&lt;Base,Derived&gt;::value</td></tr>
<tr class="memdesc:gadceff818bfc2128c84cca2e663c69f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/d07/classblaze_1_1IsBaseOf.html" title="Compile time analysis of an inheritance relationship.This type trait tests for an inheritance relatio...">IsBaseOf</a> type trait.The IsBaseOf_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../da/d07/classblaze_1_1IsBaseOf.html" title="Compile time analysis of an inheritance relationship.This type trait tests for an inheritance relatio...">IsBaseOf</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gadceff818bfc2128c84cca2e663c69f7e">More...</a><br /></td></tr>
<tr class="separator:gadceff818bfc2128c84cca2e663c69f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d646c92979829b3294839bbeaf8d9e0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5d646c92979829b3294839bbeaf8d9e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga5d646c92979829b3294839bbeaf8d9e0">blaze::IsBoolean_</a> = <a class="el" href="../../d7/d48/structblaze_1_1IsBoolean.html">IsBoolean</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga5d646c92979829b3294839bbeaf8d9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d48/structblaze_1_1IsBoolean.html" title="Compile time check for boolean types.This type trait tests whether or not the given template paramete...">IsBoolean</a> type trait.The IsBoolean_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d7/d48/structblaze_1_1IsBoolean.html" title="Compile time check for boolean types.This type trait tests whether or not the given template paramete...">IsBoolean</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga5d646c92979829b3294839bbeaf8d9e0">More...</a><br /></td></tr>
<tr class="separator:ga5d646c92979829b3294839bbeaf8d9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5e5f45aac9be086ca73b240e381e7a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4e5e5f45aac9be086ca73b240e381e7a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga4e5e5f45aac9be086ca73b240e381e7a">blaze::IsBuiltin_</a> = <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga4e5e5f45aac9be086ca73b240e381e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html" title="Compile time check for built-in data types.This type trait tests whether or not the given template pa...">IsBuiltin</a> type trait.The IsBuiltin_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html" title="Compile time check for built-in data types.This type trait tests whether or not the given template pa...">IsBuiltin</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga4e5e5f45aac9be086ca73b240e381e7a">More...</a><br /></td></tr>
<tr class="separator:ga4e5e5f45aac9be086ca73b240e381e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76751fc3d14e9e07aabc36212ab9477"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad76751fc3d14e9e07aabc36212ab9477"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gad76751fc3d14e9e07aabc36212ab9477">blaze::IsCharacter_</a> = <a class="el" href="../../de/d32/structblaze_1_1IsCharacter.html">IsCharacter</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gad76751fc3d14e9e07aabc36212ab9477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d32/structblaze_1_1IsCharacter.html" title="Compile time check for character types.This type trait tests whether or not the given template parame...">IsCharacter</a> type trait.The IsCharacter_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../de/d32/structblaze_1_1IsCharacter.html" title="Compile time check for character types.This type trait tests whether or not the given template parame...">IsCharacter</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gad76751fc3d14e9e07aabc36212ab9477">More...</a><br /></td></tr>
<tr class="separator:gad76751fc3d14e9e07aabc36212ab9477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58658afdd87e80e37f95aa1dcea2c5e9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga58658afdd87e80e37f95aa1dcea2c5e9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga58658afdd87e80e37f95aa1dcea2c5e9">blaze::IsClass_</a> = <a class="el" href="../../dd/d97/structblaze_1_1IsClass.html">IsClass</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga58658afdd87e80e37f95aa1dcea2c5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d97/structblaze_1_1IsClass.html" title="Compile time type check.The IsClass type trait tests whether or not the given template parameter is a...">IsClass</a> type trait.The IsClass_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dd/d97/structblaze_1_1IsClass.html" title="Compile time type check.The IsClass type trait tests whether or not the given template parameter is a...">IsClass</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga58658afdd87e80e37f95aa1dcea2c5e9">More...</a><br /></td></tr>
<tr class="separator:ga58658afdd87e80e37f95aa1dcea2c5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacfbd1de88421e49c47f9dcee584b6bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaacfbd1de88421e49c47f9dcee584b6bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaacfbd1de88421e49c47f9dcee584b6bc">blaze::IsComplex_</a> = <a class="el" href="../../d1/da9/structblaze_1_1IsComplex.html">IsComplex</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gaacfbd1de88421e49c47f9dcee584b6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/da9/structblaze_1_1IsComplex.html" title="Compile time check for complex types.This type trait tests whether or not the given template paramete...">IsComplex</a> type trait.The IsComplex_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d1/da9/structblaze_1_1IsComplex.html" title="Compile time check for complex types.This type trait tests whether or not the given template paramete...">IsComplex</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gaacfbd1de88421e49c47f9dcee584b6bc">More...</a><br /></td></tr>
<tr class="separator:gaacfbd1de88421e49c47f9dcee584b6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f6f885629cbb719c5f8421fa529084"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf4f6f885629cbb719c5f8421fa529084"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaf4f6f885629cbb719c5f8421fa529084">blaze::IsComplexDouble_</a> = <a class="el" href="../../d1/d5e/structblaze_1_1IsComplexDouble.html">IsComplexDouble</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gaf4f6f885629cbb719c5f8421fa529084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d5e/structblaze_1_1IsComplexDouble.html" title="Compile time check for single precision complex types.This type trait tests whether or not the given ...">IsComplexDouble</a> type trait.The IsComplexDouble_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d1/d5e/structblaze_1_1IsComplexDouble.html" title="Compile time check for single precision complex types.This type trait tests whether or not the given ...">IsComplexDouble</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gaf4f6f885629cbb719c5f8421fa529084">More...</a><br /></td></tr>
<tr class="separator:gaf4f6f885629cbb719c5f8421fa529084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06aec44dccdbd5b5707af6e8f884d3b4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga06aec44dccdbd5b5707af6e8f884d3b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga06aec44dccdbd5b5707af6e8f884d3b4">blaze::IsComplexFloat_</a> = <a class="el" href="../../df/d20/structblaze_1_1IsComplexFloat.html">IsComplexFloat</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga06aec44dccdbd5b5707af6e8f884d3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d20/structblaze_1_1IsComplexFloat.html" title="Compile time check for single precision complex types.This type trait tests whether or not the given ...">IsComplexFloat</a> type trait.The IsComplexFloat_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../df/d20/structblaze_1_1IsComplexFloat.html" title="Compile time check for single precision complex types.This type trait tests whether or not the given ...">IsComplexFloat</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga06aec44dccdbd5b5707af6e8f884d3b4">More...</a><br /></td></tr>
<tr class="separator:ga06aec44dccdbd5b5707af6e8f884d3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c42796736a94421954fe5197a4bb2c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8c42796736a94421954fe5197a4bb2c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga8c42796736a94421954fe5197a4bb2c9">blaze::IsConst_</a> = <a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html">IsConst</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga8c42796736a94421954fe5197a4bb2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html" title="Compile time check for constant data types.The IsConst type trait tests whether or not the given temp...">IsConst</a> type trait.The IsConst_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html" title="Compile time check for constant data types.The IsConst type trait tests whether or not the given temp...">IsConst</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga8c42796736a94421954fe5197a4bb2c9">More...</a><br /></td></tr>
<tr class="separator:ga8c42796736a94421954fe5197a4bb2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga671017831f218cf5ccf1095484b32efe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ga671017831f218cf5ccf1095484b32efe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga671017831f218cf5ccf1095484b32efe">blaze::IsConstructible_</a> = <a class="el" href="../../d9/dc8/structblaze_1_1IsConstructible.html">IsConstructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga671017831f218cf5ccf1095484b32efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/dc8/structblaze_1_1IsConstructible.html" title="Compile time type check.The IsConstructible type trait tests whether the expression. ">IsConstructible</a> type trait.The IsConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d9/dc8/structblaze_1_1IsConstructible.html" title="Compile time type check.The IsConstructible type trait tests whether the expression. ">IsConstructible</a> class template. For instance, given the types <em>T1</em>, <em>T2</em> and <em>T3</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga671017831f218cf5ccf1095484b32efe">More...</a><br /></td></tr>
<tr class="separator:ga671017831f218cf5ccf1095484b32efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c777a54f7d920236818ccfe73289091"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ga6c777a54f7d920236818ccfe73289091"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga6c777a54f7d920236818ccfe73289091">blaze::IsNothrowConstructible_</a> = <a class="el" href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html">IsNothrowConstructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga6c777a54f7d920236818ccfe73289091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html" title="Compile time type check.The IsNothrowConstructible type trait tests whether the expression. ">IsNothrowConstructible</a> type trait.The IsNothrowConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html" title="Compile time type check.The IsNothrowConstructible type trait tests whether the expression. ">IsNothrowConstructible</a> class template. For instance, given the types <em>T1</em>, <em>T2</em> and <em>T3</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga6c777a54f7d920236818ccfe73289091">More...</a><br /></td></tr>
<tr class="separator:ga6c777a54f7d920236818ccfe73289091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4a73ec521754e365cde9320f043703c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae4a73ec521754e365cde9320f043703c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gae4a73ec521754e365cde9320f043703c">blaze::IsDefaultConstructible_</a> = <a class="el" href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html">IsDefaultConstructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gae4a73ec521754e365cde9320f043703c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html" title="Compile time type check.The IsDefaultConstructible type trait tests whether the expression. ">IsDefaultConstructible</a> type trait.The IsDefaultConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html" title="Compile time type check.The IsDefaultConstructible type trait tests whether the expression. ">IsDefaultConstructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gae4a73ec521754e365cde9320f043703c">More...</a><br /></td></tr>
<tr class="separator:gae4a73ec521754e365cde9320f043703c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46c14973c87aa69460a009df30772180"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga46c14973c87aa69460a009df30772180"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga46c14973c87aa69460a009df30772180">blaze::IsNothrowDefaultConstructible_</a> = <a class="el" href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html">IsNothrowDefaultConstructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga46c14973c87aa69460a009df30772180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html" title="Compile time type check.The IsNothrowDefaultConstructible type trait tests whether the expression...">IsNothrowDefaultConstructible</a> type trait.The IsNothrowDefaultConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html" title="Compile time type check.The IsNothrowDefaultConstructible type trait tests whether the expression...">IsNothrowDefaultConstructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga46c14973c87aa69460a009df30772180">More...</a><br /></td></tr>
<tr class="separator:ga46c14973c87aa69460a009df30772180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f1d8c64f1e37e73928887ad55a26f6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5f1d8c64f1e37e73928887ad55a26f6f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga5f1d8c64f1e37e73928887ad55a26f6f">blaze::IsCopyConstructible_</a> = <a class="el" href="../../df/d1e/structblaze_1_1IsCopyConstructible.html">IsCopyConstructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga5f1d8c64f1e37e73928887ad55a26f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d1e/structblaze_1_1IsCopyConstructible.html" title="Compile time type check.The IsCopyConstructible type trait tests whether the expression. ">IsCopyConstructible</a> type trait.The IsCopyConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../df/d1e/structblaze_1_1IsCopyConstructible.html" title="Compile time type check.The IsCopyConstructible type trait tests whether the expression. ">IsCopyConstructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga5f1d8c64f1e37e73928887ad55a26f6f">More...</a><br /></td></tr>
<tr class="separator:ga5f1d8c64f1e37e73928887ad55a26f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eb5dfea232d8d994947fd85f0c7bf1e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6eb5dfea232d8d994947fd85f0c7bf1e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga6eb5dfea232d8d994947fd85f0c7bf1e">blaze::IsNothrowCopyConstructible_</a> = <a class="el" href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html">IsNothrowCopyConstructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga6eb5dfea232d8d994947fd85f0c7bf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html" title="Compile time type check.The IsNothrowCopyConstructible type trait tests whether the expression...">IsNothrowCopyConstructible</a> type trait.The IsNothrowCopyConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html" title="Compile time type check.The IsNothrowCopyConstructible type trait tests whether the expression...">IsNothrowCopyConstructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga6eb5dfea232d8d994947fd85f0c7bf1e">More...</a><br /></td></tr>
<tr class="separator:ga6eb5dfea232d8d994947fd85f0c7bf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c11f88a509995996aa0d6e8cb7c26c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9c11f88a509995996aa0d6e8cb7c26c7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga9c11f88a509995996aa0d6e8cb7c26c7">blaze::IsMoveConstructible_</a> = <a class="el" href="../../d1/d17/structblaze_1_1IsMoveConstructible.html">IsMoveConstructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga9c11f88a509995996aa0d6e8cb7c26c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d17/structblaze_1_1IsMoveConstructible.html" title="Compile time type check.The IsMoveConstructible type trait tests whether the expression. ">IsMoveConstructible</a> type trait.The IsMoveConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d1/d17/structblaze_1_1IsMoveConstructible.html" title="Compile time type check.The IsMoveConstructible type trait tests whether the expression. ">IsMoveConstructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga9c11f88a509995996aa0d6e8cb7c26c7">More...</a><br /></td></tr>
<tr class="separator:ga9c11f88a509995996aa0d6e8cb7c26c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e23af344466aecb67034e34861dbc54"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6e23af344466aecb67034e34861dbc54"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga6e23af344466aecb67034e34861dbc54">blaze::IsNothrowMoveConstructible_</a> = <a class="el" href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html">IsNothrowMoveConstructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga6e23af344466aecb67034e34861dbc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html" title="Compile time type check.The IsNothrowMoveConstructible type trait tests whether the expression...">IsNothrowMoveConstructible</a> type trait.The IsNothrowMoveConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html" title="Compile time type check.The IsNothrowMoveConstructible type trait tests whether the expression...">IsNothrowMoveConstructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga6e23af344466aecb67034e34861dbc54">More...</a><br /></td></tr>
<tr class="separator:ga6e23af344466aecb67034e34861dbc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084d82feb3f8558962416c487dd46334"><td class="memTemplParams" colspan="2">template&lt;typename From , typename To &gt; </td></tr>
<tr class="memitem:ga084d82feb3f8558962416c487dd46334"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga084d82feb3f8558962416c487dd46334">blaze::IsConvertible_</a> = <a class="el" href="../../dd/d98/structblaze_1_1IsConvertible.html">IsConvertible</a>&lt;From,To&gt;::value</td></tr>
<tr class="memdesc:ga084d82feb3f8558962416c487dd46334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d98/structblaze_1_1IsConvertible.html" title="Compile time pointer relationship constraint.This type traits tests whether the first given template ...">IsConvertible</a> type trait.The IsConvertible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dd/d98/structblaze_1_1IsConvertible.html" title="Compile time pointer relationship constraint.This type traits tests whether the first given template ...">IsConvertible</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga084d82feb3f8558962416c487dd46334">More...</a><br /></td></tr>
<tr class="separator:ga084d82feb3f8558962416c487dd46334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf443cd908f16ac1b9dce7fa121d3c00e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf443cd908f16ac1b9dce7fa121d3c00e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaf443cd908f16ac1b9dce7fa121d3c00e">blaze::IsDestructible_</a> = <a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html">IsDestructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gaf443cd908f16ac1b9dce7fa121d3c00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html" title="Compile time type check.The IsDestructible type trait tests whether the expression. ">IsDestructible</a> type trait.The IsDestructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html" title="Compile time type check.The IsDestructible type trait tests whether the expression. ">IsDestructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gaf443cd908f16ac1b9dce7fa121d3c00e">More...</a><br /></td></tr>
<tr class="separator:gaf443cd908f16ac1b9dce7fa121d3c00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17130ecd9705b567586e3d8d8f8a6023"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga17130ecd9705b567586e3d8d8f8a6023"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga17130ecd9705b567586e3d8d8f8a6023">blaze::IsNothrowDestructible_</a> = <a class="el" href="../../dc/d8b/structblaze_1_1IsNothrowDestructible.html">IsNothrowDestructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga17130ecd9705b567586e3d8d8f8a6023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d8b/structblaze_1_1IsNothrowDestructible.html" title="Compile time type check.The IsDestructible type trait tests whether the expression. ">IsNothrowDestructible</a> type trait.The IsNothrowDestructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/d8b/structblaze_1_1IsNothrowDestructible.html" title="Compile time type check.The IsDestructible type trait tests whether the expression. ">IsNothrowDestructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga17130ecd9705b567586e3d8d8f8a6023">More...</a><br /></td></tr>
<tr class="separator:ga17130ecd9705b567586e3d8d8f8a6023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae60080ed74c7b750717385e7f705001a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae60080ed74c7b750717385e7f705001a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gae60080ed74c7b750717385e7f705001a">blaze::IsDouble_</a> = <a class="el" href="../../de/d60/structblaze_1_1IsDouble.html">IsDouble</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gae60080ed74c7b750717385e7f705001a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d60/structblaze_1_1IsDouble.html" title="Compile time check for double precision floating point types.This type trait tests whether or not the...">IsDouble</a> type trait.The IsDouble_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../de/d60/structblaze_1_1IsDouble.html" title="Compile time check for double precision floating point types.This type trait tests whether or not the...">IsDouble</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gae60080ed74c7b750717385e7f705001a">More...</a><br /></td></tr>
<tr class="separator:gae60080ed74c7b750717385e7f705001a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ea2395a506b0a46fe36e006c452bd1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa5ea2395a506b0a46fe36e006c452bd1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaa5ea2395a506b0a46fe36e006c452bd1">blaze::IsEmpty_</a> = <a class="el" href="../../dc/d47/structblaze_1_1IsEmpty.html">IsEmpty</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gaa5ea2395a506b0a46fe36e006c452bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d47/structblaze_1_1IsEmpty.html" title="Compile time type check.This class tests whether the given template parameter is an empty class type...">IsEmpty</a> type trait.The IsEmpty_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/d47/structblaze_1_1IsEmpty.html" title="Compile time type check.This class tests whether the given template parameter is an empty class type...">IsEmpty</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gaa5ea2395a506b0a46fe36e006c452bd1">More...</a><br /></td></tr>
<tr class="separator:gaa5ea2395a506b0a46fe36e006c452bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08987d7954b54314671767bf85bd40e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga08987d7954b54314671767bf85bd40e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga08987d7954b54314671767bf85bd40e5">blaze::IsFloat_</a> = <a class="el" href="../../db/d07/structblaze_1_1IsFloat.html">IsFloat</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga08987d7954b54314671767bf85bd40e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/d07/structblaze_1_1IsFloat.html" title="Compile time check for single precision floating point types.This type trait tests whether or not the...">IsFloat</a> type trait.The IsFloat_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../db/d07/structblaze_1_1IsFloat.html" title="Compile time check for single precision floating point types.This type trait tests whether or not the...">IsFloat</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga08987d7954b54314671767bf85bd40e5">More...</a><br /></td></tr>
<tr class="separator:ga08987d7954b54314671767bf85bd40e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b0b6dc3b63b1f47994ea9ec478f638"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga08b0b6dc3b63b1f47994ea9ec478f638"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga08b0b6dc3b63b1f47994ea9ec478f638">blaze::IsFloatingPoint_</a> = <a class="el" href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html">IsFloatingPoint</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga08b0b6dc3b63b1f47994ea9ec478f638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html" title="Compile time check for floating point data types.This type trait tests whether or not the given templ...">IsFloatingPoint</a> type trait.The IsFloatingPoint_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html" title="Compile time check for floating point data types.This type trait tests whether or not the given templ...">IsFloatingPoint</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga08b0b6dc3b63b1f47994ea9ec478f638">More...</a><br /></td></tr>
<tr class="separator:ga08b0b6dc3b63b1f47994ea9ec478f638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d69d7e420a43f51f87c96f5047147d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3d69d7e420a43f51f87c96f5047147d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga3d69d7e420a43f51f87c96f5047147d9">blaze::IsInteger_</a> = <a class="el" href="../../d8/d5e/structblaze_1_1IsInteger.html">IsInteger</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga3d69d7e420a43f51f87c96f5047147d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d5e/structblaze_1_1IsInteger.html" title="Compile time check for integer types.This type trait tests whether or not the given template paramete...">IsInteger</a> type trait.The IsInteger_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d8/d5e/structblaze_1_1IsInteger.html" title="Compile time check for integer types.This type trait tests whether or not the given template paramete...">IsInteger</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga3d69d7e420a43f51f87c96f5047147d9">More...</a><br /></td></tr>
<tr class="separator:ga3d69d7e420a43f51f87c96f5047147d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ea4427cf7156058e89c161f701e4a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae1ea4427cf7156058e89c161f701e4a3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gae1ea4427cf7156058e89c161f701e4a3">blaze::IsIntegral_</a> = <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gae1ea4427cf7156058e89c161f701e4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html" title="Compile time check for integral data types.This type trait tests whether or not the given template pa...">IsIntegral</a> type trait.The IsIntegral_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html" title="Compile time check for integral data types.This type trait tests whether or not the given template pa...">IsIntegral</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gae1ea4427cf7156058e89c161f701e4a3">More...</a><br /></td></tr>
<tr class="separator:gae1ea4427cf7156058e89c161f701e4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d9b8ab9afdce6f4bf1d625da657182"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab6d9b8ab9afdce6f4bf1d625da657182"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gab6d9b8ab9afdce6f4bf1d625da657182">blaze::IsLong_</a> = <a class="el" href="../../d5/d40/structblaze_1_1IsLong.html">IsLong</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gab6d9b8ab9afdce6f4bf1d625da657182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d40/structblaze_1_1IsLong.html" title="Compile time check for long integer types.This type trait tests whether or not the given template par...">IsLong</a> type trait.The IsLong_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d5/d40/structblaze_1_1IsLong.html" title="Compile time check for long integer types.This type trait tests whether or not the given template par...">IsLong</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gab6d9b8ab9afdce6f4bf1d625da657182">More...</a><br /></td></tr>
<tr class="separator:gab6d9b8ab9afdce6f4bf1d625da657182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7abd40bcc5173b1e32e0e5443da3dcf9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7abd40bcc5173b1e32e0e5443da3dcf9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga7abd40bcc5173b1e32e0e5443da3dcf9">blaze::IsLongDouble_</a> = <a class="el" href="../../d2/d34/structblaze_1_1IsLongDouble.html">IsLongDouble</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga7abd40bcc5173b1e32e0e5443da3dcf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d34/structblaze_1_1IsLongDouble.html" title="Compile time check for extended precision floating point types.This type trait tests whether or not t...">IsLongDouble</a> type trait.The IsLongDouble_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d2/d34/structblaze_1_1IsLongDouble.html" title="Compile time check for extended precision floating point types.This type trait tests whether or not t...">IsLongDouble</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga7abd40bcc5173b1e32e0e5443da3dcf9">More...</a><br /></td></tr>
<tr class="separator:ga7abd40bcc5173b1e32e0e5443da3dcf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a6bc2539c4ecefeb8736bc95c7b0036"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3a6bc2539c4ecefeb8736bc95c7b0036"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga3a6bc2539c4ecefeb8736bc95c7b0036">blaze::IsNumeric_</a> = <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga3a6bc2539c4ecefeb8736bc95c7b0036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html" title="Compile time check for numeric types.This type trait tests whether or not the given template paramete...">IsNumeric</a> type trait.The IsNumeric_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html" title="Compile time check for numeric types.This type trait tests whether or not the given template paramete...">IsNumeric</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga3a6bc2539c4ecefeb8736bc95c7b0036">More...</a><br /></td></tr>
<tr class="separator:ga3a6bc2539c4ecefeb8736bc95c7b0036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfcd98459749cdae383c8666ea534ebc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabfcd98459749cdae383c8666ea534ebc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gabfcd98459749cdae383c8666ea534ebc">blaze::IsObject_</a> = <a class="el" href="../../dc/db8/structblaze_1_1IsObject.html">IsObject</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gabfcd98459749cdae383c8666ea534ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/db8/structblaze_1_1IsObject.html" title="Compile time type check.This class tests whether the given template parameter T is an object type...">IsObject</a> type trait.The IsObject_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/db8/structblaze_1_1IsObject.html" title="Compile time type check.This class tests whether the given template parameter T is an object type...">IsObject</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gabfcd98459749cdae383c8666ea534ebc">More...</a><br /></td></tr>
<tr class="separator:gabfcd98459749cdae383c8666ea534ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5712c09ca483bd05a59a0731645fd198"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5712c09ca483bd05a59a0731645fd198"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga5712c09ca483bd05a59a0731645fd198">blaze::IsPod_</a> = <a class="el" href="../../de/db0/structblaze_1_1IsPod.html">IsPod</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga5712c09ca483bd05a59a0731645fd198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/db0/structblaze_1_1IsPod.html" title="Compile time check for pod data types.This type trait tests whether or not the given template paramet...">IsPod</a> type trait.The IsPod_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../de/db0/structblaze_1_1IsPod.html" title="Compile time check for pod data types.This type trait tests whether or not the given template paramet...">IsPod</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga5712c09ca483bd05a59a0731645fd198">More...</a><br /></td></tr>
<tr class="separator:ga5712c09ca483bd05a59a0731645fd198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05e2afac57996122c1fe86ec5d7f23d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga05e2afac57996122c1fe86ec5d7f23d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga05e2afac57996122c1fe86ec5d7f23d4">blaze::IsPointer_</a> = <a class="el" href="../../dc/d0f/structblaze_1_1IsPointer.html">IsPointer</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga05e2afac57996122c1fe86ec5d7f23d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d0f/structblaze_1_1IsPointer.html" title="Compile time type check.This class tests whether the given template parameter is a pointer type (incl...">IsPointer</a> type trait.The IsPointer_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/d0f/structblaze_1_1IsPointer.html" title="Compile time type check.This class tests whether the given template parameter is a pointer type (incl...">IsPointer</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga05e2afac57996122c1fe86ec5d7f23d4">More...</a><br /></td></tr>
<tr class="separator:ga05e2afac57996122c1fe86ec5d7f23d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad19cbc0bec4bce544fdb1f3334959cb6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad19cbc0bec4bce544fdb1f3334959cb6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gad19cbc0bec4bce544fdb1f3334959cb6">blaze::IsReference_</a> = <a class="el" href="../../d1/dad/structblaze_1_1IsReference.html">IsReference</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gad19cbc0bec4bce544fdb1f3334959cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/dad/structblaze_1_1IsReference.html" title="Compile time type check.This class tests whether the given template parameter T is a reference type (...">IsReference</a> type trait.The IsReference_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d1/dad/structblaze_1_1IsReference.html" title="Compile time type check.This class tests whether the given template parameter T is a reference type (...">IsReference</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gad19cbc0bec4bce544fdb1f3334959cb6">More...</a><br /></td></tr>
<tr class="separator:gad19cbc0bec4bce544fdb1f3334959cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcebe6bf37af5c56ebf39747c1bf737f"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:gadcebe6bf37af5c56ebf39747c1bf737f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gadcebe6bf37af5c56ebf39747c1bf737f">blaze::IsStrictlySame_</a> = <a class="el" href="../../d4/df1/structblaze_1_1IsStrictlySame.html">IsStrictlySame</a>&lt;A,B&gt;::value</td></tr>
<tr class="memdesc:gadcebe6bf37af5c56ebf39747c1bf737f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/df1/structblaze_1_1IsStrictlySame.html" title="Compile time type relationship analysis.This class tests if the two data types A and B are equal...">IsStrictlySame</a> type trait.The IsStrictlySame_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d4/df1/structblaze_1_1IsStrictlySame.html" title="Compile time type relationship analysis.This class tests if the two data types A and B are equal...">IsStrictlySame</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gadcebe6bf37af5c56ebf39747c1bf737f">More...</a><br /></td></tr>
<tr class="separator:gadcebe6bf37af5c56ebf39747c1bf737f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a9e14833731e5c616b6ba8fb462a0b"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ga08a9e14833731e5c616b6ba8fb462a0b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga08a9e14833731e5c616b6ba8fb462a0b">blaze::IsSame_</a> = <a class="el" href="../../dc/d89/structblaze_1_1IsSame.html">IsSame</a>&lt;A,B&gt;::value</td></tr>
<tr class="memdesc:ga08a9e14833731e5c616b6ba8fb462a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d89/structblaze_1_1IsSame.html" title="Type relationship analysis.This class tests if the two data types A and B are equal. For this type comparison, the cv-qualifiers of both data types are ignored. If A and B are the same data type (ignoring the cv-qualifiers), then the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsSame</a> type trait.The IsSame_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/d89/structblaze_1_1IsSame.html" title="Type relationship analysis.This class tests if the two data types A and B are equal. For this type comparison, the cv-qualifiers of both data types are ignored. If A and B are the same data type (ignoring the cv-qualifiers), then the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsSame</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga08a9e14833731e5c616b6ba8fb462a0b">More...</a><br /></td></tr>
<tr class="separator:ga08a9e14833731e5c616b6ba8fb462a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b27fa4cbc7544fe0d503dcf5f9ec23d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0b27fa4cbc7544fe0d503dcf5f9ec23d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga0b27fa4cbc7544fe0d503dcf5f9ec23d">blaze::IsShort_</a> = <a class="el" href="../../d0/d59/structblaze_1_1IsShort.html">IsShort</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga0b27fa4cbc7544fe0d503dcf5f9ec23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/d59/structblaze_1_1IsShort.html" title="Compile time check for short integer types.This type trait tests whether or not the given template pa...">IsShort</a> type trait.The IsShort_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d0/d59/structblaze_1_1IsShort.html" title="Compile time check for short integer types.This type trait tests whether or not the given template pa...">IsShort</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga0b27fa4cbc7544fe0d503dcf5f9ec23d">More...</a><br /></td></tr>
<tr class="separator:ga0b27fa4cbc7544fe0d503dcf5f9ec23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddb5789f765663c62c457de49895b577"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaddb5789f765663c62c457de49895b577"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaddb5789f765663c62c457de49895b577">blaze::IsSigned_</a> = <a class="el" href="../../dd/def/structblaze_1_1IsSigned.html">IsSigned</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gaddb5789f765663c62c457de49895b577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/def/structblaze_1_1IsSigned.html" title="Compile time check for signed data types.This type trait tests whether or not the given template para...">IsSigned</a> type trait.The IsSigned_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dd/def/structblaze_1_1IsSigned.html" title="Compile time check for signed data types.This type trait tests whether or not the given template para...">IsSigned</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gaddb5789f765663c62c457de49895b577">More...</a><br /></td></tr>
<tr class="separator:gaddb5789f765663c62c457de49895b577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac59bf6f2809ebbee3bb38e5c2e744042"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac59bf6f2809ebbee3bb38e5c2e744042"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gac59bf6f2809ebbee3bb38e5c2e744042">blaze::IsUnion_</a> = <a class="el" href="../../de/dc7/structblaze_1_1IsUnion.html">IsUnion</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gac59bf6f2809ebbee3bb38e5c2e744042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/dc7/structblaze_1_1IsUnion.html" title="Compile time check for union data types.This type trait tests whether or not the given template param...">IsUnion</a> type trait.The IsUnion_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../de/dc7/structblaze_1_1IsUnion.html" title="Compile time check for union data types.This type trait tests whether or not the given template param...">IsUnion</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#gac59bf6f2809ebbee3bb38e5c2e744042">More...</a><br /></td></tr>
<tr class="separator:gac59bf6f2809ebbee3bb38e5c2e744042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ccdc2f0971b4b391a5646bcbad1332c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8ccdc2f0971b4b391a5646bcbad1332c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga8ccdc2f0971b4b391a5646bcbad1332c">blaze::IsUnsigned_</a> = <a class="el" href="../../de/d8c/structblaze_1_1IsUnsigned.html">IsUnsigned</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga8ccdc2f0971b4b391a5646bcbad1332c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d8c/structblaze_1_1IsUnsigned.html" title="Compile time check for unsigned data types.This type trait tests whether or not the given template pa...">IsUnsigned</a> type trait.The IsUnsigned_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../de/d8c/structblaze_1_1IsUnsigned.html" title="Compile time check for unsigned data types.This type trait tests whether or not the given template pa...">IsUnsigned</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga8ccdc2f0971b4b391a5646bcbad1332c">More...</a><br /></td></tr>
<tr class="separator:ga8ccdc2f0971b4b391a5646bcbad1332c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cfd7f0a1211e48e06775865b2aeaf22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5cfd7f0a1211e48e06775865b2aeaf22"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga5cfd7f0a1211e48e06775865b2aeaf22">blaze::IsValid_</a> = <a class="el" href="../../d1/d6e/structblaze_1_1IsValid.html">IsValid</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga5cfd7f0a1211e48e06775865b2aeaf22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d6e/structblaze_1_1IsValid.html" title="Compile time type check.This class tests whether the given template parameter is a valid or invalid d...">IsValid</a> type trait.The IsValid_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d1/d6e/structblaze_1_1IsValid.html" title="Compile time type check.This class tests whether the given template parameter is a valid or invalid d...">IsValid</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga5cfd7f0a1211e48e06775865b2aeaf22">More...</a><br /></td></tr>
<tr class="separator:ga5cfd7f0a1211e48e06775865b2aeaf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0940cc79f2d7d56b66527e556159b133"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0940cc79f2d7d56b66527e556159b133"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga0940cc79f2d7d56b66527e556159b133">blaze::IsVectorizable_</a> = <a class="el" href="../../da/d0e/structblaze_1_1IsVectorizable.html">IsVectorizable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga0940cc79f2d7d56b66527e556159b133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/d0e/structblaze_1_1IsVectorizable.html" title="Compile time check for vectorizable types.Depending on the available instruction set (SSE...">IsVectorizable</a> type trait.The IsVectorizable_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../da/d0e/structblaze_1_1IsVectorizable.html" title="Compile time check for vectorizable types.Depending on the available instruction set (SSE...">IsVectorizable</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga0940cc79f2d7d56b66527e556159b133">More...</a><br /></td></tr>
<tr class="separator:ga0940cc79f2d7d56b66527e556159b133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a7e46df74ccbc2bbeae4cc1af270034"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5a7e46df74ccbc2bbeae4cc1af270034"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga5a7e46df74ccbc2bbeae4cc1af270034">blaze::IsVoid_</a> = <a class="el" href="../../d9/d6b/structblaze_1_1IsVoid.html">IsVoid</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga5a7e46df74ccbc2bbeae4cc1af270034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/d6b/structblaze_1_1IsVoid.html" title="Compile time check for the void data type.This type trait tests whether or not the given template par...">IsVoid</a> type trait.The IsVoid_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d9/d6b/structblaze_1_1IsVoid.html" title="Compile time check for the void data type.This type trait tests whether or not the given template par...">IsVoid</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga5a7e46df74ccbc2bbeae4cc1af270034">More...</a><br /></td></tr>
<tr class="separator:ga5a7e46df74ccbc2bbeae4cc1af270034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770c98ab14a415640c5a0ebb202e38d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga770c98ab14a415640c5a0ebb202e38d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga770c98ab14a415640c5a0ebb202e38d2">blaze::IsVolatile_</a> = <a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html">IsVolatile</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga770c98ab14a415640c5a0ebb202e38d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html" title="Compile time check for volatile data types.The IsVolatile type trait tests whether or not the given t...">IsVolatile</a> type trait.The IsVolatile_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html" title="Compile time check for volatile data types.The IsVolatile type trait tests whether or not the given t...">IsVolatile</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga770c98ab14a415640c5a0ebb202e38d2">More...</a><br /></td></tr>
<tr class="separator:ga770c98ab14a415640c5a0ebb202e38d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46f58c358485b46b3a1f0f72e982e714"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga46f58c358485b46b3a1f0f72e982e714"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga46f58c358485b46b3a1f0f72e982e714">blaze::Rank_</a> = <a class="el" href="../../df/db0/structblaze_1_1Rank.html">Rank</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga46f58c358485b46b3a1f0f72e982e714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/db0/structblaze_1_1Rank.html" title="Compile time check for array ranks.This type trait determines the rank of the given template argument...">Rank</a> type trait.The Rank_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../df/db0/structblaze_1_1Rank.html" title="Compile time check for array ranks.This type trait determines the rank of the given template argument...">Rank</a> class template. For instance, given the type <em>T</em> the following two statements are identical:  <a href="../../de/d5a/group__type__traits.html#ga46f58c358485b46b3a1f0f72e982e714">More...</a><br /></td></tr>
<tr class="separator:ga46f58c358485b46b3a1f0f72e982e714"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa4d07e6853705c0c77730625effda54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4d07e6853705c0c77730625effda54f">&sect;&nbsp;</a></span>AddConst_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gaa4d07e6853705c0c77730625effda54f">blaze::AddConst_</a> = typedef typename <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html">AddConst</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html" title="Addition of a top level &#39;const&#39; qualifier.The AddConst type trait adds a top level &#39;const&#39; qualifier ...">AddConst</a> type trait.The AddConst_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html" title="Addition of a top level &#39;const&#39; qualifier.The AddConst type trait adds a top level &#39;const&#39; qualifier ...">AddConst</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> AddConst&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = AddConst_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga929fa7c8723465e3db2d609625ca92cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga929fa7c8723465e3db2d609625ca92cb">&sect;&nbsp;</a></span>AddCV_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga929fa7c8723465e3db2d609625ca92cb">blaze::AddCV_</a> = typedef typename <a class="el" href="../../df/d58/structblaze_1_1AddCV.html">AddCV</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/d58/structblaze_1_1AddCV.html" title="Addition of a top level &#39;const&#39; and &#39;volatile&#39; qualifier.The AddCV type trait adds both a top level &#39;...">AddCV</a> type trait.The AddCV_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d58/structblaze_1_1AddCV.html" title="Addition of a top level &#39;const&#39; and &#39;volatile&#39; qualifier.The AddCV type trait adds both a top level &#39;...">AddCV</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> AddCV&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = AddCV_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gad44dfb9fe9000add409150fa4b7e9d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad44dfb9fe9000add409150fa4b7e9d63">&sect;&nbsp;</a></span>AddPointer_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gad44dfb9fe9000add409150fa4b7e9d63">blaze::AddPointer_</a> = typedef typename <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html">AddPointer</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html" title="Addition of a top level pointer.The AddPointer type trait adds a top level pointer to the given type ...">AddPointer</a> type trait.The AddPointer_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html" title="Addition of a top level pointer.The AddPointer type trait adds a top level pointer to the given type ...">AddPointer</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> AddPointer&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = AddPointer_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1c3a003331b1147d9cb4991a46b9ea37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c3a003331b1147d9cb4991a46b9ea37">&sect;&nbsp;</a></span>AddReference_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga1c3a003331b1147d9cb4991a46b9ea37">blaze::AddReference_</a> = typedef typename <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html">AddReference</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html" title="Addition of a top level reference.In case the given type T is not a reference type, the AddReference type trait adds a top level reference to the given type T. Else the resulting type Type is T. ">AddReference</a> type trait.The AddReference_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html" title="Addition of a top level reference.In case the given type T is not a reference type, the AddReference type trait adds a top level reference to the given type T. Else the resulting type Type is T. ">AddReference</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> AddReference&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = AddReference_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6a8cbfccf4f9d689a42e5d670499911f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a8cbfccf4f9d689a42e5d670499911f">&sect;&nbsp;</a></span>AddVolatile_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga6a8cbfccf4f9d689a42e5d670499911f">blaze::AddVolatile_</a> = typedef typename <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html">AddVolatile</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html" title="Addition of a top level &#39;volatile&#39; qualifier.The AddVolatile type trait adds a top level &#39;volatile&#39; q...">AddVolatile</a> type trait.The AddVolatile_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html" title="Addition of a top level &#39;volatile&#39; qualifier.The AddVolatile type trait adds a top level &#39;volatile&#39; q...">AddVolatile</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> AddVolatile&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = AddVolatile_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga08c7cd3125c6a710a8e69ca26f4ea5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08c7cd3125c6a710a8e69ca26f4ea5b9">&sect;&nbsp;</a></span>CommonType_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">blaze::CommonType_</a> = typedef typename <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html">CommonType</a>&lt;T...&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html" title="Deduction of a type common to several types.The CommonType type trait deduces the result type of a mi...">CommonType</a> type trait.The CommonType_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html" title="Deduction of a type common to several types.The CommonType type trait deduces the result type of a mi...">CommonType</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> CommonType&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = CommonType_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1dc48f717dd98041ce6ebfb5a3642541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dc48f717dd98041ce6ebfb5a3642541">&sect;&nbsp;</a></span>Decay_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga1dc48f717dd98041ce6ebfb5a3642541">blaze::Decay_</a> = typedef typename <a class="el" href="../../df/dbe/structblaze_1_1Decay.html">Decay</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/dbe/structblaze_1_1Decay.html" title="Applies the type conversions for by-value function arguments.This type trait applies the type convers...">Decay</a> type trait.The Decay_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/dbe/structblaze_1_1Decay.html" title="Applies the type conversions for by-value function arguments.This type trait applies the type convers...">Decay</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> Decay&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = Decay_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4a76caf184ea9b940528ac368da1b577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a76caf184ea9b940528ac368da1b577">&sect;&nbsp;</a></span>MakeSigned_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga4a76caf184ea9b940528ac368da1b577">blaze::MakeSigned_</a> = typedef typename <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html">MakeSigned</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html" title="Compile time type conversion into a signed integral type.This type trait provides the feature to conv...">MakeSigned</a> type trait.The MakeSigned_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html" title="Compile time type conversion into a signed integral type.This type trait provides the feature to conv...">MakeSigned</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> MakeSigned&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = MakeSigned_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7d8cacb214951110d862d4183532c7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d8cacb214951110d862d4183532c7d7">&sect;&nbsp;</a></span>MakeUnsigned_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga7d8cacb214951110d862d4183532c7d7">blaze::MakeUnsigned_</a> = typedef typename <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html">MakeUnsigned</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html" title="Compile time type conversion into an unsigned integral type.This type trait provides the feature to c...">MakeUnsigned</a> type trait.The MakeUnsigned_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html" title="Compile time type conversion into an unsigned integral type.This type trait provides the feature to c...">MakeUnsigned</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> MakeUnsigned&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = MakeUnsigned_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1054a603bf1d73c443e374227954a9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1054a603bf1d73c443e374227954a9b5">&sect;&nbsp;</a></span>RemoveAdaptor_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga1054a603bf1d73c443e374227954a9b5">blaze::RemoveAdaptor_</a> = typedef typename <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html">RemoveAdaptor</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html" title="Removal of top level adaptor types.In case the given type is an adaptor type (SymmetricMatrix, LowerMatrix, UpperMatrix, ...), the RemoveAdaptor type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved. ">RemoveAdaptor</a> type trait.The RemoveAdaptor_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html" title="Removal of top level adaptor types.In case the given type is an adaptor type (SymmetricMatrix, LowerMatrix, UpperMatrix, ...), the RemoveAdaptor type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved. ">RemoveAdaptor</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemoveAdaptor&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemoveAdaptor_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga0c53798803a90d594d0ef14e1481f1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c53798803a90d594d0ef14e1481f1aa">&sect;&nbsp;</a></span>RemoveAllExtents_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga0c53798803a90d594d0ef14e1481f1aa">blaze::RemoveAllExtents_</a> = typedef typename <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html">RemoveAllExtents</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html" title="Removal of all array extents.The RemoveAllExtents type trait removes all array extents from the given...">RemoveAllExtents</a> type trait.The RemoveAllExtents_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html" title="Removal of all array extents.The RemoveAllExtents type trait removes all array extents from the given...">RemoveAllExtents</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemoveAllExtents&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemoveAllExtents_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga13fccfb14d335ce408ceab9457bf4df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13fccfb14d335ce408ceab9457bf4df0">&sect;&nbsp;</a></span>RemoveConst_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga13fccfb14d335ce408ceab9457bf4df0">blaze::RemoveConst_</a> = typedef typename <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html">RemoveConst</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> type trait.The RemoveConst_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemoveConst&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemoveConst_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf21820cc9ce037667f76051caf920c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf21820cc9ce037667f76051caf920c2e">&sect;&nbsp;</a></span>RemoveCV_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gaf21820cc9ce037667f76051caf920c2e">blaze::RemoveCV_</a> = typedef typename <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html">RemoveCV</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait.The RemoveCV_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemoveCV&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemoveCV_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gacfbcd0119d3bddd693ffdb292c6e1a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfbcd0119d3bddd693ffdb292c6e1a3a">&sect;&nbsp;</a></span>RemoveExtent_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gacfbcd0119d3bddd693ffdb292c6e1a3a">blaze::RemoveExtent_</a> = typedef typename <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html">RemoveExtent</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html" title="Removal of the top level array extent.The RemoveExtent type trait removes the top level array extent ...">RemoveExtent</a> type trait.The RemoveExtent_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html" title="Removal of the top level array extent.The RemoveExtent type trait removes the top level array extent ...">RemoveExtent</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemoveExtent&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemoveExtent_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gac6e489fdde969ad7931b740b73da1a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6e489fdde969ad7931b740b73da1a97">&sect;&nbsp;</a></span>RemovePointer_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gac6e489fdde969ad7931b740b73da1a97">blaze::RemovePointer_</a> = typedef typename <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html">RemovePointer</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html" title="Removal of pointer modifiers.The RemovePointer type trait removes any pointer modifiers from the give...">RemovePointer</a> type trait.The RemovePointer_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html" title="Removal of pointer modifiers.The RemovePointer type trait removes any pointer modifiers from the give...">RemovePointer</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemovePointer&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemovePointer_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa0beac6880fd0f492a1166e1c254e4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0beac6880fd0f492a1166e1c254e4cb">&sect;&nbsp;</a></span>RemoveReference_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gaa0beac6880fd0f492a1166e1c254e4cb">blaze::RemoveReference_</a> = typedef typename <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html">RemoveReference</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html" title="Removal of reference modifiers.The RemoveReference type trait removes any reference modifiers from th...">RemoveReference</a> type trait.The RemoveReference_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html" title="Removal of reference modifiers.The RemoveReference type trait removes any reference modifiers from th...">RemoveReference</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemoveReference&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemoveReference_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gada49326a8f411400855a3b6e376ab62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada49326a8f411400855a3b6e376ab62d">&sect;&nbsp;</a></span>RemoveVolatile_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gada49326a8f411400855a3b6e376ab62d">blaze::RemoveVolatile_</a> = typedef typename <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html">RemoveVolatile</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> type trait.The RemoveVolatile_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemoveVolatile&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemoveVolatile_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga21ed6b57b46e4eb4a400f581bca0f616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21ed6b57b46e4eb4a400f581bca0f616">&sect;&nbsp;</a></span>UnderlyingBuiltin_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">blaze::UnderlyingBuiltin_</a> = typedef typename <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html">UnderlyingBuiltin</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html" title="Evaluation of the underlying builtin element type of a given data type.Via this type trait it is poss...">UnderlyingBuiltin</a> type trait.The UnderlyingBuiltin_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html" title="Evaluation of the underlying builtin element type of a given data type.Via this type trait it is poss...">UnderlyingBuiltin</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> UnderlyingBuiltin&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = UnderlyingBuiltin_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa1d099d4d07f45ddddd62de3908b3be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1d099d4d07f45ddddd62de3908b3be2">&sect;&nbsp;</a></span>UnderlyingElement_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gaa1d099d4d07f45ddddd62de3908b3be2">blaze::UnderlyingElement_</a> = typedef typename <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html">UnderlyingElement</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html" title="Evaluation of the element type of a given data type.Via this type trait it is possible to evaluate th...">UnderlyingElement</a> type trait.The UnderlyingElement_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html" title="Evaluation of the element type of a given data type.Via this type trait it is possible to evaluate th...">UnderlyingElement</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> UnderlyingElement&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = UnderlyingElement_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga11e3f75bd557307b815516615471dc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e3f75bd557307b815516615471dc20">&sect;&nbsp;</a></span>UnderlyingNumeric_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga11e3f75bd557307b815516615471dc20">blaze::UnderlyingNumeric_</a> = typedef typename <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html">UnderlyingNumeric</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html" title="Evaluation of the underlying numeric element type of a given data type.Via this type trait it is poss...">UnderlyingNumeric</a> type trait.The UnderlyingNumeric_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html" title="Evaluation of the underlying numeric element type of a given data type.Via this type trait it is poss...">UnderlyingNumeric</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> UnderlyingNumeric&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = UnderlyingNumeric_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gad9e57614da25f41b86dd909f1d639c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9e57614da25f41b86dd909f1d639c6a">&sect;&nbsp;</a></span>AlignmentOf_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::AlignmentOf_ = <a class="el" href="../../d5/dc6/structblaze_1_1AlignmentOf.html">AlignmentOf</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d5/dc6/structblaze_1_1AlignmentOf.html" title="Evaluation of the required alignment of the given data type.The AlignmentOf type trait template evalu...">AlignmentOf</a> type trait.The AlignmentOf_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d5/dc6/structblaze_1_1AlignmentOf.html" title="Evaluation of the required alignment of the given data type.The AlignmentOf type trait template evalu...">AlignmentOf</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">size_t</span> value1 = AlignmentOf&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">size_t</span> value2 = AlignmentOf_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga178ed97e2dfe95a87bc1753f3bcf37ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga178ed97e2dfe95a87bc1753f3bcf37ff">&sect;&nbsp;</a></span>All_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class TypeTrait, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::All_ = <a class="el" href="../../d9/de6/structblaze_1_1All.html">All</a>&lt;TypeTrait,Ts...&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> type trait.The All_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> class template. For instance, given the types <em>T1</em>, <em>T2</em>, and <em>T3</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = All&lt; IsIntegral, T1, T2, T3 &gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = All_&lt; IsIntegral, T1, T2, T3 &gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gad25819e65d6692296453436ba24fee76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad25819e65d6692296453436ba24fee76">&sect;&nbsp;</a></span>Any_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class TypeTrait, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::Any_ = <a class="el" href="../../d9/dfd/structblaze_1_1Any.html">Any</a>&lt;TypeTrait,Ts...&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/dfd/structblaze_1_1Any.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">Any</a> type trait.The Any_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d9/dfd/structblaze_1_1Any.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">Any</a> class template. For instance, given the types <em>T1</em>, <em>T2</em>, and <em>T3</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = Any&lt; IsIntegral, T1, T2, T3 &gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = Any_&lt; IsIntegral, T1, T2, T3 &gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga2f4176cdebd2a47b98024c29a9f76b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f4176cdebd2a47b98024c29a9f76b31">&sect;&nbsp;</a></span>Extent_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int blaze::Extent_ = <a class="el" href="../../d2/d50/structblaze_1_1Extent.html">Extent</a>&lt;T,N&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d2/d50/structblaze_1_1Extent.html" title="Compile time check for the size of array bounds.Via this type trait it is possible to query at compil...">Extent</a> type trait.The Extent_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d2/d50/structblaze_1_1Extent.html" title="Compile time check for the size of array bounds.Via this type trait it is possible to query at compil...">Extent</a> class template. For instance, given the type <em>T</em> and the index <em>N</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value1 = Extent&lt; T[2][3][4], N &gt;::value;</div><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value2 = Extent_&lt; T[2][3][4], N &gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga2b20422550073cad222edced2cc8b1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b20422550073cad222edced2cc8b1f0">&sect;&nbsp;</a></span>Has1Byte_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::Has1Byte_ = <a class="el" href="../../d7/d94/structblaze_1_1Has1Byte.html">Has1Byte</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/d94/structblaze_1_1Has1Byte.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has1Byte</a> type trait.The Has1Byte_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d7/d94/structblaze_1_1Has1Byte.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has1Byte</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = Has1Byte&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = Has1Byte_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf32deb8bb1539df79800276342f5229b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf32deb8bb1539df79800276342f5229b">&sect;&nbsp;</a></span>Has2Bytes_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::Has2Bytes_ = <a class="el" href="../../d9/d49/structblaze_1_1Has2Bytes.html">Has2Bytes</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/d49/structblaze_1_1Has2Bytes.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has2Bytes</a> type trait.The Has2Bytes_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d9/d49/structblaze_1_1Has2Bytes.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has2Bytes</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = Has2Bytes&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = Has2Bytes_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf417d49d38b92393836cb425efd5032d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf417d49d38b92393836cb425efd5032d">&sect;&nbsp;</a></span>Has4Bytes_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::Has4Bytes_ = <a class="el" href="../../d2/d99/structblaze_1_1Has4Bytes.html">Has4Bytes</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d2/d99/structblaze_1_1Has4Bytes.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has4Bytes</a> type trait.The Has4Bytes_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d2/d99/structblaze_1_1Has4Bytes.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has4Bytes</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = Has4Bytes&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = Has4Bytes_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga59b161229656399634b0f8f2bcb46a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59b161229656399634b0f8f2bcb46a6d">&sect;&nbsp;</a></span>Has8Bytes_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::Has8Bytes_ = <a class="el" href="../../d4/df1/structblaze_1_1Has8Bytes.html">Has8Bytes</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d4/df1/structblaze_1_1Has8Bytes.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has8Bytes</a> type trait.The Has8Bytes_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d4/df1/structblaze_1_1Has8Bytes.html" title="Compile time size check.This type trait offers the possibility to test whether a given type has a siz...">Has8Bytes</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = Has8Bytes&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = Has8Bytes_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6860f7b7cb730f79dc823ee7d4cb475a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6860f7b7cb730f79dc823ee7d4cb475a">&sect;&nbsp;</a></span>HasSize_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::HasSize_ = <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,<a class="el" href="../../df/d5d/structblaze_1_1Size.html">Size</a>&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/d90/structblaze_1_1HasSize.html" title="Compile time size check.This class offers the possibility to test the size of a type at compile time...">HasSize</a> type trait.The HasSize_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../df/d90/structblaze_1_1HasSize.html" title="Compile time size check.This class offers the possibility to test the size of a type at compile time...">HasSize</a> class template. For instance, given the type <em>T</em> and the value <em>N</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = HasSize&lt;T,N&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = HasSize_&lt;T,N&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaac1e2dd0b8cdbc4c176e03342ed715ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac1e2dd0b8cdbc4c176e03342ed715ed">&sect;&nbsp;</a></span>HaveSameSize_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::HaveSameSize_ = <a class="el" href="../../d7/d76/classblaze_1_1HaveSameSize.html">HaveSameSize</a>&lt;T1,T2&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/d76/classblaze_1_1HaveSameSize.html" title="Compile time size check.This class offers the possibility to test the size of two types at compile ti...">HaveSameSize</a> type trait.The HaveSameSize_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d7/d76/classblaze_1_1HaveSameSize.html" title="Compile time size check.This class offers the possibility to test the size of two types at compile ti...">HaveSameSize</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = HaveSameSize&lt;T1,T2&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = HaveSameSize_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gadc503cc31b387d2b5fbc37e4466edd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc503cc31b387d2b5fbc37e4466edd4a">&sect;&nbsp;</a></span>IsArithmetic_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsArithmetic_ = <a class="el" href="../../dc/daf/structblaze_1_1IsArithmetic.html">IsArithmetic</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dc/daf/structblaze_1_1IsArithmetic.html" title="Compile time check for arithmetic data types.This type trait tests whether or not the given template ...">IsArithmetic</a> type trait.The IsArithmetic_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/daf/structblaze_1_1IsArithmetic.html" title="Compile time check for arithmetic data types.This type trait tests whether or not the given template ...">IsArithmetic</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsArithmetic&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsArithmetic_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7551547873ed5663bfee3448a9237497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7551547873ed5663bfee3448a9237497">&sect;&nbsp;</a></span>IsArray_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsArray_ = <a class="el" href="../../d9/d2c/structblaze_1_1IsArray.html">IsArray</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/d2c/structblaze_1_1IsArray.html" title="Compile time type check.The IsArray type trait tests whether or not the given template parameter is a...">IsArray</a> type trait.The IsArray_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d9/d2c/structblaze_1_1IsArray.html" title="Compile time type check.The IsArray type trait tests whether or not the given template parameter is a...">IsArray</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsArray&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsArray_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3d1509c151d861bd067980786495ed25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d1509c151d861bd067980786495ed25">&sect;&nbsp;</a></span>IsAssignable_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsAssignable_ = <a class="el" href="../../df/dd9/structblaze_1_1IsAssignable.html">IsAssignable</a>&lt;T,U&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/dd9/structblaze_1_1IsAssignable.html" title="Compile time type check.The IsAssignable type trait tests whether the expression. ...">IsAssignable</a> type trait.The IsAssignable_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../df/dd9/structblaze_1_1IsAssignable.html" title="Compile time type check.The IsAssignable type trait tests whether the expression. ...">IsAssignable</a> class template. For instance, given the types <em>T</em> and <em>U</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsAssignable&lt;T,U&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsAssignable_&lt;T,U&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gadceff818bfc2128c84cca2e663c69f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadceff818bfc2128c84cca2e663c69f7e">&sect;&nbsp;</a></span>IsBaseOf_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsBaseOf_ = <a class="el" href="../../da/d07/classblaze_1_1IsBaseOf.html">IsBaseOf</a>&lt;Base,Derived&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../da/d07/classblaze_1_1IsBaseOf.html" title="Compile time analysis of an inheritance relationship.This type trait tests for an inheritance relatio...">IsBaseOf</a> type trait.The IsBaseOf_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../da/d07/classblaze_1_1IsBaseOf.html" title="Compile time analysis of an inheritance relationship.This type trait tests for an inheritance relatio...">IsBaseOf</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsBaseOf&lt;T1,T2&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsBaseOf_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga5d646c92979829b3294839bbeaf8d9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d646c92979829b3294839bbeaf8d9e0">&sect;&nbsp;</a></span>IsBoolean_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsBoolean_ = <a class="el" href="../../d7/d48/structblaze_1_1IsBoolean.html">IsBoolean</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/d48/structblaze_1_1IsBoolean.html" title="Compile time check for boolean types.This type trait tests whether or not the given template paramete...">IsBoolean</a> type trait.The IsBoolean_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d7/d48/structblaze_1_1IsBoolean.html" title="Compile time check for boolean types.This type trait tests whether or not the given template paramete...">IsBoolean</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsBoolean&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsBoolean_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4e5e5f45aac9be086ca73b240e381e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e5e5f45aac9be086ca73b240e381e7a">&sect;&nbsp;</a></span>IsBuiltin_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsBuiltin_ = <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html" title="Compile time check for built-in data types.This type trait tests whether or not the given template pa...">IsBuiltin</a> type trait.The IsBuiltin_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html" title="Compile time check for built-in data types.This type trait tests whether or not the given template pa...">IsBuiltin</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsBuiltin&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsBuiltin_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gad76751fc3d14e9e07aabc36212ab9477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad76751fc3d14e9e07aabc36212ab9477">&sect;&nbsp;</a></span>IsCharacter_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsCharacter_ = <a class="el" href="../../de/d32/structblaze_1_1IsCharacter.html">IsCharacter</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../de/d32/structblaze_1_1IsCharacter.html" title="Compile time check for character types.This type trait tests whether or not the given template parame...">IsCharacter</a> type trait.The IsCharacter_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../de/d32/structblaze_1_1IsCharacter.html" title="Compile time check for character types.This type trait tests whether or not the given template parame...">IsCharacter</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsCharacter&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsCharacter_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga58658afdd87e80e37f95aa1dcea2c5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58658afdd87e80e37f95aa1dcea2c5e9">&sect;&nbsp;</a></span>IsClass_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsClass_ = <a class="el" href="../../dd/d97/structblaze_1_1IsClass.html">IsClass</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dd/d97/structblaze_1_1IsClass.html" title="Compile time type check.The IsClass type trait tests whether or not the given template parameter is a...">IsClass</a> type trait.The IsClass_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dd/d97/structblaze_1_1IsClass.html" title="Compile time type check.The IsClass type trait tests whether or not the given template parameter is a...">IsClass</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsClass&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsClass_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaacfbd1de88421e49c47f9dcee584b6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacfbd1de88421e49c47f9dcee584b6bc">&sect;&nbsp;</a></span>IsComplex_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsComplex_ = <a class="el" href="../../d1/da9/structblaze_1_1IsComplex.html">IsComplex</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d1/da9/structblaze_1_1IsComplex.html" title="Compile time check for complex types.This type trait tests whether or not the given template paramete...">IsComplex</a> type trait.The IsComplex_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d1/da9/structblaze_1_1IsComplex.html" title="Compile time check for complex types.This type trait tests whether or not the given template paramete...">IsComplex</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsComplex&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsComplex_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf4f6f885629cbb719c5f8421fa529084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4f6f885629cbb719c5f8421fa529084">&sect;&nbsp;</a></span>IsComplexDouble_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsComplexDouble_ = <a class="el" href="../../d1/d5e/structblaze_1_1IsComplexDouble.html">IsComplexDouble</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d1/d5e/structblaze_1_1IsComplexDouble.html" title="Compile time check for single precision complex types.This type trait tests whether or not the given ...">IsComplexDouble</a> type trait.The IsComplexDouble_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d1/d5e/structblaze_1_1IsComplexDouble.html" title="Compile time check for single precision complex types.This type trait tests whether or not the given ...">IsComplexDouble</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsComplexDouble&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsComplexDouble_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga06aec44dccdbd5b5707af6e8f884d3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06aec44dccdbd5b5707af6e8f884d3b4">&sect;&nbsp;</a></span>IsComplexFloat_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsComplexFloat_ = <a class="el" href="../../df/d20/structblaze_1_1IsComplexFloat.html">IsComplexFloat</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/d20/structblaze_1_1IsComplexFloat.html" title="Compile time check for single precision complex types.This type trait tests whether or not the given ...">IsComplexFloat</a> type trait.The IsComplexFloat_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../df/d20/structblaze_1_1IsComplexFloat.html" title="Compile time check for single precision complex types.This type trait tests whether or not the given ...">IsComplexFloat</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsComplexFloat&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsComplexFloat_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga8c42796736a94421954fe5197a4bb2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c42796736a94421954fe5197a4bb2c9">&sect;&nbsp;</a></span>IsConst_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsConst_ = <a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html">IsConst</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html" title="Compile time check for constant data types.The IsConst type trait tests whether or not the given temp...">IsConst</a> type trait.The IsConst_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html" title="Compile time check for constant data types.The IsConst type trait tests whether or not the given temp...">IsConst</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsConst&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsConst_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga671017831f218cf5ccf1095484b32efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga671017831f218cf5ccf1095484b32efe">&sect;&nbsp;</a></span>IsConstructible_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsConstructible_ = <a class="el" href="../../d9/dc8/structblaze_1_1IsConstructible.html">IsConstructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/dc8/structblaze_1_1IsConstructible.html" title="Compile time type check.The IsConstructible type trait tests whether the expression. ">IsConstructible</a> type trait.The IsConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d9/dc8/structblaze_1_1IsConstructible.html" title="Compile time type check.The IsConstructible type trait tests whether the expression. ">IsConstructible</a> class template. For instance, given the types <em>T1</em>, <em>T2</em> and <em>T3</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsConstructible&lt;T1,T2,T3&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsConstructible_&lt;T1,T2,T3&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga084d82feb3f8558962416c487dd46334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga084d82feb3f8558962416c487dd46334">&sect;&nbsp;</a></span>IsConvertible_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename From , typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsConvertible_ = <a class="el" href="../../dd/d98/structblaze_1_1IsConvertible.html">IsConvertible</a>&lt;From,To&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dd/d98/structblaze_1_1IsConvertible.html" title="Compile time pointer relationship constraint.This type traits tests whether the first given template ...">IsConvertible</a> type trait.The IsConvertible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dd/d98/structblaze_1_1IsConvertible.html" title="Compile time pointer relationship constraint.This type traits tests whether the first given template ...">IsConvertible</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsConvertible&lt;T1,T2&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsConvertible_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7519d0b8bb5a808895127448861a5906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7519d0b8bb5a808895127448861a5906">&sect;&nbsp;</a></span>IsCopyAssignable_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsCopyAssignable_ = <a class="el" href="../../da/d54/structblaze_1_1IsCopyAssignable.html">IsCopyAssignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../da/d54/structblaze_1_1IsCopyAssignable.html" title="Compile time type check.The IsCopyAssignable type trait tests whether the expression. ">IsCopyAssignable</a> type trait.The IsCopyAssignable_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../da/d54/structblaze_1_1IsCopyAssignable.html" title="Compile time type check.The IsCopyAssignable type trait tests whether the expression. ">IsCopyAssignable</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsCopyAssignable&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsCopyAssignable_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga5f1d8c64f1e37e73928887ad55a26f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f1d8c64f1e37e73928887ad55a26f6f">&sect;&nbsp;</a></span>IsCopyConstructible_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsCopyConstructible_ = <a class="el" href="../../df/d1e/structblaze_1_1IsCopyConstructible.html">IsCopyConstructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/d1e/structblaze_1_1IsCopyConstructible.html" title="Compile time type check.The IsCopyConstructible type trait tests whether the expression. ">IsCopyConstructible</a> type trait.The IsCopyConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../df/d1e/structblaze_1_1IsCopyConstructible.html" title="Compile time type check.The IsCopyConstructible type trait tests whether the expression. ">IsCopyConstructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsCopyConstructible&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsCopyConstructible_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gae4a73ec521754e365cde9320f043703c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4a73ec521754e365cde9320f043703c">&sect;&nbsp;</a></span>IsDefaultConstructible_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsDefaultConstructible_ = <a class="el" href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html">IsDefaultConstructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html" title="Compile time type check.The IsDefaultConstructible type trait tests whether the expression. ">IsDefaultConstructible</a> type trait.The IsDefaultConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html" title="Compile time type check.The IsDefaultConstructible type trait tests whether the expression. ">IsDefaultConstructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsDefaultConstructible&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsDefaultConstructible_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf443cd908f16ac1b9dce7fa121d3c00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf443cd908f16ac1b9dce7fa121d3c00e">&sect;&nbsp;</a></span>IsDestructible_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsDestructible_ = <a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html">IsDestructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html" title="Compile time type check.The IsDestructible type trait tests whether the expression. ">IsDestructible</a> type trait.The IsDestructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html" title="Compile time type check.The IsDestructible type trait tests whether the expression. ">IsDestructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsDestructible&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsDestructible_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gae60080ed74c7b750717385e7f705001a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae60080ed74c7b750717385e7f705001a">&sect;&nbsp;</a></span>IsDouble_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsDouble_ = <a class="el" href="../../de/d60/structblaze_1_1IsDouble.html">IsDouble</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../de/d60/structblaze_1_1IsDouble.html" title="Compile time check for double precision floating point types.This type trait tests whether or not the...">IsDouble</a> type trait.The IsDouble_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../de/d60/structblaze_1_1IsDouble.html" title="Compile time check for double precision floating point types.This type trait tests whether or not the...">IsDouble</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsDouble&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsDouble_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa5ea2395a506b0a46fe36e006c452bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5ea2395a506b0a46fe36e006c452bd1">&sect;&nbsp;</a></span>IsEmpty_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsEmpty_ = <a class="el" href="../../dc/d47/structblaze_1_1IsEmpty.html">IsEmpty</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dc/d47/structblaze_1_1IsEmpty.html" title="Compile time type check.This class tests whether the given template parameter is an empty class type...">IsEmpty</a> type trait.The IsEmpty_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/d47/structblaze_1_1IsEmpty.html" title="Compile time type check.This class tests whether the given template parameter is an empty class type...">IsEmpty</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsEmpty&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsEmpty_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga08987d7954b54314671767bf85bd40e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08987d7954b54314671767bf85bd40e5">&sect;&nbsp;</a></span>IsFloat_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsFloat_ = <a class="el" href="../../db/d07/structblaze_1_1IsFloat.html">IsFloat</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../db/d07/structblaze_1_1IsFloat.html" title="Compile time check for single precision floating point types.This type trait tests whether or not the...">IsFloat</a> type trait.The IsFloat_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../db/d07/structblaze_1_1IsFloat.html" title="Compile time check for single precision floating point types.This type trait tests whether or not the...">IsFloat</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsFloat&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsFloat_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga08b0b6dc3b63b1f47994ea9ec478f638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08b0b6dc3b63b1f47994ea9ec478f638">&sect;&nbsp;</a></span>IsFloatingPoint_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsFloatingPoint_ = <a class="el" href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html">IsFloatingPoint</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html" title="Compile time check for floating point data types.This type trait tests whether or not the given templ...">IsFloatingPoint</a> type trait.The IsFloatingPoint_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html" title="Compile time check for floating point data types.This type trait tests whether or not the given templ...">IsFloatingPoint</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsFloatingPoint&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsFloatingPoint_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3d69d7e420a43f51f87c96f5047147d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d69d7e420a43f51f87c96f5047147d9">&sect;&nbsp;</a></span>IsInteger_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsInteger_ = <a class="el" href="../../d8/d5e/structblaze_1_1IsInteger.html">IsInteger</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d8/d5e/structblaze_1_1IsInteger.html" title="Compile time check for integer types.This type trait tests whether or not the given template paramete...">IsInteger</a> type trait.The IsInteger_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d8/d5e/structblaze_1_1IsInteger.html" title="Compile time check for integer types.This type trait tests whether or not the given template paramete...">IsInteger</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsInteger&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsInteger_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gae1ea4427cf7156058e89c161f701e4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1ea4427cf7156058e89c161f701e4a3">&sect;&nbsp;</a></span>IsIntegral_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsIntegral_ = <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html" title="Compile time check for integral data types.This type trait tests whether or not the given template pa...">IsIntegral</a> type trait.The IsIntegral_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html" title="Compile time check for integral data types.This type trait tests whether or not the given template pa...">IsIntegral</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsIntegral&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsIntegral_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gab6d9b8ab9afdce6f4bf1d625da657182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6d9b8ab9afdce6f4bf1d625da657182">&sect;&nbsp;</a></span>IsLong_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsLong_ = <a class="el" href="../../d5/d40/structblaze_1_1IsLong.html">IsLong</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d5/d40/structblaze_1_1IsLong.html" title="Compile time check for long integer types.This type trait tests whether or not the given template par...">IsLong</a> type trait.The IsLong_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d5/d40/structblaze_1_1IsLong.html" title="Compile time check for long integer types.This type trait tests whether or not the given template par...">IsLong</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsLong&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsLong_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7abd40bcc5173b1e32e0e5443da3dcf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7abd40bcc5173b1e32e0e5443da3dcf9">&sect;&nbsp;</a></span>IsLongDouble_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsLongDouble_ = <a class="el" href="../../d2/d34/structblaze_1_1IsLongDouble.html">IsLongDouble</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d2/d34/structblaze_1_1IsLongDouble.html" title="Compile time check for extended precision floating point types.This type trait tests whether or not t...">IsLongDouble</a> type trait.The IsLongDouble_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d2/d34/structblaze_1_1IsLongDouble.html" title="Compile time check for extended precision floating point types.This type trait tests whether or not t...">IsLongDouble</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsLongDouble&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsLongDouble_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga0b5b95fb1d784888d6b6097c0396ea02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b5b95fb1d784888d6b6097c0396ea02">&sect;&nbsp;</a></span>IsMoveAssignable_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsMoveAssignable_ = <a class="el" href="../../d6/d39/structblaze_1_1IsMoveAssignable.html">IsMoveAssignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d6/d39/structblaze_1_1IsMoveAssignable.html" title="Compile time type check.The IsMoveAssignable type trait tests whether the expression. ">IsMoveAssignable</a> type trait.The IsMoveAssignable_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d6/d39/structblaze_1_1IsMoveAssignable.html" title="Compile time type check.The IsMoveAssignable type trait tests whether the expression. ">IsMoveAssignable</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsMoveAssignable&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsMoveAssignable_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga9c11f88a509995996aa0d6e8cb7c26c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c11f88a509995996aa0d6e8cb7c26c7">&sect;&nbsp;</a></span>IsMoveConstructible_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsMoveConstructible_ = <a class="el" href="../../d1/d17/structblaze_1_1IsMoveConstructible.html">IsMoveConstructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d1/d17/structblaze_1_1IsMoveConstructible.html" title="Compile time type check.The IsMoveConstructible type trait tests whether the expression. ">IsMoveConstructible</a> type trait.The IsMoveConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d1/d17/structblaze_1_1IsMoveConstructible.html" title="Compile time type check.The IsMoveConstructible type trait tests whether the expression. ">IsMoveConstructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsMoveConstructible&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsMoveConstructible_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4a031d9df18f8212acadf2b3fc50e609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a031d9df18f8212acadf2b3fc50e609">&sect;&nbsp;</a></span>IsNothrowAssignable_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsNothrowAssignable_ = <a class="el" href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html">IsNothrowAssignable</a>&lt;T,U&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html" title="Compile time type check.The IsNothrowAssignable type trait tests whether the expression. ">IsNothrowAssignable</a> type trait.The IsNothrowAssignable_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html" title="Compile time type check.The IsNothrowAssignable type trait tests whether the expression. ">IsNothrowAssignable</a> class template. For instance, given the types <em>T</em> and <em>U</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsNothrowAssignable&lt;T,U&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsNothrowAssignable_&lt;T,U&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6c777a54f7d920236818ccfe73289091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c777a54f7d920236818ccfe73289091">&sect;&nbsp;</a></span>IsNothrowConstructible_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsNothrowConstructible_ = <a class="el" href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html">IsNothrowConstructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html" title="Compile time type check.The IsNothrowConstructible type trait tests whether the expression. ">IsNothrowConstructible</a> type trait.The IsNothrowConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html" title="Compile time type check.The IsNothrowConstructible type trait tests whether the expression. ">IsNothrowConstructible</a> class template. For instance, given the types <em>T1</em>, <em>T2</em> and <em>T3</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsNothrowConstructible&lt;T1,T2,T3&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsNothrowConstructible_&lt;T1,T2,T3&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gae050197c31248d663cca9013a7ce3fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae050197c31248d663cca9013a7ce3fe2">&sect;&nbsp;</a></span>IsNothrowCopyAssignable_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsNothrowCopyAssignable_ = <a class="el" href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html">IsNothrowCopyAssignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html" title="Compile time type check.The IsNothrowCopyAssignable type trait tests whether the expression. ">IsNothrowCopyAssignable</a> type trait.The IsNothrowCopyAssignable_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html" title="Compile time type check.The IsNothrowCopyAssignable type trait tests whether the expression. ">IsNothrowCopyAssignable</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsNothrowCopyAssignable&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsNothrowCopyAssignable_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6eb5dfea232d8d994947fd85f0c7bf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eb5dfea232d8d994947fd85f0c7bf1e">&sect;&nbsp;</a></span>IsNothrowCopyConstructible_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsNothrowCopyConstructible_ = <a class="el" href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html">IsNothrowCopyConstructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html" title="Compile time type check.The IsNothrowCopyConstructible type trait tests whether the expression...">IsNothrowCopyConstructible</a> type trait.The IsNothrowCopyConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html" title="Compile time type check.The IsNothrowCopyConstructible type trait tests whether the expression...">IsNothrowCopyConstructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsNothrowCopyConstructible&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsNothrowCopyConstructible_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga46c14973c87aa69460a009df30772180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46c14973c87aa69460a009df30772180">&sect;&nbsp;</a></span>IsNothrowDefaultConstructible_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsNothrowDefaultConstructible_ = <a class="el" href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html">IsNothrowDefaultConstructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html" title="Compile time type check.The IsNothrowDefaultConstructible type trait tests whether the expression...">IsNothrowDefaultConstructible</a> type trait.The IsNothrowDefaultConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html" title="Compile time type check.The IsNothrowDefaultConstructible type trait tests whether the expression...">IsNothrowDefaultConstructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsNothrowDefaultConstructible&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsNothrowDefaultConstructible_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga17130ecd9705b567586e3d8d8f8a6023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17130ecd9705b567586e3d8d8f8a6023">&sect;&nbsp;</a></span>IsNothrowDestructible_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsNothrowDestructible_ = <a class="el" href="../../dc/d8b/structblaze_1_1IsNothrowDestructible.html">IsNothrowDestructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dc/d8b/structblaze_1_1IsNothrowDestructible.html" title="Compile time type check.The IsDestructible type trait tests whether the expression. ">IsNothrowDestructible</a> type trait.The IsNothrowDestructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/d8b/structblaze_1_1IsNothrowDestructible.html" title="Compile time type check.The IsDestructible type trait tests whether the expression. ">IsNothrowDestructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsNothrowDestructible&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsNothrowDestructible_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga8b352cc8798abd497fa0ac05f7fe1507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b352cc8798abd497fa0ac05f7fe1507">&sect;&nbsp;</a></span>IsNothrowMoveAssignable_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsNothrowMoveAssignable_ = <a class="el" href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html">IsNothrowMoveAssignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html" title="Compile time type check.The IsNothrowMoveAssignable type trait tests whether the expression. ">IsNothrowMoveAssignable</a> type trait.The IsNothrowMoveAssignable_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html" title="Compile time type check.The IsNothrowMoveAssignable type trait tests whether the expression. ">IsNothrowMoveAssignable</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsNothrowMoveAssignable&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsNothrowMoveAssignable_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6e23af344466aecb67034e34861dbc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e23af344466aecb67034e34861dbc54">&sect;&nbsp;</a></span>IsNothrowMoveConstructible_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsNothrowMoveConstructible_ = <a class="el" href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html">IsNothrowMoveConstructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html" title="Compile time type check.The IsNothrowMoveConstructible type trait tests whether the expression...">IsNothrowMoveConstructible</a> type trait.The IsNothrowMoveConstructible_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html" title="Compile time type check.The IsNothrowMoveConstructible type trait tests whether the expression...">IsNothrowMoveConstructible</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsNothrowMoveConstructible&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsNothrowMoveConstructible_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3a6bc2539c4ecefeb8736bc95c7b0036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a6bc2539c4ecefeb8736bc95c7b0036">&sect;&nbsp;</a></span>IsNumeric_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsNumeric_ = <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html" title="Compile time check for numeric types.This type trait tests whether or not the given template paramete...">IsNumeric</a> type trait.The IsNumeric_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html" title="Compile time check for numeric types.This type trait tests whether or not the given template paramete...">IsNumeric</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsNumeric&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsNumeric_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gabfcd98459749cdae383c8666ea534ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfcd98459749cdae383c8666ea534ebc">&sect;&nbsp;</a></span>IsObject_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsObject_ = <a class="el" href="../../dc/db8/structblaze_1_1IsObject.html">IsObject</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dc/db8/structblaze_1_1IsObject.html" title="Compile time type check.This class tests whether the given template parameter T is an object type...">IsObject</a> type trait.The IsObject_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/db8/structblaze_1_1IsObject.html" title="Compile time type check.This class tests whether the given template parameter T is an object type...">IsObject</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsObject&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsObject_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga5712c09ca483bd05a59a0731645fd198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5712c09ca483bd05a59a0731645fd198">&sect;&nbsp;</a></span>IsPod_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsPod_ = <a class="el" href="../../de/db0/structblaze_1_1IsPod.html">IsPod</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../de/db0/structblaze_1_1IsPod.html" title="Compile time check for pod data types.This type trait tests whether or not the given template paramet...">IsPod</a> type trait.The IsPod_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../de/db0/structblaze_1_1IsPod.html" title="Compile time check for pod data types.This type trait tests whether or not the given template paramet...">IsPod</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsPod&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsPod_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga05e2afac57996122c1fe86ec5d7f23d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05e2afac57996122c1fe86ec5d7f23d4">&sect;&nbsp;</a></span>IsPointer_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsPointer_ = <a class="el" href="../../dc/d0f/structblaze_1_1IsPointer.html">IsPointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dc/d0f/structblaze_1_1IsPointer.html" title="Compile time type check.This class tests whether the given template parameter is a pointer type (incl...">IsPointer</a> type trait.The IsPointer_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/d0f/structblaze_1_1IsPointer.html" title="Compile time type check.This class tests whether the given template parameter is a pointer type (incl...">IsPointer</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsPointer&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsPointer_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gad19cbc0bec4bce544fdb1f3334959cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad19cbc0bec4bce544fdb1f3334959cb6">&sect;&nbsp;</a></span>IsReference_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsReference_ = <a class="el" href="../../d1/dad/structblaze_1_1IsReference.html">IsReference</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d1/dad/structblaze_1_1IsReference.html" title="Compile time type check.This class tests whether the given template parameter T is a reference type (...">IsReference</a> type trait.The IsReference_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d1/dad/structblaze_1_1IsReference.html" title="Compile time type check.This class tests whether the given template parameter T is a reference type (...">IsReference</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsReference&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsReference_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga08a9e14833731e5c616b6ba8fb462a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08a9e14833731e5c616b6ba8fb462a0b">&sect;&nbsp;</a></span>IsSame_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsSame_ = <a class="el" href="../../dc/d89/structblaze_1_1IsSame.html">IsSame</a>&lt;A,B&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dc/d89/structblaze_1_1IsSame.html" title="Type relationship analysis.This class tests if the two data types A and B are equal. For this type comparison, the cv-qualifiers of both data types are ignored. If A and B are the same data type (ignoring the cv-qualifiers), then the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsSame</a> type trait.The IsSame_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dc/d89/structblaze_1_1IsSame.html" title="Type relationship analysis.This class tests if the two data types A and B are equal. For this type comparison, the cv-qualifiers of both data types are ignored. If A and B are the same data type (ignoring the cv-qualifiers), then the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsSame</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsSame&lt;T1,T2&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsSame_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga0b27fa4cbc7544fe0d503dcf5f9ec23d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b27fa4cbc7544fe0d503dcf5f9ec23d">&sect;&nbsp;</a></span>IsShort_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsShort_ = <a class="el" href="../../d0/d59/structblaze_1_1IsShort.html">IsShort</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d0/d59/structblaze_1_1IsShort.html" title="Compile time check for short integer types.This type trait tests whether or not the given template pa...">IsShort</a> type trait.The IsShort_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d0/d59/structblaze_1_1IsShort.html" title="Compile time check for short integer types.This type trait tests whether or not the given template pa...">IsShort</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsShort&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsShort_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaddb5789f765663c62c457de49895b577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddb5789f765663c62c457de49895b577">&sect;&nbsp;</a></span>IsSigned_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsSigned_ = <a class="el" href="../../dd/def/structblaze_1_1IsSigned.html">IsSigned</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dd/def/structblaze_1_1IsSigned.html" title="Compile time check for signed data types.This type trait tests whether or not the given template para...">IsSigned</a> type trait.The IsSigned_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../dd/def/structblaze_1_1IsSigned.html" title="Compile time check for signed data types.This type trait tests whether or not the given template para...">IsSigned</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsSigned&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsSigned_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gadcebe6bf37af5c56ebf39747c1bf737f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcebe6bf37af5c56ebf39747c1bf737f">&sect;&nbsp;</a></span>IsStrictlySame_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsStrictlySame_ = <a class="el" href="../../d4/df1/structblaze_1_1IsStrictlySame.html">IsStrictlySame</a>&lt;A,B&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d4/df1/structblaze_1_1IsStrictlySame.html" title="Compile time type relationship analysis.This class tests if the two data types A and B are equal...">IsStrictlySame</a> type trait.The IsStrictlySame_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d4/df1/structblaze_1_1IsStrictlySame.html" title="Compile time type relationship analysis.This class tests if the two data types A and B are equal...">IsStrictlySame</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsStrictlySame&lt;T1,T2&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsStrictlySame_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gac59bf6f2809ebbee3bb38e5c2e744042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac59bf6f2809ebbee3bb38e5c2e744042">&sect;&nbsp;</a></span>IsUnion_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsUnion_ = <a class="el" href="../../de/dc7/structblaze_1_1IsUnion.html">IsUnion</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../de/dc7/structblaze_1_1IsUnion.html" title="Compile time check for union data types.This type trait tests whether or not the given template param...">IsUnion</a> type trait.The IsUnion_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../de/dc7/structblaze_1_1IsUnion.html" title="Compile time check for union data types.This type trait tests whether or not the given template param...">IsUnion</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsUnion&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsUnion_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga8ccdc2f0971b4b391a5646bcbad1332c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ccdc2f0971b4b391a5646bcbad1332c">&sect;&nbsp;</a></span>IsUnsigned_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsUnsigned_ = <a class="el" href="../../de/d8c/structblaze_1_1IsUnsigned.html">IsUnsigned</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../de/d8c/structblaze_1_1IsUnsigned.html" title="Compile time check for unsigned data types.This type trait tests whether or not the given template pa...">IsUnsigned</a> type trait.The IsUnsigned_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../de/d8c/structblaze_1_1IsUnsigned.html" title="Compile time check for unsigned data types.This type trait tests whether or not the given template pa...">IsUnsigned</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsUnsigned&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsUnsigned_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga5cfd7f0a1211e48e06775865b2aeaf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cfd7f0a1211e48e06775865b2aeaf22">&sect;&nbsp;</a></span>IsValid_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsValid_ = <a class="el" href="../../d1/d6e/structblaze_1_1IsValid.html">IsValid</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d1/d6e/structblaze_1_1IsValid.html" title="Compile time type check.This class tests whether the given template parameter is a valid or invalid d...">IsValid</a> type trait.The IsValid_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d1/d6e/structblaze_1_1IsValid.html" title="Compile time type check.This class tests whether the given template parameter is a valid or invalid d...">IsValid</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsValid&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsValid_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga0940cc79f2d7d56b66527e556159b133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0940cc79f2d7d56b66527e556159b133">&sect;&nbsp;</a></span>IsVectorizable_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsVectorizable_ = <a class="el" href="../../da/d0e/structblaze_1_1IsVectorizable.html">IsVectorizable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../da/d0e/structblaze_1_1IsVectorizable.html" title="Compile time check for vectorizable types.Depending on the available instruction set (SSE...">IsVectorizable</a> type trait.The IsVectorizable_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../da/d0e/structblaze_1_1IsVectorizable.html" title="Compile time check for vectorizable types.Depending on the available instruction set (SSE...">IsVectorizable</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsVectorizable&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsVectorizable_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga5a7e46df74ccbc2bbeae4cc1af270034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a7e46df74ccbc2bbeae4cc1af270034">&sect;&nbsp;</a></span>IsVoid_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsVoid_ = <a class="el" href="../../d9/d6b/structblaze_1_1IsVoid.html">IsVoid</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/d6b/structblaze_1_1IsVoid.html" title="Compile time check for the void data type.This type trait tests whether or not the given template par...">IsVoid</a> type trait.The IsVoid_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../d9/d6b/structblaze_1_1IsVoid.html" title="Compile time check for the void data type.This type trait tests whether or not the given template par...">IsVoid</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsVoid&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsVoid_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga770c98ab14a415640c5a0ebb202e38d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga770c98ab14a415640c5a0ebb202e38d2">&sect;&nbsp;</a></span>IsVolatile_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::IsVolatile_ = <a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html">IsVolatile</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html" title="Compile time check for volatile data types.The IsVolatile type trait tests whether or not the given t...">IsVolatile</a> type trait.The IsVolatile_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html" title="Compile time check for volatile data types.The IsVolatile type trait tests whether or not the given t...">IsVolatile</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> value1 = IsVolatile&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">bool</span> value2 = IsVolatile_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga46f58c358485b46b3a1f0f72e982e714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46f58c358485b46b3a1f0f72e982e714">&sect;&nbsp;</a></span>Rank_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::Rank_ = <a class="el" href="../../df/db0/structblaze_1_1Rank.html">Rank</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/db0/structblaze_1_1Rank.html" title="Compile time check for array ranks.This type trait determines the rank of the given template argument...">Rank</a> type trait.The Rank_ alias declaration provides a convenient shortcut to access the nested <em>value</em> of the <a class="el" href="../../df/db0/structblaze_1_1Rank.html" title="Compile time check for array ranks.This type trait determines the rank of the given template argument...">Rank</a> class template. For instance, given the type <em>T</em> the following two statements are identical: </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">size_t</span> value1 = Rank&lt;T&gt;::value;</div><div class="line">constexpr <span class="keywordtype">size_t</span> value2 = Rank_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Oct 8 2016 16:45:04 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
