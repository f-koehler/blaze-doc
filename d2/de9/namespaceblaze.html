<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>blaze Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">blaze Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace of the <b>Blaze</b> C++ math library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d7/d22/namespaceblaze_1_1logging"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d22/namespaceblaze_1_1logging.html">logging</a></td></tr>
<tr class="memdesc:d7/d22/namespaceblaze_1_1logging"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the logging module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d5/d1b/namespaceblaze_1_1threadpool"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d1b/namespaceblaze_1_1threadpool.html">threadpool</a></td></tr>
<tr class="memdesc:d5/d1b/namespaceblaze_1_1threadpool"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the threadpool module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/dc7/namespaceblaze_1_1timing"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dc7/namespaceblaze_1_1timing.html">timing</a></td></tr>
<tr class="memdesc:d7/dc7/namespaceblaze_1_1timing"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the time measurement module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dae/structblaze_1_1Abs.html">Abs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a> function.  <a href="../../d6/dae/structblaze_1_1Abs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> accuracy for floating point data types.The <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the computation accuracy of the Blaze library for any floating point data type. In order to assign an accuracy value, the <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.<br />
In order to handle accuracy values conveniently, the global <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> instance <a class="el" href="../../de/df1/group__math.html#gae5273b2715d3354c16d049d1313f7e72" title="Global Accuracy instance.The blaze::accuracy instance can be used wherever a floating point data type...">blaze::accuracy</a> is provided, which can be used wherever a floating point data value is required.  <a href="../../d6/d75/classblaze_1_1Accuracy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db3/structblaze_1_1Acos.html">Acos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gabbea0b8e061ed390f6c7767c9104e40e" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a> function.  <a href="../../d4/db3/structblaze_1_1Acos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d35/structblaze_1_1Acosh.html">Acosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gafdfd453cc8c85f2c9d65bc5d82eb52e5" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a> function.  <a href="../../dd/d35/structblaze_1_1Acosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da6/structblaze_1_1AddConst.html">AddConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level 'const' qualifier.The <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html" title="Addition of a top level &#39;const&#39; qualifier.The AddConst type trait adds a top level &#39;const&#39; qualifier ...">AddConst</a> type trait adds a top level 'const' qualifier to the given type <em>T</em>.  <a href="../../d7/da6/structblaze_1_1AddConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d58/structblaze_1_1AddCV.html">AddCV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level 'const' and 'volatile' qualifier.The <a class="el" href="../../df/d58/structblaze_1_1AddCV.html" title="Addition of a top level &#39;const&#39; and &#39;volatile&#39; qualifier.The AddCV type trait adds both a top level &#39;...">AddCV</a> type trait adds both a top level 'const' and 'volatile' qualifier to the given type <em>T</em>.  <a href="../../df/d58/structblaze_1_1AddCV.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d2f/structblaze_1_1AddExpr.html">AddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all addition expression templates.The <a class="el" href="../../d5/d2f/structblaze_1_1AddExpr.html" title="Base class for all addition expression templates.The AddExpr class serves as a tag for all expression...">AddExpr</a> class serves as a tag for all expression templates that implement mathematical additions. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical addition (vector additions and matrix additions) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as addition expression template. Only in case a class is derived from the <a class="el" href="../../d5/d2f/structblaze_1_1AddExpr.html" title="Base class for all addition expression templates.The AddExpr class serves as a tag for all expression...">AddExpr</a> base class, the <a class="el" href="../../da/d0e/structblaze_1_1IsAddExpr.html" title="Compile time check whether the given type is an addition expression template.This type trait class te...">IsAddExpr</a> type trait recognizes the class as valid addition expression template.  <a href="../../d5/d2f/structblaze_1_1AddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dc4/structblaze_1_1AddExprTrait.html">AddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of an addition expression.Via this type trait it is possible to evaluate the return type of an addition expression between scalars, vectors, and matrices. Given the two types <em>T1</em> and <em>T2</em>, which must either be scalar, vector, or matrix types, the nested type <em>Type</em> corresponds to the resulting return type. In case the types of <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be added, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/dc4/structblaze_1_1AddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html">AddPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level pointer.The <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html" title="Addition of a top level pointer.The AddPointer type trait adds a top level pointer to the given type ...">AddPointer</a> type trait adds a top level pointer to the given type <em>T</em>. It has the same effect as <code>blaze::RemovePointer&lt;T&gt;::Type*</code>.  <a href="../../d4/da6/structblaze_1_1AddPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d30/structblaze_1_1AddReference.html">AddReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level reference.In case the given type <em>T</em> is not a reference type, the <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html" title="Addition of a top level reference.In case the given type T is not a reference type, the AddReference type trait adds a top level reference to the given type T. Else the resulting type Type is T. ">AddReference</a> type trait adds a top level reference to the given type <em>T</em>. Else the resulting type <em>Type</em> is <em>T</em>.  <a href="../../dd/d30/structblaze_1_1AddReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d18/structblaze_1_1AddTrait.html">AddTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class.  <a href="../../db/d18/structblaze_1_1AddTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html">AddVolatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level 'volatile' qualifier.The <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html" title="Addition of a top level &#39;volatile&#39; qualifier.The AddVolatile type trait adds a top level &#39;volatile&#39; q...">AddVolatile</a> type trait adds a top level 'volatile' qualifier to the given type <em>T</em>.  <a href="../../d2/df0/structblaze_1_1AddVolatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html">AlignedAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator for type-specific aligned memory.The <a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html" title="Allocator for type-specific aligned memory.The AlignedAllocator class template represents an implemen...">AlignedAllocator</a> class template represents an implementation of the allocator concept of the standard library for the allocation of type-specific, aligned, uninitialized memory. The allocator performs its allocation via the <a class="el" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698" title="Aligned array allocation for built-in data types. ">blaze::allocate()</a> and <a class="el" href="../../d4/d3a/group__util.html#gacba35bf708a4ea62cdca2a4a18a24c4b" title="Deallocation of memory for built-in data types. ">blaze::deallocate()</a> functions to guarantee properly aligned memory based on the alignment restrictions of the specified type <em>Type</em>. For instance, in case the given type is a fundamental, built-in data type and in case SSE vectorization is possible, the returned memory is guaranteed to be at least 16-byte aligned. In case AVX is active, the memory is even guaranteed to be at least 32-byte aligned.  <a href="../../d0/d6f/classblaze_1_1AlignedAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d25/classblaze_1_1AlignedArray.html">AlignedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a static array with a fixed alignment.The <a class="el" href="../../d3/d25/classblaze_1_1AlignedArray.html" title="Implementation of a static array with a fixed alignment.The AlignedArray class template represents a ...">AlignedArray</a> class template represents a static array with a guaranteed, fixed alignment. The type of the array elements, the number of elements and the alignment of the array can be specified via the three template parameters:  <a href="../../d3/d25/classblaze_1_1AlignedArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/structblaze_1_1AlignmentOf.html">AlignmentOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the required alignment of the given data type.The <a class="el" href="../../d5/dc6/structblaze_1_1AlignmentOf.html" title="Evaluation of the required alignment of the given data type.The AlignmentOf type trait template evalu...">AlignmentOf</a> type trait template evaluates the required alignment for the given data type. For instance, for fundamental data types that can be vectorized via SSE or AVX instructions, the proper alignment is 16 or 32 bytes, respectively. For all other data types, a multiple of the alignment chosen by the compiler is returned. The evaluated alignment can be queried via the nested <em>value</em> member.  <a href="../../d5/dc6/structblaze_1_1AlignmentOf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/de6/structblaze_1_1All.html">All</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This type trait determines whether the given type trait <em>TypeTrait</em> evaluates to <em>true</em> for all given types <em>Ts</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the expression.  <a href="../../d9/de6/structblaze_1_1All.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time logical and evaluation.The <a class="el" href="../../d7/d97/structblaze_1_1And.html" title="Compile time logical and evaluation.The And class template performs at compile time a logical and (&#39;&amp;&amp;&amp;#3...">And</a> class template performs at compile time a logical and ('&amp;&amp;') evaluation of at least two compile time conditions:  <a href="../../d7/d97/structblaze_1_1And.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dfd/structblaze_1_1Any.html">Any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This type trait determines whether the given type trait <em>TypeTrait</em> evaluates to <em>true</em> for at least one of the given types <em>Ts</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the expression.  <a href="../../d9/dfd/structblaze_1_1Any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d8d/structblaze_1_1Append.html">Append</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appending a type to a type list.The <a class="el" href="../../d3/d8d/structblaze_1_1Append.html" title="Appending a type to a type list.The Append class can be used to append the data type Type to a type l...">Append</a> class can be used to append the data type <em>Type</em> to a type list <em>TList</em>. In order to append a data type, the <a class="el" href="../../d3/d8d/structblaze_1_1Append.html" title="Appending a type to a type list.The Append class can be used to append the data type Type to a type l...">Append</a> class has to be instantiated for a particular type list and another type. The following example gives an impression of the use of the <a class="el" href="../../d3/d8d/structblaze_1_1Append.html" title="Appending a type to a type list.The Append class can be used to append the data type Type to a type l...">Append</a> class:  <a href="../../d3/d8d/structblaze_1_1Append.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d14/classblaze_1_1Archive.html">Archive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary archive for the portable serialization of data.The <a class="el" href="../../dd/d14/classblaze_1_1Archive.html" title="Binary archive for the portable serialization of data.The Archive class implements the functionality ...">Archive</a> class implements the functionality to create platform independent, portable, representations of arbitrary C++ data structures. The resulting binary data structures can be used to reconstitute the data structures in a different context, on another platform, etc.  <a href="../../dd/d14/classblaze_1_1Archive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d60/structblaze_1_1ArrayDelete.html">ArrayDelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array-delete policy class.The <a class="el" href="../../d0/d60/structblaze_1_1ArrayDelete.html" title="Array-delete policy class.The ArrayDelete policy functor class applies an array delete operation to t...">ArrayDelete</a> policy functor class applies an array delete operation to the given argument. Note that the array delete operation is NOT permitted for inclomplete types (i.e. declared but undefined data types). The attempt to apply an <a class="el" href="../../d0/d60/structblaze_1_1ArrayDelete.html" title="Array-delete policy class.The ArrayDelete policy functor class applies an array delete operation to t...">ArrayDelete</a> functor to a pointer to an array of objects of incomplete type results in a compile time error!  <a href="../../d0/d60/structblaze_1_1ArrayDelete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dde/structblaze_1_1Asin.html">Asin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gab4eed6b2d7c8e03d3ba69de01a1e54ff" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a> function.  <a href="../../d3/dde/structblaze_1_1Asin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d08/structblaze_1_1Asinh.html">Asinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga974e5ff97f8d4c431684ca167bf5be3b" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a> function.  <a href="../../d0/d08/structblaze_1_1Asinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dfc/structblaze_1_1Atan.html">Atan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gab63e8615abfd73eea11c190846d8f14b" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a> function.  <a href="../../d4/dfc/structblaze_1_1Atan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d4d/structblaze_1_1Atanh.html">Atanh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gaf39e95469abfd502a43219461590266a" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a> function.  <a href="../../de/d4d/structblaze_1_1Atanh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da0/structblaze_1_1Bool.html">Bool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time integral constant wrapper for <em>bool</em>.The <a class="el" href="../../da/da0/structblaze_1_1Bool.html" title="Compile time integral constant wrapper for bool.The Bool class template represents an integral wrappe...">Bool</a> class template represents an integral wrapper for a compile time constant expression of type <em>bool</em>. The value of a <a class="el" href="../../da/da0/structblaze_1_1Bool.html" title="Compile time integral constant wrapper for bool.The Bool class template represents an integral wrappe...">Bool</a> can be accessed via the nested <em>value</em> (which is guaranteed to be of type <em>bool</em>), the type can be accessed via the nested type definition <em>ValueType</em>.  <a href="../../da/da0/structblaze_1_1Bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d4c/structblaze_1_1Cbrt.html">Cbrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a> function.  <a href="../../d6/d4c/structblaze_1_1Cbrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9f/structblaze_1_1Ceil.html">Ceil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a> function.  <a href="../../da/d9f/structblaze_1_1Ceil.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d42/structblaze_1_1Char.html">Char</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time integral constant wrapper for <em>char</em>.The <a class="el" href="../../d1/d42/structblaze_1_1Char.html" title="Compile time integral constant wrapper for char.The Char class template represents an integral wrappe...">Char</a> class template represents an integral wrapper for a compile time constant expression of type <em>char</em>. The value of an <a class="el" href="../../d1/d42/structblaze_1_1Char.html" title="Compile time integral constant wrapper for char.The Char class template represents an integral wrappe...">Char</a> can be accessed via the nested <em>value</em> (which is guaranteed to be of type <em>char</em>), the type can be accessed via the nested type definition <em>ValueType</em>.  <a href="../../d1/d42/structblaze_1_1Char.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d15/structblaze_1_1Clamp.html">Clamp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gaed4231fbd9f5b6bf46307753b34f039c" title="Restricts each single element of the dense matrix dm to the range . ">clamp()</a> function.  <a href="../../da/d15/structblaze_1_1Clamp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d79/classblaze_1_1Column.html">Column</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a specific column of a dense or sparse matrix.The <a class="el" href="../../df/d79/classblaze_1_1Column.html" title="Reference to a specific column of a dense or sparse matrix.The Column template represents a reference...">Column</a> template represents a reference to a specific column of a dense or sparse matrix primitive. The type of the matrix is specified via the first template parameter:  <a href="../../df/d79/classblaze_1_1Column.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d61/structblaze_1_1ColumnExprTrait.html">ColumnExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type type of a column operation.Via this type trait it is possible to evaluate the return type of a column operation. Given the dense or sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting return type. In case the given type is neither a dense nor a sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d61/structblaze_1_1ColumnExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d84/structblaze_1_1Columns.html">Columns</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time evaluation of the number of columns of a matrix.The <a class="el" href="../../d5/d84/structblaze_1_1Columns.html" title="Compile time evaluation of the number of columns of a matrix.The Columns type trait evaluates the num...">Columns</a> type trait evaluates the number of columns of the given matrix type at compile time. In case the given type <em>T</em> is a matrix type with a fixed number of columns (e.g. <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a>), the <em>value</em> member constant is set to the according number of columns. In all other cases, <em>value</em> is set to 0.  <a href="../../d5/d84/structblaze_1_1Columns.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html">ColumnTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html" title="Base template for the ColumnTrait class. ">ColumnTrait</a> class.  <a href="../../d5/d7f/structblaze_1_1ColumnTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html">CommonType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction of a type common to several types.The <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html" title="Deduction of a type common to several types.The CommonType type trait deduces the result type of a mi...">CommonType</a> type trait deduces the result type of a mixed-mode arithmetic expression between all types T..., that is the type all T... can be implicitly converted to. Note that cv and reference qualifiers are generally ignored.  <a href="../../dd/d1c/structblaze_1_1CommonType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d1e/classblaze_1_1complex.html">complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex data type of the Blaze library.  <a href="../../d3/d1e/classblaze_1_1complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d8e/classblaze_1_1ComplexProxy.html">ComplexProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for complex types.The <a class="el" href="../../d3/d8e/classblaze_1_1ComplexProxy.html" title="Proxy backend for complex types.The ComplexProxy class serves as a backend for the Proxy class...">ComplexProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a complex number and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of complex numbers.  <a href="../../d3/d8e/classblaze_1_1ComplexProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of a <img class="formulaInl" alt="$ M \times N $" src="../../form_37.png"/> compressed matrix.The <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">CompressedMatrix</a> class template is the representation of an arbitrary sized sparse matrix with <img class="formulaInl" alt="$ M \cdot N $" src="../../form_164.png"/> dynamically allocated elements of arbitrary type. The type of the elements and the storage order of the matrix can be specified via the two template parameters:  <a href="../../da/d7a/classblaze_1_1CompressedMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of an arbitrary sized sparse vector.The <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">CompressedVector</a> class is the representation of an arbitrarily sized sparse vector, which stores only non-zero elements of arbitrary type. The type of the elements and the transpose flag of the vector can be specified via the two template parameters:  <a href="../../d5/d35/classblaze_1_1CompressedVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dd5/structblaze_1_1Computation.html">Computation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all compute expression templates.The <a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> class serves as a tag for all computational expression templates. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical computation (addition, subtraction, multiplication, division, absolute value calculation, ...) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as computational expression template. Only in case a class is derived from the <a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> base class, the <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html" title="Compile time check whether the given type is a computational expression template.This type trait clas...">IsComputation</a> type trait recognizes the class as valid computational expression template.  <a href="../../de/dd5/structblaze_1_1Computation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/ddf/structblaze_1_1Conj.html">Conj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga23b5c9bdbb7e7ea2c008808d235f7055" title="Returns a matrix containing the complex conjugate of each single element of dm. ">conj()</a> function.  <a href="../../db/ddf/structblaze_1_1Conj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d70/structblaze_1_1ConstantGrowth.html">ConstantGrowth</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant growth policy class.The <a class="el" href="../../d3/d70/structblaze_1_1ConstantGrowth.html" title="Constant growth policy class.The ConstantGrowth policy class implements a constant growth strategy...">ConstantGrowth</a> policy class implements a constant growth strategy. It can be customized for any purpose: the <em>Growth</em> template argument specifies the constant increase of the given size.  <a href="../../d3/d70/structblaze_1_1ConstantGrowth.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d5b/structblaze_1_1Contains.html">Contains</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searching a type list.The <a class="el" href="../../d5/d5b/structblaze_1_1Contains.html" title="Searching a type list.The Contains class can be used to search the type list for a particular type Ty...">Contains</a> class can be used to search the type list for a particular type <em>Type</em>. In contrast to the <a class="el" href="../../dd/d08/structblaze_1_1IndexOf.html" title="Searching a type list.The IndexOf class can be used to search the type list for a particular type Typ...">IndexOf</a> class, the <a class="el" href="../../d5/d5b/structblaze_1_1Contains.html" title="Searching a type list.The Contains class can be used to search the type list for a particular type Ty...">Contains</a> class does not evaluate the index of the type but only checks whether or not the type is contained in the type list. Additionally, in contrast to the <a class="el" href="../../d2/d9b/structblaze_1_1ContainsRelated.html" title="Searching a type list.The ContainsRelated class can be used to search the type list for a type relate...">ContainsRelated</a> class, the <a class="el" href="../../d5/d5b/structblaze_1_1Contains.html" title="Searching a type list.The Contains class can be used to search the type list for a particular type Ty...">Contains</a> class strictly searches for the given type <em>Type</em> and not for a related data type. In case the type is contained in the type list, the <em>value</em> member enumeration is set to 1, else it is set to 0. In order to check whether a type is part of a type list, the <a class="el" href="../../d5/d5b/structblaze_1_1Contains.html" title="Searching a type list.The Contains class can be used to search the type list for a particular type Ty...">Contains</a> class has to be instantiated for a particular type list and another type. The following example gives an impression of the use of the <a class="el" href="../../d5/d5b/structblaze_1_1Contains.html" title="Searching a type list.The Contains class can be used to search the type list for a particular type Ty...">Contains</a> class:  <a href="../../d5/d5b/structblaze_1_1Contains.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d9b/structblaze_1_1ContainsRelated.html">ContainsRelated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searching a type list.The <a class="el" href="../../d2/d9b/structblaze_1_1ContainsRelated.html" title="Searching a type list.The ContainsRelated class can be used to search the type list for a type relate...">ContainsRelated</a> class can be used to search the type list for a type related to <em>Type</em>. In contrast to the <a class="el" href="../../d5/d5b/structblaze_1_1Contains.html" title="Searching a type list.The Contains class can be used to search the type list for a particular type Ty...">Contains</a> class, the <a class="el" href="../../d2/d9b/structblaze_1_1ContainsRelated.html" title="Searching a type list.The ContainsRelated class can be used to search the type list for a type relate...">ContainsRelated</a> class only searches for a type the given data type <em>Type</em> can be converted to. In case a related type is found in the type list, the <em>value</em> member enumeration is set to 1, else it is set to 0. In order to check whether a related type is contained in the type list, the <a class="el" href="../../d2/d9b/structblaze_1_1ContainsRelated.html" title="Searching a type list.The ContainsRelated class can be used to search the type list for a type relate...">ContainsRelated</a> class has to be instantiated for a particular type list and another type. The following example gives an impression of the use of the <a class="el" href="../../d2/d9b/structblaze_1_1ContainsRelated.html" title="Searching a type list.The ContainsRelated class can be used to search the type list for a type relate...">ContainsRelated</a> class:  <a href="../../d2/d9b/structblaze_1_1ContainsRelated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0a/structblaze_1_1Cos.html">Cos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga6179f49533c111d0c1ed6b9181aabbe7" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a> function.  <a href="../../df/d0a/structblaze_1_1Cos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db2/structblaze_1_1Cosh.html">Cosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga3cb0cfa3ce6e0ca00ef6edf910149858" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a> function.  <a href="../../de/db2/structblaze_1_1Cosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc0/structblaze_1_1CrossExpr.html">CrossExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all cross product expression templates.The <a class="el" href="../../dc/dc0/structblaze_1_1CrossExpr.html" title="Base class for all cross product expression templates.The CrossExpr class serves as a tag for all exp...">CrossExpr</a> class serves as a tag for all expression templates that implement mathematical cross products. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical cross product and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as cross product expression template. Only in case a class is derived from the <a class="el" href="../../dc/dc0/structblaze_1_1CrossExpr.html" title="Base class for all cross product expression templates.The CrossExpr class serves as a tag for all exp...">CrossExpr</a> base class, the <a class="el" href="../../dc/d43/structblaze_1_1IsCrossExpr.html" title="Compile time check whether the given type is a cross product expression template.This type trait clas...">IsCrossExpr</a> type trait recognizes the class as valid cross product expression template.  <a href="../../dc/dc0/structblaze_1_1CrossExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d57/structblaze_1_1CrossExprTrait.html">CrossExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a cross product expression.Via this type trait it is possible to evaluate the return type of a cross product expression. Given the two types <em>T1</em> and <em>T2</em>, which must be dense or sparse column vectors, the nested type <em>Type</em> corresponds to the resulting return type. In case the types of <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be used in a cross product, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d57/structblaze_1_1CrossExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html">CrossTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class.  <a href="../../d4/d9c/structblaze_1_1CrossTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dee/structblaze_1_1CTrans.html">CTrans</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga48020f64de98036286379dacfa444750" title="Returns the conjugate transpose matrix of dm. ">ctrans()</a> function.  <a href="../../d4/dee/structblaze_1_1CTrans.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d23/structblaze_1_1CTransExprTrait.html">CTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a conjugate transpose expression.Via this type trait it is possible to evaluate the return type of a conjugate transpose expression. Given the type <em>T</em>, which must either be a vector or matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no conjugate transpose operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d23/structblaze_1_1CTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of a customizable matrix.The <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a> class template provides the functionality to represent an external array of elements of arbitrary type and a fixed size as a native <b>Blaze</b> dense matrix data structure. Thus in contrast to all other dense matrix types a custom matrix does not perform any kind of memory allocation by itself, but it is provided with an existing array of element during construction. A custom matrix can therefore be considered an alias to the existing array.  <a href="../../de/d43/classblaze_1_1CustomMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of a customizable vector.  <a href="../../de/d32/classblaze_1_1CustomVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc0/structblaze_1_1Deallocate.html">Deallocate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../db/dc0/structblaze_1_1Deallocate.html" title="Deallocate policy class.The Deallocate deletion policy is the according deletion policy for arrays al...">Deallocate</a> policy class.The <a class="el" href="../../db/dc0/structblaze_1_1Deallocate.html" title="Deallocate policy class.The Deallocate deletion policy is the according deletion policy for arrays al...">Deallocate</a> deletion policy is the according deletion policy for arrays allocated via the <a class="el" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698" title="Aligned array allocation for built-in data types. ">blaze::allocate</a> function. It uses deallocate to free the resource. Note that the delete operation is NOT permitted for inclomplete types (i.e. declared but undefined data types). The attempt to apply a <a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html" title="Pointer-delete policy class.The PtrDelete policy functor class applies a delete operation to the give...">PtrDelete</a> functor to a pointer to an object of incomplete type results in a compile time error!  <a href="../../db/dc0/structblaze_1_1Deallocate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbe/structblaze_1_1Decay.html">Decay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the type conversions for by-value function arguments.This type trait applies the type conversions that are used for by-value function arguments. This conversions include lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type <code>T</code>, and the removal of top level cv-qualifiers.  <a href="../../df/dbe/structblaze_1_1Decay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2a/structblaze_1_1DeclDiag.html">DeclDiag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga69a9b7ca9d7f7eb53ed37ddd2ee43874" title="Declares the given non-diagonal dense matrix expression dm as diagonal. ">decldiag()</a> function.  <a href="../../d6/d2a/structblaze_1_1DeclDiag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d42/structblaze_1_1DeclDiagExpr.html">DeclDiagExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all decldiag expression templates.The <a class="el" href="../../dd/d42/structblaze_1_1DeclDiagExpr.html" title="Base class for all decldiag expression templates.The DeclDiagExpr class serves as a tag for all expre...">DeclDiagExpr</a> class serves as a tag for all expression templates that represent an explicit diagonal declaration (decldiag) operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a decldiag operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as decldiag expression template. Only in case a class is derived from the <a class="el" href="../../dd/d42/structblaze_1_1DeclDiagExpr.html" title="Base class for all decldiag expression templates.The DeclDiagExpr class serves as a tag for all expre...">DeclDiagExpr</a> base class, the <a class="el" href="../../d5/d3b/structblaze_1_1IsDeclDiagExpr.html" title="Compile time check whether the given type is a decldiag expression template.This type trait class tes...">IsDeclDiagExpr</a> type trait recognizes the class as valid decldiag expression template.  <a href="../../dd/d42/structblaze_1_1DeclDiagExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5f/structblaze_1_1DeclDiagExprTrait.html">DeclDiagExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a diagonal declaration (decldiag) expression.Via this type trait it is possible to evaluate the return type of a diagonal declaration (decldiag) expression. Given the type <em>T</em>, which must be a matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no decldiag operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d5f/structblaze_1_1DeclDiagExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d56/structblaze_1_1DeclExpr.html">DeclExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix for-each expression templates.The <a class="el" href="../../d5/d56/structblaze_1_1DeclExpr.html" title="Base class for all matrix for-each expression templates.The DeclExpr class serves as a tag for all ex...">DeclExpr</a> class serves as a tag for all expression templates that represent an explicit declaration operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a declaration operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as declaration expression template. Only in case a class is derived from the <a class="el" href="../../d5/d56/structblaze_1_1DeclExpr.html" title="Base class for all matrix for-each expression templates.The DeclExpr class serves as a tag for all ex...">DeclExpr</a> base class, the <a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html" title="Compile time check whether the given type is a declaration expression template.This type trait class ...">IsDeclExpr</a> type trait recognizes the class as valid declaration expression template.  <a href="../../d5/d56/structblaze_1_1DeclExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7d/structblaze_1_1DeclHerm.html">DeclHerm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga7d1c7499ea0f5524b537273a98f3c09c" title="Declares the given non-Hermitian dense matrix expression dm as Hermitian. ">declherm()</a> function.  <a href="../../dc/d7d/structblaze_1_1DeclHerm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc8/structblaze_1_1DeclHermExpr.html">DeclHermExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all declherm expression templates.The <a class="el" href="../../dc/dc8/structblaze_1_1DeclHermExpr.html" title="Base class for all declherm expression templates.The DeclHermExpr class serves as a tag for all expre...">DeclHermExpr</a> class serves as a tag for all expression templates that represent an explicit Hermitian declaration (declherm) operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a declherm operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as declherm expression template. Only in case a class is derived from the <a class="el" href="../../dc/dc8/structblaze_1_1DeclHermExpr.html" title="Base class for all declherm expression templates.The DeclHermExpr class serves as a tag for all expre...">DeclHermExpr</a> base class, the <a class="el" href="../../d7/d07/structblaze_1_1IsDeclHermExpr.html" title="Compile time check whether the given type is a declherm expression template.This type trait class tes...">IsDeclHermExpr</a> type trait recognizes the class as valid declherm expression template.  <a href="../../dc/dc8/structblaze_1_1DeclHermExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d38/structblaze_1_1DeclHermExprTrait.html">DeclHermExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of an Hermitian declaration (declherm) expression.Via this type trait it is possible to evaluate the return type of an Hermitian declaration (declherm) expression. Given the type <em>T</em>, which must be a matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no declherm operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d9/d38/structblaze_1_1DeclHermExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d1b/structblaze_1_1DeclLow.html">DeclLow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gab7f9f220af2ef0545f54ff4b5c34b139" title="Declares the given non-lower dense matrix expression dm as lower. ">decllow()</a> function.  <a href="../../dd/d1b/structblaze_1_1DeclLow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d14/structblaze_1_1DeclLowExpr.html">DeclLowExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all decllow expression templates.The <a class="el" href="../../d0/d14/structblaze_1_1DeclLowExpr.html" title="Base class for all decllow expression templates.The DeclLowExpr class serves as a tag for all express...">DeclLowExpr</a> class serves as a tag for all expression templates that represent an explicit lower declaration (decllow) operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a decllow operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as decllow expression template. Only in case a class is derived from the <a class="el" href="../../d0/d14/structblaze_1_1DeclLowExpr.html" title="Base class for all decllow expression templates.The DeclLowExpr class serves as a tag for all express...">DeclLowExpr</a> base class, the <a class="el" href="../../d8/d9e/structblaze_1_1IsDeclLowExpr.html" title="Compile time check whether the given type is a decllow expression template.This type trait class test...">IsDeclLowExpr</a> type trait recognizes the class as valid decllow expression template.  <a href="../../d0/d14/structblaze_1_1DeclLowExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d74/structblaze_1_1DeclLowExprTrait.html">DeclLowExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a lower declaration (decllow) expression.Via this type trait it is possible to evaluate the return type of a lower declaration (decllow) expression. Given the type <em>T</em>, which must be a matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no decllow operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d74/structblaze_1_1DeclLowExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dba/structblaze_1_1DeclSym.html">DeclSym</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga8e0db5d90417a72a963f8dcbf3e3b6a2" title="Declares the given non-symmetric dense matrix expression dm as symmetric. ">declsym()</a> function.  <a href="../../d2/dba/structblaze_1_1DeclSym.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/db3/structblaze_1_1DeclSymExpr.html">DeclSymExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all declsym expression templates.The <a class="el" href="../../d8/db3/structblaze_1_1DeclSymExpr.html" title="Base class for all declsym expression templates.The DeclSymExpr class serves as a tag for all express...">DeclSymExpr</a> class serves as a tag for all expression templates that represent an explicit symmetry declaration (declsym) operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a declsym operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as declsym expression template. Only in case a class is derived from the <a class="el" href="../../d8/db3/structblaze_1_1DeclSymExpr.html" title="Base class for all declsym expression templates.The DeclSymExpr class serves as a tag for all express...">DeclSymExpr</a> base class, the <a class="el" href="../../d6/d3d/structblaze_1_1IsDeclSymExpr.html" title="Compile time check whether the given type is a declsym expression template.This type trait class test...">IsDeclSymExpr</a> type trait recognizes the class as valid declsym expression template.  <a href="../../d8/db3/structblaze_1_1DeclSymExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/db6/structblaze_1_1DeclSymExprTrait.html">DeclSymExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a symmetry declaration (declsym) expression.Via this type trait it is possible to evaluate the return type of a symmetry declaration (declsym) expression. Given the type <em>T</em>, which must be a matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no declsym operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/db6/structblaze_1_1DeclSymExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d41/structblaze_1_1DeclUpp.html">DeclUpp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga8ebe177b75c6ea9edbd850b65591df1f" title="Declares the given non-upper dense matrix expression dm as upper. ">declupp()</a> function.  <a href="../../d8/d41/structblaze_1_1DeclUpp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dcc/structblaze_1_1DeclUppExpr.html">DeclUppExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all declupp expression templates.The <a class="el" href="../../d1/dcc/structblaze_1_1DeclUppExpr.html" title="Base class for all declupp expression templates.The DeclUppExpr class serves as a tag for all express...">DeclUppExpr</a> class serves as a tag for all expression templates that represent an explicit upper declaration (declupp) operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a declupp operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as declupp expression template. Only in case a class is derived from the <a class="el" href="../../d1/dcc/structblaze_1_1DeclUppExpr.html" title="Base class for all declupp expression templates.The DeclUppExpr class serves as a tag for all express...">DeclUppExpr</a> base class, the <a class="el" href="../../d9/dc0/structblaze_1_1IsDeclUppExpr.html" title="Compile time check whether the given type is a declupp expression template.This type trait class test...">IsDeclUppExpr</a> type trait recognizes the class as valid declupp expression template.  <a href="../../d1/dcc/structblaze_1_1DeclUppExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1f/structblaze_1_1DeclUppExprTrait.html">DeclUppExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a upper declaration (declupp) expression.Via this type trait it is possible to evaluate the return type of a upper declaration (declupp) expression. Given the type <em>T</em>, which must be a matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no declupp operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d1f/structblaze_1_1DeclUppExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df1/structblaze_1_1DefaultDelete.html">DefaultDelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default C++ deletion policy class.The <a class="el" href="../../d2/df1/structblaze_1_1DefaultDelete.html" title="Default C++ deletion policy class.The DefaultDelete deletion policy is the standard delete for resour...">DefaultDelete</a> deletion policy is the standard delete for resources allocated via the new operator. It uses delete or array delete (depending on the template argument) to free the resource:  <a href="../../d2/df1/structblaze_1_1DefaultDelete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d30/classblaze_1_1DefaultProxy.html">DefaultProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default proxy backend for built-in and alternate user-specific class types.The <a class="el" href="../../df/d30/classblaze_1_1DefaultProxy.html" title="Default proxy backend for built-in and alternate user-specific class types.The DefaultProxy class ser...">DefaultProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a built-in or alternate user-specific class type. This proxy does not augment the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by any additional interface.  <a href="../../df/d30/classblaze_1_1DefaultProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a generic iterator for dense vectors and matrices.The <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> represents a generic random-access iterator that can be used for dense vectors and specific rows/columns of dense matrices.  <a href="../../dc/de8/classblaze_1_1DenseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dense matrices.The <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html" title="Base class for dense matrices.The DenseMatrix class is a base class for all dense matrix classes...">DenseMatrix</a> class is a base class for all dense matrix classes. It provides an abstraction from the actual type of the dense matrix, but enables a conversion back to this type via the <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> base class.  <a href="../../d0/d89/structblaze_1_1DenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for dense matrix types.The <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html" title="Proxy backend for dense matrix types.The DenseMatrixProxy class serves as a backend for the Proxy cla...">DenseMatrixProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a dense matrix and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of dense matrices.  <a href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for N-dimensional dense vectors.The <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html" title="Base class for N-dimensional dense vectors.The DenseVector class is a base class for all arbitrarily ...">DenseVector</a> class is a base class for all arbitrarily sized (N-dimensional) dense vectors. It provides an abstraction from the actual type of the dense vector, but enables a conversion back to this type via the <a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> base class.  <a href="../../d1/db2/structblaze_1_1DenseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for dense vector types.The <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html" title="Proxy backend for dense vector types.The DenseVectorProxy class serves as a backend for the Proxy cla...">DenseVectorProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a dense vector and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of dense vectors.  <a href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d31/classblaze_1_1Dependency.html">Dependency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lifetime dependency on a singleton object.The <a class="el" href="../../d4/d31/classblaze_1_1Dependency.html" title="Lifetime dependency on a singleton object.The Dependency template class represents a lifetime depende...">Dependency</a> template class represents a lifetime dependency on a singleton object based on the Blaze <a class="el" href="../../d4/d8d/classblaze_1_1Singleton.html" title="Base class for all lifetime managed singletons.The Singleton class represents the base class for all ...">Singleton</a> functionality. By use of the <a class="el" href="../../d4/d31/classblaze_1_1Dependency.html" title="Lifetime dependency on a singleton object.The Dependency template class represents a lifetime depende...">Dependency</a> template, any class can by either public or non-public inheritance or composition define a single or multiple lifetime dependencies on one or several singletons, which guarantees that the singleton instance(s) will be destroyed after the dependent object. The following example demonstrates both the inheritance as well as the composition approach:  <a href="../../d4/d31/classblaze_1_1Dependency.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dc1/structblaze_1_1DerestrictTrait.html">DerestrictTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of the derestrict function.Via this type trait it is possible to evaluate the resulting return type of the derestrict function. Given the vector or matrix type <em>T</em>, the nested type <em>Type</em> corresponds to the resulting return type. In case <em>T</em> is neither a dense or sparse vector or matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d9/dc1/structblaze_1_1DerestrictTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3f/classblaze_1_1DiagonalMatrix.html">DiagonalMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> adapter for diagonal <img class="formulaInl" alt="$ N \times N $" src="../../form_18.png"/> matrices.  <a href="../../d9/d3f/classblaze_1_1DiagonalMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dec/classblaze_1_1DiagonalProxy.html">DiagonalProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for diagonal matrices.The <a class="el" href="../../dd/dec/classblaze_1_1DiagonalProxy.html" title="Access proxy for diagonal matrices.The DiagonalProxy provides controlled access to the elements of a ...">DiagonalProxy</a> provides controlled access to the elements of a non-const diagonal matrix. It guarantees that the diagonal matrix invariant is not violated, i.e. that elements in the lower and upper part of the matrix remain default values. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> dense diagonal matrix:  <a href="../../dd/dec/classblaze_1_1DiagonalProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not class template negates the given compile time condition. In case the given condition would evaluate to true, the nested member enumeration is set to false and vice versa: ">Not</a> An Error (SFINAE) class.The <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIf class template is an auxiliary tool...">DisableIf</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not class template negates the given compile time condition. In case the given condition would evaluate to true, the nested member enumeration is set to false and vice versa: ">Not</a> An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../d6/d36/structblaze_1_1DisableIf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html">DisableIfTrue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not class template negates the given compile time condition. In case the given condition would evaluate to true, the nested member enumeration is set to false and vice versa: ">Not</a> An Error (SFINAE) class.The <a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIfTrue class template is an auxiliary ...">DisableIfTrue</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not class template negates the given compile time condition. In case the given condition would evaluate to true, the nested member enumeration is set to false and vice versa: ">Not</a> An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../df/df2/structblaze_1_1DisableIfTrue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d46/structblaze_1_1DivExpr.html">DivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all division expression templates.The <a class="el" href="../../dd/d46/structblaze_1_1DivExpr.html" title="Base class for all division expression templates.The DivExpr class serves as a tag for all expression...">DivExpr</a> class serves as a tag for all expression templates that implement mathematical divisions. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical division (vector/scalar divisions and matrix/scalar division) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as division expression template. Only in case a class is derived from the <a class="el" href="../../dd/d46/structblaze_1_1DivExpr.html" title="Base class for all division expression templates.The DivExpr class serves as a tag for all expression...">DivExpr</a> base class, the <a class="el" href="../../d7/d13/structblaze_1_1IsDivExpr.html" title="Compile time check whether the given type is a division expression template.This type trait class tes...">IsDivExpr</a> type trait recognizes the class as valid division expression template.  <a href="../../dd/d46/structblaze_1_1DivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d73/structblaze_1_1DivExprTrait.html">DivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the resulting expression type of a division.Via this type trait it is possible to evaluate the return type of a division expression between scalars, vectors, and matrices. Given the two types <em>T1</em> and <em>T2</em>, where <em>T1</em> must either be a scalar, vector, or matrix type and <em>T2</em> which must be a scalar type, the nested type <em>Type</em> corresponds to the resulting return type. In case <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be divided, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d73/structblaze_1_1DivExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html">DivTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class. ">DivTrait</a> class.  <a href="../../d2/d67/structblaze_1_1DivTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d7f/structblaze_1_1DMatCTransExprTrait.html">DMatCTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix conjugate transpose operation. Given the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/d7f/structblaze_1_1DMatCTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dbe/classblaze_1_1DMatDeclDiagExpr.html">DMatDeclDiagExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the explicit diagonal declaration of dense matrices.The <a class="el" href="../../dc/dbe/classblaze_1_1DMatDeclDiagExpr.html" title="Expression object for the explicit diagonal declaration of dense matrices.The DMatDeclDiagExpr class ...">DMatDeclDiagExpr</a> class represents the compile time expression for the explicit diagonal declaration of a dense matrix.  <a href="../../dc/dbe/classblaze_1_1DMatDeclDiagExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcc/structblaze_1_1DMatDeclDiagExprTrait.html">DMatDeclDiagExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix decldiag operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix decldiag operation. Given the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d5/dcc/structblaze_1_1DMatDeclDiagExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/df9/classblaze_1_1DMatDeclHermExpr.html">DMatDeclHermExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the explicit Hermitian declaration of dense matrices.The <a class="el" href="../../db/df9/classblaze_1_1DMatDeclHermExpr.html" title="Expression object for the explicit Hermitian declaration of dense matrices.The DMatDeclHermExpr class...">DMatDeclHermExpr</a> class represents the compile time expression for the explicit Hermitian declaration of a dense matrix.  <a href="../../db/df9/classblaze_1_1DMatDeclHermExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d8e/structblaze_1_1DMatDeclHermExprTrait.html">DMatDeclHermExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix declherm operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix declherm operation. Given the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/d8e/structblaze_1_1DMatDeclHermExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d26/classblaze_1_1DMatDeclLowExpr.html">DMatDeclLowExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the explicit lower declaration of dense matrices.The <a class="el" href="../../d8/d26/classblaze_1_1DMatDeclLowExpr.html" title="Expression object for the explicit lower declaration of dense matrices.The DMatDeclLowExpr class repr...">DMatDeclLowExpr</a> class represents the compile time expression for the explicit lower declaration of a dense matrix.  <a href="../../d8/d26/classblaze_1_1DMatDeclLowExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d5c/structblaze_1_1DMatDeclLowExprTrait.html">DMatDeclLowExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix decllow operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix decllow operation. Given the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d5c/structblaze_1_1DMatDeclLowExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db7/classblaze_1_1DMatDeclSymExpr.html">DMatDeclSymExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the explicit symmetry declaration of dense matrices.The <a class="el" href="../../d2/db7/classblaze_1_1DMatDeclSymExpr.html" title="Expression object for the explicit symmetry declaration of dense matrices.The DMatDeclSymExpr class r...">DMatDeclSymExpr</a> class represents the compile time expression for the explicit symmetry declaration of a dense matrix.  <a href="../../d2/db7/classblaze_1_1DMatDeclSymExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d2a/structblaze_1_1DMatDeclSymExprTrait.html">DMatDeclSymExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix declsym operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix declsym operation. Given the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d2a/structblaze_1_1DMatDeclSymExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d58/classblaze_1_1DMatDeclUppExpr.html">DMatDeclUppExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the explicit upper declaration of dense matrices.The <a class="el" href="../../d5/d58/classblaze_1_1DMatDeclUppExpr.html" title="Expression object for the explicit upper declaration of dense matrices.The DMatDeclUppExpr class repr...">DMatDeclUppExpr</a> class represents the compile time expression for the explicit upper declaration of a dense matrix.  <a href="../../d5/d58/classblaze_1_1DMatDeclUppExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d21/structblaze_1_1DMatDeclUppExprTrait.html">DMatDeclUppExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix declupp operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix declupp operation. Given the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d21/structblaze_1_1DMatDeclUppExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d2d/classblaze_1_1DMatDMatAddExpr.html">DMatDMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-dense matrix additions.The <a class="el" href="../../d9/d2d/classblaze_1_1DMatDMatAddExpr.html" title="Expression object for dense matrix-dense matrix additions.The DMatDMatAddExpr class represents the co...">DMatDMatAddExpr</a> class represents the compile time expression for additions between dense matrices with identical storage order.  <a href="../../d9/d2d/classblaze_1_1DMatDMatAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/da5/structblaze_1_1DMatDMatAddExprTrait.html">DMatDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/dense matrix addition. Given the two row-major dense matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a row-major dense matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/da5/structblaze_1_1DMatDMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d40/classblaze_1_1DMatDMatMultExpr.html">DMatDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-dense matrix multiplications.The <a class="el" href="../../d3/d40/classblaze_1_1DMatDMatMultExpr.html" title="Expression object for dense matrix-dense matrix multiplications.The DMatDMatMultExpr class represents...">DMatDMatMultExpr</a> class represents the compile time expression for multiplications between row-major dense matrices.  <a href="../../d3/d40/classblaze_1_1DMatDMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/structblaze_1_1DMatDMatMultExprTrait.html">DMatDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/dense matrix multiplication. Given the two row-major dense matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a row-major dense matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/df1/structblaze_1_1DMatDMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/ddb/classblaze_1_1DMatDMatSubExpr.html">DMatDMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-dense matrix subtractions.The <a class="el" href="../../d9/ddb/classblaze_1_1DMatDMatSubExpr.html" title="Expression object for dense matrix-dense matrix subtractions.The DMatDMatSubExpr class represents the...">DMatDMatSubExpr</a> class represents the compile time expression for subtractions between dense matrices with identical storage order.  <a href="../../d9/ddb/classblaze_1_1DMatDMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d11/structblaze_1_1DMatDMatSubExprTrait.html">DMatDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/dense matrix subtraction. Given the two row-major dense matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a row-major dense matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d11/structblaze_1_1DMatDMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dce/classblaze_1_1DMatDVecMultExpr.html">DMatDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-dense vector multiplications.The <a class="el" href="../../df/dce/classblaze_1_1DMatDVecMultExpr.html" title="Expression object for dense matrix-dense vector multiplications.The DMatDVecMultExpr class represents...">DMatDVecMultExpr</a> class represents the compile time expression for multiplications between row-major dense matrices and dense vectors.  <a href="../../df/dce/classblaze_1_1DMatDVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d54/structblaze_1_1DMatDVecMultExprTrait.html">DMatDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/dense vector multiplication. Given the row-major dense matrix type <em>MT</em> and the non-transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major dense matrix type or <em>VT</em> is not a non-transpose dense vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d5/d54/structblaze_1_1DMatDVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classblaze_1_1DMatEvalExpr.html">DMatEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the forced evaluation of dense matrices.The <a class="el" href="../../db/d9a/classblaze_1_1DMatEvalExpr.html" title="Expression object for the forced evaluation of dense matrices.The DMatEvalExpr class represents the c...">DMatEvalExpr</a> class represents the compile time expression for the forced evaluation of a dense matrix.  <a href="../../db/d9a/classblaze_1_1DMatEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d85/structblaze_1_1DMatEvalExprTrait.html">DMatEvalExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix evaluation operation. Given the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d85/structblaze_1_1DMatEvalExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the dense matrix <a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a> function.The <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html" title="Expression object for the dense matrix forEach() function.The DMatForEachExpr class represents the co...">DMatForEachExpr</a> class represents the compile time expression for the evaluation of a custom operation on each element of a dense matrix via the <a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a> function.  <a href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da6/structblaze_1_1DMatForEachExprTrait.html">DMatForEachExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix custom operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix custom operation. Given the row-major dense matrix type <em>MT</em> and the custom operation type <em>OP</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/da6/structblaze_1_1DMatForEachExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d92/classblaze_1_1DMatInvExpr.html">DMatInvExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix inversions.The <a class="el" href="../../d3/d92/classblaze_1_1DMatInvExpr.html" title="Expression object for dense matrix inversions.The DMatInvExpr class represents the compile time expre...">DMatInvExpr</a> class represents the compile time expression for inversions of dense matrices.  <a href="../../d3/d92/classblaze_1_1DMatInvExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d45/structblaze_1_1DMatInvExprTrait.html">DMatInvExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix inversion operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix inversion operation. Given the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../da/d45/structblaze_1_1DMatInvExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/db1/classblaze_1_1DMatScalarDivExpr.html">DMatScalarDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for divisions of a dense matrix by a scalar.The <a class="el" href="../../db/db1/classblaze_1_1DMatScalarDivExpr.html" title="Expression object for divisions of a dense matrix by a scalar.The DMatScalarDivExpr class represents ...">DMatScalarDivExpr</a> class represents the compile time expression for divisions of dense matrices and by scalar values.  <a href="../../db/db1/classblaze_1_1DMatScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d25/structblaze_1_1DMatScalarDivExprTrait.html">DMatScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/scalar division. Given the row-major dense matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major dense matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d25/structblaze_1_1DMatScalarDivExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8b/classblaze_1_1DMatScalarMultExpr.html">DMatScalarMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-scalar multiplications.The <a class="el" href="../../d5/d8b/classblaze_1_1DMatScalarMultExpr.html" title="Expression object for dense matrix-scalar multiplications.The DMatScalarMultExpr class represents the...">DMatScalarMultExpr</a> class represents the compile time expression for multiplications between a dense matrix and a scalar value.  <a href="../../d5/d8b/classblaze_1_1DMatScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da4/structblaze_1_1DMatScalarMultExprTrait.html">DMatScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/scalar multiplication. Given the row-major dense matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major dense matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/da4/structblaze_1_1DMatScalarMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dec/classblaze_1_1DMatSerialExpr.html">DMatSerialExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the forced serial evaluation of dense matrices.The <a class="el" href="../../d9/dec/classblaze_1_1DMatSerialExpr.html" title="Expression object for the forced serial evaluation of dense matrices.The DMatSerialExpr class represe...">DMatSerialExpr</a> class represents the compile time expression for the forced serial evaluation of a dense matrix.  <a href="../../d9/dec/classblaze_1_1DMatSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/def/structblaze_1_1DMatSerialExprTrait.html">DMatSerialExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix serial evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix serial evaluation operation. Given the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/def/structblaze_1_1DMatSerialExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classblaze_1_1DMatSMatAddExpr.html">DMatSMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-sparse matrix additions.The <a class="el" href="../../df/d65/classblaze_1_1DMatSMatAddExpr.html" title="Expression object for dense matrix-sparse matrix additions.The DMatSMatAddExpr class represents the c...">DMatSMatAddExpr</a> class represents the compile time expression for additions between a dense matrix and a sparse matrix with identical storage order.  <a href="../../df/d65/classblaze_1_1DMatSMatAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dab/structblaze_1_1DMatSMatAddExprTrait.html">DMatSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/sparse matrix addition. Given the row-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../da/dab/structblaze_1_1DMatSMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d2b/classblaze_1_1DMatSMatMultExpr.html">DMatSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-sparse matrix multiplications.The <a class="el" href="../../d1/d2b/classblaze_1_1DMatSMatMultExpr.html" title="Expression object for dense matrix-sparse matrix multiplications.The DMatSMatMultExpr class represent...">DMatSMatMultExpr</a> class represents the compile time expression for multiplications between a row-major dense matrix and a row-major sparse matrix.  <a href="../../d1/d2b/classblaze_1_1DMatSMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d84/structblaze_1_1DMatSMatMultExprTrait.html">DMatSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/sparse matrix multiplication. Given the row-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d84/structblaze_1_1DMatSMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/deb/classblaze_1_1DMatSMatSubExpr.html">DMatSMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-sparse matrix subtractions.The <a class="el" href="../../d3/deb/classblaze_1_1DMatSMatSubExpr.html" title="Expression object for dense matrix-sparse matrix subtractions.The DMatSMatSubExpr class represents th...">DMatSMatSubExpr</a> class represents the compile time expression for subtractions between a dense matrix and a sparse matrix with identical storage order.  <a href="../../d3/deb/classblaze_1_1DMatSMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d07/structblaze_1_1DMatSMatSubExprTrait.html">DMatSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/sparse matrix subtraction. Given the row-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../da/d07/structblaze_1_1DMatSMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d34/classblaze_1_1DMatSVecMultExpr.html">DMatSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-sparse vector multiplications.The <a class="el" href="../../d7/d34/classblaze_1_1DMatSVecMultExpr.html" title="Expression object for dense matrix-sparse vector multiplications.The DMatSVecMultExpr class represent...">DMatSVecMultExpr</a> class represents the compile time expression for multiplications between row-major dense matrices and sparse vectors.  <a href="../../d7/d34/classblaze_1_1DMatSVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d42/structblaze_1_1DMatSVecMultExprTrait.html">DMatSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/sparse vector multiplication. Given the row-major dense matrix type <em>MT</em> and the non-transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major dense matrix type or <em>VT</em> is not a non-transpose sparse vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d42/structblaze_1_1DMatSVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbe/classblaze_1_1DMatTDMatAddExpr.html">DMatTDMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-transpose dense matrix additions.The <a class="el" href="../../df/dbe/classblaze_1_1DMatTDMatAddExpr.html" title="Expression object for dense matrix-transpose dense matrix additions.The DMatTDMatAddExpr class repres...">DMatTDMatAddExpr</a> class represents the compile time expression for additions between a row-major dense matrix and column-major dense matrix.  <a href="../../df/dbe/classblaze_1_1DMatTDMatAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da3/structblaze_1_1DMatTDMatAddExprTrait.html">DMatTDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/transpose dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose dense matrix addition. Given the row-major dense matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/da3/structblaze_1_1DMatTDMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d8a/classblaze_1_1DMatTDMatMultExpr.html">DMatTDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-transpose dense matrix multiplications.The <a class="el" href="../../d3/d8a/classblaze_1_1DMatTDMatMultExpr.html" title="Expression object for dense matrix-transpose dense matrix multiplications.The DMatTDMatMultExpr class...">DMatTDMatMultExpr</a> class represents the compile time expression for multiplications between a row-major dense matrix and a column-major dense matrix.  <a href="../../d3/d8a/classblaze_1_1DMatTDMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3c/structblaze_1_1DMatTDMatMultExprTrait.html">DMatTDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose dense matrix multiplication. Given the row-major dense matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d3c/structblaze_1_1DMatTDMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d16/classblaze_1_1DMatTDMatSubExpr.html">DMatTDMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-transpose dense matrix subtractions.The <a class="el" href="../../d8/d16/classblaze_1_1DMatTDMatSubExpr.html" title="Expression object for dense matrix-transpose dense matrix subtractions.The DMatTDMatSubExpr class rep...">DMatTDMatSubExpr</a> class represents the compile time expression for subtractions between a row-major dense matrix and a column-major dense matrix.  <a href="../../d8/d16/classblaze_1_1DMatTDMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d21/structblaze_1_1DMatTDMatSubExprTrait.html">DMatTDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/transpose dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose dense matrix subtraction. Given the row-major dense matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d21/structblaze_1_1DMatTDMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d86/classblaze_1_1DMatTransExpr.html">DMatTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix transpositions.The <a class="el" href="../../d1/d86/classblaze_1_1DMatTransExpr.html" title="Expression object for dense matrix transpositions.The DMatTransExpr class represents the compile time...">DMatTransExpr</a> class represents the compile time expression for transpositions of dense matrices.  <a href="../../d1/d86/classblaze_1_1DMatTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d81/structblaze_1_1DMatTransExprTrait.html">DMatTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix transpose operation. Given the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d81/structblaze_1_1DMatTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d12/classblaze_1_1DMatTransposer.html">DMatTransposer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the transposition of a dense matrix.The <a class="el" href="../../d9/d12/classblaze_1_1DMatTransposer.html" title="Expression object for the transposition of a dense matrix.The DMatTransposer class is a wrapper objec...">DMatTransposer</a> class is a wrapper object for the temporary transposition of a dense matrix.  <a href="../../d9/d12/classblaze_1_1DMatTransposer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d61/classblaze_1_1DMatTSMatAddExpr.html">DMatTSMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-sparse matrix additions.The <a class="el" href="../../df/d61/classblaze_1_1DMatTSMatAddExpr.html" title="Expression object for dense matrix-sparse matrix additions.The DMatTSMatAddExpr class represents the ...">DMatTSMatAddExpr</a> class represents the compile time expression for additions between a row-major dense matrix and a column-major sparse matrix.  <a href="../../df/d61/classblaze_1_1DMatTSMatAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc3/structblaze_1_1DMatTSMatAddExprTrait.html">DMatTSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/transpose sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose sparse matrix addition. Given the row-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/dc3/structblaze_1_1DMatTSMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/ddc/classblaze_1_1DMatTSMatMultExpr.html">DMatTSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-transpose sparse matrix multiplications.The <a class="el" href="../../d5/ddc/classblaze_1_1DMatTSMatMultExpr.html" title="Expression object for dense matrix-transpose sparse matrix multiplications.The DMatTSMatMultExpr clas...">DMatTSMatMultExpr</a> class represents the compile time expression for multiplications between a row-major dense matrix and a column-major sparse matrix.  <a href="../../d5/ddc/classblaze_1_1DMatTSMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d14/structblaze_1_1DMatTSMatMultExprTrait.html">DMatTSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/ transpose sparse matrix multiplication. Given the row-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d14/structblaze_1_1DMatTSMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d76/classblaze_1_1DMatTSMatSubExpr.html">DMatTSMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-transpose sparse matrix subtractions.The <a class="el" href="../../d1/d76/classblaze_1_1DMatTSMatSubExpr.html" title="Expression object for dense matrix-transpose sparse matrix subtractions.The DMatTSMatSubExpr class re...">DMatTSMatSubExpr</a> class represents the compile time expression for subtractions between a row-major dense matrix and a column-major sparse matrix.  <a href="../../d1/d76/classblaze_1_1DMatTSMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc2/structblaze_1_1DMatTSMatSubExprTrait.html">DMatTSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/transpose sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/ transpose sparse matrix subtraction. Given the row-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/dc2/structblaze_1_1DMatTSMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d31/structblaze_1_1DVecCTransExprTrait.html">DVecCTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector conjugate transpose operation. Given the non-transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d31/structblaze_1_1DVecCTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc4/classblaze_1_1DVecDVecAddExpr.html">DVecDVecAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-dense vector additions.The <a class="el" href="../../db/dc4/classblaze_1_1DVecDVecAddExpr.html" title="Expression object for dense vector-dense vector additions.The DVecDVecAddExpr class represents the co...">DVecDVecAddExpr</a> class represents the compile time expression for additions between dense vectors.  <a href="../../db/dc4/classblaze_1_1DVecDVecAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/structblaze_1_1DVecDVecAddExprTrait.html">DVecDVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/dense vector addition.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/dense vector addition. Given the two non-transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d17/structblaze_1_1DVecDVecAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/da6/classblaze_1_1DVecDVecCrossExpr.html">DVecDVecCrossExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-dense vector cross products.The <a class="el" href="../../d5/da6/classblaze_1_1DVecDVecCrossExpr.html" title="Expression object for dense vector-dense vector cross products.The DVecDVecCrossExpr class represents...">DVecDVecCrossExpr</a> class represents the compile time expression for cross products between dense vectors.  <a href="../../d5/da6/classblaze_1_1DVecDVecCrossExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d42/structblaze_1_1DVecDVecCrossExprTrait.html">DVecDVecCrossExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/dense vector cross product.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/dense vector cross product. Given the two non-transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/d42/structblaze_1_1DVecDVecCrossExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d77/classblaze_1_1DVecDVecDivExpr.html">DVecDVecDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-dense vector divisions.The <a class="el" href="../../df/d77/classblaze_1_1DVecDVecDivExpr.html" title="Expression object for dense vector-dense vector divisions.The DVecDVecDivExpr class represents the co...">DVecDVecDivExpr</a> class represents the compile time expression for componentwise divisions between dense vectors.  <a href="../../df/d77/classblaze_1_1DVecDVecDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d6d/structblaze_1_1DVecDVecDivExprTrait.html">DVecDVecDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/dense vector division.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/dense vector division. Given the two non-transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d5/d6d/structblaze_1_1DVecDVecDivExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d76/classblaze_1_1DVecDVecMultExpr.html">DVecDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-dense vector multiplications.The <a class="el" href="../../d0/d76/classblaze_1_1DVecDVecMultExpr.html" title="Expression object for dense vector-dense vector multiplications.The DVecDVecMultExpr class represents...">DVecDVecMultExpr</a> class represents the compile time expression for componentwise multiplications between dense vectors.  <a href="../../d0/d76/classblaze_1_1DVecDVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d9b/structblaze_1_1DVecDVecMultExprTrait.html">DVecDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/dense vector multiplication. Given the two non-transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d9/d9b/structblaze_1_1DVecDVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d79/classblaze_1_1DVecDVecSubExpr.html">DVecDVecSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-dense vector subtractions.The <a class="el" href="../../de/d79/classblaze_1_1DVecDVecSubExpr.html" title="Expression object for dense vector-dense vector subtractions.The DVecDVecSubExpr class represents the...">DVecDVecSubExpr</a> class represents the compile time expression for subtractions between dense vectors.  <a href="../../de/d79/classblaze_1_1DVecDVecSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d0f/structblaze_1_1DVecDVecSubExprTrait.html">DVecDVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/dense vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/dense vector subtraction. Given the two non-transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/d0f/structblaze_1_1DVecDVecSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d94/classblaze_1_1DVecEvalExpr.html">DVecEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the forced evaluation of dense vectors.The <a class="el" href="../../d2/d94/classblaze_1_1DVecEvalExpr.html" title="Expression object for the forced evaluation of dense vectors.The DVecEvalExpr class represents the co...">DVecEvalExpr</a> class represents the compile time expression for the forced evaluation of a dense vector.  <a href="../../d2/d94/classblaze_1_1DVecEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d58/structblaze_1_1DVecEvalExprTrait.html">DVecEvalExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector evaluation operation. Given the non-transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d58/structblaze_1_1DVecEvalExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the dense vector <a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a> function.The <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html" title="Expression object for the dense vector forEach() function.The DVecForEachExpr class represents the co...">DVecForEachExpr</a> class represents the compile time expression for the evaluation of a custom operation on each element of a dense vector via the <a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a> function.  <a href="../../d5/d92/classblaze_1_1DVecForEachExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/db7/structblaze_1_1DVecForEachExprTrait.html">DVecForEachExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector custom operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector custom operation. Given the non-transpose dense vector type <em>VT</em> and the custom operation type <em>OP</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/db7/structblaze_1_1DVecForEachExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db9/classblaze_1_1DVecScalarDivExpr.html">DVecScalarDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for divisions of a dense vector by a scalar.The <a class="el" href="../../d5/db9/classblaze_1_1DVecScalarDivExpr.html" title="Expression object for divisions of a dense vector by a scalar.The DVecScalarDivExpr class represents ...">DVecScalarDivExpr</a> class represents the compile time expression for divisions of dense vectors by scalar values.  <a href="../../d5/db9/classblaze_1_1DVecScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dfb/structblaze_1_1DVecScalarDivExprTrait.html">DVecScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/scalar division. Given the non-transpose dense vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a non-transpose dense vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/dfb/structblaze_1_1DVecScalarDivExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de8/classblaze_1_1DVecScalarMultExpr.html">DVecScalarMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-scalar multiplications.The <a class="el" href="../../df/de8/classblaze_1_1DVecScalarMultExpr.html" title="Expression object for dense vector-scalar multiplications.The DVecScalarMultExpr class represents the...">DVecScalarMultExpr</a> class represents the compile time expression for multiplications between a dense vector and a scalar value.  <a href="../../df/de8/classblaze_1_1DVecScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d2e/structblaze_1_1DVecScalarMultExprTrait.html">DVecScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/scalar multiplication. Given the non-transpose dense vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a non-transpose dense vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/d2e/structblaze_1_1DVecScalarMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc4/classblaze_1_1DVecSerialExpr.html">DVecSerialExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the forced serial evaluation of dense vectors.The <a class="el" href="../../d0/dc4/classblaze_1_1DVecSerialExpr.html" title="Expression object for the forced serial evaluation of dense vectors.The DVecSerialExpr class represen...">DVecSerialExpr</a> class represents the compile time expression for the forced serial evaluation of a dense vector.  <a href="../../d0/dc4/classblaze_1_1DVecSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc9/structblaze_1_1DVecSerialExprTrait.html">DVecSerialExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector serial evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector serial evaluation operation. Given the non-transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/dc9/structblaze_1_1DVecSerialExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d67/classblaze_1_1DVecSVecAddExpr.html">DVecSVecAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-sparse vector additions.The <a class="el" href="../../d0/d67/classblaze_1_1DVecSVecAddExpr.html" title="Expression object for dense vector-sparse vector additions.The DVecSVecAddExpr class represents the c...">DVecSVecAddExpr</a> class represents the compile time expression for additions between a dense vector and a sparse vector.  <a href="../../d0/d67/classblaze_1_1DVecSVecAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d85/structblaze_1_1DVecSVecAddExprTrait.html">DVecSVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/sparse vector addition.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/sparse vector addition. Given the non-transpose dense vector type <em>VT1</em> and the non-transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose dense vector type or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/d85/structblaze_1_1DVecSVecAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da6/classblaze_1_1DVecSVecCrossExpr.html">DVecSVecCrossExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-sparse vector cross products.The <a class="el" href="../../dd/da6/classblaze_1_1DVecSVecCrossExpr.html" title="Expression object for dense vector-sparse vector cross products.The DVecSVecCrossExpr class represent...">DVecSVecCrossExpr</a> class represents the compile time expression for cross products between a dense vector and a sparse vector.  <a href="../../dd/da6/classblaze_1_1DVecSVecCrossExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d5e/structblaze_1_1DVecSVecCrossExprTrait.html">DVecSVecCrossExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/sparse vector cross product.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/sparse vector cross product. Given the non-transpose dense vector type <em>VT1</em> and the non-transpose sparse vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose dense vector type or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d5e/structblaze_1_1DVecSVecCrossExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dd2/classblaze_1_1DVecSVecMultExpr.html">DVecSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-sparse vector multiplications.The <a class="el" href="../../de/dd2/classblaze_1_1DVecSVecMultExpr.html" title="Expression object for dense vector-sparse vector multiplications.The DVecSVecMultExpr class represent...">DVecSVecMultExpr</a> class represents the compile time expression for componentwise multiplications between a dense vector and a sparse vector.  <a href="../../de/dd2/classblaze_1_1DVecSVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dad/structblaze_1_1DVecSVecMultExprTrait.html">DVecSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/sparse vector multiplication. Given the non-transpose dense vector type <em>VT1</em> and the non-transpose sparse vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose dense vector type or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/dad/structblaze_1_1DVecSVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de0/classblaze_1_1DVecSVecSubExpr.html">DVecSVecSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-sparse vector subtractions.The <a class="el" href="../../df/de0/classblaze_1_1DVecSVecSubExpr.html" title="Expression object for dense vector-sparse vector subtractions.The DVecSVecSubExpr class represents th...">DVecSVecSubExpr</a> class represents the compile time expression for subtractions between a dense vector and a sparse vector.  <a href="../../df/de0/classblaze_1_1DVecSVecSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d38/structblaze_1_1DVecSVecSubExprTrait.html">DVecSVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/sparse vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/sparse vector subtraction. Given the non-transpose dense vector type <em>VT1</em> and the non-transpose sparse vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose dense vector type or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d5/d38/structblaze_1_1DVecSVecSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dcd/classblaze_1_1DVecTDVecMultExpr.html">DVecTDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for outer products between two dense vectors.The <a class="el" href="../../d1/dcd/classblaze_1_1DVecTDVecMultExpr.html" title="Expression object for outer products between two dense vectors.The DVecTDVecMultExpr class represents...">DVecTDVecMultExpr</a> class represents the compile time expression for outer products between dense vectors.  <a href="../../d1/dcd/classblaze_1_1DVecTDVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d92/structblaze_1_1DVecTDVecMultExprTrait.html">DVecTDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/transpose dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose dense vector multiplication (outer product). Given the non-transpose dense vector type <em>VT1</em> and the transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose dense vector type or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d92/structblaze_1_1DVecTDVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/db6/classblaze_1_1DVecTransExpr.html">DVecTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector transpositions.The <a class="el" href="../../db/db6/classblaze_1_1DVecTransExpr.html" title="Expression object for dense vector transpositions.The DVecTransExpr class represents the compile time...">DVecTransExpr</a> class represents the compile time expression for transpositions of dense vectors.  <a href="../../db/db6/classblaze_1_1DVecTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d90/structblaze_1_1DVecTransExprTrait.html">DVecTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector transpose operation. Given the non-transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d90/structblaze_1_1DVecTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">DVecTransposer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the transposition of a dense vector.The <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html" title="Expression object for the transposition of a dense vector.The DVecTransposer class is a wrapper objec...">DVecTransposer</a> class is a wrapper object for the temporary transposition of a dense vector.  <a href="../../d0/d30/classblaze_1_1DVecTransposer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/da5/classblaze_1_1DVecTSVecMultExpr.html">DVecTSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-sparse vector outer products.The <a class="el" href="../../d5/da5/classblaze_1_1DVecTSVecMultExpr.html" title="Expression object for dense vector-sparse vector outer products.The DVecTSVecMultExpr class represent...">DVecTSVecMultExpr</a> class represents the compile time expression for dense vector-sparse vector outer products.  <a href="../../d5/da5/classblaze_1_1DVecTSVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d7a/structblaze_1_1DVecTSVecMultExprTrait.html">DVecTSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/transpose sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose sparse vector multiplication (outer product). Given the non-transpose dense vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose dense vector type or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d7a/structblaze_1_1DVecTSVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of a dynamic <img class="formulaInl" alt="$ M \times N $" src="../../form_37.png"/> matrix.The <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a> class template is the representation of an arbitrary sized matrix with <img class="formulaInl" alt="$ M \times N $" src="../../form_37.png"/> dynamically allocated elements of arbitrary type. The type of the elements and the storage order of the matrix can be specified via the two template parameters:  <a href="../../de/d1e/classblaze_1_1DynamicMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of an arbitrary sized vector.The <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">DynamicVector</a> class template is the representation of an arbitrary sized vector with dynamically allocated elements of arbitrary type. The type of the elements and the transpose flag of the vector can be specified via the two template parameters:  <a href="../../da/d9e/classblaze_1_1DynamicVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da5/structblaze_1_1EmptyType.html">EmptyType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty data type for utility purposes.  <a href="../../d7/da5/structblaze_1_1EmptyType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not class template negates the given compile time condition. In case the given condition would evaluate to true, the nested member enumeration is set to false and vice versa: ">Not</a> An Error (SFINAE) class.The <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIf class template is an auxiliary tool ...">EnableIf</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not class template negates the given compile time condition. In case the given condition would evaluate to true, the nested member enumeration is set to false and vice versa: ">Not</a> An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../d9/d28/structblaze_1_1EnableIf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html">EnableIfTrue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not class template negates the given compile time condition. In case the given condition would evaluate to true, the nested member enumeration is set to false and vice versa: ">Not</a> An Error (SFINAE) class.The <a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIfTrue class template is an auxiliary t...">EnableIfTrue</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not class template negates the given compile time condition. In case the given condition would evaluate to true, the nested member enumeration is set to false and vice versa: ">Not</a> An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../d7/d2c/structblaze_1_1EnableIfTrue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical epsilon value for floating point data types.The <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the smallest difference between two values of any floating point data type. In order to assign an epsilon value, the <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.<br />
In order to handle epsilon values conveniently, the global <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> instance <a class="el" href="../../de/df1/group__math.html#gad7691c4cf9181e1f56571cf39d785cf3" title="Global Epsilon instance.The blaze::epsilon instance can be used wherever a floating point data type i...">blaze::epsilon</a> is provided, which can be used wherever a floating point data type is required.  <a href="../../dd/d28/classblaze_1_1Epsilon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dc4/structblaze_1_1Equal.html">Equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type comparison.The <a class="el" href="../../d7/dc4/structblaze_1_1Equal.html" title="Compile time type comparison.The Equal class template compares the two given types using the equality...">Equal</a> class template compares the two given types using the equality operator ('=='). In case <em>T1::value</em> is equal to <em>T2::value</em>, the nested <em>value</em> member is set to <em>true</em>. Otherwise it is set to <em>false</em>.  <a href="../../d7/dc4/structblaze_1_1Equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d37/structblaze_1_1Erase.html">Erase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing the first occurrence of a type from a type list.The <a class="el" href="../../d4/d37/structblaze_1_1Erase.html" title="Erasing the first occurrence of a type from a type list.The Erase class can be used to erase the firs...">Erase</a> class can be used to erase the first occurrence of data type <em>Type</em> from a type list <em>TList</em>. In order to erase the first occurrence of a data type, the <a class="el" href="../../d4/d37/structblaze_1_1Erase.html" title="Erasing the first occurrence of a type from a type list.The Erase class can be used to erase the firs...">Erase</a> class has to be instantiated for a particular type list and another type. The following example gives an impression of the use of the <a class="el" href="../../d4/d37/structblaze_1_1Erase.html" title="Erasing the first occurrence of a type from a type list.The Erase class can be used to erase the firs...">Erase</a> class:  <a href="../../d4/d37/structblaze_1_1Erase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcd/structblaze_1_1EraseAll.html">EraseAll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing all occurrences of a type from a type list.The <a class="el" href="../../dc/dcd/structblaze_1_1EraseAll.html" title="Erasing all occurrences of a type from a type list.The EraseAll class can be used to erase all occurr...">EraseAll</a> class can be used to erase all occurrences of data type <em>Type</em> from a type list <em>TList</em>. In order to erase all occurrences of a data type, the <a class="el" href="../../dc/dcd/structblaze_1_1EraseAll.html" title="Erasing all occurrences of a type from a type list.The EraseAll class can be used to erase all occurr...">EraseAll</a> class has to be instantiated for a particular type list and another type. The following example gives an impression of the use of the <a class="el" href="../../dc/dcd/structblaze_1_1EraseAll.html" title="Erasing all occurrences of a type from a type list.The EraseAll class can be used to erase all occurr...">EraseAll</a> class:  <a href="../../dc/dcd/structblaze_1_1EraseAll.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d2c/structblaze_1_1Erf.html">Erf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gab93959cccb52b78dccb927b9ea0afafe" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a> function.  <a href="../../dd/d2c/structblaze_1_1Erf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d5a/structblaze_1_1Erfc.html">Erfc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga8444088c1f7a23fe9ca5d44f8b736b6a" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a> function.  <a href="../../de/d5a/structblaze_1_1Erfc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc3/structblaze_1_1Eval.html">Eval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gacb9f8190d38edb0e52d9c376da5486d6" title="Forces the evaluation of the given dense matrix expression dm. ">eval()</a> function.  <a href="../../d6/dc3/structblaze_1_1Eval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d24/structblaze_1_1EvalExpr.html">EvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all evaluation expression templates.The <a class="el" href="../../db/d24/structblaze_1_1EvalExpr.html" title="Base class for all evaluation expression templates.The EvalExpr class serves as a tag for all express...">EvalExpr</a> class serves as a tag for all expression templates that implement an evaluation operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent an evaluation operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as evaluation expression template. Only in case a class is derived from the <a class="el" href="../../db/d24/structblaze_1_1EvalExpr.html" title="Base class for all evaluation expression templates.The EvalExpr class serves as a tag for all express...">EvalExpr</a> base class, the <a class="el" href="../../d6/d62/structblaze_1_1IsEvalExpr.html" title="Compile time check whether the given type is an evaluation expression template.This type trait class ...">IsEvalExpr</a> type trait recognizes the class as valid evaluation expression template.  <a href="../../db/d24/structblaze_1_1EvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dc7/structblaze_1_1EvalExprTrait.html">EvalExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of an evaluation expression.Via this type trait it is possible to evaluate the return type of an evaluation expression. Given the type <em>T</em>, which must either be a vector or matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no evaluation operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d9/dc7/structblaze_1_1EvalExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d45/structblaze_1_1Exp.html">Exp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4" title="Computes  for each single element of the dense matrix dm. ">exp()</a> function.  <a href="../../d4/d45/structblaze_1_1Exp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc8/structblaze_1_1Exp10.html">Exp10</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2" title="Computes  for each single element of the dense matrix dm. ">exp10()</a> function.  <a href="../../db/dc8/structblaze_1_1Exp10.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbb/structblaze_1_1Exp2.html">Exp2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576" title="Computes  for each single element of the dense matrix dm. ">exp2()</a> function.  <a href="../../df/dbb/structblaze_1_1Exp2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all expression templates.The <a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> class is the base class for all expression templates. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as expression template. Only in case a class is derived from the <a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> base class, the <a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html" title="Compile time check whether the given type is an expression template.This type trait class tests wheth...">IsExpression</a> type trait recognizes the class as valid expression template.  <a href="../../d5/d2e/structblaze_1_1Expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d50/structblaze_1_1Extent.html">Extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the size of array bounds.Via this type trait it is possible to query at compile time for the size of a particular array extent. In case the given template argument is an array type with a rank greater than N, the <em>value</em> member constant is set to the number of elements of the N'th array dimension. In all other cases, and especially in case the N'th array dimension is incomplete, <em>value</em> is set to 0.  <a href="../../d2/d50/structblaze_1_1Extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d67/structblaze_1_1Floor.html">Floor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a> function.  <a href="../../d2/d67/structblaze_1_1Floor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d1a/structblaze_1_1ForEachExpr.html">ForEachExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all for-each expression templates.The <a class="el" href="../../dd/d1a/structblaze_1_1ForEachExpr.html" title="Base class for all for-each expression templates.The ForEachExpr class serves as a tag for all expres...">ForEachExpr</a> class serves as a tag for all expression templates that represent a unary, custom operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a custom operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as for-each expression template. Only in case a class is derived from the <a class="el" href="../../dd/d1a/structblaze_1_1ForEachExpr.html" title="Base class for all for-each expression templates.The ForEachExpr class serves as a tag for all expres...">ForEachExpr</a> base class, the <a class="el" href="../../da/dc2/structblaze_1_1IsForEachExpr.html" title="Compile time check whether the given type is a for-each expression template.This type trait class tes...">IsForEachExpr</a> type trait recognizes the class as valid for-each expression template.  <a href="../../dd/d1a/structblaze_1_1ForEachExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/de4/structblaze_1_1ForEachExprTrait.html">ForEachExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a <code>forEach</code> expression.Via this type trait it is possible to evaluate the return type of a <code>forEach</code> expression. Given the type <em>T</em>, which must either be a scalar, vector, or matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no <code>forEach</code> operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../da/de4/structblaze_1_1ForEachExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de7/structblaze_1_1ForEachTrait.html">ForEachTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../db/de7/structblaze_1_1ForEachTrait.html" title="Base template for the ForEachTrait class.The ForEachTrait class template offers the possibility to se...">ForEachTrait</a> class.The <a class="el" href="../../db/de7/structblaze_1_1ForEachTrait.html" title="Base template for the ForEachTrait class.The ForEachTrait class template offers the possibility to se...">ForEachTrait</a> class template offers the possibility to select the resulting data type of a generic <em>forEach</em> operation on the given type <em>T</em>. Given the type <em>T</em>, which must either be a vector or matrix type, the nested type <em>Type</em> corresponds to the resulting data type of the operation. In case the type of <em>T</em> doesn't fit or if no <em>forEach</em> operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>. Note that <em>const</em> and <em>volatile</em> qualifiers and reference modifiers are generally ignored.  <a href="../../db/de7/structblaze_1_1ForEachTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/structblaze_1_1Greater.html">Greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type comparison.The <a class="el" href="../../d8/df7/structblaze_1_1Greater.html" title="Compile time type comparison.The Greater class template compares the two given types using the greate...">Greater</a> class template compares the two given types using the greater-than operator ('&gt;'). In case <em>T1::value</em> is greater than <em>T2::value</em>, the nested <em>value</em> member is set to 1. Otherwise it is set to 0.  <a href="../../d8/df7/structblaze_1_1Greater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d94/structblaze_1_1Has1Byte.html">Has1Byte</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly one byte. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has one byte, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d94/structblaze_1_1Has1Byte.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d49/structblaze_1_1Has2Bytes.html">Has2Bytes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly two bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has two bytes, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d49/structblaze_1_1Has2Bytes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d99/structblaze_1_1Has4Bytes.html">Has4Bytes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly four bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has four bytes, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d99/structblaze_1_1Has4Bytes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/structblaze_1_1Has8Bytes.html">Has8Bytes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly four bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has four bytes, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from<em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the classderives from <em>FalseType</em>.  <a href="../../d4/df1/structblaze_1_1Has8Bytes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd2/structblaze_1_1HasConstDataAccess.html">HasConstDataAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for low-level access to constant data.This type trait tests whether the given data type provides a low-level access to constant data via a const 'data' member function. In case the according member function is provided, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../df/dd2/structblaze_1_1HasConstDataAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d86/structblaze_1_1HasCyclicDependency.html">HasCyclicDependency</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d87/structblaze_1_1HasMutableDataAccess.html">HasMutableDataAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for low-level access to mutable data.This type trait tests whether the given data type provides a low-level access to mutable data via a non-const 'data' member function. In case the according member function is provided, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../dc/d87/structblaze_1_1HasMutableDataAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da7/structblaze_1_1HasSIMDAbs.html">HasSIMDAbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD absolute value operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD absolute value operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d7/da7/structblaze_1_1HasSIMDAbs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc1/structblaze_1_1HasSIMDAcos.html">HasSIMDAcos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse cosine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD inverse cosine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d0/dc1/structblaze_1_1HasSIMDAcos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d75/structblaze_1_1HasSIMDAcosh.html">HasSIMDAcosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse hyperbolic cosine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD inverse hyperbolic cosine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../dc/d75/structblaze_1_1HasSIMDAcosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/structblaze_1_1HasSIMDAdd.html">HasSIMDAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD addition for the given data types.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...), and the used compiler, this type trait provides the information whether a SIMD addition operation exists for the two given data types <em>T1</em> and <em>T2</em> (ignoring the cv-qualifiers). In case the SIMD addition is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d8/dfc/structblaze_1_1HasSIMDAdd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d72/structblaze_1_1HasSIMDAsin.html">HasSIMDAsin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse sine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD inverse sine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../dc/d72/structblaze_1_1HasSIMDAsin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d74/structblaze_1_1HasSIMDAsinh.html">HasSIMDAsinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse hyperbolic sine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD hyperbolic inverse sine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d3/d74/structblaze_1_1HasSIMDAsinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dfc/structblaze_1_1HasSIMDAtan.html">HasSIMDAtan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse tangent operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD inverse tangent operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../de/dfc/structblaze_1_1HasSIMDAtan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d35/structblaze_1_1HasSIMDAtanh.html">HasSIMDAtanh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse hyperbolic tangent operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD inverse hyperbolic tangent operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d2/d35/structblaze_1_1HasSIMDAtanh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de0/structblaze_1_1HasSIMDCbrt.html">HasSIMDCbrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD cubic root operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD cubic root operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../db/de0/structblaze_1_1HasSIMDCbrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d06/structblaze_1_1HasSIMDCeil.html">HasSIMDCeil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD ceil operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD ceil operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d3/d06/structblaze_1_1HasSIMDCeil.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d8d/structblaze_1_1HasSIMDConj.html">HasSIMDConj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD conjugate operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD conjugate operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d9/d8d/structblaze_1_1HasSIMDConj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc0/structblaze_1_1HasSIMDCos.html">HasSIMDCos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD cosine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD cosine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../de/dc0/structblaze_1_1HasSIMDCos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d2c/structblaze_1_1HasSIMDCosh.html">HasSIMDCosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD hyperbolic cosine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD hyperbolic cosine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../dd/d2c/structblaze_1_1HasSIMDCosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d72/structblaze_1_1HasSIMDDiv.html">HasSIMDDiv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD division for the given data types.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD division operation exists for the two given data types <em>T1</em> and <em>T2</em> (ignoring the cv-qualifiers). In case the SIMD division is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d0/d72/structblaze_1_1HasSIMDDiv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dd9/structblaze_1_1HasSIMDErf.html">HasSIMDErf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD error function (<code>erf</code>) operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD error function (<code>erf</code>) operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../de/dd9/structblaze_1_1HasSIMDErf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dfe/structblaze_1_1HasSIMDErfc.html">HasSIMDErfc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD complementary error function (<code>erfc</code>) operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD complementary error function (<code>erfc</code>) operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d7/dfe/structblaze_1_1HasSIMDErfc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d62/structblaze_1_1HasSIMDExp.html">HasSIMDExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD <code><a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4" title="Computes  for each single element of the dense matrix dm. ">exp()</a></code> operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD <code><a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4" title="Computes  for each single element of the dense matrix dm. ">exp()</a></code> operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d3/d62/structblaze_1_1HasSIMDExp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d02/structblaze_1_1HasSIMDExp10.html">HasSIMDExp10</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD <code><a class="el" href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></code> operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD <code><a class="el" href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></code> operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../df/d02/structblaze_1_1HasSIMDExp10.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/ded/structblaze_1_1HasSIMDExp2.html">HasSIMDExp2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD <code><a class="el" href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></code> operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD <code><a class="el" href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></code> operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d8/ded/structblaze_1_1HasSIMDExp2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3d/structblaze_1_1HasSIMDFloor.html">HasSIMDFloor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD floor operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD floor operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d1/d3d/structblaze_1_1HasSIMDFloor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db9/structblaze_1_1HasSIMDInvCbrt.html">HasSIMDInvCbrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse cubic root operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD inverse cubic root operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d4/db9/structblaze_1_1HasSIMDInvCbrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/db1/structblaze_1_1HasSIMDInvSqrt.html">HasSIMDInvSqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse square root operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD inverse square root operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d6/db1/structblaze_1_1HasSIMDInvSqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d25/structblaze_1_1HasSIMDLog.html">HasSIMDLog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD natural logarithm operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD natural logarithm operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d7/d25/structblaze_1_1HasSIMDLog.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de2/structblaze_1_1HasSIMDLog10.html">HasSIMDLog10</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD common logarithm operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD common logarithm operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../db/de2/structblaze_1_1HasSIMDLog10.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dd0/structblaze_1_1HasSIMDLog2.html">HasSIMDLog2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD binary logarithm operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD binary logarithm operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d0/dd0/structblaze_1_1HasSIMDLog2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/structblaze_1_1HasSIMDMult.html">HasSIMDMult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD multiplication for the given data types.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD multiplication operation exists for the two given data types <em>T1</em> and <em>T2</em> (ignoring the cv-qualifiers). In case the SIMD multiplication is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d3/de8/structblaze_1_1HasSIMDMult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da6/structblaze_1_1HasSIMDPow.html">HasSIMDPow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD power operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD power operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../dd/da6/structblaze_1_1HasSIMDPow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d45/structblaze_1_1HasSIMDRound.html">HasSIMDRound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD round operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD round operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d0/d45/structblaze_1_1HasSIMDRound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d55/structblaze_1_1HasSIMDSin.html">HasSIMDSin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD sine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD sine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d0/d55/structblaze_1_1HasSIMDSin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/de7/structblaze_1_1HasSIMDSinh.html">HasSIMDSinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD hyperbolic sine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD hyperbolic sine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d9/de7/structblaze_1_1HasSIMDSinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df3/structblaze_1_1HasSIMDSqrt.html">HasSIMDSqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD square root operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD square root operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d8/df3/structblaze_1_1HasSIMDSqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d9c/structblaze_1_1HasSIMDSub.html">HasSIMDSub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD subtraction for the given data types.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD subtraction operation exists for the two given data types <em>T1</em> and <em>T2</em> (ignoring the cv-qualifiers). In case the SIMD subtraction is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../de/d9c/structblaze_1_1HasSIMDSub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dfb/structblaze_1_1HasSIMDTan.html">HasSIMDTan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD tangent operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD tangent operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d3/dfb/structblaze_1_1HasSIMDTan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d01/structblaze_1_1HasSIMDTanh.html">HasSIMDTanh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD hyperbolic tangent operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD hyperbolic tangent operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../dc/d01/structblaze_1_1HasSIMDTanh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d75/structblaze_1_1HasSIMDTrunc.html">HasSIMDTrunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD trunc operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD trunc operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../dc/d75/structblaze_1_1HasSIMDTrunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This class offers the possibility to test the size of a type at compile time. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> is exactly <em><a class="el" href="../../df/d5d/structblaze_1_1Size.html" title="Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...">Size</a></em> bytes large, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d90/structblaze_1_1HasSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d76/classblaze_1_1HaveSameSize.html">HaveSameSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This class offers the possibility to test the size of two types at compile time. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> an object of type <em>T1</em> has the same size as an object of type <em>T2</em>, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d76/classblaze_1_1HaveSameSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da7/classblaze_1_1HermitianElement.html">HermitianElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of two synchronized elements within the sparse Hermitian matrix.The <a class="el" href="../../dc/da7/classblaze_1_1HermitianElement.html" title="Representation of two synchronized elements within the sparse Hermitian matrix.The HermitianElement c...">HermitianElement</a> class represents two synchronized elements (i.e. two value/index pairs) within a sparse Hermitian matrix. It guarantees that a modification of element <img class="formulaInl" alt="$ a_{ij} $" src="../../form_24.png"/> via iterator is also applied to element <img class="formulaInl" alt="$ a_{ji} $" src="../../form_25.png"/>. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> dense Hermitian matrix:  <a href="../../dc/da7/classblaze_1_1HermitianElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/df4/classblaze_1_1HermitianMatrix.html">HermitianMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> adapter for Hermitian <img class="formulaInl" alt="$ N \times N $" src="../../form_18.png"/> matrices.  <a href="../../dd/df4/classblaze_1_1HermitianMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbd/classblaze_1_1HermitianProxy.html">HermitianProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for Hermitian matrices.The <a class="el" href="../../d8/dbd/classblaze_1_1HermitianProxy.html" title="Access proxy for Hermitian matrices.The HermitianProxy provides controlled access to the elements of ...">HermitianProxy</a> provides controlled access to the elements of a non-const Hermitian matrix. It guarantees that a modification of element <img class="formulaInl" alt="$ a_{ij} $" src="../../form_24.png"/> of the accessed matrix is also applied to element <img class="formulaInl" alt="$ a_{ji} $" src="../../form_25.png"/>. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> dense Hermitian matrix:  <a href="../../d8/dbd/classblaze_1_1HermitianProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3c/classblaze_1_1HermitianValue.html">HermitianValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of two synchronized values within a sparse Hermitian matrix.The <a class="el" href="../../d2/d3c/classblaze_1_1HermitianValue.html" title="Representation of two synchronized values within a sparse Hermitian matrix.The HermitianValue class r...">HermitianValue</a> class represents two synchronized values within a sparse Hermitian matrix. It guarantees that a modification of value <img class="formulaInl" alt="$ a_{ij} $" src="../../form_24.png"/> via iterator is also applied to the value <img class="formulaInl" alt="$ a_{ji} $" src="../../form_25.png"/>. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> sparse Hermitian matrix:  <a href="../../d2/d3c/classblaze_1_1HermitianValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d1e/structblaze_1_1HighType.html">HighType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../dc/d1e/structblaze_1_1HighType.html" title="Base template for the HighType type trait. ">HighType</a> type trait.  <a href="../../dc/d1e/structblaze_1_1HighType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/classblaze_1_1HybridMatrix.html">HybridMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of a dynamically sized matrix with static memory.The <a class="el" href="../../d6/d60/classblaze_1_1HybridMatrix.html" title="Efficient implementation of a dynamically sized matrix with static memory.The HybridMatrix class temp...">HybridMatrix</a> class template combines the flexibility of a dynamically sized matrix with the efficiency and performance of a fixed-size matrix. It is implemented as a crossing between the <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">blaze::StaticMatrix</a> and the <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">blaze::DynamicMatrix</a> class templates: Similar to the static matrix it uses static stack memory instead of dynamically allocated memory and similar to the dynamic matrix it can be resized (within the extend of the static memory). The type of the elements, the maximum number of rows and columns and the storage order of the matrix can be specified via the four template parameters:  <a href="../../d6/d60/classblaze_1_1HybridMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of a dynamically sized vector with static memory.The <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a> class template combines the flexibility of a dynamically sized vector with the efficiency and performance of a fixed-size vector. It is implemented as a crossing between the <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector</a> and the <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector</a> class templates: Similar to the static vector it uses static stack memory instead of dynamically allocated memory and similar to the dynamic vector it can be resized (within the extend of the static memory). The type of the elements, the maximum number of elements and the transpose flag of the vector can be specified via the three template parameters:  <a href="../../da/d6b/classblaze_1_1HybridVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d0c/structblaze_1_1If.html">If</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type selection.The <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> class template selects one of the two given types <em>T2</em> and <em>T3</em> depending on <em>T1</em>. In case <em>T1::value</em> evaluates to <em>true</em>, the member type definition <em>Type</em> is set to <em>T2</em>. In case <em>T1::value</em> evaluates to <em>false</em>, <em>Type</em> is set to <em>T3</em>.  <a href="../../d7/d0c/structblaze_1_1If.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type selection.The <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html" title="Compile time type selection.The IfTrue class template selects one of the two given types T1 and T2 de...">IfTrue</a> class template selects one of the two given types <em>T1</em> and <em>T2</em> depending on the <em>Condition</em> template argument. In case the <em>Condition</em> compile time constant expression evaluates to <em>true</em>, the member type definition <em>Type</em> is set to <em>T1</em>. In case <em>Condition</em> evaluates to <em>false</em>, <em>Type</em> is set to <em>T2</em>.  <a href="../../de/d6e/structblaze_1_1IfTrue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d61/structblaze_1_1Imag.html">Imag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga801fe45f59d396249b21d1e4f686f427" title="Returns a matrix containing the imaginary part of each single element of dm. ">imag()</a> function.  <a href="../../d3/d61/structblaze_1_1Imag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html">ImagTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html" title="Base template for the ImagTrait class.The ImagTrait class template offers the possibility to select t...">ImagTrait</a> class.The <a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html" title="Base template for the ImagTrait class.The ImagTrait class template offers the possibility to select t...">ImagTrait</a> class template offers the possibility to select the resulting data type of a generic <em>imag</em> operation on the given type <em>T</em>. Given the type <em>T</em>, which must either be a scalar, vector, or matrix type, the nested type <em>Type</em> corresponds to the resulting data type of the operation. In case the type of <em>T</em> doesn't fit or if no <em>imag</em> operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>. Note that <em>const</em> and <em>volatile</em> qualifiers and reference modifiers are generally ignored.  <a href="../../df/d0b/structblaze_1_1ImagTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d08/structblaze_1_1IndexOf.html">IndexOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searching a type list.The <a class="el" href="../../dd/d08/structblaze_1_1IndexOf.html" title="Searching a type list.The IndexOf class can be used to search the type list for a particular type Typ...">IndexOf</a> class can be used to search the type list for a particular type <em>Type</em>. In contrast to the <a class="el" href="../../d5/d5b/structblaze_1_1Contains.html" title="Searching a type list.The Contains class can be used to search the type list for a particular type Ty...">Contains</a> and the <a class="el" href="../../d2/d9b/structblaze_1_1ContainsRelated.html" title="Searching a type list.The ContainsRelated class can be used to search the type list for a type relate...">ContainsRelated</a> classes, the <a class="el" href="../../dd/d08/structblaze_1_1IndexOf.html" title="Searching a type list.The IndexOf class can be used to search the type list for a particular type Typ...">IndexOf</a> class evaluates the index of the given type in the type list. In case the type is contained in the type list, the <em>value</em> member represents the index of the queried type. Otherwise the <em>value</em> member is set to -1. In order to search for a type, the <a class="el" href="../../dd/d08/structblaze_1_1IndexOf.html" title="Searching a type list.The IndexOf class can be used to search the type list for a particular type Typ...">IndexOf</a> class has to be instantiated for a particular type list and a search type. The following example gives an impression of the use of the <a class="el" href="../../dd/d08/structblaze_1_1IndexOf.html" title="Searching a type list.The IndexOf class can be used to search the type list for a particular type Typ...">IndexOf</a> class:  <a href="../../dd/d08/structblaze_1_1IndexOf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d46/classblaze_1_1Indices.html">Indices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary class for the generation of random indices.  <a href="../../d8/d46/classblaze_1_1Indices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive infinity for built-in data types.The <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class to provide the possiblity to assign a positive infinity value to built-in data types. As positive infinity value, the largest possible positive value of the corresponding data type is used. In order to assign the positive infinity value, the <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> class can be implicitly converted to the following 13 built-in integral and floating point data types:  <a href="../../da/dff/classblaze_1_1Infinity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dd9/classblaze_1_1initializer__list.html">initializer_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list type of the Blaze library.  <a href="../../d8/dd9/classblaze_1_1initializer__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dfc/classblaze_1_1InputString.html">InputString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a string wrapper.The <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class is a wrapper class for the purpose to read input strings delimited by quotations from streams, like for instance "example input". <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> characters between the leading and the trailing quotation are extracted unchanged from the input stream, including whitespaces. The input string has to be in one single line. In case of input errors, the <em>std::istream::failbit</em> of the input stream is set.  <a href="../../da/dfc/classblaze_1_1InputString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d21/structblaze_1_1Int.html">Int</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time integral constant wrapper for <em>int</em>.The <a class="el" href="../../d8/d21/structblaze_1_1Int.html" title="Compile time integral constant wrapper for int.The Int class template represents an integral wrapper ...">Int</a> class template represents an integral wrapper for a compile time constant expression of type <em>int</em>. The value of an <a class="el" href="../../d8/d21/structblaze_1_1Int.html" title="Compile time integral constant wrapper for int.The Int class template represents an integral wrapper ...">Int</a> can be accessed via the nested <em>value</em> (which is guaranteed to be of type <em>int</em>), the type can be accessed via the nested type definition <em>ValueType</em>.  <a href="../../d8/d21/structblaze_1_1Int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d66/classblaze_1_1int16__t.html">int16_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit signed integer type of the Blaze library.  <a href="../../d9/d66/classblaze_1_1int16__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d2d/classblaze_1_1int32__t.html">int32_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit signed integer type of the Blaze library.  <a href="../../de/d2d/classblaze_1_1int32__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc7/classblaze_1_1int64__t.html">int64_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit signed integer type of the Blaze library.  <a href="../../d8/dc7/classblaze_1_1int64__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d3b/classblaze_1_1int8__t.html">int8_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit signed integer type of the Blaze library.  <a href="../../d6/d3b/classblaze_1_1int8__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d59/structblaze_1_1IntegralConstant.html">IntegralConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for a compile time constant integral value.The <a class="el" href="../../de/d59/structblaze_1_1IntegralConstant.html" title="Generic wrapper for a compile time constant integral value.The IntegralConstant class template repres...">IntegralConstant</a> class template represents a generic wrapper for a compile time constant integral value. The value of an <a class="el" href="../../de/d59/structblaze_1_1IntegralConstant.html" title="Generic wrapper for a compile time constant integral value.The IntegralConstant class template repres...">IntegralConstant</a> can be accessed via the nested <em>value</em> (which is guaranteed to be of type <em>T</em>), the type can be accessed via the nested type definition <em>ValueType</em>.  <a href="../../de/d59/structblaze_1_1IntegralConstant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d12/structblaze_1_1Inv.html">Inv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gad2f1c5357c878446236a3b6b3d0e107c" title="Calculation of the inverse of the given dense matrix. ">inv()</a> function.  <a href="../../d3/d12/structblaze_1_1Inv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2f/structblaze_1_1InvCbrt.html">InvCbrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga683192b628e107e6082a6b6876d62614" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a> function.  <a href="../../d2/d2f/structblaze_1_1InvCbrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d78/structblaze_1_1InvExprTrait.html">InvExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of an inversion expression.Via this type trait it is possible to evaluate the return type of an inversion expression. Given the type <em>T</em>, which must either a (complex) floating point type or a dense matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no inversion operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d78/structblaze_1_1InvExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d20/structblaze_1_1InvSqrt.html">InvSqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga8e33f65ba5d0b7f32fe15b818d6914e6" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a> function.  <a href="../../df/d20/structblaze_1_1InvSqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for adaptors.This type trait tests whether the given template parameter is an adaptor type (for instance <em><a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html" title="Matrix adapter for lower triangular  matrices. ">LowerMatrix</a></em>, <em><a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html" title="Matrix adapter for upper triangular  matrices. ">UpperMatrix</a></em>, or <em><a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html" title="Matrix adapter for symmetric  matrices. ">SymmetricMatrix</a></em>). In case the type is an adaptor type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example demonstrates this by means of the mentioned matrix adaptors:  <a href="../../d4/da2/structblaze_1_1IsAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0e/structblaze_1_1IsAddExpr.html">IsAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an addition expression template.This type trait class tests whether or not the given type <em>Type</em> is an addition expression template (i.e. an expression representing a vector addition or a matrix addition). In order to qualify as a valid addition expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d5/d2f/structblaze_1_1AddExpr.html" title="Base class for all addition expression templates.The AddExpr class serves as a tag for all expression...">AddExpr</a> base class. In case the given type is a valid addition expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d0e/structblaze_1_1IsAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d07/structblaze_1_1IsAligned.html">IsAligned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the alignment of data types.This type trait tests whether the given data type guarantees to provide aligned data values with respect to the requirements of the available instruction set. For instance, vectorizable data types such as built-in and complex data types are required to be 16-bit aligned for SSE, 32-bit aligned for AVX, and 64-bit aligned for MIC. In case the data type is properly aligned, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../de/d07/structblaze_1_1IsAligned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/daf/structblaze_1_1IsArithmetic.html">IsArithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for arithmetic data types.This type trait tests whether or not the given template parameter is a (possibly cv-qualified) arithmetic (integral or floating point) data type. In case the type is an arithmetic type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../dc/daf/structblaze_1_1IsArithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d2c/structblaze_1_1IsArray.html">IsArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d9/d2c/structblaze_1_1IsArray.html" title="Compile time type check.The IsArray type trait tests whether or not the given template parameter is a...">IsArray</a> type trait tests whether or not the given template parameter is an array type. In case the given data type is an array type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is set to <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../d9/d2c/structblaze_1_1IsArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd9/structblaze_1_1IsAssignable.html">IsAssignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../df/dd9/structblaze_1_1IsAssignable.html" title="Compile time type check.The IsAssignable type trait tests whether the expression. ...">IsAssignable</a> type trait tests whether the expression.  <a href="../../df/dd9/structblaze_1_1IsAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d07/classblaze_1_1IsBaseOf.html">IsBaseOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time analysis of an inheritance relationship.This type trait tests for an inheritance relationship between the two types <em>Base</em> and <em>Derived</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>Derived</em> is a type derived from <em>Base</em> or the same type as <em>Base</em> the <em>value</em> member contant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d07/classblaze_1_1IsBaseOf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d1b/structblaze_1_1IsBLASCompatible.html">IsBLASCompatible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types.This type trait tests whether or not the given template parameter is a data type compatible to the BLAS standard. The BLAS standard supports <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code> and <code>complex&lt;double&gt;</code> values. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type is BLAS compatible, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d1b/structblaze_1_1IsBLASCompatible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d48/structblaze_1_1IsBoolean.html">IsBoolean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for boolean types.This type trait tests whether or not the given template parameter is of boolean type. In case the type is a boolean (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d48/structblaze_1_1IsBoolean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for built-in data types.This type trait tests whether or not the given template parameter is a built-in/fundamental data type. In case the type is a built-in type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d1c/structblaze_1_1IsBuiltin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/structblaze_1_1IsCharacter.html">IsCharacter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for character types.This type trait tests whether or not the given template parameter is a character type (i.e., either char, signed char, unsigned char, or wchar_t, possibly cv-qualified). In case the type is a character type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d32/structblaze_1_1IsCharacter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d97/structblaze_1_1IsClass.html">IsClass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dd/d97/structblaze_1_1IsClass.html" title="Compile time type check.The IsClass type trait tests whether or not the given template parameter is a...">IsClass</a> type trait tests whether or not the given template parameter is a (possibly cv-qualified) class type. In case the given data type is a class type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is set to <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../dd/d97/structblaze_1_1IsClass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d61/structblaze_1_1IsColumn.html">IsColumn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for columns.This type trait tests whether or not the given template parameter is a column (i.e. dense or sparse column). In case the type is a column, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d61/structblaze_1_1IsColumn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d55/structblaze_1_1IsColumnMajorMatrix.html">IsColumnMajorMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for column-major matrix types.This type trait tests whether or not the given template argument is a column-major dense or sparse matrix type (i.e., a matrix whose storage order is set to <em>true</em>). In case the type is a column-major matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d55/structblaze_1_1IsColumnMajorMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d10/structblaze_1_1IsColumnVector.html">IsColumnVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for column vector types.This type trait tests whether or not the given template argument is a column dense or sparse vector type (i.e. a vector whose transposition flag is set to <a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors. ">blaze::columnVector</a>). In case the type is a column vector type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d10/structblaze_1_1IsColumnVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da9/structblaze_1_1IsComplex.html">IsComplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for complex types.This type trait tests whether or not the given template parameter is a complex data type. In case the type is a complex data type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/da9/structblaze_1_1IsComplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d5e/structblaze_1_1IsComplexDouble.html">IsComplexDouble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for single precision complex types.This type trait tests whether or not the given template parameter is of type <code>complex&lt;double&gt;</code>. In case the type is <code>complex&lt;double&gt;</code> (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/d5e/structblaze_1_1IsComplexDouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d20/structblaze_1_1IsComplexFloat.html">IsComplexFloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for single precision complex types.This type trait tests whether or not the given template parameter is of type <code>complex&lt;float&gt;</code>. In case the type is <code>complex&lt;float&gt;</code> (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d20/structblaze_1_1IsComplexFloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">IsComputation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a computational expression template.This type trait class tests whether or not the given type <em>Type</em> is a computational expression template (i.e. a mathematical operation such as an addition, a subtraction, a multiplication, a division, an absolute value calculation, ...). In order to qualify as a valid computational expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> base class. In case the given type is a valid computational expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/daf/structblaze_1_1IsComputation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html">IsConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for constant data types.The <a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html" title="Compile time check for constant data types.The IsConst type trait tests whether or not the given temp...">IsConst</a> type trait tests whether or not the given template parameter is a (top level) const-qualified data type. In case the given data type is const-qualified, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d5f/structblaze_1_1IsConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dc8/structblaze_1_1IsConstructible.html">IsConstructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d9/dc8/structblaze_1_1IsConstructible.html" title="Compile time type check.The IsConstructible type trait tests whether the expression. ">IsConstructible</a> type trait tests whether the expression.  <a href="../../d9/dc8/structblaze_1_1IsConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d98/structblaze_1_1IsConvertible.html">IsConvertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time pointer relationship constraint.This type traits tests whether the first given template argument can be converted to the second template argument via copy construction. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the first argument can be converted to the second argument, the <em>value</em> member constnt is set to <em>true</em>, the nested type definition <em>type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/d98/structblaze_1_1IsConvertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d54/structblaze_1_1IsCopyAssignable.html">IsCopyAssignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../da/d54/structblaze_1_1IsCopyAssignable.html" title="Compile time type check.The IsCopyAssignable type trait tests whether the expression. ">IsCopyAssignable</a> type trait tests whether the expression.  <a href="../../da/d54/structblaze_1_1IsCopyAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d1e/structblaze_1_1IsCopyConstructible.html">IsCopyConstructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../df/d1e/structblaze_1_1IsCopyConstructible.html" title="Compile time type check.The IsCopyConstructible type trait tests whether the expression. ">IsCopyConstructible</a> type trait tests whether the expression.  <a href="../../df/d1e/structblaze_1_1IsCopyConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d43/structblaze_1_1IsCrossExpr.html">IsCrossExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a cross product expression template.This type trait class tests whether or not the given type <em>Type</em> is a cross product expression template. In order to qualify as a valid cross product expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../dc/dc0/structblaze_1_1CrossExpr.html" title="Base class for all cross product expression templates.The CrossExpr class serves as a tag for all exp...">CrossExpr</a> base class. In case the given type is a valid cross product expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d43/structblaze_1_1IsCrossExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/df1/structblaze_1_1IsCustom.html">IsCustom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for custom data types.This type trait tests whether the given data type is a custom data type, i.e. a custom vector or a custom matrix. In case the data type a custom data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../d1/df1/structblaze_1_1IsCustom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d3b/structblaze_1_1IsDeclDiagExpr.html">IsDeclDiagExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a decldiag expression template.This type trait class tests whether or not the given type <em>Type</em> is a decldiag expression template. In order to qualify as a valid decldiag expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../dd/d42/structblaze_1_1DeclDiagExpr.html" title="Base class for all decldiag expression templates.The DeclDiagExpr class serves as a tag for all expre...">DeclDiagExpr</a> base class. In case the given type is a valid decldiag expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d3b/structblaze_1_1IsDeclDiagExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html">IsDeclExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a declaration expression template.This type trait class tests whether or not the given type <em>Type</em> is a declaration expression template. In order to qualify as a valid declaration expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d5/d56/structblaze_1_1DeclExpr.html" title="Base class for all matrix for-each expression templates.The DeclExpr class serves as a tag for all ex...">DeclExpr</a> base class. In case the given type is a valid declaration expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/dce/structblaze_1_1IsDeclExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d07/structblaze_1_1IsDeclHermExpr.html">IsDeclHermExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a declherm expression template.This type trait class tests whether or not the given type <em>Type</em> is a declherm expression template. In order to qualify as a valid declherm expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../dc/dc8/structblaze_1_1DeclHermExpr.html" title="Base class for all declherm expression templates.The DeclHermExpr class serves as a tag for all expre...">DeclHermExpr</a> base class. In case the given type is a valid declherm expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d07/structblaze_1_1IsDeclHermExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d9e/structblaze_1_1IsDeclLowExpr.html">IsDeclLowExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a decllow expression template.This type trait class tests whether or not the given type <em>Type</em> is a decllow expression template. In order to qualify as a valid decllow expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d0/d14/structblaze_1_1DeclLowExpr.html" title="Base class for all decllow expression templates.The DeclLowExpr class serves as a tag for all express...">DeclLowExpr</a> base class. In case the given type is a valid decllow expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d9e/structblaze_1_1IsDeclLowExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d3d/structblaze_1_1IsDeclSymExpr.html">IsDeclSymExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a declsym expression template.This type trait class tests whether or not the given type <em>Type</em> is a declsym expression template. In order to qualify as a valid declsym expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d8/db3/structblaze_1_1DeclSymExpr.html" title="Base class for all declsym expression templates.The DeclSymExpr class serves as a tag for all express...">DeclSymExpr</a> base class. In case the given type is a valid declsym expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d3d/structblaze_1_1IsDeclSymExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dc0/structblaze_1_1IsDeclUppExpr.html">IsDeclUppExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a declupp expression template.This type trait class tests whether or not the given type <em>Type</em> is a declupp expression template. In order to qualify as a valid declupp expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d1/dcc/structblaze_1_1DeclUppExpr.html" title="Base class for all declupp expression templates.The DeclUppExpr class serves as a tag for all express...">DeclUppExpr</a> base class. In case the given type is a valid declupp expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/dc0/structblaze_1_1IsDeclUppExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html">IsDefaultConstructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html" title="Compile time type check.The IsDefaultConstructible type trait tests whether the expression. ">IsDefaultConstructible</a> type trait tests whether the expression.  <a href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d1a/structblaze_1_1IsDenseMatrix.html">IsDenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for dense matrix types.This type trait tests whether or not the given template parameter is a dense, N-dimensional matrix type. In case the type is a dense matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d1a/structblaze_1_1IsDenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d50/structblaze_1_1IsDenseVector.html">IsDenseVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for dense vector types.This type trait tests whether or not the given template parameter is a dense, N-dimensional vector type. In case the type is a dense vector type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d50/structblaze_1_1IsDenseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html">IsDestructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html" title="Compile time type check.The IsDestructible type trait tests whether the expression. ">IsDestructible</a> type trait tests whether the expression.  <a href="../../dc/d64/structblaze_1_1IsDestructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for diagonal matrices.This type trait tests whether or not the given template parameter is a diagonal matrix type (i.e. a matrix type that is guaranteed to be diagonal at compile time). In case the type is a diagonal matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d38/structblaze_1_1IsDiagonal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d13/structblaze_1_1IsDivExpr.html">IsDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a division expression template.This type trait class tests whether or not the given type <em>Type</em> is a division expression template (i.e. an expression representing a vector/scalar division or a matrix/scalar division). In order to qualify as a valid division expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../dd/d46/structblaze_1_1DivExpr.html" title="Base class for all division expression templates.The DivExpr class serves as a tag for all expression...">DivExpr</a> base class. In case the given type is a valid division expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d13/structblaze_1_1IsDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d60/structblaze_1_1IsDouble.html">IsDouble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for double precision floating point types.This type trait tests whether or not the given template parameter is of double type. In case the type is double (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d60/structblaze_1_1IsDouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d47/structblaze_1_1IsEmpty.html">IsEmpty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter is an empty class type, i.e. a type without member data and virtual functions. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> it is an empty class type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d47/structblaze_1_1IsEmpty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd5/structblaze_1_1IsEnum.html">IsEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for complete enumeration types.This type trait tests whether or not the given template parameter is an enumeration type. In case the type is an enumeration type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/dd5/structblaze_1_1IsEnum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d62/structblaze_1_1IsEvalExpr.html">IsEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is an evaluation expression template. In order to qualify as a valid evaluation expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../db/d24/structblaze_1_1EvalExpr.html" title="Base class for all evaluation expression templates.The EvalExpr class serves as a tag for all express...">EvalExpr</a> base class. In case the given type is a valid evaluation expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d62/structblaze_1_1IsEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d20/structblaze_1_1IsEven.html">IsEven</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether a compile time constant expression is even.This value trait tests whether the given integral value <em>N</em> is an even value. In case the value is even, the <em>value</em> member enumeration is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d20/structblaze_1_1IsEven.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html">IsExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an expression template.This type trait class tests whether or not the given type <em>Type</em> is a Blaze expression template. In order to qualify as a valid expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> base class. In case the given type is a valid expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d44/structblaze_1_1IsExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d07/structblaze_1_1IsFloat.html">IsFloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for single precision floating point types.This type trait tests whether or not the given template parameter is of float type. In case the type is float (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d07/structblaze_1_1IsFloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html">IsFloatingPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for floating point data types.This type trait tests whether or not the given template parameter is a floating point data type (ignoring the cv-qualifiers). In case the type is a floating point data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dc2/structblaze_1_1IsForEachExpr.html">IsForEachExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a for-each expression template.This type trait class tests whether or not the given type <em>Type</em> is a for-each expression template. In order to qualify as a valid for-each expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../dd/d1a/structblaze_1_1ForEachExpr.html" title="Base class for all for-each expression templates.The ForEachExpr class serves as a tag for all expres...">ForEachExpr</a> base class. In case the given type is a valid for-each expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/dc2/structblaze_1_1IsForEachExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d23/structblaze_1_1IsGeneral.html">IsGeneral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for general matrices.This type trait tests whether or not the given template parameter is a general matrix type (i.e. a matrix type that is neither symmetric, Hermitian, lower triangular or upper triangular at compile time). In case the type is a general matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d23/structblaze_1_1IsGeneral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/daf/structblaze_1_1IsHermitian.html">IsHermitian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for Hermitian matrices.This type trait tests whether or not the given template parameter is an Hermitian matrix type (i.e. a matrix type that is guaranteed to be Hermitian at compile time). In case the type is a Hermitian matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/daf/structblaze_1_1IsHermitian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db0/structblaze_1_1IsIdentity.html">IsIdentity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for identity matrices.This type trait tests whether or not the given template parameter is an identity matrix type (i.e. a matrix type that is guaranteed to be an identity matrix at compile time). In case the type is an identity matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/db0/structblaze_1_1IsIdentity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5e/structblaze_1_1IsInteger.html">IsInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for integer types.This type trait tests whether or not the given template parameter is an integer type (i.e., either (signed) int or unsigned int, possibly cv-qualified). In case the type is an integer type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d5e/structblaze_1_1IsInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for integral data types.This type trait tests whether or not the given template parameter is an integral data type. In case the type is an integral data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d73/structblaze_1_1IsIntegral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd5/structblaze_1_1IsInvertible.html">IsInvertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types.This type trait tests whether or not the given template parameter is invertible. The type is considered to be invertible if it is either BLAS compatible (i.e. <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code>), <code>long double</code>, <code>complex&lt;long double&gt;</code> or any dense matrix type with a BLAS compatible element type. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the given type is invertible, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/dd5/structblaze_1_1IsInvertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d40/structblaze_1_1IsLong.html">IsLong</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for long integer types.This type trait tests whether or not the given template parameter is a long integer type (i.e., either (signed) long or unsigned long, possibly cv-qualified). In case the type is a long integer type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d40/structblaze_1_1IsLong.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d34/structblaze_1_1IsLongDouble.html">IsLongDouble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for extended precision floating point types.This type trait tests whether or not the given template parameter is of long double type. In case the type is long double (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d34/structblaze_1_1IsLongDouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for lower triangular matrices.This type trait tests whether or not the given template parameter is a lower triangular matrix type (i.e. a matrix type that is guaranteed to be lower triangular at compile time). This also includes lower unitriangular and strictly lower triangular matrices. In case the type is a lower triangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d64/structblaze_1_1IsLower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d49/structblaze_1_1IsMatEvalExpr.html">IsMatEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix evaluation expression template. In order to qualify as a valid matrix evaluation expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d5/d77/structblaze_1_1MatEvalExpr.html" title="Base class for all matrix evaluation expression templates.The MatEvalExpr class serves as a tag for a...">MatEvalExpr</a> base class. In case the given type is a valid matrix evaluation expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d49/structblaze_1_1IsMatEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d73/structblaze_1_1IsMatForEachExpr.html">IsMatForEachExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix for-each expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix for-each expression template. In order to qualify as a valid matrix for-each expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../db/d8a/structblaze_1_1MatForEachExpr.html" title="Base class for all matrix for-each expression templates.The MatForEachExpr class serves as a tag for ...">MatForEachExpr</a> base class. In case the given type is a valid matrix for-each expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d73/structblaze_1_1IsMatForEachExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/structblaze_1_1IsMatInvExpr.html">IsMatInvExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix inversion expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix inversion expression template. In order to qualify as a valid matrix inversion expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d1/d0d/structblaze_1_1MatInvExpr.html" title="Base class for all matrix inversion expression templates.The MatInvExpr class serves as a tag for all...">MatInvExpr</a> base class. In case the given type is a valid matrix inversion expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/dc6/structblaze_1_1IsMatInvExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d11/structblaze_1_1IsMatMatAddExpr.html">IsMatMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/matrix addition expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/matrix addition expression template. In order to qualify as a valid matrix addition expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d0/dea/structblaze_1_1MatMatAddExpr.html" title="Base class for all matrix/matrix addition expression templates.The MatMatAddExpr class serves as a ta...">MatMatAddExpr</a> base class. In case the given type is a valid matrix addition expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d11/structblaze_1_1IsMatMatAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/matrix multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/matrix multiplication expression template. In order to qualify as a valid matrix multiplication expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html" title="Base class for all matrix/matrix multiplication expression templates.The MatMatMultExpr class serves ...">MatMatMultExpr</a> base class. In case the given type is a valid matrix multiplication expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d07/structblaze_1_1IsMatMatSubExpr.html">IsMatMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/matrix subtraction expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/matrix subtraction expression template. In order to qualify as a valid matrix subtraction expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../db/dbd/structblaze_1_1MatMatSubExpr.html" title="Base class for all matrix/matrix subtraction expression templates.The MatMatSubExpr class serves as a...">MatMatSubExpr</a> base class. In case the given type is a valid matrix subtraction expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d07/structblaze_1_1IsMatMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d44/structblaze_1_1IsMatrix.html">IsMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for matrix types.This type trait tests whether or not the given template parameter is a N-dimensional dense or sparse matrix type. In case the type is a matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d44/structblaze_1_1IsMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd2/structblaze_1_1IsMatScalarDivExpr.html">IsMatScalarDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/scalar division expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/scalar division expression template. In order to qualify as a valid matrix/scalar division expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html" title="Base class for all matrix/scalar divsion expression templates.The MatScalarDivExpr class serves as a ...">MatScalarDivExpr</a> base class. In case the given type is a valid matrix/scalar division expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/dd2/structblaze_1_1IsMatScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/structblaze_1_1IsMatScalarMultExpr.html">IsMatScalarMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/scalar multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/scalar multiplication expression template. In order to qualify as a valid matrix/scalar multiplication expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html" title="Base class for all matrix/scalar multiplication expression templates.The MatScalarMultExpr class serv...">MatScalarMultExpr</a> base class. In case the given type is a valid matrix/scalar multiplication expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/db6/structblaze_1_1IsMatScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dba/structblaze_1_1IsMatSerialExpr.html">IsMatSerialExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix serial evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix serial evaluation expression template. In order to qualify as a valid matrix serial evaluation expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d6/d2f/structblaze_1_1MatSerialExpr.html" title="Base class for all matrix serial evaluation expression templates.The MatSerialExpr class serves as a ...">MatSerialExpr</a> base class. In case the given type is a valid matrix serial evaluation expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/dba/structblaze_1_1IsMatSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/structblaze_1_1IsMatTransExpr.html">IsMatTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix transposition expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix transposition expression template. In order to qualify as a valid matrix transposition expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d7/d54/structblaze_1_1MatTransExpr.html" title="Base class for all matrix transposition expression templates.The MatTransExpr class serves as a tag f...">MatTransExpr</a> base class. In case the given type is a valid matrix transposition expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/da5/structblaze_1_1IsMatTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d84/structblaze_1_1IsMatVecMultExpr.html">IsMatVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/vector multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/vector multiplication expression template. In order to qualify as a valid matrix/vector multiplication expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../db/de7/structblaze_1_1MatVecMultExpr.html" title="Base class for all matrix/vector multiplication expression templates.The MatVecMultExpr class serves ...">MatVecMultExpr</a> base class. In case the given type is a valid matrix/vector multiplication expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d84/structblaze_1_1IsMatVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d39/structblaze_1_1IsMoveAssignable.html">IsMoveAssignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d6/d39/structblaze_1_1IsMoveAssignable.html" title="Compile time type check.The IsMoveAssignable type trait tests whether the expression. ">IsMoveAssignable</a> type trait tests whether the expression.  <a href="../../d6/d39/structblaze_1_1IsMoveAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/structblaze_1_1IsMoveConstructible.html">IsMoveConstructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d1/d17/structblaze_1_1IsMoveConstructible.html" title="Compile time type check.The IsMoveConstructible type trait tests whether the expression. ">IsMoveConstructible</a> type trait tests whether the expression.  <a href="../../d1/d17/structblaze_1_1IsMoveConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dd3/structblaze_1_1IsMultExpr.html">IsMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a multiplication expression template (i.e. an expression representing an element-wise vector multiplication, a matrix/vector multiplication, a vector/matrix multiplication, or a matrix multiplication). In order to qualify as a valid multiplication expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../df/dfd/structblaze_1_1MultExpr.html" title="Base class for all multiplication expression templates.The MultExpr class serves as a tag for all exp...">MultExpr</a> base class. In case the given type is a valid multiplication expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/dd3/structblaze_1_1IsMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de2/structblaze_1_1IsMultipleOf.html">IsMultipleOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for a multiplicative relationship of two integral values.This value trait tests whether the first given integral value <em>M</em> is a multiple of the second integral value <em>N</em> (i.e. if <img class="formulaInl" alt="$ M = x*N $" src="../../form_189.png"/>, where x is any positive integer in the range <img class="formulaInl" alt="$ [0..\infty) $" src="../../form_190.png"/>). In case the value is a multiple of <em>N</em>, the <em>value</em> member enumeration is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/de2/structblaze_1_1IsMultipleOf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html">IsNothrowAssignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html" title="Compile time type check.The IsNothrowAssignable type trait tests whether the expression. ">IsNothrowAssignable</a> type trait tests whether the expression.  <a href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html">IsNothrowConstructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html" title="Compile time type check.The IsNothrowConstructible type trait tests whether the expression. ">IsNothrowConstructible</a> type trait tests whether the expression.  <a href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html">IsNothrowCopyAssignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html" title="Compile time type check.The IsNothrowCopyAssignable type trait tests whether the expression. ">IsNothrowCopyAssignable</a> type trait tests whether the expression.  <a href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html">IsNothrowCopyConstructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html" title="Compile time type check.The IsNothrowCopyConstructible type trait tests whether the expression...">IsNothrowCopyConstructible</a> type trait tests whether the expression.  <a href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html">IsNothrowDefaultConstructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html" title="Compile time type check.The IsNothrowDefaultConstructible type trait tests whether the expression...">IsNothrowDefaultConstructible</a> type trait tests whether the expression.  <a href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d8b/structblaze_1_1IsNothrowDestructible.html">IsNothrowDestructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html" title="Compile time type check.The IsDestructible type trait tests whether the expression. ">IsDestructible</a> type trait tests whether the expression.  <a href="../../dc/d8b/structblaze_1_1IsNothrowDestructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html">IsNothrowMoveAssignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html" title="Compile time type check.The IsNothrowMoveAssignable type trait tests whether the expression. ">IsNothrowMoveAssignable</a> type trait tests whether the expression.  <a href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html">IsNothrowMoveConstructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html" title="Compile time type check.The IsNothrowMoveConstructible type trait tests whether the expression...">IsNothrowMoveConstructible</a> type trait tests whether the expression.  <a href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for numeric types.This type trait tests whether or not the given template parameter is a numeric data type. Blaze considers all integral (except <em>bool</em>), floating point, and complex data types as numeric data types. In case the type is a numeric type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/dea/structblaze_1_1IsNumeric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d83/structblaze_1_1IsNumericMatrix.html">IsNumericMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for numeric matrix types.This type trait tests whether or not the given template parameter is a numeric matrix type, i.e. a matrix with numeric element type. In case the type is a numeric matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d83/structblaze_1_1IsNumericMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d1f/structblaze_1_1IsNumericVector.html">IsNumericVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for numeric vector types.This type trait tests whether or not the given template parameter is a numeric vector type, i.e. a vector with numeric element type. In case the type is a numeric vector type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d1f/structblaze_1_1IsNumericVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db8/structblaze_1_1IsObject.html">IsObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter <em>T</em> is an object type. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> types are considered object types except references, <em>void</em>, and function types. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>T</em> is an object type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/db8/structblaze_1_1IsObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d04/structblaze_1_1IsOdd.html">IsOdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether a compile time constant expression is odd.This value trait tests whether the given integral value <em>N</em> is an odd value. In case the value is odd, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d04/structblaze_1_1IsOdd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/ddb/structblaze_1_1IsOpposedView.html">IsOpposedView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for resizable data types.This type trait tests whether the given data type is an opposed view, i.e. a view that is opposed to the natural storage order of its underlying type. In case the data type is an opposed view, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../d8/ddb/structblaze_1_1IsOpposedView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d57/structblaze_1_1IsPadded.html">IsPadded</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types with padding.This type trait tests whether the given data type employs or simulates padding such that no special treatment of remainder elements is necessary for vectorized operations on the type. In case the data type is padded, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../d2/d57/structblaze_1_1IsPadded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db0/structblaze_1_1IsPod.html">IsPod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for pod data types.This type trait tests whether or not the given template parameter is a POD (Plain Old Data). In case the type is a POD, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/db0/structblaze_1_1IsPod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0f/structblaze_1_1IsPointer.html">IsPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter is a pointer type (including function pointers, but excluding pointers to members) or not. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> it is a pointer type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d0f/structblaze_1_1IsPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d6c/structblaze_1_1IsPowerOf.html">IsPowerOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for a power relationship of integral values to a given base.This value trait tests whether the given integral value <em>N</em> is a power of the base <em>B</em> according to the equation <img class="formulaInl" alt="$ B^x = N $" src="../../form_191.png"/>, where x is any positive integer in the range <img class="formulaInl" alt="$ [0..\infty) $" src="../../form_190.png"/>. In case the value is a power of <em>B</em>, the <em>value</em> member enumeration is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d6c/structblaze_1_1IsPowerOf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for proxy types.This type trait tests whether or not the given template parameter is a proxy type (i.e. derived from the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">blaze::Proxy</a> class template). In case the type is a proxy, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d54/structblaze_1_1IsProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dad/structblaze_1_1IsReference.html">IsReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter <em>T</em> is a reference type (including references to functions). <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> it is a reference type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/dad/structblaze_1_1IsReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9b/structblaze_1_1IsResizable.html">IsResizable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for resizable data types.This type trait tests whether the given data type is a resizable data type. In case the data type can be resized (via the <a class="el" href="../../dd/d7a/group__matrix.html#ga651c6be92e3a13425c42f3d92cf309fc" title="Changing the size of the matrix. ">resize()</a> function), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../db/d9b/structblaze_1_1IsResizable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/df0/structblaze_1_1IsRestricted.html">IsRestricted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types with restricted data access.This type trait tests whether the given data type has a restricted data access. Examples are the <a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html" title="Matrix adapter for lower triangular  matrices. ">LowerMatrix</a> and <a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html" title="Matrix adapter for upper triangular  matrices. ">UpperMatrix</a> adaptors that don't allow write access to the elements in the upper or lower part of the matrix, respectively. In case the data type has a restricted data access, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../df/df0/structblaze_1_1IsRestricted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da2/structblaze_1_1IsRow.html">IsRow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for rows.This type trait tests whether or not the given template parameter is a row (i.e. dense or sparse row). In case the type is a row, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/da2/structblaze_1_1IsRow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d0a/structblaze_1_1IsRowMajorMatrix.html">IsRowMajorMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for row-major matrix types.This type trait tests whether or not the given template argument is a row-major dense or sparse matrix type (i.e., a matrix whose storage order is set to <em>true</em>). In case the type is a row-major matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d0a/structblaze_1_1IsRowMajorMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d1c/structblaze_1_1IsRowVector.html">IsRowVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for row vector types.This type trait tests whether or not the given template argument is a row dense or sparse vector type (i.e. a vector whose transposition flag is set to <a class="el" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors. ">blaze::rowVector</a>). In case the type is a row vector type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d1c/structblaze_1_1IsRowVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d89/structblaze_1_1IsSame.html">IsSame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type relationship analysis.This class tests if the two data types <em>A</em> and <em>B</em> are equal. For this type comparison, the cv-qualifiers of both data types are ignored. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>A</em> and <em>B</em> are the same data type (ignoring the cv-qualifiers), then the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d89/structblaze_1_1IsSame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d47/structblaze_1_1IsSerialExpr.html">IsSerialExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a serial evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a serial evaluation expression template. In order to qualify as a valid serial evaluation expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d5/d7c/structblaze_1_1SerialExpr.html" title="Base class for all serial evaluation expression templates.The SerialExpr class serves as a tag for al...">SerialExpr</a> base class. In case the given type is a valid serial evaluation expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d47/structblaze_1_1IsSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d59/structblaze_1_1IsShort.html">IsShort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for short integer types.This type trait tests whether or not the given template parameter is a short integer type (i.e., either (signed) short or unsigned short, possibly cv-qualified). In case the type is a short integer type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d59/structblaze_1_1IsShort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/def/structblaze_1_1IsSigned.html">IsSigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for signed data types.This type trait tests whether or not the given template parameter is a signed integral or a floating point data type. In case the type is a signed (possibly cv-qualified) data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/def/structblaze_1_1IsSigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d53/structblaze_1_1IsSIMDCombinable.html">IsSIMDCombinable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types.This type trait tests whether or not the given types can be combined in the context of SIMD operations. By default, all numeric data types are considered combinable to themselves. Also, different integral types of the same size can be combined. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the types are determined to be SIMD combinable, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d53/structblaze_1_1IsSIMDCombinable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/ddc/structblaze_1_1IsSIMDEnabled.html">IsSIMDEnabled</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types.This type trait tests whether or not the given data type <em>T</em> is a SIMD-enabled data type (i.e. provides the according SIMD-related member functions, such as <code>load()</code>, store(), etc). <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type is SIMD-enabled, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/ddc/structblaze_1_1IsSIMDEnabled.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d68/structblaze_1_1IsSIMDPack.html">IsSIMDPack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for SIMD data types.This type trait tests whether the given data type is a Blaze SIMD packed data type. The following types are considered valid SIMD packed types:  <a href="../../d5/d68/structblaze_1_1IsSIMDPack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de3/structblaze_1_1IsSMPAssignable.html">IsSMPAssignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types.This type trait tests whether or not the given template parameter is an SMP-assignable data type (i.e. if it is a data type that can possibly and efficiently be assigned by several threads). In this context, built-in data types as well as complex numbers are non-SMP-assignable, whereas several vector and matrix types (as for instance <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">DynamicVector</a> and <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a>) can be SMP-assignable. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type is SMP-assignable, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/de3/structblaze_1_1IsSMPAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d39/structblaze_1_1IsSparseElement.html">IsSparseElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a sparse element type.This type trait class tests whether or not the given type <em>Type</em> is a Blaze sparse element type, i.e. if the type implements the sparse element concept by providing a value() and an index() member function. In order to qualify as a valid sparse element type, the given type has to derive (publicly or privately) from the <a class="el" href="../../db/db5/structblaze_1_1SparseElement.html" title="Base class for all sparse element types.The SparseElement class is the base class for all sparse elem...">SparseElement</a> base class. In case the given type is a valid sparse element, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d39/structblaze_1_1IsSparseElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d80/structblaze_1_1IsSparseMatrix.html">IsSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for sparse matrix types.This type trait tests whether or not the given template parameter is a sparse, N-dimensional matrix type. In case the type is a sparse matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d80/structblaze_1_1IsSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de1/structblaze_1_1IsSparseVector.html">IsSparseVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for sparse vector types.This type trait tests whether or not the given template parameter is a sparse, N-dimensional vector type. In case the type is a sparse vector type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/de1/structblaze_1_1IsSparseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3b/structblaze_1_1IsSquare.html">IsSquare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for square matrices.This type trait tests whether or not the given template parameter is a square matrix type (i.e. a matrix type that is guaranteed to be square at compile time). In case the type is a square matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d3b/structblaze_1_1IsSquare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d49/structblaze_1_1IsStrictlyLower.html">IsStrictlyLower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for strictly lower triangular matrices.This type trait tests whether or not the given template parameter is a strictly lower triangular matrix type (i.e. a matrix type that is guaranteed to be strictly lower triangular at compile time). In case the type is a strictly lower triangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d3/d49/structblaze_1_1IsStrictlyLower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/structblaze_1_1IsStrictlySame.html">IsStrictlySame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type relationship analysis.This class tests if the two data types <em>A</em> and <em>B</em> are equal. For this type comparison, the cv-qualifiers of both data types are not ignored. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>A</em> and <em>B</em> are the same data type, then the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/df1/structblaze_1_1IsStrictlySame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d32/structblaze_1_1IsStrictlyTriangular.html">IsStrictlyTriangular</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for strictly triangular matrix types.This type trait tests whether or not the given template parameter is a strictly lower or upper triangular matrix type. In case the type is a triangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d32/structblaze_1_1IsStrictlyTriangular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/db5/structblaze_1_1IsStrictlyUpper.html">IsStrictlyUpper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for strictly upper triangular matrices.This type trait tests whether or not the given template parameter is a strictly upper triangular matrix type (i.e. a matrix type that is guaranteed to be strictly upper triangular at compile time). In case the type is a strictly upper triangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/db5/structblaze_1_1IsStrictlyUpper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d3f/structblaze_1_1IsSubExpr.html">IsSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a subtraction expression template.This type trait class tests whether or not the given type <em>Type</em> is a subtraction expression template (i.e. an expression representing a vector subtraction or a matrix subtraction). In order to qualify as a valid subtraction expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d0/d7a/structblaze_1_1SubExpr.html" title="Base class for all subtraction expression templates.The SubExpr class serves as a tag for all express...">SubExpr</a> base class. In case the given type is a valid subtraction expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d3f/structblaze_1_1IsSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d1c/structblaze_1_1IsSubmatrix.html">IsSubmatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for submatrices.This type trait tests whether or not the given template parameter is a submatrix (i.e. dense or sparse submatrix). In case the type is a submatrix, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/d1c/structblaze_1_1IsSubmatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/structblaze_1_1IsSubvector.html">IsSubvector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for subvectors.This type trait tests whether or not the given template parameter is a subvector (i.e. dense or sparse subvector). In case the type is a subvector, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d9a/structblaze_1_1IsSubvector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for symmetric matrices.This type trait tests whether or not the given template parameter is a symmetric matrix type (i.e. a matrix type that is guaranteed to be symmetric at compile time). In case the type is a symmetric matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/db5/structblaze_1_1IsSymmetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dca/structblaze_1_1IsTemporary.html">IsTemporary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a temporary vector or matrix type.This type trait class tests whether the given type is a temporary vector or matrix type, i.e. can be used for a temporary vector or matrix. In case the given type can be used as temporary, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/dca/structblaze_1_1IsTemporary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">IsTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a transposition expression template.This type trait class tests whether or not the given type <em>Type</em> is a transposition expression template (i.e. an expression representing a vector transposition or a matrix transposition). In order to qualify as a valid transposition expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../dd/dfe/structblaze_1_1TransExpr.html" title="Base class for all transposition expression templates.The TransExpr class serves as a tag for all exp...">TransExpr</a> base class. In case the given type is a valid transposition expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d04/structblaze_1_1IsTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d73/structblaze_1_1IsTriangular.html">IsTriangular</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for triangular matrix types.This type trait tests whether or not the given template parameter is a lower or upper triangular matrix type. In case the type is a triangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/d73/structblaze_1_1IsTriangular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d08/structblaze_1_1IsTVecMatMultExpr.html">IsTVecMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/matrix multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/matrix multiplication expression template. In order to qualify as a valid vector/matrix multiplication expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html" title="Base class for all vector/matrix multiplication expression templates.The TVecMatMultExpr class serves...">TVecMatMultExpr</a> base class. In case the given type is a valid vector/matrix multiplication expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d08/structblaze_1_1IsTVecMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d77/structblaze_1_1IsUniLower.html">IsUniLower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for lower unitriangular matrices.This type trait tests whether or not the given template parameter is a lower unitriangular matrix type (i.e. a matrix type that is guaranteed to be lower unitriangular at compile time). In case the type is a lower unitriangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d77/structblaze_1_1IsUniLower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc7/structblaze_1_1IsUnion.html">IsUnion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for union data types.This type trait tests whether or not the given template parameter is a union data type. In case the type is a union, the <em>value</em> member constant is set o <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/dc7/structblaze_1_1IsUnion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d70/structblaze_1_1IsUniTriangular.html">IsUniTriangular</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for unitriangular matrix types.This type trait tests whether or not the given template parameter is a lower or upper unitriangular matrix type. In case the type is an unitriangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d70/structblaze_1_1IsUniTriangular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/ddc/structblaze_1_1IsUniUpper.html">IsUniUpper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for upper unitriangular matrices.This type trait tests whether or not the given template parameter is an upper unitriangular matrix type (i.e. a matrix type that is guaranteed to be upper unitriangular at compile time). In case the type is an upper unitriangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/ddc/structblaze_1_1IsUniUpper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d8c/structblaze_1_1IsUnsigned.html">IsUnsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for unsigned data types.This type trait tests whether or not the given template parameter is an unsigned, integral data type. In case the type is an unsigned (possibly cv-qualified) data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d8c/structblaze_1_1IsUnsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for upper triangular matrices.This type trait tests whether or not the given template parameter is an upper triangular matrix type (i.e. a matrix type that is guaranteed to be upper triangular at compile time). This also includes upper unitriangular and strictly upper triangular matrices. In case the type is an upper triangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d0e/structblaze_1_1IsUpper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6e/structblaze_1_1IsValid.html">IsValid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter is a valid or invalid data type (i.e. if the type is the INVALID_TYPE). <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>T</em> is not the INVALID_TYPE class type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/d6e/structblaze_1_1IsValid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d05/structblaze_1_1IsVecEvalExpr.html">IsVecEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector evaluation expression template. In order to qualify as a valid vector evaluation expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../da/d95/structblaze_1_1VecEvalExpr.html" title="Base class for all vector evaluation expression templates.The VecEvalExpr class serves as a tag for a...">VecEvalExpr</a> base class. In case the given type is a valid vector evaluation expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d05/structblaze_1_1IsVecEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dfc/structblaze_1_1IsVecForEachExpr.html">IsVecForEachExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector for-each expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector for-each expression template. In order to qualify as a valid vector for-each expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../dd/d40/structblaze_1_1VecForEachExpr.html" title="Base class for all vector for-each expression templates.The VecForEachExpr class serves as a tag for ...">VecForEachExpr</a> base class. In case the given type is a valid vector for-each expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/dfc/structblaze_1_1IsVecForEachExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da6/structblaze_1_1IsVecScalarDivExpr.html">IsVecScalarDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/scalar division expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/scalar division expression template. In order to qualify as a valid vector/scalar division expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html" title="Base class for all vector/scalar division expression templates.The VecScalarDivExpr class serves as a...">VecScalarDivExpr</a> base class. In case the given type is a valid vector/scalar division expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/da6/structblaze_1_1IsVecScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/structblaze_1_1IsVecScalarMultExpr.html">IsVecScalarMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/scalar multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/scalar multiplication expression template. In order to qualify as a valid vector/scalar multiplication expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../df/d01/structblaze_1_1VecScalarMultExpr.html" title="Base class for all vector/scalar multiplication expression templates.The VecScalarMultExpr class serv...">VecScalarMultExpr</a> base class. In case the given type is a valid vector/scalar multiplication expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/da8/structblaze_1_1IsVecScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d59/structblaze_1_1IsVecSerialExpr.html">IsVecSerialExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector serial evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector serial evaluation expression template. In order to qualify as a valid vector serial evaluation expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d8/dfb/structblaze_1_1VecSerialExpr.html" title="Base class for all vector serial evaluation expression templates.The VecSerialExpr class serves as a ...">VecSerialExpr</a> base class. In case the given type is a valid vector serial evaluation expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d59/structblaze_1_1IsVecSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de4/structblaze_1_1IsVector.html">IsVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for vector types.This type trait tests whether or not the given template parameter is a N-dimensional dense or sparse vector type. In case the type is a vector type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/de4/structblaze_1_1IsVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0e/structblaze_1_1IsVectorizable.html">IsVectorizable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for vectorizable types.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...), this type trait tests whether or not the given template parameter is a vectorizable type, i.e. a type for which intrinsic vector operations and optimizations can be used. Currently, all built-in data types except <code>bool</code> and the according complex numbers are considered to be vectorizable types. In case the type is vectorizable, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d0e/structblaze_1_1IsVectorizable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3d/structblaze_1_1IsVecTransExpr.html">IsVecTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector transposition expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector transposition expression template. In order to qualify as a valid vector transposition expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d0/dec/structblaze_1_1VecTransExpr.html" title="Base class for all vector transposition expression templates.The VecTransExpr class serves as a tag f...">VecTransExpr</a> base class. In case the given type is a valid vector transposition expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d3d/structblaze_1_1IsVecTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d17/structblaze_1_1IsVecTVecMultExpr.html">IsVecTVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an outer product expression template.This type trait class tests whether or not the given type <em>Type</em> is an outer product expression template (i.e. an expression representing the multiplication between a column vector and a row vector). In order to qualify as a valid outer product expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../de/d08/structblaze_1_1VecTVecMultExpr.html" title="Base class for all outer product expression templates.The VecTVecMultExpr class serves as a tag for a...">VecTVecMultExpr</a> base class. In case the given type is a valid outer product expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d17/structblaze_1_1IsVecTVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dae/structblaze_1_1IsVecVecAddExpr.html">IsVecVecAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/vector addition expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/vector addition expression template. In order to qualify as a valid vector addition expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d0/d58/structblaze_1_1VecVecAddExpr.html" title="Base class for all vector/vector addition expression templates.The VecVecAddExpr class serves as a ta...">VecVecAddExpr</a> base class. In case the given type is a valid vector addition expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/dae/structblaze_1_1IsVecVecAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/ddd/structblaze_1_1IsVecVecDivExpr.html">IsVecVecDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/vector division expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/vector division expression template. In order to qualify as a valid vector division expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../de/dc6/structblaze_1_1VecVecDivExpr.html" title="Base class for all vector/vector division expression templates.The VecVecDivExpr class serves as a ta...">VecVecDivExpr</a> base class. In case the given type is a valid vector division expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/ddd/structblaze_1_1IsVecVecDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d79/structblaze_1_1IsVecVecMultExpr.html">IsVecVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/vector multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/vector multiplication expression template. In order to qualify as a valid vector multiplication expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../df/d10/structblaze_1_1VecVecMultExpr.html" title="Base class for all vector/vector multiplication expression templates.The VecVecMultExpr class serves ...">VecVecMultExpr</a> base class. In case the given type is a valid vector multiplication expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d79/structblaze_1_1IsVecVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d16/structblaze_1_1IsVecVecSubExpr.html">IsVecVecSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/vector subtraction expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/vector subtraction expression template. In order to qualify as a valid vector subtraction expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d1/d87/structblaze_1_1VecVecSubExpr.html" title="Base class for all vector/vector subtraction expression templates.The VecVecSubExpr class serves as a...">VecVecSubExpr</a> base class. In case the given type is a valid vector subtraction expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d16/structblaze_1_1IsVecVecSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbb/structblaze_1_1IsView.html">IsView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for views.This type trait tests whether or not the given template parameter is a view (i.e. subvector, submatrix, row, column, ...). In case the type is a view, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/dbb/structblaze_1_1IsView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6b/structblaze_1_1IsVoid.html">IsVoid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the <em>void</em> data type.This type trait tests whether or not the given template parameter is of type <em>void</em> (ignoring the cv-qualifiers). In case the type is of type <em>void</em>, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d6b/structblaze_1_1IsVoid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html">IsVolatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for volatile data types.The <a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html" title="Compile time check for volatile data types.The IsVolatile type trait tests whether or not the given t...">IsVolatile</a> type trait tests whether or not the given template parameter is a (top level) volatile-qualified data type. In case the given data type is volatile, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/db9/structblaze_1_1IsVolatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4f/structblaze_1_1Length.html">Length</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculating the length of a type list.The <a class="el" href="../../d0/d4f/structblaze_1_1Length.html" title="Calculating the length of a type list.The Length class can be used to obtain the length of a type lis...">Length</a> class can be used to obtain the length of a type list (i.e. the number of contained types). In order to obtain the length of a type list, the <a class="el" href="../../d0/d4f/structblaze_1_1Length.html" title="Calculating the length of a type list.The Length class can be used to obtain the length of a type lis...">Length</a> class has to be instantiated for a particular type list. The length of the type list can be obtained using the member enumeration <em>value</em>. The following example gives an impression of the use of the <a class="el" href="../../d0/d4f/structblaze_1_1Length.html" title="Calculating the length of a type list.The Length class can be used to obtain the length of a type lis...">Length</a> class:  <a href="../../d0/d4f/structblaze_1_1Length.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d42/structblaze_1_1Less.html">Less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type comparison.The <a class="el" href="../../d6/d42/structblaze_1_1Less.html" title="Compile time type comparison.The Less class template compares the two given types using the less-than...">Less</a> class template compares the two given types using the less-than operator ('&lt;'). In case <em>T1::value</em> is less than <em>T2::value</em>, the nested <em>value</em> member is set to 1. Otherwise it is set to 0.  <a href="../../d6/d42/structblaze_1_1Less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dea/structblaze_1_1Limits.html">Limits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical limits of built-in data types.The <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">Limits</a> class provides numerical limits for the following built-in data types:  <a href="../../d9/dea/structblaze_1_1Limits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d4f/structblaze_1_1LinearGrowth.html">LinearGrowth</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear growth policy class.The <a class="el" href="../../df/d4f/structblaze_1_1LinearGrowth.html" title="Linear growth policy class.The LinearGrowth policy class implements a linear growth strategy...">LinearGrowth</a> policy class implements a linear growth strategy. It can be customized for any purpose: the <em>Growth</em> template argument specifies the factor of the size growth.  <a href="../../df/d4f/structblaze_1_1LinearGrowth.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d9c/structblaze_1_1Log.html">Log</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga8359ccb837055c7056c1eae56c45eb1a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a> function.  <a href="../../d3/d9c/structblaze_1_1Log.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d33/structblaze_1_1Log10.html">Log10</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga979d59d108165583def861daf609d8ca" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a> function.  <a href="../../de/d33/structblaze_1_1Log10.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc7/structblaze_1_1Log2.html">Log2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gaba8707d555ca3ec8c6394d9724e2b504" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a> function.  <a href="../../d5/dc7/structblaze_1_1Log2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db7/structblaze_1_1Long.html">Long</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time integral constant wrapper for <em>long</em>.The <a class="el" href="../../d1/db7/structblaze_1_1Long.html" title="Compile time integral constant wrapper for long.The Long class template represents an integral wrappe...">Long</a> class template represents an integral wrapper for a compile time constant expression of type <em>long</em>. The value of an <a class="el" href="../../d1/db7/structblaze_1_1Long.html" title="Compile time integral constant wrapper for long.The Long class template represents an integral wrappe...">Long</a> can be accessed via the nested <em>value</em> (which is guaranteed to be of type <em>long</em>), the type can be accessed via the nested type definition <em>ValueType</em>.  <a href="../../d1/db7/structblaze_1_1Long.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html">LowerMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> adapter for lower triangular <img class="formulaInl" alt="$ N \times N $" src="../../form_18.png"/> matrices.  <a href="../../da/ddf/classblaze_1_1LowerMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/classblaze_1_1LowerProxy.html">LowerProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for lower triangular matrices.The <a class="el" href="../../d5/de5/classblaze_1_1LowerProxy.html" title="Access proxy for lower triangular matrices.The LowerProxy provides controlled access to the elements ...">LowerProxy</a> provides controlled access to the elements of a non-const lower triangular matrix. It guarantees that the lower matrix invariant is not violated, i.e. that elements in the upper part of the matrix remain default values. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> dense lower matrix:  <a href="../../d5/de5/classblaze_1_1LowerProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d00/structblaze_1_1LowType.html">LowType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d5/d00/structblaze_1_1LowType.html" title="Base template for the LowType type trait. ">LowType</a> type trait.  <a href="../../d5/d00/structblaze_1_1LowType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html">MakeSigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type conversion into a signed integral type.This type trait provides the feature to convert the given integral or constant type <em>T</em> to the corresponding signed integral data type with the same size and with the same cv-qualifiers. Note that in case <em>T</em> is bool or a non-integral data type, a compilation error is created.  <a href="../../da/da3/structblaze_1_1MakeSigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html">MakeUnsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type conversion into an unsigned integral type.This type trait provides the feature to convert the given integral or constant type <em>T</em> to the corresponding unsigned integral data type with the same size and with the same cv-qualifiers. Note that in case <em>T</em> is bool or a non-integral data type, a compilation error is created.  <a href="../../d9/dd7/structblaze_1_1MakeUnsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d77/structblaze_1_1MatEvalExpr.html">MatEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix evaluation expression templates.The <a class="el" href="../../d5/d77/structblaze_1_1MatEvalExpr.html" title="Base class for all matrix evaluation expression templates.The MatEvalExpr class serves as a tag for a...">MatEvalExpr</a> class serves as a tag for all expression templates that implement a matrix evaluation operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix evaluation operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix evaluation expression template. Only in case a class is derived from the <a class="el" href="../../d5/d77/structblaze_1_1MatEvalExpr.html" title="Base class for all matrix evaluation expression templates.The MatEvalExpr class serves as a tag for a...">MatEvalExpr</a> base class, the <a class="el" href="../../da/d49/structblaze_1_1IsMatEvalExpr.html" title="Compile time check whether the given type is a matrix evaluation expression template.This type trait class tests whether or not the given type Type is a matrix evaluation expression template. In order to qualify as a valid matrix evaluation expression template, the given type has to derive (publicly or privately) from the MatEvalExpr base class. In case the given type is a valid matrix evaluation expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMatEvalExpr</a> type trait recognizes the class as valid matrix evaluation expression template.  <a href="../../d5/d77/structblaze_1_1MatEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d8a/structblaze_1_1MatForEachExpr.html">MatForEachExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix for-each expression templates.The <a class="el" href="../../db/d8a/structblaze_1_1MatForEachExpr.html" title="Base class for all matrix for-each expression templates.The MatForEachExpr class serves as a tag for ...">MatForEachExpr</a> class serves as a tag for all expression templates that represent a unary, custom operation on a matrix. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix custom operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix for-each expression template. Only in case a class is derived from the <a class="el" href="../../db/d8a/structblaze_1_1MatForEachExpr.html" title="Base class for all matrix for-each expression templates.The MatForEachExpr class serves as a tag for ...">MatForEachExpr</a> base class, the <a class="el" href="../../d0/d73/structblaze_1_1IsMatForEachExpr.html" title="Compile time check whether the given type is a matrix for-each expression template.This type trait class tests whether or not the given type Type is a matrix for-each expression template. In order to qualify as a valid matrix for-each expression template, the given type has to derive (publicly or privately) from the MatForEachExpr base class. In case the given type is a valid matrix for-each expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMatForEachExpr</a> type trait recognizes the class as valid matrix for-each expression template.  <a href="../../db/d8a/structblaze_1_1MatForEachExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d0d/structblaze_1_1MatInvExpr.html">MatInvExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix inversion expression templates.The <a class="el" href="../../d1/d0d/structblaze_1_1MatInvExpr.html" title="Base class for all matrix inversion expression templates.The MatInvExpr class serves as a tag for all...">MatInvExpr</a> class serves as a tag for all expression templates that implement a matrix inversion operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix inversion operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix inversion expression template. Only in case a class is derived from the <a class="el" href="../../d1/d0d/structblaze_1_1MatInvExpr.html" title="Base class for all matrix inversion expression templates.The MatInvExpr class serves as a tag for all...">MatInvExpr</a> base class, the <a class="el" href="../../db/dc6/structblaze_1_1IsMatInvExpr.html" title="Compile time check whether the given type is a matrix inversion expression template.This type trait class tests whether or not the given type Type is a matrix inversion expression template. In order to qualify as a valid matrix inversion expression template, the given type has to derive (publicly or privately) from the MatInvExpr base class. In case the given type is a valid matrix inversion expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMatInvExpr</a> type trait recognizes the class as valid matrix inversion expression template.  <a href="../../d1/d0d/structblaze_1_1MatInvExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dea/structblaze_1_1MatMatAddExpr.html">MatMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/matrix addition expression templates.The <a class="el" href="../../d0/dea/structblaze_1_1MatMatAddExpr.html" title="Base class for all matrix/matrix addition expression templates.The MatMatAddExpr class serves as a ta...">MatMatAddExpr</a> class serves as a tag for all expression templates that implement a matrix/matrix addition. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix addition and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix addition expression template. Only in case a class is derived from the <a class="el" href="../../d0/dea/structblaze_1_1MatMatAddExpr.html" title="Base class for all matrix/matrix addition expression templates.The MatMatAddExpr class serves as a ta...">MatMatAddExpr</a> base class, the <a class="el" href="../../db/d11/structblaze_1_1IsMatMatAddExpr.html" title="Compile time check whether the given type is a matrix/matrix addition expression template.This type trait class tests whether or not the given type Type is a matrix/matrix addition expression template. In order to qualify as a valid matrix addition expression template, the given type has to derive (publicly or privately) from the MatMatAddExpr base class. In case the given type is a valid matrix addition expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMatMatAddExpr</a> type trait recognizes the class as valid matrix addition expression template.  <a href="../../d0/dea/structblaze_1_1MatMatAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html">MatMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/matrix multiplication expression templates.The <a class="el" href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html" title="Base class for all matrix/matrix multiplication expression templates.The MatMatMultExpr class serves ...">MatMatMultExpr</a> class serves as a tag for all expression templates that implement a matrix/matrix multiplication. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix multiplication and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix multiplication expression template. Only in case a class is derived from the <a class="el" href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html" title="Base class for all matrix/matrix multiplication expression templates.The MatMatMultExpr class serves ...">MatMatMultExpr</a> base class, the <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html" title="Compile time check whether the given type is a matrix/matrix multiplication expression template...">IsMatMatMultExpr</a> type trait recognizes the class as valid matrix multiplication expression template.  <a href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dbd/structblaze_1_1MatMatSubExpr.html">MatMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/matrix subtraction expression templates.The <a class="el" href="../../db/dbd/structblaze_1_1MatMatSubExpr.html" title="Base class for all matrix/matrix subtraction expression templates.The MatMatSubExpr class serves as a...">MatMatSubExpr</a> class serves as a tag for all expression templates that implement a matrix/matrix subtraction. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix subtraction and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix subtraction expression template. Only in case a class is derived from the <a class="el" href="../../db/dbd/structblaze_1_1MatMatSubExpr.html" title="Base class for all matrix/matrix subtraction expression templates.The MatMatSubExpr class serves as a...">MatMatSubExpr</a> base class, the <a class="el" href="../../dc/d07/structblaze_1_1IsMatMatSubExpr.html" title="Compile time check whether the given type is a matrix/matrix subtraction expression template...">IsMatMatSubExpr</a> type trait recognizes the class as valid matrix subtraction expression template.  <a href="../../db/dbd/structblaze_1_1MatMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for matrices.The <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> class is a base class for all dense and sparse matrix classes within the Blaze library. It provides an abstraction from the actual type of the matrix, but enables a conversion back to this type via the 'Curiously Recurring Template Pattern' (CRTP).  <a href="../../d0/d5c/structblaze_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for sparse, <img class="formulaInl" alt="$ M \times N $" src="../../form_37.png"/> matrices.The <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> provides safe access to the elements of a non-const sparse matrices.<br />
The proxied access to the elements of a sparse matrix is necessary since it may be possible that several insertion operations happen in the same statement. The following code illustrates this with two examples by means of the <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">CompressedMatrix</a> class:  <a href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da6/classblaze_1_1MatrixSerializer.html">MatrixSerializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializer for dense and sparse matrices.The <a class="el" href="../../d1/da6/classblaze_1_1MatrixSerializer.html" title="Serializer for dense and sparse matrices.The MatrixSerializer implements the necessary logic to seria...">MatrixSerializer</a> implements the necessary logic to serialize dense and sparse matrices, i.e. to convert them into a portable, binary representation. The following example demonstrates the (de-)serialization process of matrices:  <a href="../../d1/da6/classblaze_1_1MatrixSerializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html">MatScalarDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/scalar divsion expression templates.The <a class="el" href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html" title="Base class for all matrix/scalar divsion expression templates.The MatScalarDivExpr class serves as a ...">MatScalarDivExpr</a> class serves as a tag for all expression templates that implement a matrix/scalar divsion. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix/scalar divsion and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix/scalar divsion expression template. Only in case a class is derived from the <a class="el" href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html" title="Base class for all matrix/scalar divsion expression templates.The MatScalarDivExpr class serves as a ...">MatScalarDivExpr</a> base class, the <a class="el" href="../../df/dd2/structblaze_1_1IsMatScalarDivExpr.html" title="Compile time check whether the given type is a matrix/scalar division expression template.This type trait class tests whether or not the given type Type is a matrix/scalar division expression template. In order to qualify as a valid matrix/scalar division expression template, the given type has to derive (publicly or privately) from the MatScalarDivExpr base class. In case the given type is a valid matrix/scalar division expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMatScalarDivExpr</a> type trait recognizes the class as valid matrix/scalar divsion expression template.  <a href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html">MatScalarMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/scalar multiplication expression templates.The <a class="el" href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html" title="Base class for all matrix/scalar multiplication expression templates.The MatScalarMultExpr class serv...">MatScalarMultExpr</a> class serves as a tag for all expression templates that implement a matrix/scalar multiplication. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix/scalar multiplication and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix/scalar multiplication expression template. Only in case a class is derived from the <a class="el" href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html" title="Base class for all matrix/scalar multiplication expression templates.The MatScalarMultExpr class serv...">MatScalarMultExpr</a> base class, the <a class="el" href="../../d5/db6/structblaze_1_1IsMatScalarMultExpr.html" title="Compile time check whether the given type is a matrix/scalar multiplication expression template...">IsMatScalarMultExpr</a> type trait recognizes the class as valid matrix/scalar multiplication expression template.  <a href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2f/structblaze_1_1MatSerialExpr.html">MatSerialExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix serial evaluation expression templates.The <a class="el" href="../../d6/d2f/structblaze_1_1MatSerialExpr.html" title="Base class for all matrix serial evaluation expression templates.The MatSerialExpr class serves as a ...">MatSerialExpr</a> class serves as a tag for all expression templates that enforce a serial evaluation of a matrix. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix serialization operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix serial evaluation expression template. Only in case a class is derived from the <a class="el" href="../../d6/d2f/structblaze_1_1MatSerialExpr.html" title="Base class for all matrix serial evaluation expression templates.The MatSerialExpr class serves as a ...">MatSerialExpr</a> base class, the <a class="el" href="../../dc/dba/structblaze_1_1IsMatSerialExpr.html" title="Compile time check whether the given type is a matrix serial evaluation expression template...">IsMatSerialExpr</a> type trait recognizes the class as valid matrix serial evaluation expression template.  <a href="../../d6/d2f/structblaze_1_1MatSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d54/structblaze_1_1MatTransExpr.html">MatTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix transposition expression templates.The <a class="el" href="../../d7/d54/structblaze_1_1MatTransExpr.html" title="Base class for all matrix transposition expression templates.The MatTransExpr class serves as a tag f...">MatTransExpr</a> class serves as a tag for all expression templates that implement a matrix transposition operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix transposition operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix transposition expression template. Only in case a class is derived from the <a class="el" href="../../d7/d54/structblaze_1_1MatTransExpr.html" title="Base class for all matrix transposition expression templates.The MatTransExpr class serves as a tag f...">MatTransExpr</a> base class, the <a class="el" href="../../dd/da5/structblaze_1_1IsMatTransExpr.html" title="Compile time check whether the given type is a matrix transposition expression template.This type trait class tests whether or not the given type Type is a matrix transposition expression template. In order to qualify as a valid matrix transposition expression template, the given type has to derive (publicly or privately) from the MatTransExpr base class. In case the given type is a valid matrix transposition expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMatTransExpr</a> type trait recognizes the class as valid matrix transposition expression template.  <a href="../../d7/d54/structblaze_1_1MatTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de7/structblaze_1_1MatVecMultExpr.html">MatVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/vector multiplication expression templates.The <a class="el" href="../../db/de7/structblaze_1_1MatVecMultExpr.html" title="Base class for all matrix/vector multiplication expression templates.The MatVecMultExpr class serves ...">MatVecMultExpr</a> class serves as a tag for all expression templates that implement a matrix/vector multiplication. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix/vector multiplication and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix/vector multiplication expression template. Only in case a class is derived from the <a class="el" href="../../db/de7/structblaze_1_1MatVecMultExpr.html" title="Base class for all matrix/vector multiplication expression templates.The MatVecMultExpr class serves ...">MatVecMultExpr</a> base class, the <a class="el" href="../../db/d84/structblaze_1_1IsMatVecMultExpr.html" title="Compile time check whether the given type is a matrix/vector multiplication expression template...">IsMatVecMultExpr</a> type trait recognizes the class as valid matrix/vector multiplication expression template.  <a href="../../db/de7/structblaze_1_1MatVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d14/structblaze_1_1Max.html">Max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time value evaluation.The <a class="el" href="../../dc/d14/structblaze_1_1Max.html" title="Compile time value evaluation.The Max class template selects the larger of the two given template arg...">Max</a> class template selects the larger of the two given template arguments <em>T1</em> and <em>T2</em>. In order for <a class="el" href="../../dc/d14/structblaze_1_1Max.html" title="Compile time value evaluation.The Max class template selects the larger of the two given template arg...">Max</a> to be able to determine the larger type, both arguments are required to have a nested member <em>value</em>. The result of the minimum operation can be accessed via the nested member <em>value</em>, the resulting type is available via the nested type <em>ValueType</em>.  <a href="../../dc/d14/structblaze_1_1Max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/classblaze_1_1MemoryPool.html">MemoryPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory pool for small objects.The memory pool efficiently improves the performance of dynamic memory allocations for small objects. By allocating a large block of memory that can be dynamically assigned to small objects, the memory allocation is reduced from a few hundred cycles to only a few cycles.<br />
The memory pool is build from memory blocks of type <a class="el" href="../../d2/d64/structblaze_1_1MemoryPool_1_1Block.html" title="Memory block within the memory bool. ">Block</a>, which hold the memory for a specified number of objects. The memory of these blocks is managed as a single free list.  <a href="../../d2/d8d/classblaze_1_1MemoryPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dee/structblaze_1_1Min.html">Min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time value evaluation.The <a class="el" href="../../dc/dee/structblaze_1_1Min.html" title="Compile time value evaluation.The Min class template selects the smaller of the two given template ar...">Min</a> class template selects the smaller of the two given template arguments <em>T1</em> and <em>T2</em>. In order for <a class="el" href="../../dc/dee/structblaze_1_1Min.html" title="Compile time value evaluation.The Min class template selects the smaller of the two given template ar...">Min</a> to be able to determine the smaller type, both arguments are required to have a nested member <em>value</em>. The result of the minimum operation can be accessed via the nested member <em>value</em>, the resulting type is available via the nested type <em>ValueType</em>.  <a href="../../dc/dee/structblaze_1_1Min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dc2/structblaze_1_1Minus.html">Minus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time integral subtraction.The <a class="el" href="../../dd/dc2/structblaze_1_1Minus.html" title="Compile time integral subtraction.The Minus class template returns the difference of the two given te...">Minus</a> class template returns the difference of the two given template arguments <em>T1</em> and <em>T2</em>. In order for <a class="el" href="../../dd/dc2/structblaze_1_1Minus.html" title="Compile time integral subtraction.The Minus class template returns the difference of the two given te...">Minus</a> to be able to subtract the two types, both arguments are required to have a nested member <em>value</em>. The result of the subtraction can be accessed via the nested member <em>value</em>, the resulting type is available via the nested type <em>ValueType</em>.  <a href="../../dd/dc2/structblaze_1_1Minus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/df5/structblaze_1_1Modulus.html">Modulus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time integral modulus operation.The <a class="el" href="../../db/df5/structblaze_1_1Modulus.html" title="Compile time integral modulus operation.The Modulus class template returns the result of a modulus op...">Modulus</a> class template returns the result of a modulus operation between the two given template arguments <em>T1</em> and <em>T2</em>. In order for <a class="el" href="../../db/df5/structblaze_1_1Modulus.html" title="Compile time integral modulus operation.The Modulus class template returns the result of a modulus op...">Modulus</a> to be able to perform the operation with the given two types, both arguments are required to have a nested member <em>value</em>. The result of the modulus operation can be accessed via the nested member <em>value</em>, the resulting type is available via the nested type <em>ValueType</em>.  <a href="../../db/df5/structblaze_1_1Modulus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dfd/structblaze_1_1MultExpr.html">MultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all multiplication expression templates.The <a class="el" href="../../df/dfd/structblaze_1_1MultExpr.html" title="Base class for all multiplication expression templates.The MultExpr class serves as a tag for all exp...">MultExpr</a> class serves as a tag for all expression templates that implement mathematical multiplications. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical multiplication (element-wise vector multiplications, matrix/vector multiplications, vector/matrix multiplications and matrix/matrix multiplications) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as multiplication expression template. Only in case a class is derived from the <a class="el" href="../../df/dfd/structblaze_1_1MultExpr.html" title="Base class for all multiplication expression templates.The MultExpr class serves as a tag for all exp...">MultExpr</a> base class, the <a class="el" href="../../d0/dd3/structblaze_1_1IsMultExpr.html" title="Compile time check whether the given type is a multiplication expression template.This type trait class tests whether or not the given type Type is a multiplication expression template (i.e. an expression representing an element-wise vector multiplication, a matrix/vector multiplication, a vector/matrix multiplication, or a matrix multiplication). In order to qualify as a valid multiplication expression template, the given type has to derive (publicly or privately) from the MultExpr base class. In case the given type is a valid multiplication expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMultExpr</a> type trait recognizes the class as valid multiplication expression template.  <a href="../../df/dfd/structblaze_1_1MultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the resulting expression type of a multiplication.Via this type trait it is possible to evaluate the return type of a multiplication expression between scalars, vectors, and matrices. Given the two types <em>T1</em> and <em>T2</em>, which must be either scalar, vector, or matrix types, the nested type <em>Type</em> corresponds to the resulting return type. In case <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be multiplied, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/da3/structblaze_1_1MultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class.  <a href="../../df/daf/structblaze_1_1MultTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative computation accuracy for floating point data types.The <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the negative computation accuracy of the Blaze library for any floating point data type. In order to assign a negative accuracy value, the <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.  <a href="../../da/d32/classblaze_1_1NegativeAccuracy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative epsilon value for floating point data types.The <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the negative smallest difference between two values of any floating point data type. In order to assign a negative epsilon value, the <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.  <a href="../../d9/d70/classblaze_1_1NegativeEpsilon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative infinity for built-in data types.The <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class to provide the possibility to assign negative infinity values to built-in data types. As negative infinity value, the largest possible negative value of the corresponding data type is used. In order to assign the negative infinity value, the <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> class can be implicitly converted to all signed integral and floating point data types:  <a href="../../db/da3/classblaze_1_1NegativeInfinity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc7/structblaze_1_1NoDelete.html">NoDelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-delete policy class.  <a href="../../d8/dc7/structblaze_1_1NoDelete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dbc/classblaze_1_1NonCopyable.html">NonCopyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for non-copyable class instances.The <a class="el" href="../../dd/dbc/classblaze_1_1NonCopyable.html" title="Base class for non-copyable class instances.The NonCopyable class is intended to work as a base class...">NonCopyable</a> class is intended to work as a base class for non-copyable classes. Both the copy constructor and the copy assignment operator are explicitly deleted in order to prohibit copy operations of the derived classes.<br />
.  <a href="../../dd/dbc/classblaze_1_1NonCopyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d8e/classblaze_1_1NonCreatable.html">NonCreatable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for non-creatable (static) classes.The <a class="el" href="../../d6/d8e/classblaze_1_1NonCreatable.html" title="Base class for non-creatable (static) classes.The NonCreatable class is intended to work as a base cl...">NonCreatable</a> class is intended to work as a base class for non-creatable classes, i.e. classes that cannot be instantiated and exclusively offer static functions/data. Both the standard as well as the copy constructor and the copy assignment operator are declared private and left undefinded in order to prohibit the instantiation of objects of derived classes.<br />
.  <a href="../../d6/d8e/classblaze_1_1NonCreatable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for symmetric, square matrices with non-numeric element types.The <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> provides controlled access to the elements of a non-const symmetric matrix with non-numeric element type (e.g. vectors or matrices). It guarantees that a modification of element <img class="formulaInl" alt="$ a_{ij} $" src="../../form_24.png"/> of the accessed matrix is also applied to element <img class="formulaInl" alt="$ a_{ji} $" src="../../form_25.png"/>. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> sparse symmetric matrix with <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a> elements:  <a href="../../d4/dcd/classblaze_1_1NonNumericProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d91/structblaze_1_1Noop.html">Noop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the null function.  <a href="../../d8/d91/structblaze_1_1Noop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type negation.The <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not class template negates the given compile time condition. In case the given condition would evaluate to true, the nested member enumeration is set to false and vice versa: ">Not</a> class template negates the given compile time condition. In case the given condition would evaluate to <em>true</em>, the nested member enumeration is set to <em>false</em> and vice versa:  <a href="../../dd/d46/structblaze_1_1Not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da4/classblaze_1_1NullType.html">NullType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type for generic codes.The <a class="el" href="../../dd/da4/classblaze_1_1NullType.html" title="Utility type for generic codes.The NullType class represents an invalid or terminating data type for ...">NullType</a> class represents an invalid or terminating data type for generic codes. For instance, the <a class="el" href="../../df/d88/structblaze_1_1TypeList.html" title="Implementation of a type list.The TypeList class is an implementation of a type list according to the...">TypeList</a> class uses the <a class="el" href="../../dd/da4/classblaze_1_1NullType.html" title="Utility type for generic codes.The NullType class represents an invalid or terminating data type for ...">NullType</a> as terminating data type for the type list.  <a href="../../dd/da4/classblaze_1_1NullType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d85/classblaze_1_1NumericProxy.html">NumericProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for symmetric, square matrices with numeric element types.The <a class="el" href="../../d2/d85/classblaze_1_1NumericProxy.html" title="Access proxy for symmetric, square matrices with numeric element types.The NumericProxy provides cont...">NumericProxy</a> provides controlled access to the elements of a non-const symmetric matrix with numeric element type (e.g. integral values, floating point values, and complex values). It guarantees that a modification of element <img class="formulaInl" alt="$ a_{ij} $" src="../../form_24.png"/> of the accessed matrix is also applied to element <img class="formulaInl" alt="$ a_{ji} $" src="../../form_25.png"/>. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> dense symmetric matrix:  <a href="../../d2/d85/classblaze_1_1NumericProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3f/structblaze_1_1OptimalGrowth.html">OptimalGrowth</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimal growth policy class.The <a class="el" href="../../d2/d3f/structblaze_1_1OptimalGrowth.html" title="Optimal growth policy class.The OptimalGrowth policy class implements the optimal growth strategy sug...">OptimalGrowth</a> policy class implements the optimal growth strategy suggested by Andrew Koenig for the std::vector class (see Andrew Koenig's column in the September 1998 issue of JOOP (Journal of Object-Oriented Programming), or the Dr. Dobb's article 'C++ Made Easier: How Vectors Grow', 2001). It applies an exponential growth strategy using a factor of 1.5 and additionally ensures that the sizes returns are always multiples of four.  <a href="../../d2/d3f/structblaze_1_1OptimalGrowth.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time logical or evaluation.The <a class="el" href="../../d3/d81/structblaze_1_1Or.html" title="Compile time logical or evaluation.The Or class template performs at compile time a logical or (&#39;&amp;&amp;&#39;)...">Or</a> class template performs at compile time a logical or ('&amp;&amp;') evaluation of at least two compile time conditions:  <a href="../../d3/d81/structblaze_1_1Or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d25/classblaze_1_1ParallelSection.html">ParallelSection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Section for the debugging of the shared-memory parallelization.The <a class="el" href="../../d3/d25/classblaze_1_1ParallelSection.html" title="Section for the debugging of the shared-memory parallelization.The ParallelSection class is an auxili...">ParallelSection</a> class is an auxiliary helper class for the <em>BLAZE_PARALLEL_SECTION</em> macro. It provides the functionality to detected whether a parallel section has been started and with that serves as a utility for debugging the shared-memory parallelization.  <a href="../../d3/d25/classblaze_1_1ParallelSection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd1/structblaze_1_1Plus.html">Plus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time integral addition.The <a class="el" href="../../d4/dd1/structblaze_1_1Plus.html" title="Compile time integral addition.The Plus class template returns the sum of the two given template argu...">Plus</a> class template returns the sum of the two given template arguments <em>T1</em> and <em>T2</em>. In order for <a class="el" href="../../d4/dd1/structblaze_1_1Plus.html" title="Compile time integral addition.The Plus class template returns the sum of the two given template argu...">Plus</a> to be able to add the two types, both arguments are required to have a nested member <em>value</em>. The result of the addition can be accessed via the nested member <em>value</em>, the resulting type is available via the nested type <em>ValueType</em>.  <a href="../../d4/dd1/structblaze_1_1Plus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d41/structblaze_1_1Pow.html">Pow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga04b65a79150f5e9e3118257b2f77a0ed" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a> function.  <a href="../../d3/d41/structblaze_1_1Pow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> base class.The <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class is a base class for all proxy classes within the <b>Blaze</b> library that may represent non-numeric data types (vectors, matrices, ...). It augments the interface of the deriving proxy class depending on the data type represented by the proxy. In addition, it provides an abstraction from the actual type of the proxy, but enables a type-safe conversion back to this type via the 'Curiously Recurring Template Pattern' (CRTP).  <a href="../../de/df9/classblaze_1_1Proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html">PtrDelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer-delete policy class.The <a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html" title="Pointer-delete policy class.The PtrDelete policy functor class applies a delete operation to the give...">PtrDelete</a> policy functor class applies a delete operation to the given argument. Note that the delete operation is NOT permitted for inclomplete types (i.e. declared but undefined data types). The attempt to apply a <a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html" title="Pointer-delete policy class.The PtrDelete policy functor class applies a delete operation to the give...">PtrDelete</a> functor to a pointer to an object of incomplete type results in a compile time error!  <a href="../../d9/d94/structblaze_1_1PtrDelete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8c/classblaze_1_1ptrdiff__t.html">ptrdiff_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer difference type of the Blaze library.  <a href="../../d2/d8c/classblaze_1_1ptrdiff__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of an iterator for pointer vectors.The <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> class follows the example of the random-access iterator classes of the STL. However, the focus of this iterator implementation is the use with (polymorphic) pointers. The implementation of the Blaze library eases the use of iterators over a range of pointers and improves the semantics on these pointers.<br />
.  <a href="../../d2/d15/classblaze_1_1PtrIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a vector for (polymorphic) pointers.  <a href="../../d3/ddf/classblaze_1_1PtrVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dca/classblaze_1_1Rand.html">Rand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the <a class="el" href="../../db/dca/classblaze_1_1Rand.html" title="Default implementation of the Rand class for integral data types.This default implementation of the R...">Rand</a> class for integral data types.This default implementation of the <a class="el" href="../../db/dca/classblaze_1_1Rand.html" title="Default implementation of the Rand class for integral data types.This default implementation of the R...">Rand</a> class creates random, integral numbers in the range <img class="formulaInl" alt="$ [0..max] $" src="../../form_186.png"/>, where <em>max</em> is the maximal value of the given data type <em>T</em>.  <a href="../../db/dca/classblaze_1_1Rand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc4/classblaze_1_1Random.html">Random</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/dc4/classblaze_1_1Random.html" title="Random number generator.The Random class encapsulates the initialization of the given random number g...">Random</a> number generator.The <a class="el" href="../../d0/dc4/classblaze_1_1Random.html" title="Random number generator.The Random class encapsulates the initialization of the given random number g...">Random</a> class encapsulates the initialization of the given random number generator with a pseudo-random seed obtained by the std::time() function. Currently, the mersenne-twister mt19937 as provided by the C++ standard library is used per default. For more information see the for instance the following documentation of the random number functionality of the C++11 standard library:  <a href="../../d0/dc4/classblaze_1_1Random.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db0/structblaze_1_1Rank.html">Rank</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for array ranks.This type trait determines the rank of the given template argument. In case the given type is an array type, the nested <em>value</em> member constant is set to the number of dimensions of <em>T</em>. Otherwise <em>value</em> is set to 0.  <a href="../../df/db0/structblaze_1_1Rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/df4/structblaze_1_1Real.html">Real</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga146e7401b84cc73dc213edc50bf3a236" title="Returns a matrix containing the real part of each single element of dm. ">real()</a> function.  <a href="../../dd/df4/structblaze_1_1Real.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html">RealTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html" title="Base template for the RealTrait class.The RealTrait class template offers the possibility to select t...">RealTrait</a> class.The <a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html" title="Base template for the RealTrait class.The RealTrait class template offers the possibility to select t...">RealTrait</a> class template offers the possibility to select the resulting data type of a generic <em>real</em> operation on the given type <em>T</em>. Given the type <em>T</em>, which must either be a scalar, vector, or matrix type, the nested type <em>Type</em> corresponds to the resulting data type of the operation. In case the type of <em>T</em> doesn't fit or if no <em>real</em> operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>. Note that <em>const</em> and <em>volatile</em> qualifiers and reference modifiers are generally ignored.  <a href="../../dd/d50/structblaze_1_1RealTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d06/structblaze_1_1Rebind.html">Rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/d06/structblaze_1_1Rebind.html" title="Rebind mechanism to obtain a CompressedMatrix with different data/element type. ">Rebind</a> mechanism to obtain a <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">CompressedMatrix</a> with different data/element type.  <a href="../../de/d06/structblaze_1_1Rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html">RemoveAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of top level adaptor types.In case the given type is an adaptor type (<a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html" title="Matrix adapter for symmetric  matrices. ">SymmetricMatrix</a>, <a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html" title="Matrix adapter for lower triangular  matrices. ">LowerMatrix</a>, <a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html" title="Matrix adapter for upper triangular  matrices. ">UpperMatrix</a>, ...), the <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html" title="Removal of top level adaptor types.In case the given type is an adaptor type (SymmetricMatrix, LowerMatrix, UpperMatrix, ...), the RemoveAdaptor type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved. ">RemoveAdaptor</a> type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved.  <a href="../../d2/d34/structblaze_1_1RemoveAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html">RemoveAllExtents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of all array extents.The <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html" title="Removal of all array extents.The RemoveAllExtents type trait removes all array extents from the given...">RemoveAllExtents</a> type trait removes all array extents from the given type <em>T</em>.  <a href="../../de/d59/structblaze_1_1RemoveAllExtents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html">RemoveConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of const-qualifiers.The <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> type trait removes all top level 'const' qualifiers from the given type <em>T</em>.  <a href="../../d9/d25/structblaze_1_1RemoveConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html">RemoveCV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of top level cv-qualifiers.The <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait removes all top level cv-qualifiers from the given type <em>T</em>.  <a href="../../d0/d1c/structblaze_1_1RemoveCV.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html">RemoveExtent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of the top level array extent.The <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html" title="Removal of the top level array extent.The RemoveExtent type trait removes the top level array extent ...">RemoveExtent</a> type trait removes the top level array extent from the given type <em>T</em>.  <a href="../../d7/d88/structblaze_1_1RemoveExtent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html">RemovePointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of pointer modifiers.The <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html" title="Removal of pointer modifiers.The RemovePointer type trait removes any pointer modifiers from the give...">RemovePointer</a> type trait removes any pointer modifiers from the given type <em>T</em>.  <a href="../../df/d04/structblaze_1_1RemovePointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html">RemoveReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of reference modifiers.The <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html" title="Removal of reference modifiers.The RemoveReference type trait removes any reference modifiers from th...">RemoveReference</a> type trait removes any reference modifiers from the given type <em>T</em>.  <a href="../../d5/df4/structblaze_1_1RemoveReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html">RemoveVolatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of volatile-qualifiers.The <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> type trait removes all top level 'volatile' qualifiers from the given type <em>T</em>.  <a href="../../d9/de6/structblaze_1_1RemoveVolatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">RequiresEvaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check to query the requirement to evaluate an expression.Via this type trait it is possible to determine whether a given vector or matrix expression type requires an intermediate evaluation in the context of a compound expression. In case the given type requires an evaluation, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/df1/structblaze_1_1RequiresEvaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d83/structblaze_1_1Round.html">Round</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a> function.  <a href="../../de/d83/structblaze_1_1Round.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d67/classblaze_1_1Row.html">Row</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a specific row of a dense or sparse matrix.The <a class="el" href="../../d2/d67/classblaze_1_1Row.html" title="Reference to a specific row of a dense or sparse matrix.The Row template represents a reference to a ...">Row</a> template represents a reference to a specific row of a dense or sparse matrix primitive. The type of the matrix is specified via the first template parameter:  <a href="../../d2/d67/classblaze_1_1Row.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d25/structblaze_1_1RowExprTrait.html">RowExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type type of a row operation.Via this type trait it is possible to evaluate the return type of a row operation. Given the dense or sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting return type. In case the given type is neither a dense nor a sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d25/structblaze_1_1RowExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/structblaze_1_1Rows.html">Rows</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time evaluation of the number of rows of a matrix.The <a class="el" href="../../d2/d38/structblaze_1_1Rows.html" title="Compile time evaluation of the number of rows of a matrix.The Rows type trait evaluates the number of...">Rows</a> type trait evaluates the number of rows of the given matrix type at compile time. In case the given type <em>T</em> is a matrix type with a fixed number of rows (e.g. <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a>), the <em>value</em> member constant is set to the according number of rows. In all other cases, <em>value</em> is set to 0.  <a href="../../d2/d38/structblaze_1_1Rows.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html">RowTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html" title="Base template for the RowTrait class. ">RowTrait</a> class.  <a href="../../df/d8f/structblaze_1_1RowTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d25/structblaze_1_1Serial.html">Serial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../df/d25/structblaze_1_1Serial.html#a87370ca3b676f2455061e7380732746d" title="Default constructor of the Serial functor. ">Serial()</a> function.  <a href="../../df/d25/structblaze_1_1Serial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7c/structblaze_1_1SerialExpr.html">SerialExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all serial evaluation expression templates.The <a class="el" href="../../d5/d7c/structblaze_1_1SerialExpr.html" title="Base class for all serial evaluation expression templates.The SerialExpr class serves as a tag for al...">SerialExpr</a> class serves as a tag for all expression templates that enforce a serial evaluation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a serialization operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as serial evaluation expression template. Only in case a class is derived from the <a class="el" href="../../d5/d7c/structblaze_1_1SerialExpr.html" title="Base class for all serial evaluation expression templates.The SerialExpr class serves as a tag for al...">SerialExpr</a> base class, the <a class="el" href="../../d8/d47/structblaze_1_1IsSerialExpr.html" title="Compile time check whether the given type is a serial evaluation expression template.This type trait class tests whether or not the given type Type is a serial evaluation expression template. In order to qualify as a valid serial evaluation expression template, the given type has to derive (publicly or privately) from the SerialExpr base class. In case the given type is a valid serial evaluation expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsSerialExpr</a> type trait recognizes the class as valid serial evaluation expression template.  <a href="../../d5/d7c/structblaze_1_1SerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de8/structblaze_1_1SerialExprTrait.html">SerialExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a serial evaluation expression.Via this type trait it is possible to evaluate the return type of a serial evaluation expression. Given the type <em>T</em>, which must either be a vector or matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no serial evaluation operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/de8/structblaze_1_1SerialExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/ddb/classblaze_1_1SerialSection.html">SerialSection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Section to enforce the serial execution of operations.The <a class="el" href="../../d5/ddb/classblaze_1_1SerialSection.html" title="Section to enforce the serial execution of operations.The SerialSection class is an auxiliary helper ...">SerialSection</a> class is an auxiliary helper class for the <em>BLAZE_SERIAL_SECTION</em> macro. It provides the functionality to detect whether a serial section is active, i.e. if the currently executed code is inside a serial section.  <a href="../../d5/ddb/classblaze_1_1SerialSection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d20/classblaze_1_1SharedValue.html">SharedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value shared among several positions within a symmetric matrix.The <a class="el" href="../../d2/d20/classblaze_1_1SharedValue.html" title="Value shared among several positions within a symmetric matrix.The SharedValue class template represe...">SharedValue</a> class template represents a single value of a symmetric matrix that is shared among several positions within the symmetric matrix. Changes to the value of one position are therefore applied to all positions sharing the same value.  <a href="../../d2/d20/classblaze_1_1SharedValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 64-bit double precision complex values.  <a href="../../da/d3e/classblaze_1_1SIMDcdouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 32-bit single precision complex values.  <a href="../../d4/dd2/classblaze_1_1SIMDcfloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d30/classblaze_1_1SIMDcint16.html">SIMDcint16</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 16-bit signed integral complex values.  <a href="../../db/d30/classblaze_1_1SIMDcint16.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d39/classblaze_1_1SIMDcint32.html">SIMDcint32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 32-bit signed integral complex values.  <a href="../../dc/d39/classblaze_1_1SIMDcint32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/df7/classblaze_1_1SIMDcint64.html">SIMDcint64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 64-bit signed integral complex values.  <a href="../../d7/df7/classblaze_1_1SIMDcint64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/db1/classblaze_1_1SIMDcint8.html">SIMDcint8</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 8-bit signed integral complex values.  <a href="../../d8/db1/classblaze_1_1SIMDcint8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d8d/classblaze_1_1SIMDcuint16.html">SIMDcuint16</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 16-bit unsigned integral complex values.  <a href="../../dc/d8d/classblaze_1_1SIMDcuint16.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d64/classblaze_1_1SIMDcuint32.html">SIMDcuint32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 32-bit unsigned integral complex values.  <a href="../../df/d64/classblaze_1_1SIMDcuint32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/ddd/classblaze_1_1SIMDcuint64.html">SIMDcuint64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 64-bit unsigned integral complex values.  <a href="../../de/ddd/classblaze_1_1SIMDcuint64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db5/classblaze_1_1SIMDcuint8.html">SIMDcuint8</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 8-bit unsigned integral complex values.  <a href="../../df/db5/classblaze_1_1SIMDcuint8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 64-bit double precision floating point data values.  <a href="../../d2/d94/classblaze_1_1SIMDdouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d53/structblaze_1_1SIMDf32FmaddExpr.html">SIMDf32FmaddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for 32-bit floating point fused multiply-add operations.The <a class="el" href="../../d9/d53/structblaze_1_1SIMDf32FmaddExpr.html" title="Expression object for 32-bit floating point fused multiply-add operations.The SIMDf32FmaddExpr class ...">SIMDf32FmaddExpr</a> class represents the compile time expression for 32-bit floating point fused multiply-add operations.  <a href="../../d9/d53/structblaze_1_1SIMDf32FmaddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/da1/structblaze_1_1SIMDf32FmsubExpr.html">SIMDf32FmsubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for 32-bit floating point fused multiply-subtract operations.The <a class="el" href="../../d8/da1/structblaze_1_1SIMDf32FmsubExpr.html" title="Expression object for 32-bit floating point fused multiply-subtract operations.The SIMDf32FmsubExpr c...">SIMDf32FmsubExpr</a> class represents the compile time expression for 32-bit floating point fused multiply-subtract operations.  <a href="../../d8/da1/structblaze_1_1SIMDf32FmsubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d1a/structblaze_1_1SIMDf32MultExpr.html">SIMDf32MultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for 32-bit floating point multiplication operations.The <a class="el" href="../../df/d1a/structblaze_1_1SIMDf32MultExpr.html" title="Expression object for 32-bit floating point multiplication operations.The SIMDf32MultExpr class repre...">SIMDf32MultExpr</a> class represents the compile time expression for 32-bit floating point multiplication operations.  <a href="../../df/d1a/structblaze_1_1SIMDf32MultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d47/structblaze_1_1SIMDf64FmaddExpr.html">SIMDf64FmaddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for fusing a 32-bit floating point multiplication and addition.  <a href="../../d0/d47/structblaze_1_1SIMDf64FmaddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d44/structblaze_1_1SIMDf64FmsubExpr.html">SIMDf64FmsubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for 64-bit floating point fused multiply-subtract operations.The <a class="el" href="../../de/d44/structblaze_1_1SIMDf64FmsubExpr.html" title="Expression object for 64-bit floating point fused multiply-subtract operations.The SIMDf64FmsubExpr c...">SIMDf64FmsubExpr</a> class represents the compile time expression for 64-bit floating point fused multiply-subtract operations.  <a href="../../de/d44/structblaze_1_1SIMDf64FmsubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da9/structblaze_1_1SIMDf64MultExpr.html">SIMDf64MultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for 64-bit floating point multiplication operations.The <a class="el" href="../../d1/da9/structblaze_1_1SIMDf64MultExpr.html" title="Expression object for 64-bit floating point multiplication operations.The SIMDf64MultExpr class repre...">SIMDf64MultExpr</a> class represents the compile time expression for 64-bit floating point multiplication operations.  <a href="../../d1/da9/structblaze_1_1SIMDf64MultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 32-bit single precision floating point data values.  <a href="../../d2/dba/classblaze_1_1SIMDfloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4c/classblaze_1_1SIMDint16.html">SIMDint16</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 16-bit signed integral data values.  <a href="../../d5/d4c/classblaze_1_1SIMDint16.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dca/classblaze_1_1SIMDint32.html">SIMDint32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 32-bit signed integral data values.  <a href="../../db/dca/classblaze_1_1SIMDint32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d16/classblaze_1_1SIMDint64.html">SIMDint64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 64-bit integral data values.  <a href="../../d0/d16/classblaze_1_1SIMDint64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classblaze_1_1SIMDint8.html">SIMDint8</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 8-bit signed integral data values.  <a href="../../d0/df2/classblaze_1_1SIMDint8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d96/structblaze_1_1SIMDPack.html">SIMDPack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all SIMD data types.The <a class="el" href="../../d4/d96/structblaze_1_1SIMDPack.html" title="Base class for all SIMD data types.The SIMDPack class template is a base class for all SIMD data type...">SIMDPack</a> class template is a base class for all SIMD data types within the Blaze library. It provides an abstraction from the actual type of the SIMD pack, but enables a conversion back to this type via the 'Curiously Recurring Template Pattern' (CRTP).  <a href="../../d4/d96/structblaze_1_1SIMDPack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD characteristics of data types.The <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html" title="SIMD characteristics of data types.The SIMDTrait class template provides the SIMD characteristics of ...">SIMDTrait</a> class template provides the SIMD characteristics of a specific data type:  <a href="../../d4/ddb/classblaze_1_1SIMDTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d05/classblaze_1_1SIMDuint16.html">SIMDuint16</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 16-bit unsigned integral data values.  <a href="../../d5/d05/classblaze_1_1SIMDuint16.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d06/classblaze_1_1SIMDuint32.html">SIMDuint32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 32-bit unsigned integral data values.  <a href="../../d8/d06/classblaze_1_1SIMDuint32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d32/classblaze_1_1SIMDuint64.html">SIMDuint64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 64-bit unsigned integral data values.  <a href="../../d1/d32/classblaze_1_1SIMDuint64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d00/classblaze_1_1SIMDuint8.html">SIMDuint8</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type for 8-bit unsigned integral data values.  <a href="../../dd/d00/classblaze_1_1SIMDuint8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d56/structblaze_1_1Sin.html">Sin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga0a06568d5cd7314f4a0995a051d68062" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a> function.  <a href="../../de/d56/structblaze_1_1Sin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8d/classblaze_1_1Singleton.html">Singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all lifetime managed singletons.The <a class="el" href="../../d4/d8d/classblaze_1_1Singleton.html" title="Base class for all lifetime managed singletons.The Singleton class represents the base class for all ...">Singleton</a> class represents the base class for all lifetime managed singletons of the Blaze library. Classes, which are supposed to be implemented in terms of the singleton pattern, only have to derive from this class in order to gain all basic characteristics of a singleton:  <a href="../../d4/d8d/classblaze_1_1Singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d59/structblaze_1_1Sinh.html">Sinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga4111317de20c08c0a40b10182eee2539" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a> function.  <a href="../../d4/d59/structblaze_1_1Sinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d5d/structblaze_1_1Size.html">Size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time evaluation of the size of a vector.The <a class="el" href="../../df/d5d/structblaze_1_1Size.html" title="Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...">Size</a> type trait evaluates the size of the given vector type at compile time. In case the given type <em>T</em> is a vector type with a fixed size (e.g. <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a>), the <em>value</em> member constant is set to the according size. In all other cases, <em>value</em> is set to 0.  <a href="../../df/d5d/structblaze_1_1Size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../df/d5d/structblaze_1_1Size.html" title="Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...">Size</a> type of the Blaze library.  <a href="../../d9/dcd/classblaze_1_1size__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d4d/structblaze_1_1SizeT.html">SizeT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time integral constant wrapper for <em><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html" title="Size type of the Blaze library. ">size_t</a></em>.The <a class="el" href="../../d1/d4d/structblaze_1_1SizeT.html" title="Compile time integral constant wrapper for size_t.The SizeT class template represents an integral wra...">SizeT</a> class template represents an integral wrapper for a compile time constant expression of type <em><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html" title="Size type of the Blaze library. ">size_t</a></em>. The value of an <a class="el" href="../../d1/d4d/structblaze_1_1SizeT.html" title="Compile time integral constant wrapper for size_t.The SizeT class template represents an integral wra...">SizeT</a> can be accessed via the nested <em>value</em> (which is guaranteed to be of type <em><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html" title="Size type of the Blaze library. ">size_t</a></em>), the type can be accessed via the nested type definition <em>ValueType</em>.  <a href="../../d1/d4d/structblaze_1_1SizeT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dad/structblaze_1_1SMatCTransExprTrait.html">SMatCTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix conjugate transpose operation. Given the row-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d9/dad/structblaze_1_1SMatCTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d98/classblaze_1_1SMatDeclDiagExpr.html">SMatDeclDiagExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the explicit diagonal declaration of sparse matrices.The <a class="el" href="../../d1/d98/classblaze_1_1SMatDeclDiagExpr.html" title="Expression object for the explicit diagonal declaration of sparse matrices.The SMatDeclDiagExpr class...">SMatDeclDiagExpr</a> class represents the compile time expression for the explicit diagonal declaration of a sparse matrix.  <a href="../../d1/d98/classblaze_1_1SMatDeclDiagExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d70/structblaze_1_1SMatDeclDiagExprTrait.html">SMatDeclDiagExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix decldiag operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix decldiag operation. Given the row-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d70/structblaze_1_1SMatDeclDiagExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d8a/classblaze_1_1SMatDeclHermExpr.html">SMatDeclHermExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the explicit Hermitian declaration of sparse matrices.The <a class="el" href="../../d9/d8a/classblaze_1_1SMatDeclHermExpr.html" title="Expression object for the explicit Hermitian declaration of sparse matrices.The SMatDeclHermExpr clas...">SMatDeclHermExpr</a> class represents the compile time expression for the explicit Hermitian declaration of a sparse matrix.  <a href="../../d9/d8a/classblaze_1_1SMatDeclHermExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d9f/structblaze_1_1SMatDeclHermExprTrait.html">SMatDeclHermExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix declherm operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix declherm operation. Given the row-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d9f/structblaze_1_1SMatDeclHermExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d3c/classblaze_1_1SMatDeclLowExpr.html">SMatDeclLowExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the explicit lower declaration of sparse matrices.The <a class="el" href="../../d3/d3c/classblaze_1_1SMatDeclLowExpr.html" title="Expression object for the explicit lower declaration of sparse matrices.The SMatDeclLowExpr class rep...">SMatDeclLowExpr</a> class represents the compile time expression for the explicit lower declaration of a sparse matrix.  <a href="../../d3/d3c/classblaze_1_1SMatDeclLowExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de6/structblaze_1_1SMatDeclLowExprTrait.html">SMatDeclLowExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix decllow operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix decllow operation. Given the row-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/de6/structblaze_1_1SMatDeclLowExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da0/classblaze_1_1SMatDeclSymExpr.html">SMatDeclSymExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the explicit symmetry declaration of sparse matrices.The <a class="el" href="../../da/da0/classblaze_1_1SMatDeclSymExpr.html" title="Expression object for the explicit symmetry declaration of sparse matrices.The SMatDeclSymExpr class ...">SMatDeclSymExpr</a> class represents the compile time expression for the explicit symmetry declaration of a sparse matrix.  <a href="../../da/da0/classblaze_1_1SMatDeclSymExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dc2/structblaze_1_1SMatDeclSymExprTrait.html">SMatDeclSymExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix declsym operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix declsym operation. Given the row-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/dc2/structblaze_1_1SMatDeclSymExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/df5/classblaze_1_1SMatDeclUppExpr.html">SMatDeclUppExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the explicit upper declaration of sparse matrices.The <a class="el" href="../../d5/df5/classblaze_1_1SMatDeclUppExpr.html" title="Expression object for the explicit upper declaration of sparse matrices.The SMatDeclUppExpr class rep...">SMatDeclUppExpr</a> class represents the compile time expression for the explicit upper declaration of a sparse matrix.  <a href="../../d5/df5/classblaze_1_1SMatDeclUppExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d5a/structblaze_1_1SMatDeclUppExprTrait.html">SMatDeclUppExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix declupp operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix declupp operation. Given the row-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d5a/structblaze_1_1SMatDeclUppExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d14/structblaze_1_1SMatDMatAddExprTrait.html">SMatDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/dense matrix addition. Given the row-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d14/structblaze_1_1SMatDMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc5/classblaze_1_1SMatDMatMultExpr.html">SMatDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-dense matrix multiplications.The <a class="el" href="../../d6/dc5/classblaze_1_1SMatDMatMultExpr.html" title="Expression object for sparse matrix-dense matrix multiplications.The SMatDMatMultExpr class represent...">SMatDMatMultExpr</a> class represents the compile time expression for multiplications between a row-major sparse matrix and a row-major dense matrix.  <a href="../../d6/dc5/classblaze_1_1SMatDMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d14/structblaze_1_1SMatDMatMultExprTrait.html">SMatDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/dense matrix multiplication. Given the row-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d14/structblaze_1_1SMatDMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db6/classblaze_1_1SMatDMatSubExpr.html">SMatDMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-dense matrix subtractions.The <a class="el" href="../../df/db6/classblaze_1_1SMatDMatSubExpr.html" title="Expression object for sparse matrix-dense matrix subtractions.The SMatDMatSubExpr class represents th...">SMatDMatSubExpr</a> class represents the compile time expression for subtractions between a sparse matrix and a dense matrix with identical storage order.  <a href="../../df/db6/classblaze_1_1SMatDMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d1a/structblaze_1_1SMatDMatSubExprTrait.html">SMatDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/dense matrix subtraction. Given the row-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../df/d1a/structblaze_1_1SMatDMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d53/classblaze_1_1SMatDVecMultExpr.html">SMatDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-dense vector multiplications.The <a class="el" href="../../d5/d53/classblaze_1_1SMatDVecMultExpr.html" title="Expression object for sparse matrix-dense vector multiplications.The SMatDVecMultExpr class represent...">SMatDVecMultExpr</a> class represents the compile time expression for multiplications between row-major sparse matrices and dense vectors.  <a href="../../d5/d53/classblaze_1_1SMatDVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d40/structblaze_1_1SMatDVecMultExprTrait.html">SMatDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/dense vector multiplication. Given the row-major sparse matrix type <em>MT</em> and the non-transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major sparse matrix type or <em>VT</em> is not a non-transpose dense vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d40/structblaze_1_1SMatDVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da4/classblaze_1_1SMatEvalExpr.html">SMatEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the forced evaluation of sparse matrices.The <a class="el" href="../../df/da4/classblaze_1_1SMatEvalExpr.html" title="Expression object for the forced evaluation of sparse matrices.The SMatEvalExpr class represents the ...">SMatEvalExpr</a> class represents the compile time expression for the forced evaluation of a sparse matrix.  <a href="../../df/da4/classblaze_1_1SMatEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d64/structblaze_1_1SMatEvalExprTrait.html">SMatEvalExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix evaluation operation. Given the row-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d5/d64/structblaze_1_1SMatEvalExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the sparse matrix <a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a> function.The <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html" title="Expression object for the sparse matrix forEach() function.The SMatForEachExpr class represents the c...">SMatForEachExpr</a> class represents the compile time expression for the evaluation of a custom operation on each element of a sparse matrix via the <a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a> function.  <a href="../../d8/d35/classblaze_1_1SMatForEachExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d0f/structblaze_1_1SMatForEachExprTrait.html">SMatForEachExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix for-each operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix for-each operation. Given the row-major sparse matrix type <em>MT</em> and the custom operation type <em>OP</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/d0f/structblaze_1_1SMatForEachExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da4/classblaze_1_1SMatScalarDivExpr.html">SMatScalarDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-scalar divisions.The SMatScalarMult class represents the compile time expression for divisions between a sparse matrix and a scalar value.  <a href="../../df/da4/classblaze_1_1SMatScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d46/structblaze_1_1SMatScalarDivExprTrait.html">SMatScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/scalar division. Given the row-major sparse matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major sparse matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/d46/structblaze_1_1SMatScalarDivExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d6e/classblaze_1_1SMatScalarMultExpr.html">SMatScalarMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-scalar multiplications.The SMatScalarMult class represents the compile time expression for multiplications between a sparse matrix and a scalar value.  <a href="../../db/d6e/classblaze_1_1SMatScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d4d/structblaze_1_1SMatScalarMultExprTrait.html">SMatScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/scalar multiplication. Given the row-major sparse matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major sparse matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d4d/structblaze_1_1SMatScalarMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc8/classblaze_1_1SMatSerialExpr.html">SMatSerialExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the forced serial evaluation of sparse matrices.The <a class="el" href="../../d8/dc8/classblaze_1_1SMatSerialExpr.html" title="Expression object for the forced serial evaluation of sparse matrices.The SMatSerialExpr class repres...">SMatSerialExpr</a> class represents the compile time expression for the forced serial evaluation of a sparse matrix.  <a href="../../d8/dc8/classblaze_1_1SMatSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d8f/structblaze_1_1SMatSerialExprTrait.html">SMatSerialExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix serial evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix serial evaluation operation. Given the row-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../da/d8f/structblaze_1_1SMatSerialExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d18/classblaze_1_1SMatSMatAddExpr.html">SMatSMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-sparse matrix additions.The <a class="el" href="../../d4/d18/classblaze_1_1SMatSMatAddExpr.html" title="Expression object for sparse matrix-sparse matrix additions.The SMatSMatAddExpr class represents the ...">SMatSMatAddExpr</a> class represents the compile time expression for additions between two row-major sparse matrices.  <a href="../../d4/d18/classblaze_1_1SMatSMatAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d9c/structblaze_1_1SMatSMatAddExprTrait.html">SMatSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/sparse matrix addition. Given the two row-major sparse matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a row-major sparse matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/d9c/structblaze_1_1SMatSMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d13/classblaze_1_1SMatSMatMultExpr.html">SMatSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-sparse matrix multiplications.The <a class="el" href="../../db/d13/classblaze_1_1SMatSMatMultExpr.html" title="Expression object for sparse matrix-sparse matrix multiplications.The SMatSMatMultExpr class represen...">SMatSMatMultExpr</a> class represents the compile time expression for multiplications between row-major sparse matrices.  <a href="../../db/d13/classblaze_1_1SMatSMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d59/structblaze_1_1SMatSMatMultExprTrait.html">SMatSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/sparse matrix multiplication. Given the two row-major sparse matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a row-major sparse matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../da/d59/structblaze_1_1SMatSMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d92/classblaze_1_1SMatSMatSubExpr.html">SMatSMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-sparse matrix subtractions.The <a class="el" href="../../d0/d92/classblaze_1_1SMatSMatSubExpr.html" title="Expression object for sparse matrix-sparse matrix subtractions.The SMatSMatSubExpr class represents t...">SMatSMatSubExpr</a> class represents the compile time expression for subtractions between sparse matrices.  <a href="../../d0/d92/classblaze_1_1SMatSMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/structblaze_1_1SMatSMatSubExprTrait.html">SMatSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/sparse matrix subtraction. Given the two row-major sparse matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a row-major sparse matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/d43/structblaze_1_1SMatSMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dbf/classblaze_1_1SMatSVecMultExpr.html">SMatSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-sparse vector multiplications.The <a class="el" href="../../d6/dbf/classblaze_1_1SMatSVecMultExpr.html" title="Expression object for sparse matrix-sparse vector multiplications.The SMatSVecMultExpr class represen...">SMatSVecMultExpr</a> class represents the compile time expression for multiplications between row-major sparse matrices and sparse vectors.  <a href="../../d6/dbf/classblaze_1_1SMatSVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d35/structblaze_1_1SMatSVecMultExprTrait.html">SMatSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/sparse vector multiplication. Given the row-major sparse matrix type <em>MT</em> and the non-transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major sparse matrix type or <em>VT</em> is not a non-transpose sparse vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d35/structblaze_1_1SMatSVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d9f/structblaze_1_1SMatTDMatAddExprTrait.html">SMatTDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/transpose dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose dense matrix addition. Given the row-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/d9f/structblaze_1_1SMatTDMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d43/classblaze_1_1SMatTDMatMultExpr.html">SMatTDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-transpose dense matrix multiplications.The <a class="el" href="../../dd/d43/classblaze_1_1SMatTDMatMultExpr.html" title="Expression object for sparse matrix-transpose dense matrix multiplications.The SMatTDMatMultExpr clas...">SMatTDMatMultExpr</a> class represents the compile time expression for multiplications between a row-major sparse matrix and a column-major dense matrix.  <a href="../../dd/d43/classblaze_1_1SMatTDMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d9d/structblaze_1_1SMatTDMatMultExprTrait.html">SMatTDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose dense matrix multiplication. Given the row-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d9d/structblaze_1_1SMatTDMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de7/classblaze_1_1SMatTDMatSubExpr.html">SMatTDMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-transpose dense matrix subtractions.The <a class="el" href="../../d5/de7/classblaze_1_1SMatTDMatSubExpr.html" title="Expression object for sparse matrix-transpose dense matrix subtractions.The SMatTDMatSubExpr class re...">SMatTDMatSubExpr</a> class represents the compile time expression for subtractions between a row-major sparse matrix and a column-major dense matrix.  <a href="../../d5/de7/classblaze_1_1SMatTDMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d76/structblaze_1_1SMatTDMatSubExprTrait.html">SMatTDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/transpose dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose dense matrix subtraction. Given the row-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d9/d76/structblaze_1_1SMatTDMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d09/classblaze_1_1SMatTransExpr.html">SMatTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix transpositions.The <a class="el" href="../../da/d09/classblaze_1_1SMatTransExpr.html" title="Expression object for sparse matrix transpositions.The SMatTransExpr class represents the compile tim...">SMatTransExpr</a> class represents the compile time expression for transpositions of sparse matrices.  <a href="../../da/d09/classblaze_1_1SMatTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/da2/structblaze_1_1SMatTransExprTrait.html">SMatTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix transpose operation. Given the row-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a row-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/da2/structblaze_1_1SMatTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dbd/classblaze_1_1SMatTransposer.html">SMatTransposer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the transposition of a sparse matrix.The <a class="el" href="../../de/dbd/classblaze_1_1SMatTransposer.html" title="Expression object for the transposition of a sparse matrix.The SMatTransposer class is a wrapper obje...">SMatTransposer</a> class is a wrapper object for the temporary transposition of a sparse matrix.  <a href="../../de/dbd/classblaze_1_1SMatTransposer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d9c/classblaze_1_1SMatTSMatAddExpr.html">SMatTSMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-transpose sparse matrix additions.The <a class="el" href="../../d6/d9c/classblaze_1_1SMatTSMatAddExpr.html" title="Expression object for sparse matrix-transpose sparse matrix additions.The SMatTSMatAddExpr class repr...">SMatTSMatAddExpr</a> class represents the compile time expression for additions between a row-major sparse matrix and a column-major sparse matrix.  <a href="../../d6/d9c/classblaze_1_1SMatTSMatAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d48/structblaze_1_1SMatTSMatAddExprTrait.html">SMatTSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/transpose sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose sparse matrix addition. Given the row-major sparse matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d48/structblaze_1_1SMatTSMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc8/classblaze_1_1SMatTSMatMultExpr.html">SMatTSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-transpose sparse matrix multiplications.The <a class="el" href="../../d3/dc8/classblaze_1_1SMatTSMatMultExpr.html" title="Expression object for sparse matrix-transpose sparse matrix multiplications.The SMatTSMatMultExpr cla...">SMatTSMatMultExpr</a> class represents the compile time expression for multiplications between a row-major and a column-major sparse matrix.  <a href="../../d3/dc8/classblaze_1_1SMatTSMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dbb/structblaze_1_1SMatTSMatMultExprTrait.html">SMatTSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose sparse matrix multiplication. Given the row-major sparse matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/dbb/structblaze_1_1SMatTSMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dad/classblaze_1_1SMatTSMatSubExpr.html">SMatTSMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-transpose sparse matrix subtractions.The <a class="el" href="../../da/dad/classblaze_1_1SMatTSMatSubExpr.html" title="Expression object for sparse matrix-transpose sparse matrix subtractions.The SMatTSMatSubExpr class r...">SMatTSMatSubExpr</a> class represents the compile time expression for subtractions between a row-major sparse matrix and a column-major sparse matrix.  <a href="../../da/dad/classblaze_1_1SMatTSMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da1/structblaze_1_1SMatTSMatSubExprTrait.html">SMatTSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/transpose sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose sparse matrix subtraction. Given the row-major sparse matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/da1/structblaze_1_1SMatTSMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/db5/structblaze_1_1SparseElement.html">SparseElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all sparse element types.The <a class="el" href="../../db/db5/structblaze_1_1SparseElement.html" title="Base class for all sparse element types.The SparseElement class is the base class for all sparse elem...">SparseElement</a> class is the base class for all sparse element types. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> types that conceptually represent a sparse vector or matrix element and that provide a <code>value()</code> and an <code>index()</code> member function have to derive from this class in order to qualify as sparse element. Only in case a class is derived from the <a class="el" href="../../db/db5/structblaze_1_1SparseElement.html" title="Base class for all sparse element types.The SparseElement class is the base class for all sparse elem...">SparseElement</a> base class, the <a class="el" href="../../d5/d39/structblaze_1_1IsSparseElement.html" title="Compile time check whether the given type is a sparse element type.This type trait class tests whethe...">IsSparseElement</a> type trait recognizes the class as valid sparse element.  <a href="../../db/db5/structblaze_1_1SparseElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sparse matrices.The <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html" title="Base class for sparse matrices.The SparseMatrix class is a base class for all sparse matrix classes...">SparseMatrix</a> class is a base class for all sparse matrix classes. It provides an abstraction from the actual type of the sparse matrix, but enables a conversion back to this type via the <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> base class.  <a href="../../d7/d5d/structblaze_1_1SparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for sparse matrix types.The <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html" title="Proxy backend for sparse matrix types.The SparseMatrixProxy class serves as a backend for the Proxy c...">SparseMatrixProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a sparse matrix and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of sparse matrices.  <a href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sparse vectors.The <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html" title="Base class for sparse vectors.The SparseVector class is a base class for all arbitrarily sized (N-dim...">SparseVector</a> class is a base class for all arbitrarily sized (N-dimensional) sparse vectors. It provides an abstraction from the actual type of the sparse vector, but enables a conversion back to this type via the <a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> base class.  <a href="../../d6/d31/structblaze_1_1SparseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for sparse vector types.The <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html" title="Proxy backend for sparse vector types.The SparseVectorProxy class serves as a backend for the Proxy c...">SparseVectorProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a sparse vector and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of sparse vectors.  <a href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d06/structblaze_1_1Sqrt.html">Sqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a> function.  <a href="../../d0/d06/structblaze_1_1Sqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of a fixed-sized matrix.The <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a> class template is the representation of a fixed-size matrix with statically allocated elements of arbitrary type. The type of the elements, the number of rows and columns and the storage order of the matrix can be specified via the four template parameters:  <a href="../../d3/dd3/classblaze_1_1StaticMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of a fixed-sized vector.The <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a> class template is the representation of a fixed-size vector with statically allocated elements of arbitrary type. The type of the elements, the number of elements and the transpose flag of the vector can be specified via the three template parameters:  <a href="../../d9/d3c/classblaze_1_1StaticVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d34/structblaze_1_1StorageOrder.html">StorageOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the storage order of a given matrix type.Via this type trait it is possible to evaluate the storage order of a given matrix type. In case the given type is a row-major matrix type the nested boolean <em>value</em> is set to <em>rowMajor</em>, in case it is a column-major matrix type it is set to <em>columnMajor</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the given type is not a matrix type a compilation error is created.  <a href="../../d9/d34/structblaze_1_1StorageOrder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d08/classblaze_1_1StrictlyLowerMatrix.html">StrictlyLowerMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> adapter for strictly lower triangular <img class="formulaInl" alt="$ N \times N $" src="../../form_18.png"/> matrices.  <a href="../../db/d08/classblaze_1_1StrictlyLowerMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d0d/classblaze_1_1StrictlyLowerProxy.html">StrictlyLowerProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for strictly lower triangular matrices.The <a class="el" href="../../de/d0d/classblaze_1_1StrictlyLowerProxy.html" title="Access proxy for strictly lower triangular matrices.The StrictlyLowerProxy provides controlled access...">StrictlyLowerProxy</a> provides controlled access to the elements of a non-const strictly lower triangular matrix. It guarantees that the strictly lower matrix invariant is not violated, i.e. that elements on the diagonal and in the upper part of the matrix remain 0. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> dense strictly lower triangular matrix:  <a href="../../de/d0d/classblaze_1_1StrictlyLowerProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d41/classblaze_1_1StrictlyUpperMatrix.html">StrictlyUpperMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> adapter for strictly upper triangular <img class="formulaInl" alt="$ N \times N $" src="../../form_18.png"/> matrices.  <a href="../../de/d41/classblaze_1_1StrictlyUpperMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d4b/classblaze_1_1StrictlyUpperProxy.html">StrictlyUpperProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for strictly upper triangular matrices.The <a class="el" href="../../d3/d4b/classblaze_1_1StrictlyUpperProxy.html" title="Access proxy for strictly upper triangular matrices.The StrictlyUpperProxy provides controlled access...">StrictlyUpperProxy</a> provides controlled access to the elements of a non-const strictly upper triangular matrix. It guarantees that the strictly upper matrix invariant is not violated, i.e. that elements on the diagonal and in the lower part of the matrix remain 0. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> dense strictly upper triangular matrix:  <a href="../../d3/d4b/classblaze_1_1StrictlyUpperProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d7a/structblaze_1_1SubExpr.html">SubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all subtraction expression templates.The <a class="el" href="../../d0/d7a/structblaze_1_1SubExpr.html" title="Base class for all subtraction expression templates.The SubExpr class serves as a tag for all express...">SubExpr</a> class serves as a tag for all expression templates that implement mathematical subtractions. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical subtraction (vector subtractions and matrix subtractions) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as subtraction expression template. Only in case a class is derived from the <a class="el" href="../../d0/d7a/structblaze_1_1SubExpr.html" title="Base class for all subtraction expression templates.The SubExpr class serves as a tag for all express...">SubExpr</a> base class, the <a class="el" href="../../da/d3f/structblaze_1_1IsSubExpr.html" title="Compile time check whether the given type is a subtraction expression template.This type trait class ...">IsSubExpr</a> type trait recognizes the class as valid subtraction expression template.  <a href="../../d0/d7a/structblaze_1_1SubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9b/structblaze_1_1SubExprTrait.html">SubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a subtraction expression.Via this type trait it is possible to evaluate the return type of a subtraction expression between scalar, vectors, and matrices. Given the two types <em>T1</em> and <em>T2</em>, which must be either scalar, vector, or matrix types, the nested type <em>Type</em> corresponds to the resulting return type. In case <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be subtracted, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/d9b/structblaze_1_1SubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> on a specific submatrix of a dense or sparse matrix.The <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html" title="View on a specific submatrix of a dense or sparse matrix.The Submatrix class template represents a vi...">Submatrix</a> class template represents a view on a specific submatrix of a dense or sparse matrix primitive. The type of the matrix is specified via the first template parameter:  <a href="../../d1/da2/classblaze_1_1Submatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d6d/structblaze_1_1SubmatrixExprTrait.html">SubmatrixExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type type of a submatrix operation.Via this type trait it is possible to evaluate the return type of a submatrix operation. Given the dense or sparse matrix type <em>MT</em> and the alignment flag <em>AF</em>, the nested type <em>Type</em> corresponds to the resulting return type. In case the given type is neither a dense nor a sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d6d/structblaze_1_1SubmatrixExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html">SubmatrixTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html" title="Base template for the SubmatrixTrait class. ">SubmatrixTrait</a> class.  <a href="../../de/d83/structblaze_1_1SubmatrixTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html">SubTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class.  <a href="../../dd/d27/structblaze_1_1SubTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd2/classblaze_1_1Subvector.html">Subvector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> on a specific subvector of a dense or sparse vector.The <a class="el" href="../../d4/dd2/classblaze_1_1Subvector.html" title="View on a specific subvector of a dense or sparse vector.The Subvector class template represents a vi...">Subvector</a> class template represents a view on a specific subvector of a dense or sparse vector primitive. The type of the vector is specified via the first template parameter:  <a href="../../d4/dd2/classblaze_1_1Subvector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/df0/structblaze_1_1SubvectorExprTrait.html">SubvectorExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type type of a subvector operation.Via this type trait it is possible to evaluate the return type of a subvector operation. Given the dense or sparse vector type <em>VT</em> and the alignment flag <em>AF</em>, the nested type <em>Type</em> corresponds to the resulting return type. In case the given type is neither a dense nor a sparse vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/df0/structblaze_1_1SubvectorExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html">SubvectorTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html" title="Base template for the SubvectorTrait class. ">SubvectorTrait</a> class.  <a href="../../df/d1b/structblaze_1_1SubvectorTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d83/structblaze_1_1SVecCTransExprTrait.html">SVecCTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector conjugate transpose operation. Given the non-transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d83/structblaze_1_1SVecCTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc3/structblaze_1_1SVecDVecAddExprTrait.html">SVecDVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/dense vector addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/dense vector addition. Given the non-transpose sparse vector type <em>VT1</em> and the non-transpose dense vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose sparse vector type or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/dc3/structblaze_1_1SVecDVecAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dbd/classblaze_1_1SVecDVecCrossExpr.html">SVecDVecCrossExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-dense vector cross products.The <a class="el" href="../../d4/dbd/classblaze_1_1SVecDVecCrossExpr.html" title="Expression object for sparse vector-dense vector cross products.The SVecDVecCrossExpr class represent...">SVecDVecCrossExpr</a> class represents the compile time expression for cross products between a sparse vector and a dense vector.  <a href="../../d4/dbd/classblaze_1_1SVecDVecCrossExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/ddb/structblaze_1_1SVecDVecCrossExprTrait.html">SVecDVecCrossExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/dense vector cross product.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/dense vector cross product. Given the non-transpose sparse vector type <em>VT1</em> and the non-transpose dense vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose sparse vector type or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/ddb/structblaze_1_1SVecDVecCrossExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d84/classblaze_1_1SVecDVecDivExpr.html">SVecDVecDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-dense vector divisions.The <a class="el" href="../../d1/d84/classblaze_1_1SVecDVecDivExpr.html" title="Expression object for sparse vector-dense vector divisions.The SVecDVecDivExpr class represents the c...">SVecDVecDivExpr</a> class represents the compile time expression for componentwise divisions between a sparse vector and a dense vector.  <a href="../../d1/d84/classblaze_1_1SVecDVecDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db2/structblaze_1_1SVecDVecDivExprTrait.html">SVecDVecDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/dense vector division.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/dense vector division. Given the non-transpose sparse vector type <em>VT1</em> and the non-transpose dense vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose sparse vector type or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/db2/structblaze_1_1SVecDVecDivExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd1/classblaze_1_1SVecDVecMultExpr.html">SVecDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-dense vector multiplications.The <a class="el" href="../../d1/dd1/classblaze_1_1SVecDVecMultExpr.html" title="Expression object for sparse vector-dense vector multiplications.The SVecDVecMultExpr class represent...">SVecDVecMultExpr</a> class represents the compile time expression for componentwise multiplications between a sparse vector and a dense vector.  <a href="../../d1/dd1/classblaze_1_1SVecDVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d42/structblaze_1_1SVecDVecMultExprTrait.html">SVecDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/dense vector multiplication. Given the non-transpose sparse vector type <em>VT1</em> and the non-transpose dense vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose sparse vector type or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d42/structblaze_1_1SVecDVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d09/classblaze_1_1SVecDVecSubExpr.html">SVecDVecSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-dense vector subtractions.The <a class="el" href="../../d8/d09/classblaze_1_1SVecDVecSubExpr.html" title="Expression object for sparse vector-dense vector subtractions.The SVecDVecSubExpr class represents th...">SVecDVecSubExpr</a> class represents the compile time expression for subtractions between a sparse vector and a dense vector.  <a href="../../d8/d09/classblaze_1_1SVecDVecSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d8a/structblaze_1_1SVecDVecSubExprTrait.html">SVecDVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/dense vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/dense vector subtraction. Given the non-transpose sparse vector type <em>VT1</em> and the non-transpose dense vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose sparse vector type or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d8a/structblaze_1_1SVecDVecSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d39/classblaze_1_1SVecEvalExpr.html">SVecEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the forced evaluation of sparse vectors.The <a class="el" href="../../d7/d39/classblaze_1_1SVecEvalExpr.html" title="Expression object for the forced evaluation of sparse vectors.The SVecEvalExpr class represents the c...">SVecEvalExpr</a> class represents the compile time expression for the forced evaluation of a sparse vector.  <a href="../../d7/d39/classblaze_1_1SVecEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d64/structblaze_1_1SVecEvalExprTrait.html">SVecEvalExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector evaluation operation. Given the non-transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d64/structblaze_1_1SVecEvalExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the sparse vector <a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a> function.The <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html" title="Expression object for the sparse vector forEach() function.The SVecForEachExpr class represents the c...">SVecForEachExpr</a> class represents the compile time expression for the evaluation of a custom operation on each element of a sparse vector via the <a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a> function.  <a href="../../db/d18/classblaze_1_1SVecForEachExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d06/structblaze_1_1SVecForEachExprTrait.html">SVecForEachExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector for-each operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector custom operation. Given the non-transpose sparse vector type <em>VT</em> and the custom operation type <em>OP</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d06/structblaze_1_1SVecForEachExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d8f/classblaze_1_1SVecScalarDivExpr.html">SVecScalarDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for divisions of a sparse vector by a scalar.The <a class="el" href="../../d7/d8f/classblaze_1_1SVecScalarDivExpr.html" title="Expression object for divisions of a sparse vector by a scalar.The SVecScalarDivExpr class represents...">SVecScalarDivExpr</a> class represents the compile time expression for divisions of sparse vectors by scalar values.  <a href="../../d7/d8f/classblaze_1_1SVecScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd3/structblaze_1_1SVecScalarDivExprTrait.html">SVecScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/scalar division. Given the non-transpose sparse vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a non-transpose sparse vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/dd3/structblaze_1_1SVecScalarDivExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dc2/classblaze_1_1SVecScalarMultExpr.html">SVecScalarMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-scalar multiplications.The <a class="el" href="../../d7/dc2/classblaze_1_1SVecScalarMultExpr.html" title="Expression object for sparse vector-scalar multiplications.The SVecScalarMultExpr class represents th...">SVecScalarMultExpr</a> class represents the compile time expression for multiplications between a sparse vector and a scalar value.  <a href="../../d7/dc2/classblaze_1_1SVecScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d16/structblaze_1_1SVecScalarMultExprTrait.html">SVecScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/scalar multiplication. Given the non-transpose sparse vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a non-transpose sparse vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d5/d16/structblaze_1_1SVecScalarMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/ddd/classblaze_1_1SVecSerialExpr.html">SVecSerialExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the forced serial evaluation of sparse vectors.The <a class="el" href="../../df/ddd/classblaze_1_1SVecSerialExpr.html" title="Expression object for the forced serial evaluation of sparse vectors.The SVecSerialExpr class represe...">SVecSerialExpr</a> class represents the compile time expression for the forced serial evaluation of a sparse vector.  <a href="../../df/ddd/classblaze_1_1SVecSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d06/structblaze_1_1SVecSerialExprTrait.html">SVecSerialExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector serial evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector serial evaluation operation. Given the non-transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d06/structblaze_1_1SVecSerialExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d63/classblaze_1_1SVecSVecAddExpr.html">SVecSVecAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-sparse vector additions.The <a class="el" href="../../d9/d63/classblaze_1_1SVecSVecAddExpr.html" title="Expression object for sparse vector-sparse vector additions.The SVecSVecAddExpr class represents the ...">SVecSVecAddExpr</a> class represents the compile time expression for additions between sparse vectors.  <a href="../../d9/d63/classblaze_1_1SVecSVecAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd9/structblaze_1_1SVecSVecAddExprTrait.html">SVecSVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/sparse vector addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse vector addition. Given the two non-transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/dd9/structblaze_1_1SVecSVecAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7d/classblaze_1_1SVecSVecCrossExpr.html">SVecSVecCrossExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-sparse vector cross products.The <a class="el" href="../../d3/d7d/classblaze_1_1SVecSVecCrossExpr.html" title="Expression object for sparse vector-sparse vector cross products.The SVecSVecCrossExpr class represen...">SVecSVecCrossExpr</a> class represents the compile time expression for cross products between sparse vectors.  <a href="../../d3/d7d/classblaze_1_1SVecSVecCrossExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/ddd/structblaze_1_1SVecSVecCrossExprTrait.html">SVecSVecCrossExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/sparse vector cross product.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse vector cross product. Given the two non-transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/ddd/structblaze_1_1SVecSVecCrossExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/ddb/classblaze_1_1SVecSVecMultExpr.html">SVecSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-sparse vector multiplications.The <a class="el" href="../../d5/ddb/classblaze_1_1SVecSVecMultExpr.html" title="Expression object for sparse vector-sparse vector multiplications.The SVecSVecMultExpr class represen...">SVecSVecMultExpr</a> class represents the compile time expression for componentwise multiplications between sparse vectors.  <a href="../../d5/ddb/classblaze_1_1SVecSVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d94/structblaze_1_1SVecSVecMultExprTrait.html">SVecSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse vector multiplication. Given the two non-transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d94/structblaze_1_1SVecSVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d48/classblaze_1_1SVecSVecSubExpr.html">SVecSVecSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-sparse vector subtractions.The <a class="el" href="../../de/d48/classblaze_1_1SVecSVecSubExpr.html" title="Expression object for sparse vector-sparse vector subtractions.The SVecSVecSubExpr class represents t...">SVecSVecSubExpr</a> class represents the compile time expression for subtractions between sparse vectors.  <a href="../../de/d48/classblaze_1_1SVecSVecSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3e/structblaze_1_1SVecSVecSubExprTrait.html">SVecSVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/sparse vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse vector subtraction. Given the two non-transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d3e/structblaze_1_1SVecSVecSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3b/classblaze_1_1SVecTDVecMultExpr.html">SVecTDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-dense vector outer products.The <a class="el" href="../../db/d3b/classblaze_1_1SVecTDVecMultExpr.html" title="Expression object for sparse vector-dense vector outer products.The SVecTDVecMultExpr class represent...">SVecTDVecMultExpr</a> class represents the compile time expression for sparse vector-dense vector outer products.  <a href="../../db/d3b/classblaze_1_1SVecTDVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dad/structblaze_1_1SVecTDVecMultExprTrait.html">SVecTDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/transpose dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose dense vector multiplication (outer product). Given the non-transpose sparse vector type <em>VT1</em> and the transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose sparse vector type or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/dad/structblaze_1_1SVecTDVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd7/classblaze_1_1SVecTransExpr.html">SVecTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector transpositions.The <a class="el" href="../../d9/dd7/classblaze_1_1SVecTransExpr.html" title="Expression object for sparse vector transpositions.The SVecTransExpr class represents the compile tim...">SVecTransExpr</a> class represents the compile time expression for transpositions of sparse vectors.  <a href="../../d9/dd7/classblaze_1_1SVecTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9e/structblaze_1_1SVecTransExprTrait.html">SVecTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector transpose operation. Given the non-transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d9e/structblaze_1_1SVecTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dd2/classblaze_1_1SVecTransposer.html">SVecTransposer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the transposition of a sparse vector.The <a class="el" href="../../dd/dd2/classblaze_1_1SVecTransposer.html" title="Expression object for the transposition of a sparse vector.The SVecTransposer class is a wrapper obje...">SVecTransposer</a> class is a wrapper object for the temporary transposition of a sparse vector.  <a href="../../dd/dd2/classblaze_1_1SVecTransposer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d04/classblaze_1_1SVecTSVecMultExpr.html">SVecTSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-sparse vector outer products.The <a class="el" href="../../d5/d04/classblaze_1_1SVecTSVecMultExpr.html" title="Expression object for sparse vector-sparse vector outer products.The SVecTSVecMultExpr class represen...">SVecTSVecMultExpr</a> class represents the compile time expression for sparse vector-sparse vector outer products.  <a href="../../d5/d04/classblaze_1_1SVecTSVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d83/structblaze_1_1SVecTSVecMultExprTrait.html">SVecTSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/transpose sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose sparse vector multiplication (outer product). Given the non-transpose sparse vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose sparse vector type or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/d83/structblaze_1_1SVecTSVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d76/classblaze_1_1SymmetricElement.html">SymmetricElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of two synchronized elements within the sparse symmetric matrix.The <a class="el" href="../../d2/d76/classblaze_1_1SymmetricElement.html" title="Representation of two synchronized elements within the sparse symmetric matrix.The SymmetricElement c...">SymmetricElement</a> class represents two synchronized elements (i.e. two value/index pairs) within a sparse symmetric matrix. It guarantees that a modification of element <img class="formulaInl" alt="$ a_{ij} $" src="../../form_24.png"/> via iterator is also applied to element <img class="formulaInl" alt="$ a_{ji} $" src="../../form_25.png"/>. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> dense Hermitian matrix:  <a href="../../d2/d76/classblaze_1_1SymmetricElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">SymmetricMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> adapter for symmetric <img class="formulaInl" alt="$ N \times N $" src="../../form_18.png"/> matrices.  <a href="../../d4/dab/classblaze_1_1SymmetricMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d85/classblaze_1_1SymmetricValue.html">SymmetricValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of two synchronized values within a sparse symmetric matrix.The <a class="el" href="../../d5/d85/classblaze_1_1SymmetricValue.html" title="Representation of two synchronized values within a sparse symmetric matrix.The SymmetricValue class r...">SymmetricValue</a> class represents two synchronized values within a sparse symmetric matrix. It guarantees that a modification of value <img class="formulaInl" alt="$ a_{ij} $" src="../../form_24.png"/> via iterator is also applied to the value <img class="formulaInl" alt="$ a_{ji} $" src="../../form_25.png"/>. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> sparse symmetric matrix:  <a href="../../d5/d85/classblaze_1_1SymmetricValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dc7/classblaze_1_1SystemClock.html">SystemClock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">System clock of the Blaze library.The <a class="el" href="../../dd/dc7/classblaze_1_1SystemClock.html" title="System clock of the Blaze library.The SystemClock class represents the system clock of the Blaze libr...">SystemClock</a> class represents the system clock of the Blaze library. The system clock is the central timing functionality that can be used to query for the start time of the process, the current timestamp and the elapsed time since the start of the process. The following example demonstrates how the single system clock instance is acquired via the <a class="el" href="../../d4/d3a/group__util.html#ga0547f7041f58ea87ba920e520236bd12" title="Returns a handle to the Blaze system clock. ">theSystemClock()</a> functcion and how the system clock can be used:  <a href="../../dd/dc7/classblaze_1_1SystemClock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d5e/structblaze_1_1Tan.html">Tan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga90be532925f9874efae43a23918194ce" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a> function.  <a href="../../db/d5e/structblaze_1_1Tan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db7/structblaze_1_1Tanh.html">Tanh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#gac3e7dda64b4203c08bf00bc0813b4d05" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a> function.  <a href="../../df/db7/structblaze_1_1Tanh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df2/structblaze_1_1TDMatCTransExprTrait.html">TDMatCTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix conjugate transpose operation. Given the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/df2/structblaze_1_1TDMatCTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dda/structblaze_1_1TDMatDeclDiagExprTrait.html">TDMatDeclDiagExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix decldiag operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix decldiag evaluation operation. Given the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../df/dda/structblaze_1_1TDMatDeclDiagExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3b/structblaze_1_1TDMatDeclHermExprTrait.html">TDMatDeclHermExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix declherm operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix declherm evaluation operation. Given the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d3b/structblaze_1_1TDMatDeclHermExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d3d/structblaze_1_1TDMatDeclLowExprTrait.html">TDMatDeclLowExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix decllow operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix decllow evaluation operation. Given the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d3d/structblaze_1_1TDMatDeclLowExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dbf/structblaze_1_1TDMatDeclSymExprTrait.html">TDMatDeclSymExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix declsym operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix declsym evaluation operation. Given the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/dbf/structblaze_1_1TDMatDeclSymExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d16/structblaze_1_1TDMatDeclUppExprTrait.html">TDMatDeclUppExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix declupp operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix declupp evaluation operation. Given the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d16/structblaze_1_1TDMatDeclUppExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d24/structblaze_1_1TDMatDMatAddExprTrait.html">TDMatDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense matrix addition. Given the column-major dense matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d24/structblaze_1_1TDMatDMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classblaze_1_1TDMatDMatMultExpr.html">TDMatDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense matrix-dense matrix multiplications.The <a class="el" href="../../dc/dc9/classblaze_1_1TDMatDMatMultExpr.html" title="Expression object for transpose dense matrix-dense matrix multiplications.The TDMatDMatMultExpr class...">TDMatDMatMultExpr</a> class represents the compile time expression for multiplications between a column-major dense matrix and a row-major dense matrix.  <a href="../../dc/dc9/classblaze_1_1TDMatDMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d09/structblaze_1_1TDMatDMatMultExprTrait.html">TDMatDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense matrix multiplication. Given the column-major dense matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d09/structblaze_1_1TDMatDMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d15/structblaze_1_1TDMatDMatSubExprTrait.html">TDMatDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense matrix subtraction. Given the column-major dense matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/d15/structblaze_1_1TDMatDMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dd4/classblaze_1_1TDMatDVecMultExpr.html">TDMatDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense matrix-dense vector multiplications.The <a class="el" href="../../dc/dd4/classblaze_1_1TDMatDVecMultExpr.html" title="Expression object for transpose dense matrix-dense vector multiplications.The TDMatDVecMultExpr class...">TDMatDVecMultExpr</a> class represents the compile time expression for multiplications between column-major dense matrices and dense vectors.  <a href="../../dc/dd4/classblaze_1_1TDMatDVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d6f/structblaze_1_1TDMatDVecMultExprTrait.html">TDMatDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense vector multiplication. Given the column-major dense matrix type <em>MT</em> and the non-transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major dense matrix type or <em>VT</em> is not a non-transpose dense vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/d6f/structblaze_1_1TDMatDVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d34/structblaze_1_1TDMatEvalExprTrait.html">TDMatEvalExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix evaluation operation. Given the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/d34/structblaze_1_1TDMatEvalExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d2c/structblaze_1_1TDMatForEachExprTrait.html">TDMatForEachExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix custom operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix custom operation. Given the column-major dense matrix type <em>MT</em> and the custom operation type <em>OP</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/d2c/structblaze_1_1TDMatForEachExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dec/structblaze_1_1TDMatInvExprTrait.html">TDMatInvExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix inversion operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix inversion operation. Given the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/dec/structblaze_1_1TDMatInvExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/da0/structblaze_1_1TDMatScalarDivExprTrait.html">TDMatScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/scalar division. Given the column-major dense matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major dense matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/da0/structblaze_1_1TDMatScalarDivExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d61/structblaze_1_1TDMatScalarMultExprTrait.html">TDMatScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/scalar multiplication. Given the column-major dense matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major dense matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../da/d61/structblaze_1_1TDMatScalarMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/da0/structblaze_1_1TDMatSerialExprTrait.html">TDMatSerialExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix serial evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix serial evaluation operation. Given the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/da0/structblaze_1_1TDMatSerialExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d0c/classblaze_1_1TDMatSMatAddExpr.html">TDMatSMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-sparse matrix additions.The <a class="el" href="../../d9/d0c/classblaze_1_1TDMatSMatAddExpr.html" title="Expression object for dense matrix-sparse matrix additions.The TDMatSMatAddExpr class represents the ...">TDMatSMatAddExpr</a> class represents the compile time expression for additions between a column-major dense matrix and a row-major sparse matrix.  <a href="../../d9/d0c/classblaze_1_1TDMatSMatAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d21/structblaze_1_1TDMatSMatAddExprTrait.html">TDMatSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse matrix addition. Given the column-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/d21/structblaze_1_1TDMatSMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dfb/classblaze_1_1TDMatSMatMultExpr.html">TDMatSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense matrix-sparse matrix multiplications.The <a class="el" href="../../d4/dfb/classblaze_1_1TDMatSMatMultExpr.html" title="Expression object for transpose dense matrix-sparse matrix multiplications.The TDMatSMatMultExpr clas...">TDMatSMatMultExpr</a> class represents the compile time expression for multiplications between a column-major dense matrix and a row-major sparse matrix.  <a href="../../d4/dfb/classblaze_1_1TDMatSMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d89/structblaze_1_1TDMatSMatMultExprTrait.html">TDMatSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse matrix multiplication. Given the column-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d89/structblaze_1_1TDMatSMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/classblaze_1_1TDMatSMatSubExpr.html">TDMatSMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense matrix-sparse matrix subtractions.The <a class="el" href="../../da/d5b/classblaze_1_1TDMatSMatSubExpr.html" title="Expression object for transpose dense matrix-sparse matrix subtractions.The TDMatSMatSubExpr class re...">TDMatSMatSubExpr</a> class represents the compile time expression for subtractions between a row-major dense matrix and a column-major sparse matrix.  <a href="../../da/d5b/classblaze_1_1TDMatSMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d90/structblaze_1_1TDMatSMatSubExprTrait.html">TDMatSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse matrix subtraction. Given the column-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d90/structblaze_1_1TDMatSMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d0b/classblaze_1_1TDMatSVecMultExpr.html">TDMatSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense matrix-sparse vector multiplications.The <a class="el" href="../../d4/d0b/classblaze_1_1TDMatSVecMultExpr.html" title="Expression object for transpose dense matrix-sparse vector multiplications.The TDMatSVecMultExpr clas...">TDMatSVecMultExpr</a> class represents the compile time expression for multiplications between column-major dense matrices and sparse vectors.  <a href="../../d4/d0b/classblaze_1_1TDMatSVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dee/structblaze_1_1TDMatSVecMultExprTrait.html">TDMatSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse vector multiplication. Given the column-major dense matrix type <em>MT</em> and the non-transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major dense matrix type or <em>VT</em> is not a non-transpose sparse vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/dee/structblaze_1_1TDMatSVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d14/structblaze_1_1TDMatTDMatAddExprTrait.html">TDMatTDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/transpose dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/transpose dense matrix addition. Given the two column-major dense matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a column-major dense matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d14/structblaze_1_1TDMatTDMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d6f/classblaze_1_1TDMatTDMatMultExpr.html">TDMatTDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense matrix-transpose dense matrix multiplications.The <a class="el" href="../../dd/d6f/classblaze_1_1TDMatTDMatMultExpr.html" title="Expression object for transpose dense matrix-transpose dense matrix multiplications.The TDMatTDMatMultExpr class represents the compile time expression for multiplications between two column-major dense matrices. ">TDMatTDMatMultExpr</a> class represents the compile time expression for multiplications between two column-major dense matrices.  <a href="../../dd/d6f/classblaze_1_1TDMatTDMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/ded/structblaze_1_1TDMatTDMatMultExprTrait.html">TDMatTDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/transpose dense matrix multiplication. Given the two column-major dense matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a column-major dense matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/ded/structblaze_1_1TDMatTDMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfa/structblaze_1_1TDMatTDMatSubExprTrait.html">TDMatTDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/transpose dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/transpose dense matrix subtraction. Given the two column-major dense matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a column-major dense matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/dfa/structblaze_1_1TDMatTDMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/df1/structblaze_1_1TDMatTransExprTrait.html">TDMatTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix transpose operation. Given the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/df1/structblaze_1_1TDMatTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da3/structblaze_1_1TDMatTSMatAddExprTrait.html">TDMatTSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/transpose sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/transpose sparse matrix addition. Given the column-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../df/da3/structblaze_1_1TDMatTSMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d9c/classblaze_1_1TDMatTSMatMultExpr.html">TDMatTSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense matrix-transpose sparse matrix multiplications.The <a class="el" href="../../d9/d9c/classblaze_1_1TDMatTSMatMultExpr.html" title="Expression object for transpose dense matrix-transpose sparse matrix multiplications.The TDMatTSMatMultExpr class represents the compile time expression for multiplications between a column-major dense matrix and a column-major sparse matrix. ">TDMatTSMatMultExpr</a> class represents the compile time expression for multiplications between a column-major dense matrix and a column-major sparse matrix.  <a href="../../d9/d9c/classblaze_1_1TDMatTSMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc5/structblaze_1_1TDMatTSMatMultExprTrait.html">TDMatTSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/transpose sparse matrix multiplication. Given the column-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/dc5/structblaze_1_1TDMatTSMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d8b/structblaze_1_1TDMatTSMatSubExprTrait.html">TDMatTSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/transpose sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/transpose sparse matrix subtraction. Given the column-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d8b/structblaze_1_1TDMatTSMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3b/structblaze_1_1TDVecCTransExprTrait.html">TDVecCTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector conjugate transpose operation. Given the transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d3b/structblaze_1_1TDVecCTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d47/classblaze_1_1TDVecDMatMultExpr.html">TDVecDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense vector-dense matrix multiplications.The <a class="el" href="../../d8/d47/classblaze_1_1TDVecDMatMultExpr.html" title="Expression object for transpose dense vector-dense matrix multiplications.The TDVecDMatMultExpr class...">TDVecDMatMultExpr</a> class represents the compile time expression for multiplications between transpose dense vectors and dense matrices.  <a href="../../d8/d47/classblaze_1_1TDVecDMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d4b/structblaze_1_1TDVecDMatMultExprTrait.html">TDVecDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/dense matrix multiplication. Given the transpose dense vector type <em>VT</em> and the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose dense vector type or <em>MT</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d4b/structblaze_1_1TDVecDMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/structblaze_1_1TDVecDVecMultExprTrait.html">TDVecDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/dense vector multiplication (inner product). Given the transpose dense vector type <em>VT1</em> and the non-transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose dense vector type or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d5e/structblaze_1_1TDVecDVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc3/structblaze_1_1TDVecEvalExprTrait.html">TDVecEvalExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector evaluation operation. Given the transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/dc3/structblaze_1_1TDVecEvalExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dfb/structblaze_1_1TDVecForEachExprTrait.html">TDVecForEachExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector custom operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector custom operation. Given the transpose dense vector type <em>VT</em> and the custom operation type <em>OP</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/dfb/structblaze_1_1TDVecForEachExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d59/structblaze_1_1TDVecScalarDivExprTrait.html">TDVecScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/scalar division. Given the transpose dense vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose dense vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d59/structblaze_1_1TDVecScalarDivExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d39/structblaze_1_1TDVecScalarMultExprTrait.html">TDVecScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/scalar multiplication. Given the transpose dense vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose dense vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/d39/structblaze_1_1TDVecScalarMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d35/structblaze_1_1TDVecSerialExprTrait.html">TDVecSerialExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector serial evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector serial evaluation operation. Given the transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d35/structblaze_1_1TDVecSerialExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense vector-sparse matrix multiplications.The <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html" title="Expression object for transpose dense vector-sparse matrix multiplications.The TDVecSMatMultExpr clas...">TDVecSMatMultExpr</a> class represents the compile time expression for multiplications between transpose dense vectors and row-major sparse matrices.  <a href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d02/structblaze_1_1TDVecSMatMultExprTrait.html">TDVecSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/sparse matrix multiplication. Given the transpose dense vector type <em>VT</em> and the row-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose dense vector type or <em>MT</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d02/structblaze_1_1TDVecSMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/ded/structblaze_1_1TDVecSVecMultExprTrait.html">TDVecSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/sparse vector multiplication (inner product). Given the transpose dense vector type <em>VT1</em> and the non-transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose dense vector type or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/ded/structblaze_1_1TDVecSVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de4/classblaze_1_1TDVecTDMatMultExpr.html">TDVecTDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense vector-transpose dense matrix multiplications.The <a class="el" href="../../db/de4/classblaze_1_1TDVecTDMatMultExpr.html" title="Expression object for transpose dense vector-transpose dense matrix multiplications.The TDVecTDMatMultExpr class represents the compile time expression for multiplications between transpose dense vectors and column-major dense matrices. ">TDVecTDMatMultExpr</a> class represents the compile time expression for multiplications between transpose dense vectors and column-major dense matrices.  <a href="../../db/de4/classblaze_1_1TDVecTDMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dbe/structblaze_1_1TDVecTDMatMultExprTrait.html">TDVecTDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose dense matrix multiplication. Given the transpose dense vector type <em>VT</em> and the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose dense vector type or <em>MT</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/dbe/structblaze_1_1TDVecTDMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d48/structblaze_1_1TDVecTDVecAddExprTrait.html">TDVecTDVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/transpose dense vector addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/transpose dense vector addition. Given the two transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d48/structblaze_1_1TDVecTDVecAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d92/structblaze_1_1TDVecTDVecCrossExprTrait.html">TDVecTDVecCrossExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/dense vector cross product.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/dense vector cross product. Given the two transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d92/structblaze_1_1TDVecTDVecCrossExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d70/structblaze_1_1TDVecTDVecDivExprTrait.html">TDVecTDVecDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/transpose dense vector division.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/transpose dense vector division. Given the two transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/d70/structblaze_1_1TDVecTDVecDivExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d96/structblaze_1_1TDVecTDVecMultExprTrait.html">TDVecTDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/transpose dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/transpose dense vector multiplication. Given the two transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/d96/structblaze_1_1TDVecTDVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da4/structblaze_1_1TDVecTDVecSubExprTrait.html">TDVecTDVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/transpose dense vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/transpose dense vector subtraction. Given the two transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/da4/structblaze_1_1TDVecTDVecSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d09/structblaze_1_1TDVecTransExprTrait.html">TDVecTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector transpose operation. Given the transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d09/structblaze_1_1TDVecTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense vector-transpose sparse matrix multiplications.The <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html" title="Expression object for transpose dense vector-transpose sparse matrix multiplications.The TDVecTSMatMultExpr class represents the compile time expression for multiplications between transpose dense vectors and column-major sparse matrices. ">TDVecTSMatMultExpr</a> class represents the compile time expression for multiplications between transpose dense vectors and column-major sparse matrices.  <a href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d39/structblaze_1_1TDVecTSMatMultExprTrait.html">TDVecTSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose sparse matrix multiplication. Given the transpose dense vector type <em>VT</em> and the column-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose dense vector type or <em>MT</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../df/d39/structblaze_1_1TDVecTSMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/db9/structblaze_1_1TDVecTSVecAddExprTrait.html">TDVecTSVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/transpose sparse vector addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/transpose sparse vector addition. Given the transpose dense vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose dense vector type or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/db9/structblaze_1_1TDVecTSVecAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db3/structblaze_1_1TDVecTSVecCrossExprTrait.html">TDVecTSVecCrossExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/sparse vector cross product.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/sparse vector cross product. Given the transpose dense vector type <em>VT1</em> and the transpose sparse vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose dense vector type or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d5/db3/structblaze_1_1TDVecTSVecCrossExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da4/structblaze_1_1TDVecTSVecMultExprTrait.html">TDVecTSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/transpose sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/transpose sparse vector multiplication. Given the transpose dense vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose dense vector type or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/da4/structblaze_1_1TDVecTSVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc3/structblaze_1_1TDVecTSVecSubExprTrait.html">TDVecTSVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/transpose sparse vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/transpose sparse vector subtraction. Given the transpose dense vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose dense vector type or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/dc3/structblaze_1_1TDVecTSVecSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d7d/classblaze_1_1Thread.html">Thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a single thread of execution.  <a href="../../de/d7d/classblaze_1_1Thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">ThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a thread pool.  <a href="../../db/d38/classblaze_1_1ThreadPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d2f/structblaze_1_1Times.html">Times</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time integral multiplication.The <a class="el" href="../../de/d2f/structblaze_1_1Times.html" title="Compile time integral multiplication.The Times class template returns the product of the two given te...">Times</a> class template returns the product of the two given template arguments <em>T1</em> and <em>T2</em>. In order for <a class="el" href="../../de/d2f/structblaze_1_1Times.html" title="Compile time integral multiplication.The Times class template returns the product of the two given te...">Times</a> to be able to multiply the two types, both arguments are required to have a nested member <em>value</em>. The result of the multiplication can be accessed via the nested member <em>value</em>, the resulting type is available via the nested type <em>ValueType</em>.  <a href="../../de/d2f/structblaze_1_1Times.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d46/structblaze_1_1Trans.html">Trans</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac" title="Calculation of the transpose of the given dense matrix. ">trans()</a> function.  <a href="../../db/d46/structblaze_1_1Trans.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dfe/structblaze_1_1TransExpr.html">TransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all transposition expression templates.The <a class="el" href="../../dd/dfe/structblaze_1_1TransExpr.html" title="Base class for all transposition expression templates.The TransExpr class serves as a tag for all exp...">TransExpr</a> class serves as a tag for all expression templates that implement mathematical transpositions. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical transposition (vector transpositions and matrix transpositions) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as transposition expression template. Only in case a class is derived from the <a class="el" href="../../dd/dfe/structblaze_1_1TransExpr.html" title="Base class for all transposition expression templates.The TransExpr class serves as a tag for all exp...">TransExpr</a> base class, the <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html" title="Compile time check whether the given type is a transposition expression template.This type trait clas...">IsTransExpr</a> type trait recognizes the class as valid transposition expression template.  <a href="../../dd/dfe/structblaze_1_1TransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d9a/structblaze_1_1TransExprTrait.html">TransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a transpose expression.Via this type trait it is possible to evaluate the return type of a transpose expression. Given the type <em>T</em>, which must either be a vector or matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no transpose operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d9a/structblaze_1_1TransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd9/structblaze_1_1TransposeFlag.html">TransposeFlag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the transpose flag of a given matrix type.Via this type trait it is possible to evaluate the transpose flag of a given vector type. In case the given type is a row vector type the nested boolean <em>value</em> is set to <em>rowVector</em>, in case it is a column vector type it is set to <em>columnVector</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the given type is not a vector type a compilation error is created.  <a href="../../d5/dd9/structblaze_1_1TransposeFlag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d23/structblaze_1_1Trunc.html">Trunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for the <a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a> function.  <a href="../../de/d23/structblaze_1_1Trunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de8/structblaze_1_1TSMatCTransExprTrait.html">TSMatCTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix conjugate transpose operation. Given the column-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/de8/structblaze_1_1TSMatCTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d17/structblaze_1_1TSMatDeclDiagExprTrait.html">TSMatDeclDiagExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix decldiag operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix decldiag operation. Given the column-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/d17/structblaze_1_1TSMatDeclDiagExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d2f/structblaze_1_1TSMatDeclHermExprTrait.html">TSMatDeclHermExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix declherm operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix declherm operation. Given the column-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/d2f/structblaze_1_1TSMatDeclHermExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de3/structblaze_1_1TSMatDeclLowExprTrait.html">TSMatDeclLowExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix decllow operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix decllow operation. Given the column-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/de3/structblaze_1_1TSMatDeclLowExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de4/structblaze_1_1TSMatDeclSymExprTrait.html">TSMatDeclSymExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix declsym operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix declsym operation. Given the column-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/de4/structblaze_1_1TSMatDeclSymExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd0/structblaze_1_1TSMatDeclUppExprTrait.html">TSMatDeclUppExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix declupp operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix declupp operation. Given the column-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/dd0/structblaze_1_1TSMatDeclUppExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d7a/structblaze_1_1TSMatDMatAddExprTrait.html">TSMatDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense matrix addition. Given the column-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d7a/structblaze_1_1TSMatDMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/ddb/classblaze_1_1TSMatDMatMultExpr.html">TSMatDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-dense matrix multiplications.The <a class="el" href="../../df/ddb/classblaze_1_1TSMatDMatMultExpr.html" title="Expression object for transpose sparse matrix-dense matrix multiplications.The TSMatDMatMultExpr clas...">TSMatDMatMultExpr</a> class represents the compile time expression for multiplications between a column-major sparse matrix and a row-major dense matrix.  <a href="../../df/ddb/classblaze_1_1TSMatDMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d45/structblaze_1_1TSMatDMatMultExprTrait.html">TSMatDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense matrix multiplication. Given the column-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/d45/structblaze_1_1TSMatDMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d71/classblaze_1_1TSMatDMatSubExpr.html">TSMatDMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-dense matrix subtractions.The <a class="el" href="../../df/d71/classblaze_1_1TSMatDMatSubExpr.html" title="Expression object for transpose sparse matrix-dense matrix subtractions.The TSMatDMatSubExpr class re...">TSMatDMatSubExpr</a> class represents the compile time expression for subtractions between a column-major sparse matrix and a row-major dense matrix.  <a href="../../df/d71/classblaze_1_1TSMatDMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df5/structblaze_1_1TSMatDMatSubExprTrait.html">TSMatDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense matrix subtraction. Given the column-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/df5/structblaze_1_1TSMatDMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/ddb/classblaze_1_1TSMatDVecMultExpr.html">TSMatDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-dense vector multiplications.The <a class="el" href="../../dc/ddb/classblaze_1_1TSMatDVecMultExpr.html" title="Expression object for transpose sparse matrix-dense vector multiplications.The TSMatDVecMultExpr clas...">TSMatDVecMultExpr</a> class represents the compile time expression for multiplications between column-major sparse matrices and dense vectors.  <a href="../../dc/ddb/classblaze_1_1TSMatDVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d6c/structblaze_1_1TSMatDVecMultExprTrait.html">TSMatDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense vector multiplication. Given the column-major sparse matrix type <em>MT</em> and the non-transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major sparse matrix type or <em>VT</em> is not a non-transpose dense vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/d6c/structblaze_1_1TSMatDVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d16/structblaze_1_1TSMatEvalExprTrait.html">TSMatEvalExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix evaluation operation. Given the column-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d16/structblaze_1_1TSMatEvalExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/ddd/structblaze_1_1TSMatForEachExprTrait.html">TSMatForEachExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix for-each operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix for-each operation. Given the column-major sparse matrix type <em>MT</em> and the custom operation type <em>OP</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/ddd/structblaze_1_1TSMatForEachExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6e/structblaze_1_1TSMatScalarDivExprTrait.html">TSMatScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/scalar division. Given the column-major sparse matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major sparse matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d6e/structblaze_1_1TSMatScalarDivExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d4f/structblaze_1_1TSMatScalarMultExprTrait.html">TSMatScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/scalar multiplication. Given the column-major sparse matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major sparse matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../df/d4f/structblaze_1_1TSMatScalarMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d6c/structblaze_1_1TSMatSerialExprTrait.html">TSMatSerialExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix serial evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix serial evaluation operation. Given the column-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/d6c/structblaze_1_1TSMatSerialExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/df7/structblaze_1_1TSMatSMatAddExprTrait.html">TSMatSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse matrix addition. Given the column-major sparse matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/df7/structblaze_1_1TSMatSMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc3/classblaze_1_1TSMatSMatMultExpr.html">TSMatSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-sparse matrix multiplications.The <a class="el" href="../../db/dc3/classblaze_1_1TSMatSMatMultExpr.html" title="Expression object for transpose sparse matrix-sparse matrix multiplications.The TSMatSMatMultExpr cla...">TSMatSMatMultExpr</a> class represents the compile time expression for multiplications between a column-major and a row-major sparse matrix.  <a href="../../db/dc3/classblaze_1_1TSMatSMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d96/structblaze_1_1TSMatSMatMultExprTrait.html">TSMatSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse matrix multiplication. Given the column-major sparse matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d96/structblaze_1_1TSMatSMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d0d/classblaze_1_1TSMatSMatSubExpr.html">TSMatSMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-sparse matrix subtractions.The <a class="el" href="../../d0/d0d/classblaze_1_1TSMatSMatSubExpr.html" title="Expression object for transpose sparse matrix-sparse matrix subtractions.The TSMatSMatSubExpr class r...">TSMatSMatSubExpr</a> class represents the compile time expression for subtractions between a column-major sparse matrix and a row-major sparse matrix.  <a href="../../d0/d0d/classblaze_1_1TSMatSMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de9/structblaze_1_1TSMatSMatSubExprTrait.html">TSMatSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse matrix subtraction. Given the column-major sparse matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/de9/structblaze_1_1TSMatSMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d16/classblaze_1_1TSMatSVecMultExpr.html">TSMatSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-sparse vector multiplications.The <a class="el" href="../../de/d16/classblaze_1_1TSMatSVecMultExpr.html" title="Expression object for sparse matrix-sparse vector multiplications.The TSMatSVecMultExpr class represe...">TSMatSVecMultExpr</a> class represents the compile time expression for multiplications between column-major sparse matrices and sparse vectors.  <a href="../../de/d16/classblaze_1_1TSMatSVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dbc/structblaze_1_1TSMatSVecMultExprTrait.html">TSMatSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse vector multiplication. Given the column-major sparse matrix type <em>MT</em> and the non-transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major sparse matrix type or <em>VT</em> is not a non-transpose sparse vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/dbc/structblaze_1_1TSMatSVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d27/structblaze_1_1TSMatTDMatAddExprTrait.html">TSMatTDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/transpose dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/transpose dense matrix addition. Given the column-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d27/structblaze_1_1TSMatTDMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d9f/classblaze_1_1TSMatTDMatMultExpr.html">TSMatTDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-transpose dense matrix multiplications.The <a class="el" href="../../d9/d9f/classblaze_1_1TSMatTDMatMultExpr.html" title="Expression object for transpose sparse matrix-transpose dense matrix multiplications.The TSMatTDMatMultExpr class represents the compile time expression for multiplications between a column-major sparse matrix and a column-major dense matrix. ">TSMatTDMatMultExpr</a> class represents the compile time expression for multiplications between a column-major sparse matrix and a column-major dense matrix.  <a href="../../d9/d9f/classblaze_1_1TSMatTDMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d13/structblaze_1_1TSMatTDMatMultExprTrait.html">TSMatTDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/transpose dense matrix multiplication. Given the column-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d13/structblaze_1_1TSMatTDMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/db2/structblaze_1_1TSMatTDMatSubExprTrait.html">TSMatTDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/transpose dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/transpose dense matrix subtraction. Given the column-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/db2/structblaze_1_1TSMatTDMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/df0/structblaze_1_1TSMatTransExprTrait.html">TSMatTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix transpose operation. Given the column-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>MT</em> is not a column-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/df0/structblaze_1_1TSMatTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d90/classblaze_1_1TSMatTSMatAddExpr.html">TSMatTSMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-transpose sparse matrix additions.The <a class="el" href="../../d5/d90/classblaze_1_1TSMatTSMatAddExpr.html" title="Expression object for transpose sparse matrix-transpose sparse matrix additions.The TSMatTSMatAddExpr...">TSMatTSMatAddExpr</a> class represents the compile time expression for additions between two column-major sparse matrices.  <a href="../../d5/d90/classblaze_1_1TSMatTSMatAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3f/structblaze_1_1TSMatTSMatAddExprTrait.html">TSMatTSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/transpose sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/transpose sparse matrix addition. Given the two column-major sparse matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a column-major sparse matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/d3f/structblaze_1_1TSMatTSMatAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dec/classblaze_1_1TSMatTSMatMultExpr.html">TSMatTSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-transpose sparse matrix multiplications.The <a class="el" href="../../d0/dec/classblaze_1_1TSMatTSMatMultExpr.html" title="Expression object for transpose sparse matrix-transpose sparse matrix multiplications.The TSMatTSMatMultExpr class represents the compile time expression for multiplications between two column-major sparse matrices. ">TSMatTSMatMultExpr</a> class represents the compile time expression for multiplications between two column-major sparse matrices.  <a href="../../d0/dec/classblaze_1_1TSMatTSMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d49/structblaze_1_1TSMatTSMatMultExprTrait.html">TSMatTSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/transpose sparse matrix multiplication. Given the two column-major sparse matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a column-major sparse matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d49/structblaze_1_1TSMatTSMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3f/classblaze_1_1TSMatTSMatSubExpr.html">TSMatTSMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-transpose sparse matrix subtractions.The <a class="el" href="../../d9/d3f/classblaze_1_1TSMatTSMatSubExpr.html" title="Expression object for transpose sparse matrix-transpose sparse matrix subtractions.The TSMatTSMatSubExpr class represents the compile time expression for subtractions between two column-major sparse matrices. ">TSMatTSMatSubExpr</a> class represents the compile time expression for subtractions between two column-major sparse matrices.  <a href="../../d9/d3f/classblaze_1_1TSMatTSMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de0/structblaze_1_1TSMatTSMatSubExprTrait.html">TSMatTSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/transpose sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/transpose sparse matrix subtraction. Given the two column-major sparse matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a column-major sparse matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/de0/structblaze_1_1TSMatTSMatSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d28/structblaze_1_1TSVecCTransExprTrait.html">TSVecCTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector conjugate transpose operation. Given the transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/d28/structblaze_1_1TSVecCTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse vector-dense matrix multiplications.The <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html" title="Expression object for transpose sparse vector-dense matrix multiplications.The TSVecDMatMultExpr clas...">TSVecDMatMultExpr</a> class represents the compile time expression for multiplications between transpose sparse vectors and row-major dense matrices.  <a href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7b/structblaze_1_1TSVecDMatMultExprTrait.html">TSVecDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/dense matrix multiplication. Given the transpose sparse vector type <em>VT</em> and the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose sparse vector type or <em>MT</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/d7b/structblaze_1_1TSVecDMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d75/structblaze_1_1TSVecDVecMultExprTrait.html">TSVecDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/dense vector multiplication (inner product). Given the transpose sparse vector type <em>VT1</em> and the non-transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose sparse vector type or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d75/structblaze_1_1TSVecDVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dad/structblaze_1_1TSVecEvalExprTrait.html">TSVecEvalExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector evaluation operation. Given the transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/dad/structblaze_1_1TSVecEvalExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/db8/structblaze_1_1TSVecForEachExprTrait.html">TSVecForEachExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector for-each operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector custom operation. Given the transpose sparse vector type <em>VT</em> and the custom operation type <em>OP</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/db8/structblaze_1_1TSVecForEachExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dfb/structblaze_1_1TSVecScalarDivExprTrait.html">TSVecScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/scalar division. Given the transpose sparse vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose sparse vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/dfb/structblaze_1_1TSVecScalarDivExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d98/structblaze_1_1TSVecScalarMultExprTrait.html">TSVecScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/scalar multiplication. Given the transpose sparse vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose sparse vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/d98/structblaze_1_1TSVecScalarMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d84/structblaze_1_1TSVecSerialExprTrait.html">TSVecSerialExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector serial evaluation operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector serial evaluation operation. Given the transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d84/structblaze_1_1TSVecSerialExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da7/classblaze_1_1TSVecSMatMultExpr.html">TSVecSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-sparse matrix multiplications.The <a class="el" href="../../d1/da7/classblaze_1_1TSVecSMatMultExpr.html" title="Expression object for sparse vector-sparse matrix multiplications.The TSVecSMatMultExpr class represe...">TSVecSMatMultExpr</a> class represents the compile time expression for multiplications between transpose sparse vectors and row-major sparse matrices.  <a href="../../d1/da7/classblaze_1_1TSVecSMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/daf/structblaze_1_1TSVecSMatMultExprTrait.html">TSVecSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse matrix multiplication. Given the transpose sparse vector type <em>VT</em> and the row-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose sparse vector type or <em>MT</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/daf/structblaze_1_1TSVecSMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d59/structblaze_1_1TSVecSVecMultExprTrait.html">TSVecSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/sparse vector multiplication (inner product). Given the transpose sparse vector type <em>VT1</em> and the non-transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose sparse vector type or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d5/d59/structblaze_1_1TSVecSVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse vector-transpose dense matrix multiplications.The <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html" title="Expression object for transpose sparse vector-transpose dense matrix multiplications.The TSVecTDMatMultExpr class represents the compile time expression for multiplications between transpose sparse vectors and column-major dense matrices. ">TSVecTDMatMultExpr</a> class represents the compile time expression for multiplications between transpose sparse vectors and column-major dense matrices.  <a href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d8e/structblaze_1_1TSVecTDMatMultExprTrait.html">TSVecTDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose dense matrix multiplication. Given the transpose sparse vector type <em>VT</em> and the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose sparse vector type or <em>MT</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d8e/structblaze_1_1TSVecTDMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de5/structblaze_1_1TSVecTDVecAddExprTrait.html">TSVecTDVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/transpose dense vector addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/transpose dense vector addition. Given the transpose sparse vector type <em>VT1</em> and the transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose sparse vector type or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/de5/structblaze_1_1TSVecTDVecAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d49/structblaze_1_1TSVecTDVecCrossExprTrait.html">TSVecTDVecCrossExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/dense vector cross product.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/dense vector cross product. Given the transpose sparse vector type <em>VT1</em> and the transpose dense vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose sparse vector type or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/d49/structblaze_1_1TSVecTDVecCrossExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d67/structblaze_1_1TSVecTDVecDivExprTrait.html">TSVecTDVecDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/transpose dense vector division.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/transpose dense vector division. Given the transpose sparse vector type <em>VT1</em> and the transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose sparse vector type or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d67/structblaze_1_1TSVecTDVecDivExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/da5/structblaze_1_1TSVecTDVecMultExprTrait.html">TSVecTDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/transpose dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/transpose dense vector multiplication. Given the transpose sparse vector type <em>VT1</em> and the transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose sparse vector type or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/da5/structblaze_1_1TSVecTDVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d6e/structblaze_1_1TSVecTDVecSubExprTrait.html">TSVecTDVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/transpose dense vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/transpose dense vector subtraction. Given the transpose sparse vector type <em>VT1</em> and the transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose sparse vector type or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d6e/structblaze_1_1TSVecTDVecSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0d/structblaze_1_1TSVecTransExprTrait.html">TSVecTransExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector transpose operation. Given the transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case <em>VT</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../da/d0d/structblaze_1_1TSVecTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d31/classblaze_1_1TSVecTSMatMultExpr.html">TSVecTSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-sparse matrix multiplications.The <a class="el" href="../../df/d31/classblaze_1_1TSVecTSMatMultExpr.html" title="Expression object for sparse vector-sparse matrix multiplications.The TSVecTSMatMultExpr class repres...">TSVecTSMatMultExpr</a> class represents the compile time expression for multiplications between transpose sparse vectors and column-major sparse matrices.  <a href="../../df/d31/classblaze_1_1TSVecTSMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d8e/structblaze_1_1TSVecTSMatMultExprTrait.html">TSVecTSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose sparse matrix multiplication. Given the transpose sparse vector type <em>VT</em> and the column-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose sparse vector type or <em>MT</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/d8e/structblaze_1_1TSVecTSMatMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d9f/structblaze_1_1TSVecTSVecAddExprTrait.html">TSVecTSVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/transpose sparse vector addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/transpose sparse vector addition. Given the two transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d9f/structblaze_1_1TSVecTSVecAddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d55/structblaze_1_1TSVecTSVecCrossExprTrait.html">TSVecTSVecCrossExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/sparse vector cross product.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse vector cross product. Given the two transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/d55/structblaze_1_1TSVecTSVecCrossExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/structblaze_1_1TSVecTSVecMultExprTrait.html">TSVecTSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/transpose sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/transpose sparse vector multiplication. Given the two transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d5/d8c/structblaze_1_1TSVecTSVecMultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d70/structblaze_1_1TSVecTSVecSubExprTrait.html">TSVecTSVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/transpose sparse vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/transpose sparse vector subtraction. Given the two transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d70/structblaze_1_1TSVecTSVecSubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html">TVecMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/matrix multiplication expression templates.The <a class="el" href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html" title="Base class for all vector/matrix multiplication expression templates.The TVecMatMultExpr class serves...">TVecMatMultExpr</a> class serves as a tag for all expression templates that implement a vector/matrix multiplication. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector/matrix multiplication and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector/matrix multiplication expression template. Only in case a class is derived from the <a class="el" href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html" title="Base class for all vector/matrix multiplication expression templates.The TVecMatMultExpr class serves...">TVecMatMultExpr</a> base class, the <a class="el" href="../../d8/d08/structblaze_1_1IsTVecMatMultExpr.html" title="Compile time check whether the given type is a vector/matrix multiplication expression template...">IsTVecMatMultExpr</a> type trait recognizes the class as valid vector/matrix multiplication expression template.  <a href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/da4/structblaze_1_1TypeAt.html">TypeAt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexing a type list.The <a class="el" href="../../d8/da4/structblaze_1_1TypeAt.html" title="Indexing a type list.The TypeAt class can be used to access a type list at a specified position to qu...">TypeAt</a> class can be used to access a type list at a specified position to query the according type. In order to index a type list, the <a class="el" href="../../d8/da4/structblaze_1_1TypeAt.html" title="Indexing a type list.The TypeAt class can be used to access a type list at a specified position to qu...">TypeAt</a> class has to be instantiated for a particular type list and an index value. The indexed type is available via the member type definition <em>Result</em>. The following example gives an impression of the use of the <a class="el" href="../../d8/da4/structblaze_1_1TypeAt.html" title="Indexing a type list.The TypeAt class can be used to access a type list at a specified position to qu...">TypeAt</a> class:  <a href="../../d8/da4/structblaze_1_1TypeAt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d88/structblaze_1_1TypeList.html">TypeList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a type list.The <a class="el" href="../../df/d88/structblaze_1_1TypeList.html" title="Implementation of a type list.The TypeList class is an implementation of a type list according to the...">TypeList</a> class is an implementation of a type list according to the example of Andrei Alexandrescu. The type list merely consists of the two data types <em>Head</em> and <em>Tail</em>. In order to create type lists of more data types, the <a class="el" href="../../df/d88/structblaze_1_1TypeList.html" title="Implementation of a type list.The TypeList class is an implementation of a type list according to the...">TypeList</a> class is used recursively:  <a href="../../df/d88/structblaze_1_1TypeList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d70/structblaze_1_1TypeValueMapping.html">TypeValueMapping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion from a data type to a serial representation.This class template converts the given data type into an integral representation suited for serialization. Depending on the given data type, the <em>value</em> member enumeration is set to the according serial representation.  <a href="../../d8/d70/structblaze_1_1TypeValueMapping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3a/classblaze_1_1uint16__t.html">uint16_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit unsigned integer type of the Blaze library.  <a href="../../de/d3a/classblaze_1_1uint16__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dba/classblaze_1_1uint32__t.html">uint32_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit unsigned integer type of the Blaze library.  <a href="../../d6/dba/classblaze_1_1uint32__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d68/classblaze_1_1uint64__t.html">uint64_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit unsigned integer type of the Blaze library.  <a href="../../d5/d68/classblaze_1_1uint64__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da1/classblaze_1_1uint8__t.html">uint8_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit unsigned integer type of the Blaze library.  <a href="../../da/da1/classblaze_1_1uint8__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html">UnderlyingBuiltin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the underlying builtin element type of a given data type.Via this type trait it is possible to evaluate the underlying fundamental element type at the heart of a given data type. Examples:  <a href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html">UnderlyingElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the element type of a given data type.Via this type trait it is possible to evaluate the element type of a given data type. Examples:  <a href="../../d5/d7f/structblaze_1_1UnderlyingElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html">UnderlyingNumeric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the underlying numeric element type of a given data type.Via this type trait it is possible to evaluate the underlying numeric (fundamental or complex) element type at the heart of a given data type. Examples:  <a href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9b/classblaze_1_1UniLowerElement.html">UniLowerElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an element within a sparse lower unitriangular matrix.The <a class="el" href="../../d5/d9b/classblaze_1_1UniLowerElement.html" title="Representation of an element within a sparse lower unitriangular matrix.The UniLowerElement class rep...">UniLowerElement</a> class represents an element (i.e. value/index pair) within a sparse lower unitriangular matrix. It guarantees that the unilower matrix invariant is not violated, i.e. that elements in the upper part of the matrix remain 0 and the diagonal elements remain 1. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> sparse lower unitriangular matrix:  <a href="../../d5/d9b/classblaze_1_1UniLowerElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d62/classblaze_1_1UniLowerMatrix.html">UniLowerMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> adapter for lower unitriangular <img class="formulaInl" alt="$ N \times N $" src="../../form_18.png"/> matrices.  <a href="../../d2/d62/classblaze_1_1UniLowerMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0e/classblaze_1_1UniLowerProxy.html">UniLowerProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for lower unitriangular matrices.The <a class="el" href="../../da/d0e/classblaze_1_1UniLowerProxy.html" title="Access proxy for lower unitriangular matrices.The UniLowerProxy provides controlled access to the ele...">UniLowerProxy</a> provides controlled access to the elements of a non-const lower unitriangular matrix. It guarantees that the unilower matrix invariant is not violated, i.e. that elements in the upper part of the matrix remain 0 and the diagonal elements remain 1. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> dense lower unitriangular matrix:  <a href="../../da/d0e/classblaze_1_1UniLowerProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc7/classblaze_1_1UniLowerValue.html">UniLowerValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a value within a sparse lower unitriangular matrix.The <a class="el" href="../../d0/dc7/classblaze_1_1UniLowerValue.html" title="Representation of a value within a sparse lower unitriangular matrix.The UniLowerValue class represen...">UniLowerValue</a> class represents a single value within a sparse lower unitriangular matrix. It guarantees that the unilower matrix invariant is not violated, i.e. that elements in the upper part of the matrix remain 0 and the diagonal elements remain 1. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> sparse lower unitriangular matrix:  <a href="../../d0/dc7/classblaze_1_1UniLowerValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de6/structblaze_1_1Unique.html">Unique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing all duplicates from a type list.The <a class="el" href="../../d0/de6/structblaze_1_1Unique.html" title="Erasing all duplicates from a type list.The Unique class can be used to erase all duplicates from a t...">Unique</a> class can be used to erase all duplicates from a type list <em>TList</em>. In order to erase all duplicates, the <a class="el" href="../../d0/de6/structblaze_1_1Unique.html" title="Erasing all duplicates from a type list.The Unique class can be used to erase all duplicates from a t...">Unique</a> class has to be instantiated for a particular type list. The following example gives an impression of the use of the <a class="el" href="../../d0/de6/structblaze_1_1Unique.html" title="Erasing all duplicates from a type list.The Unique class can be used to erase all duplicates from a t...">Unique</a> class:  <a href="../../d0/de6/structblaze_1_1Unique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d18/classblaze_1_1UniUpperElement.html">UniUpperElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an element within a sparse upper unitriangular matrix.The <a class="el" href="../../d1/d18/classblaze_1_1UniUpperElement.html" title="Representation of an element within a sparse upper unitriangular matrix.The UniUpperElement class rep...">UniUpperElement</a> class represents an element (i.e. value/index pair) within a sparse upper unitriangular matrix. It guarantees that the uniupper matrix invariant is not violated, i.e. that elements in the lower part of the matrix remain 0 and the diagonal elements remain 1. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> sparse upper unitriangular matrix:  <a href="../../d1/d18/classblaze_1_1UniUpperElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d0d/classblaze_1_1UniUpperMatrix.html">UniUpperMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> adapter for upper unitriangular <img class="formulaInl" alt="$ N \times N $" src="../../form_18.png"/> matrices.  <a href="../../db/d0d/classblaze_1_1UniUpperMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d98/classblaze_1_1UniUpperProxy.html">UniUpperProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for upper unitriangular matrices.The <a class="el" href="../../d8/d98/classblaze_1_1UniUpperProxy.html" title="Access proxy for upper unitriangular matrices.The UniUpperProxy provides controlled access to the ele...">UniUpperProxy</a> provides controlled access to the elements of a non-const upper unitriangular matrix. It guarantees that the uniupper matrix invariant is not violated, i.e. that elements in the lower part of the matrix remain 0 and the diagonal elements remain 1. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> dense upper unitriangular matrix:  <a href="../../d8/d98/classblaze_1_1UniUpperProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7c/classblaze_1_1UniUpperValue.html">UniUpperValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a value within a sparse upper unitriangular matrix.The <a class="el" href="../../dc/d7c/classblaze_1_1UniUpperValue.html" title="Representation of a value within a sparse upper unitriangular matrix.The UniUpperValue class represen...">UniUpperValue</a> class represents a single value within a sparse upper unitriangular matrix. It guarantees that the uniupper matrix invariant is not violated, i.e. that elements in the upper part of the matrix remain 0 and the diagonal elements remain 1. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> sparse upper unitriangular matrix:  <a href="../../dc/d7c/classblaze_1_1UniUpperValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-in unsigned integral type in order to be able to extract non-negative unsigned integral values from an input stream.  <a href="../../da/d54/classblaze_1_1UnsignedValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html">UpperMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> adapter for upper triangular <img class="formulaInl" alt="$ N \times N $" src="../../form_18.png"/> matrices.  <a href="../../d5/daf/classblaze_1_1UpperMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dee/classblaze_1_1UpperProxy.html">UpperProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for upper triangular matrices.The <a class="el" href="../../d7/dee/classblaze_1_1UpperProxy.html" title="Access proxy for upper triangular matrices.The UpperProxy provides controlled access to the elements ...">UpperProxy</a> provides controlled access to the elements of a non-const upper triangular matrix. It guarantees that the upper matrix invariant is not violated, i.e. that elements in the lower part of the matrix remain default values. The following example illustrates this by means of a <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_21.png"/> dense upper matrix:  <a href="../../d7/dee/classblaze_1_1UpperProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc7/classblaze_1_1ValueIndexPair.html">ValueIndexPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-value-pair for sparse vectors and matrices.The <a class="el" href="../../db/dc7/classblaze_1_1ValueIndexPair.html" title="Index-value-pair for sparse vectors and matrices.The ValueIndexPair class represents a single index-v...">ValueIndexPair</a> class represents a single index-value-pair of a sparse vector or sparse matrix.  <a href="../../db/dc7/classblaze_1_1ValueIndexPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d95/structblaze_1_1VecEvalExpr.html">VecEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector evaluation expression templates.The <a class="el" href="../../da/d95/structblaze_1_1VecEvalExpr.html" title="Base class for all vector evaluation expression templates.The VecEvalExpr class serves as a tag for a...">VecEvalExpr</a> class serves as a tag for all expression templates that implement a vector evaluation operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector evaluation operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector evaluation expression template. Only in case a class is derived from the <a class="el" href="../../da/d95/structblaze_1_1VecEvalExpr.html" title="Base class for all vector evaluation expression templates.The VecEvalExpr class serves as a tag for a...">VecEvalExpr</a> base class, the <a class="el" href="../../d6/d05/structblaze_1_1IsVecEvalExpr.html" title="Compile time check whether the given type is a vector evaluation expression template.This type trait class tests whether or not the given type Type is a vector evaluation expression template. In order to qualify as a valid vector evaluation expression template, the given type has to derive (publicly or privately) from the VecEvalExpr base class. In case the given type is a valid vector evaluation expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecEvalExpr</a> type trait recognizes the class as valid vector evaluation expression template.  <a href="../../da/d95/structblaze_1_1VecEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d40/structblaze_1_1VecForEachExpr.html">VecForEachExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector for-each expression templates.The <a class="el" href="../../dd/d40/structblaze_1_1VecForEachExpr.html" title="Base class for all vector for-each expression templates.The VecForEachExpr class serves as a tag for ...">VecForEachExpr</a> class serves as a tag for all expression templates that represent a unary, custom operation on a vector. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector custom operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector for-each expression template. Only in case a class is derived from the <a class="el" href="../../dd/d40/structblaze_1_1VecForEachExpr.html" title="Base class for all vector for-each expression templates.The VecForEachExpr class serves as a tag for ...">VecForEachExpr</a> base class, the <a class="el" href="../../d6/dfc/structblaze_1_1IsVecForEachExpr.html" title="Compile time check whether the given type is a vector for-each expression template.This type trait class tests whether or not the given type Type is a vector for-each expression template. In order to qualify as a valid vector for-each expression template, the given type has to derive (publicly or privately) from the VecForEachExpr base class. In case the given type is a valid vector for-each expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecForEachExpr</a> type trait recognizes the class as valid vector for-each expression template.  <a href="../../dd/d40/structblaze_1_1VecForEachExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html">VecScalarDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/scalar division expression templates.The <a class="el" href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html" title="Base class for all vector/scalar division expression templates.The VecScalarDivExpr class serves as a...">VecScalarDivExpr</a> class serves as a tag for all expression templates that implement a vector/scalar division. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector/scalar division and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector/scalar division expression template. Only in case a class is derived from the <a class="el" href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html" title="Base class for all vector/scalar division expression templates.The VecScalarDivExpr class serves as a...">VecScalarDivExpr</a> base class, the <a class="el" href="../../d7/da6/structblaze_1_1IsVecScalarDivExpr.html" title="Compile time check whether the given type is a vector/scalar division expression template.This type trait class tests whether or not the given type Type is a vector/scalar division expression template. In order to qualify as a valid vector/scalar division expression template, the given type has to derive (publicly or privately) from the VecScalarDivExpr base class. In case the given type is a valid vector/scalar division expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecScalarDivExpr</a> type trait recognizes the class as valid vector/scalar division expression template.  <a href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d01/structblaze_1_1VecScalarMultExpr.html">VecScalarMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/scalar multiplication expression templates.The <a class="el" href="../../df/d01/structblaze_1_1VecScalarMultExpr.html" title="Base class for all vector/scalar multiplication expression templates.The VecScalarMultExpr class serv...">VecScalarMultExpr</a> class serves as a tag for all expression templates that implement a vector/scalar multiplication. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector/scalar multiplication and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector/scalar multiplication expression template. Only in case a class is derived from the <a class="el" href="../../df/d01/structblaze_1_1VecScalarMultExpr.html" title="Base class for all vector/scalar multiplication expression templates.The VecScalarMultExpr class serv...">VecScalarMultExpr</a> base class, the <a class="el" href="../../d7/da8/structblaze_1_1IsVecScalarMultExpr.html" title="Compile time check whether the given type is a vector/scalar multiplication expression template...">IsVecScalarMultExpr</a> type trait recognizes the class as valid vector/scalar multiplication expression template.  <a href="../../df/d01/structblaze_1_1VecScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfb/structblaze_1_1VecSerialExpr.html">VecSerialExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector serial evaluation expression templates.The <a class="el" href="../../d8/dfb/structblaze_1_1VecSerialExpr.html" title="Base class for all vector serial evaluation expression templates.The VecSerialExpr class serves as a ...">VecSerialExpr</a> class serves as a tag for all expression templates that enforce a serial evaluation of a vector. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector serialization operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector serial evaluation expression template. Only in case a class is derived from the <a class="el" href="../../d8/dfb/structblaze_1_1VecSerialExpr.html" title="Base class for all vector serial evaluation expression templates.The VecSerialExpr class serves as a ...">VecSerialExpr</a> base class, the <a class="el" href="../../d2/d59/structblaze_1_1IsVecSerialExpr.html" title="Compile time check whether the given type is a vector serial evaluation expression template...">IsVecSerialExpr</a> type trait recognizes the class as valid vector serial evaluation expression template.  <a href="../../d8/dfb/structblaze_1_1VecSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for N-dimensional vectors.The <a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> class is a base class for all arbitrarily sized (N-dimensional) dense and sparse vector classes within the Blaze library. It provides an abstraction from the actual type of the vector, but enables a conversion back to this type via the 'Curiously Recurring Template Pattern' (CRTP).  <a href="../../da/d86/structblaze_1_1Vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for sparse, N-dimensional vectors.The <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> provides safe access to the elements of a non-const sparse vector.<br />
The proxied access to the elements of a sparse vector is necessary since it may be possible that several insertion operations happen in the same statement. The following code illustrates this with two examples by means of the <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">CompressedVector</a> class:  <a href="../../df/de3/classblaze_1_1VectorAccessProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d88/classblaze_1_1VectorSerializer.html">VectorSerializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializer for dense and sparse vectors.The <a class="el" href="../../d7/d88/classblaze_1_1VectorSerializer.html" title="Serializer for dense and sparse vectors.The VectorSerializer implements the necessary logic to serial...">VectorSerializer</a> implements the necessary logic to serialize dense and sparse vectors, i.e. to convert them into a portable, binary representation. The following example demonstrates the (de-)serialization process of vectors:  <a href="../../d7/d88/classblaze_1_1VectorSerializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dec/structblaze_1_1VecTransExpr.html">VecTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector transposition expression templates.The <a class="el" href="../../d0/dec/structblaze_1_1VecTransExpr.html" title="Base class for all vector transposition expression templates.The VecTransExpr class serves as a tag f...">VecTransExpr</a> class serves as a tag for all expression templates that implement a vector transposition operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector transposition operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector transposition expression template. Only in case a class is derived from the <a class="el" href="../../d0/dec/structblaze_1_1VecTransExpr.html" title="Base class for all vector transposition expression templates.The VecTransExpr class serves as a tag f...">VecTransExpr</a> base class, the <a class="el" href="../../d9/d3d/structblaze_1_1IsVecTransExpr.html" title="Compile time check whether the given type is a vector transposition expression template.This type trait class tests whether or not the given type Type is a vector transposition expression template. In order to qualify as a valid vector transposition expression template, the given type has to derive (publicly or privately) from the VecTransExpr base class. In case the given type is a valid vector transposition expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecTransExpr</a> type trait recognizes the class as valid vector transposition expression template.  <a href="../../d0/dec/structblaze_1_1VecTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d08/structblaze_1_1VecTVecMultExpr.html">VecTVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all outer product expression templates.The <a class="el" href="../../de/d08/structblaze_1_1VecTVecMultExpr.html" title="Base class for all outer product expression templates.The VecTVecMultExpr class serves as a tag for a...">VecTVecMultExpr</a> class serves as a tag for all expression templates that implement mathematical outer products (i.e. multiplications between a column vector and a row vector). <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical outer product and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as outer product expression template. Only in case a class is derived from the <a class="el" href="../../de/d08/structblaze_1_1VecTVecMultExpr.html" title="Base class for all outer product expression templates.The VecTVecMultExpr class serves as a tag for a...">VecTVecMultExpr</a> base class, the <a class="el" href="../../d7/d17/structblaze_1_1IsVecTVecMultExpr.html" title="Compile time check whether the given type is an outer product expression template.This type trait class tests whether or not the given type Type is an outer product expression template (i.e. an expression representing the multiplication between a column vector and a row vector). In order to qualify as a valid outer product expression template, the given type has to derive (publicly or privately) from the VecTVecMultExpr base class. In case the given type is a valid outer product expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecTVecMultExpr</a> type trait recognizes the class as valid outer product expression template.  <a href="../../de/d08/structblaze_1_1VecTVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d58/structblaze_1_1VecVecAddExpr.html">VecVecAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/vector addition expression templates.The <a class="el" href="../../d0/d58/structblaze_1_1VecVecAddExpr.html" title="Base class for all vector/vector addition expression templates.The VecVecAddExpr class serves as a ta...">VecVecAddExpr</a> class serves as a tag for all expression templates that implement a vector/vector addition. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector addition and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector addition expression template. Only in case a class is derived from the <a class="el" href="../../d0/d58/structblaze_1_1VecVecAddExpr.html" title="Base class for all vector/vector addition expression templates.The VecVecAddExpr class serves as a ta...">VecVecAddExpr</a> base class, the <a class="el" href="../../d5/dae/structblaze_1_1IsVecVecAddExpr.html" title="Compile time check whether the given type is a vector/vector addition expression template.This type trait class tests whether or not the given type Type is a vector/vector addition expression template. In order to qualify as a valid vector addition expression template, the given type has to derive (publicly or privately) from the VecVecAddExpr base class. In case the given type is a valid vector addition expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecVecAddExpr</a> type trait recognizes the class as valid vector addition expression template.  <a href="../../d0/d58/structblaze_1_1VecVecAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc6/structblaze_1_1VecVecDivExpr.html">VecVecDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/vector division expression templates.The <a class="el" href="../../de/dc6/structblaze_1_1VecVecDivExpr.html" title="Base class for all vector/vector division expression templates.The VecVecDivExpr class serves as a ta...">VecVecDivExpr</a> class serves as a tag for all expression templates that implement a vector/vector division. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector division and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector division expression template. Only in case a class is derived from the <a class="el" href="../../de/dc6/structblaze_1_1VecVecDivExpr.html" title="Base class for all vector/vector division expression templates.The VecVecDivExpr class serves as a ta...">VecVecDivExpr</a> base class, the <a class="el" href="../../d1/ddd/structblaze_1_1IsVecVecDivExpr.html" title="Compile time check whether the given type is a vector/vector division expression template.This type trait class tests whether or not the given type Type is a vector/vector division expression template. In order to qualify as a valid vector division expression template, the given type has to derive (publicly or privately) from the VecVecDivExpr base class. In case the given type is a valid vector division expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecVecDivExpr</a> type trait recognizes the class as valid vector division expression template.  <a href="../../de/dc6/structblaze_1_1VecVecDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d10/structblaze_1_1VecVecMultExpr.html">VecVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/vector multiplication expression templates.The <a class="el" href="../../df/d10/structblaze_1_1VecVecMultExpr.html" title="Base class for all vector/vector multiplication expression templates.The VecVecMultExpr class serves ...">VecVecMultExpr</a> class serves as a tag for all expression templates that implement a vector/vector multiplication. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector multiplication and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector multiplication expression template. Only in case a class is derived from the <a class="el" href="../../df/d10/structblaze_1_1VecVecMultExpr.html" title="Base class for all vector/vector multiplication expression templates.The VecVecMultExpr class serves ...">VecVecMultExpr</a> base class, the <a class="el" href="../../dc/d79/structblaze_1_1IsVecVecMultExpr.html" title="Compile time check whether the given type is a vector/vector multiplication expression template...">IsVecVecMultExpr</a> type trait recognizes the class as valid vector multiplication expression template.  <a href="../../df/d10/structblaze_1_1VecVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d87/structblaze_1_1VecVecSubExpr.html">VecVecSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/vector subtraction expression templates.The <a class="el" href="../../d1/d87/structblaze_1_1VecVecSubExpr.html" title="Base class for all vector/vector subtraction expression templates.The VecVecSubExpr class serves as a...">VecVecSubExpr</a> class serves as a tag for all expression templates that implement a vector/vector subtraction. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector subtraction and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector subtraction expression template. Only in case a class is derived from the <a class="el" href="../../d1/d87/structblaze_1_1VecVecSubExpr.html" title="Base class for all vector/vector subtraction expression templates.The VecVecSubExpr class serves as a...">VecVecSubExpr</a> base class, the <a class="el" href="../../d9/d16/structblaze_1_1IsVecVecSubExpr.html" title="Compile time check whether the given type is a vector/vector subtraction expression template...">IsVecVecSubExpr</a> type trait recognizes the class as valid vector subtraction expression template.  <a href="../../d1/d87/structblaze_1_1VecVecSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dae/structblaze_1_1View.html">View</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all views.The <a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the <a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> base class, the <a class="el" href="../../da/dbb/structblaze_1_1IsView.html" title="Compile time check for views.This type trait tests whether or not the given template parameter is a v...">IsView</a> type trait recognizes the class as valid view.  <a href="../../d4/dae/structblaze_1_1View.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da9/structblaze_1_1Xor.html">Xor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time logical xor evaluation.The <a class="el" href="../../d0/da9/structblaze_1_1Xor.html" title="Compile time logical xor evaluation.The Xor class template performs at compile time a logical xor eva...">Xor</a> class template performs at compile time a logical xor evaluation of the two given compile time conditions:  <a href="../../d0/da9/structblaze_1_1Xor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf3e403c679e31e0915664a12344b5e8c"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaf3e403c679e31e0915664a12344b5e8c">real_t</a></td></tr>
<tr class="memdesc:gaf3e403c679e31e0915664a12344b5e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating point data type of the Blaze library.This type definition offers the possibility to switch the floating point precision of the Blaze library between float, double and long double.  <a href="../../d1/d44/group__config.html#gaf3e403c679e31e0915664a12344b5e8c">More...</a><br /></td></tr>
<tr class="separator:gaf3e403c679e31e0915664a12344b5e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb3f2f3c2cfd4879412749690748da33"><td class="memItemLeft" align="right" valign="top">typedef std::mt19937&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gadb3f2f3c2cfd4879412749690748da33">RNG</a></td></tr>
<tr class="memdesc:gadb3f2f3c2cfd4879412749690748da33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the random number generator of the Blaze library.This type definition represents the type of the random number generated used in the Blaze library. The default random number generator is the std::mt19937 mersenne-twister pseudo random number generator. For more information see the following reference documentation:  <a href="../../d1/d44/group__config.html#gadb3f2f3c2cfd4879412749690748da33">More...</a><br /></td></tr>
<tr class="separator:gadb3f2f3c2cfd4879412749690748da33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66bdb6fd80a82c4f231125a9b7e8820"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa66bdb6fd80a82c4f231125a9b7e8820"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#aa66bdb6fd80a82c4f231125a9b7e8820">BaseType_</a> = typename T::BaseType</td></tr>
<tr class="memdesc:aa66bdb6fd80a82c4f231125a9b7e8820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>BaseType</code> type definitions.The BaseType_ alias declaration provides a convenient shortcut to access the nested <em>BaseType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#aa66bdb6fd80a82c4f231125a9b7e8820">More...</a><br /></td></tr>
<tr class="separator:aa66bdb6fd80a82c4f231125a9b7e8820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0851f216dd228db447fbf55718e18c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf0851f216dd228db447fbf55718e18c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#acf0851f216dd228db447fbf55718e18c">CompositeType_</a> = typename T::CompositeType</td></tr>
<tr class="memdesc:acf0851f216dd228db447fbf55718e18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>CompositeType</code> type definitions.The CompositeType_ alias declaration provides a convenient shortcut to access the nested <em>CompositeType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#acf0851f216dd228db447fbf55718e18c">More...</a><br /></td></tr>
<tr class="separator:acf0851f216dd228db447fbf55718e18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d864b56dde1649490ccd585cb20508"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1d864b56dde1649490ccd585cb20508"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#aa1d864b56dde1649490ccd585cb20508">ConstIterator_</a> = typename T::ConstIterator</td></tr>
<tr class="memdesc:aa1d864b56dde1649490ccd585cb20508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>ConstIterator</code> type definitions.The ConstIterator_ alias declaration provides a convenient shortcut to access the nested <em>ConstIterator</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#aa1d864b56dde1649490ccd585cb20508">More...</a><br /></td></tr>
<tr class="separator:aa1d864b56dde1649490ccd585cb20508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe86491b935b63fcc07559cd23830314"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe86491b935b63fcc07559cd23830314"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#afe86491b935b63fcc07559cd23830314">ConstPointer_</a> = typename T::ConstPointer</td></tr>
<tr class="memdesc:afe86491b935b63fcc07559cd23830314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>ConstPointer</code> type definitions.The ConstPointer_ alias declaration provides a convenient shortcut to access the nested <em>ConstPointer</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#afe86491b935b63fcc07559cd23830314">More...</a><br /></td></tr>
<tr class="separator:afe86491b935b63fcc07559cd23830314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7428fec1f7754658bd4d765ed6e87841"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7428fec1f7754658bd4d765ed6e87841"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a7428fec1f7754658bd4d765ed6e87841">ConstReference_</a> = typename T::ConstReference</td></tr>
<tr class="memdesc:a7428fec1f7754658bd4d765ed6e87841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>ConstReference</code> type definitions.The ConstReference_ alias declaration provides a convenient shortcut to access the nested <em>ConstReference</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#a7428fec1f7754658bd4d765ed6e87841">More...</a><br /></td></tr>
<tr class="separator:a7428fec1f7754658bd4d765ed6e87841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d478221c22767e2ab79fe64681a744b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d478221c22767e2ab79fe64681a744b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a> = typename T::ElementType</td></tr>
<tr class="memdesc:a9d478221c22767e2ab79fe64681a744b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>ElementType</code> type definitions.The ElementType_ alias declaration provides a convenient shortcut to access the nested <em>ElementType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#a9d478221c22767e2ab79fe64681a744b">More...</a><br /></td></tr>
<tr class="separator:a9d478221c22767e2ab79fe64681a744b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cefc4108da9a311933047654da11b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a55cefc4108da9a311933047654da11b1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a55cefc4108da9a311933047654da11b1">Iterator_</a> = typename T::Iterator</td></tr>
<tr class="memdesc:a55cefc4108da9a311933047654da11b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>Iterator</code> type definitions.The Iterator_ alias declaration provides a convenient shortcut to access the nested <em>Iterator</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#a55cefc4108da9a311933047654da11b1">More...</a><br /></td></tr>
<tr class="separator:a55cefc4108da9a311933047654da11b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d0b1baafdb999e088b9cb10b7346d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79d0b1baafdb999e088b9cb10b7346d9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a79d0b1baafdb999e088b9cb10b7346d9">LeftOperand_</a> = typename T::LeftOperand</td></tr>
<tr class="memdesc:a79d0b1baafdb999e088b9cb10b7346d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>LeftOperand</code> type definitions.The LeftOperand_ alias declaration provides a convenient shortcut to access the nested <em>LeftOperand</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#a79d0b1baafdb999e088b9cb10b7346d9">More...</a><br /></td></tr>
<tr class="separator:a79d0b1baafdb999e088b9cb10b7346d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aedbbd636a9bb4c0c5b633710f861e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8aedbbd636a9bb4c0c5b633710f861e7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a8aedbbd636a9bb4c0c5b633710f861e7">Operand_</a> = typename T::Operand</td></tr>
<tr class="memdesc:a8aedbbd636a9bb4c0c5b633710f861e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>Operand</code> type definitions.The Operand_ alias declaration provides a convenient shortcut to access the nested <em>Operand</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#a8aedbbd636a9bb4c0c5b633710f861e7">More...</a><br /></td></tr>
<tr class="separator:a8aedbbd636a9bb4c0c5b633710f861e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad282ad15aa380c05ce262000a81e6d81"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad282ad15aa380c05ce262000a81e6d81"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ad282ad15aa380c05ce262000a81e6d81">OppositeType_</a> = typename T::OppositeType</td></tr>
<tr class="memdesc:ad282ad15aa380c05ce262000a81e6d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>OppositeType</code> type definitions.The OppositeType_ alias declaration provides a convenient shortcut to access the nested <em>OppositeType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#ad282ad15aa380c05ce262000a81e6d81">More...</a><br /></td></tr>
<tr class="separator:ad282ad15aa380c05ce262000a81e6d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d7e49942dc7ea47dc5289b3f43c35b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52d7e49942dc7ea47dc5289b3f43c35b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a52d7e49942dc7ea47dc5289b3f43c35b">Pointer_</a> = typename T::Pointer</td></tr>
<tr class="memdesc:a52d7e49942dc7ea47dc5289b3f43c35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>Pointer</code> type definitions.The Pointer_ alias declaration provides a convenient shortcut to access the nested <em>Pointer</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#a52d7e49942dc7ea47dc5289b3f43c35b">More...</a><br /></td></tr>
<tr class="separator:a52d7e49942dc7ea47dc5289b3f43c35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1285adb17e7a11f3dee9b2b0f03f8a89"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1285adb17e7a11f3dee9b2b0f03f8a89"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a1285adb17e7a11f3dee9b2b0f03f8a89">Reference_</a> = typename T::Reference</td></tr>
<tr class="memdesc:a1285adb17e7a11f3dee9b2b0f03f8a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>Reference</code> type definitions.The Reference_ alias declaration provides a convenient shortcut to access the nested <em>Reference</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#a1285adb17e7a11f3dee9b2b0f03f8a89">More...</a><br /></td></tr>
<tr class="separator:a1285adb17e7a11f3dee9b2b0f03f8a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10b120fdcec644d7b612ec666aeebde"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae10b120fdcec644d7b612ec666aeebde"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a> = typename T::RepresentedType</td></tr>
<tr class="memdesc:ae10b120fdcec644d7b612ec666aeebde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>RepresentedType</code> type definitions.The RepresentedType_ alias declaration provides a convenient shortcut to access the nested <em>RepresentedType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#ae10b120fdcec644d7b612ec666aeebde">More...</a><br /></td></tr>
<tr class="separator:ae10b120fdcec644d7b612ec666aeebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a86db58851c76c3500769d8afdc759e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a86db58851c76c3500769d8afdc759e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a5a86db58851c76c3500769d8afdc759e">ResultType_</a> = typename T::ResultType</td></tr>
<tr class="memdesc:a5a86db58851c76c3500769d8afdc759e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>ResultType</code> type definitions.The ResultType_ alias declaration provides a convenient shortcut to access the nested <em>ResultType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#a5a86db58851c76c3500769d8afdc759e">More...</a><br /></td></tr>
<tr class="separator:a5a86db58851c76c3500769d8afdc759e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e2edcdde49d73a7ca7d2515046b088"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2e2edcdde49d73a7ca7d2515046b088"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#aa2e2edcdde49d73a7ca7d2515046b088">ReturnType_</a> = typename T::ReturnType</td></tr>
<tr class="memdesc:aa2e2edcdde49d73a7ca7d2515046b088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>ReturnType</code> type definitions.The ReturnType_ alias declaration provides a convenient shortcut to access the nested <em>ReturnType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#aa2e2edcdde49d73a7ca7d2515046b088">More...</a><br /></td></tr>
<tr class="separator:aa2e2edcdde49d73a7ca7d2515046b088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494d63c91ad9b77468f45f852098c5e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a494d63c91ad9b77468f45f852098c5e7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a494d63c91ad9b77468f45f852098c5e7">RightOperand_</a> = typename T::RightOperand</td></tr>
<tr class="memdesc:a494d63c91ad9b77468f45f852098c5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>RightOperand</code> type definitions.The RightOperand_ alias declaration provides a convenient shortcut to access the nested <em>RightOperand</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#a494d63c91ad9b77468f45f852098c5e7">More...</a><br /></td></tr>
<tr class="separator:a494d63c91ad9b77468f45f852098c5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae826b6abc142b9ae2a5b4ca14cc679"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acae826b6abc142b9ae2a5b4ca14cc679"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#acae826b6abc142b9ae2a5b4ca14cc679">SIMDType_</a> = typename T::SIMDType</td></tr>
<tr class="memdesc:acae826b6abc142b9ae2a5b4ca14cc679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>SIMDType</code> type definitions.The SIMDType_ alias declaration provides a convenient shortcut to access the nested <em>SIMDType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#acae826b6abc142b9ae2a5b4ca14cc679">More...</a><br /></td></tr>
<tr class="separator:acae826b6abc142b9ae2a5b4ca14cc679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0f2ff41fa8f2a1a6ff10fe09817cd8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca0f2ff41fa8f2a1a6ff10fe09817cd8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#aca0f2ff41fa8f2a1a6ff10fe09817cd8">TransposeType_</a> = typename T::TransposeType</td></tr>
<tr class="memdesc:aca0f2ff41fa8f2a1a6ff10fe09817cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>TransposeType</code> type definitions.The TransposeType_ alias declaration provides a convenient shortcut to access the nested <em>TransposeType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#aca0f2ff41fa8f2a1a6ff10fe09817cd8">More...</a><br /></td></tr>
<tr class="separator:aca0f2ff41fa8f2a1a6ff10fe09817cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43526a90acc81e127cc2e3242087e82e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43526a90acc81e127cc2e3242087e82e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a43526a90acc81e127cc2e3242087e82e">ValueType_</a> = typename T::ValueType</td></tr>
<tr class="memdesc:a43526a90acc81e127cc2e3242087e82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for nested <code>ValueType</code> type definitions.The ValueType_ alias declaration provides a convenient shortcut to access the nested <em>ValueType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition:  <a href="#a43526a90acc81e127cc2e3242087e82e">More...</a><br /></td></tr>
<tr class="separator:a43526a90acc81e127cc2e3242087e82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc4593306ec43f62edee3757f2ff56d7"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; char &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gafc4593306ec43f62edee3757f2ff56d7">SIMDchar</a></td></tr>
<tr class="memdesc:gafc4593306ec43f62edee3757f2ff56d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'char'. <br /></td></tr>
<tr class="separator:gafc4593306ec43f62edee3757f2ff56d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga806697a97d99b1b11fd7cdc9b2e70a54"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; signed char &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga806697a97d99b1b11fd7cdc9b2e70a54">SIMDschar</a></td></tr>
<tr class="memdesc:ga806697a97d99b1b11fd7cdc9b2e70a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'signed char'. <br /></td></tr>
<tr class="separator:ga806697a97d99b1b11fd7cdc9b2e70a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48a8e58e3e17d5abfd844bdae3ffc8b"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; unsigned char &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gab48a8e58e3e17d5abfd844bdae3ffc8b">SIMDuchar</a></td></tr>
<tr class="memdesc:gab48a8e58e3e17d5abfd844bdae3ffc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'unsigned char'. <br /></td></tr>
<tr class="separator:gab48a8e58e3e17d5abfd844bdae3ffc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ee12e6bbd8f747573e65737f5d4e42"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; wchar_t &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga57ee12e6bbd8f747573e65737f5d4e42">SIMDwchar</a></td></tr>
<tr class="memdesc:ga57ee12e6bbd8f747573e65737f5d4e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'wchar_t'. <br /></td></tr>
<tr class="separator:ga57ee12e6bbd8f747573e65737f5d4e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28313c887c7509fc7f0548a08b73939d"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; complex&lt; char &gt; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga28313c887c7509fc7f0548a08b73939d">SIMDcchar</a></td></tr>
<tr class="memdesc:ga28313c887c7509fc7f0548a08b73939d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'complex&lt;char&gt;'. <br /></td></tr>
<tr class="separator:ga28313c887c7509fc7f0548a08b73939d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43eb5bda1d6fba2c47706c63a403664"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; complex&lt; signed char &gt; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaf43eb5bda1d6fba2c47706c63a403664">SIMDcschar</a></td></tr>
<tr class="memdesc:gaf43eb5bda1d6fba2c47706c63a403664"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'complex&lt;signed char&gt;'. <br /></td></tr>
<tr class="separator:gaf43eb5bda1d6fba2c47706c63a403664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb51876f7636fadd96a49aa93bb6449"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; complex&lt; unsigned char &gt; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga9eb51876f7636fadd96a49aa93bb6449">SIMDcuchar</a></td></tr>
<tr class="memdesc:ga9eb51876f7636fadd96a49aa93bb6449"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'complex&lt;unsigned char&gt;'. <br /></td></tr>
<tr class="separator:ga9eb51876f7636fadd96a49aa93bb6449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e5ad8d57db179a50bf009d2231697b"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; complex&lt; wchar_t &gt; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga97e5ad8d57db179a50bf009d2231697b">SIMDcwchar</a></td></tr>
<tr class="memdesc:ga97e5ad8d57db179a50bf009d2231697b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'complex&lt;wchar_t&gt;'. <br /></td></tr>
<tr class="separator:ga97e5ad8d57db179a50bf009d2231697b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga501ed33fd3772b3091f994b0028f9790"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; short &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga501ed33fd3772b3091f994b0028f9790">SIMDshort</a></td></tr>
<tr class="memdesc:ga501ed33fd3772b3091f994b0028f9790"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'short'. <br /></td></tr>
<tr class="separator:ga501ed33fd3772b3091f994b0028f9790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68764d021dbf1b1416decfd6f13a2410"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; unsigned short &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga68764d021dbf1b1416decfd6f13a2410">SIMDushort</a></td></tr>
<tr class="memdesc:ga68764d021dbf1b1416decfd6f13a2410"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'unsigned short'. <br /></td></tr>
<tr class="separator:ga68764d021dbf1b1416decfd6f13a2410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ee6ba4e4324205543a7d177fb96bfae"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; complex&lt; short &gt; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga7ee6ba4e4324205543a7d177fb96bfae">SIMDcshort</a></td></tr>
<tr class="memdesc:ga7ee6ba4e4324205543a7d177fb96bfae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'complex&lt;short&gt;'. <br /></td></tr>
<tr class="separator:ga7ee6ba4e4324205543a7d177fb96bfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad271619a0f0abc58ac20f8dda1e854b8"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; complex&lt; unsigned short &gt; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gad271619a0f0abc58ac20f8dda1e854b8">SIMDcushort</a></td></tr>
<tr class="memdesc:gad271619a0f0abc58ac20f8dda1e854b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'complex&lt;unsigned short&gt;'. <br /></td></tr>
<tr class="separator:gad271619a0f0abc58ac20f8dda1e854b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2930e74b08bf234dc53a65ad04506aa9"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; int &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga2930e74b08bf234dc53a65ad04506aa9">SIMDint</a></td></tr>
<tr class="memdesc:ga2930e74b08bf234dc53a65ad04506aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'int'. <br /></td></tr>
<tr class="separator:ga2930e74b08bf234dc53a65ad04506aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2dc0cb14f7a41753df37731232ccef"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; unsigned int &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga6b2dc0cb14f7a41753df37731232ccef">SIMDuint</a></td></tr>
<tr class="memdesc:ga6b2dc0cb14f7a41753df37731232ccef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'unsigned int'. <br /></td></tr>
<tr class="separator:ga6b2dc0cb14f7a41753df37731232ccef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6cf630355768f47e1c721da4cb010ac"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; complex&lt; int &gt; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaf6cf630355768f47e1c721da4cb010ac">SIMDcint</a></td></tr>
<tr class="memdesc:gaf6cf630355768f47e1c721da4cb010ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'complex&lt;int&gt;'. <br /></td></tr>
<tr class="separator:gaf6cf630355768f47e1c721da4cb010ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39f0f332d0aa7f9b907296cd87853fb1"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; complex&lt; unsigned int &gt; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga39f0f332d0aa7f9b907296cd87853fb1">SIMDcuint</a></td></tr>
<tr class="memdesc:ga39f0f332d0aa7f9b907296cd87853fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'complex&lt;unsigned int&gt;'. <br /></td></tr>
<tr class="separator:ga39f0f332d0aa7f9b907296cd87853fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfc2acacd44616e6e7cd36397eb8e623"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; long &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gabfc2acacd44616e6e7cd36397eb8e623">SIMDlong</a></td></tr>
<tr class="memdesc:gabfc2acacd44616e6e7cd36397eb8e623"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'long int'. <br /></td></tr>
<tr class="separator:gabfc2acacd44616e6e7cd36397eb8e623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga105cb599cf632527f41ec97fae181dab"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; unsigned long &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga105cb599cf632527f41ec97fae181dab">SIMDulong</a></td></tr>
<tr class="memdesc:ga105cb599cf632527f41ec97fae181dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'unsigned long int'. <br /></td></tr>
<tr class="separator:ga105cb599cf632527f41ec97fae181dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0aa08b1df68516691f269fae70c719b"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; complex&lt; long &gt; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gab0aa08b1df68516691f269fae70c719b">SIMDclong</a></td></tr>
<tr class="memdesc:gab0aa08b1df68516691f269fae70c719b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'complex&lt;long int&gt;'. <br /></td></tr>
<tr class="separator:gab0aa08b1df68516691f269fae70c719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46df17c048e825d30923f67a5178d3fb"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; complex&lt; unsigned long &gt; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga46df17c048e825d30923f67a5178d3fb">SIMDculong</a></td></tr>
<tr class="memdesc:ga46df17c048e825d30923f67a5178d3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD data type for 'complex&lt;unsigned long int&gt;'. <br /></td></tr>
<tr class="separator:ga46df17c048e825d30923f67a5178d3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b575b0b82167488f51b14b02b664ba2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0b575b0b82167488f51b14b02b664ba2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga0b575b0b82167488f51b14b02b664ba2">SIMDTrait_</a> = typename <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html">SIMDTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga0b575b0b82167488f51b14b02b664ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html" title="SIMD characteristics of data types.The SIMDTrait class template provides the SIMD characteristics of ...">SIMDTrait</a> class template.The SIMDTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/ddb/classblaze_1_1SIMDTrait.html" title="SIMD characteristics of data types.The SIMDTrait class template provides the SIMD characteristics of ...">SIMDTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../dc/d7b/group__simd.html#ga0b575b0b82167488f51b14b02b664ba2">More...</a><br /></td></tr>
<tr class="separator:ga0b575b0b82167488f51b14b02b664ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d591d2c425e4ef2d4cd42a040be25a1"><td class="memItemLeft" align="right" valign="top"><a id="a6d591d2c425e4ef2d4cd42a040be25a1"></a>
typedef <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a>&lt; Type, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a6d591d2c425e4ef2d4cd42a040be25a1">This</a></td></tr>
<tr class="memdesc:a6d591d2c425e4ef2d4cd42a040be25a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">CompressedMatrix</a> instance. <br /></td></tr>
<tr class="separator:a6d591d2c425e4ef2d4cd42a040be25a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7c5527ae2ac48cfdb3de233d5a46a6"><td class="memItemLeft" align="right" valign="top"><a id="ada7c5527ae2ac48cfdb3de233d5a46a6"></a>
typedef <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a6d591d2c425e4ef2d4cd42a040be25a1">This</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ada7c5527ae2ac48cfdb3de233d5a46a6">BaseType</a></td></tr>
<tr class="memdesc:ada7c5527ae2ac48cfdb3de233d5a46a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of this <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">CompressedMatrix</a> instance. <br /></td></tr>
<tr class="separator:ada7c5527ae2ac48cfdb3de233d5a46a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab880bcfe14bd3b7e561200b678e5f28b"><td class="memItemLeft" align="right" valign="top"><a id="ab880bcfe14bd3b7e561200b678e5f28b"></a>
typedef <a class="el" href="../../d2/de9/namespaceblaze.html#a6d591d2c425e4ef2d4cd42a040be25a1">This</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ab880bcfe14bd3b7e561200b678e5f28b">ResultType</a></td></tr>
<tr class="memdesc:ab880bcfe14bd3b7e561200b678e5f28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br /></td></tr>
<tr class="separator:ab880bcfe14bd3b7e561200b678e5f28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72be1239ba1aeee2cfb0111420725425"><td class="memItemLeft" align="right" valign="top"><a id="a72be1239ba1aeee2cfb0111420725425"></a>
typedef <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a>&lt; Type, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a72be1239ba1aeee2cfb0111420725425">OppositeType</a></td></tr>
<tr class="memdesc:a72be1239ba1aeee2cfb0111420725425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type with opposite storage order for expression template evaluations. <br /></td></tr>
<tr class="separator:a72be1239ba1aeee2cfb0111420725425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc33d53e646d54b24573e3b1212025f"><td class="memItemLeft" align="right" valign="top"><a id="a2fc33d53e646d54b24573e3b1212025f"></a>
typedef <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a>&lt; Type, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a2fc33d53e646d54b24573e3b1212025f">TransposeType</a></td></tr>
<tr class="memdesc:a2fc33d53e646d54b24573e3b1212025f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br /></td></tr>
<tr class="separator:a2fc33d53e646d54b24573e3b1212025f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b4e9cc4b409c6fc6cac71e78f0d0f9"><td class="memItemLeft" align="right" valign="top"><a id="ae1b4e9cc4b409c6fc6cac71e78f0d0f9"></a>
typedef Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ae1b4e9cc4b409c6fc6cac71e78f0d0f9">ElementType</a></td></tr>
<tr class="memdesc:ae1b4e9cc4b409c6fc6cac71e78f0d0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the sparse matrix elements. <br /></td></tr>
<tr class="separator:ae1b4e9cc4b409c6fc6cac71e78f0d0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f92fc9fe8248ba74d39f106f08e1b7"><td class="memItemLeft" align="right" valign="top"><a id="ae6f92fc9fe8248ba74d39f106f08e1b7"></a>
typedef const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ae6f92fc9fe8248ba74d39f106f08e1b7">ReturnType</a></td></tr>
<tr class="memdesc:ae6f92fc9fe8248ba74d39f106f08e1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br /></td></tr>
<tr class="separator:ae6f92fc9fe8248ba74d39f106f08e1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f17a6068c222e5986b1fd69f34bd78"><td class="memItemLeft" align="right" valign="top"><a id="a65f17a6068c222e5986b1fd69f34bd78"></a>
typedef const <a class="el" href="../../d2/de9/namespaceblaze.html#a6d591d2c425e4ef2d4cd42a040be25a1">This</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a65f17a6068c222e5986b1fd69f34bd78">CompositeType</a></td></tr>
<tr class="memdesc:a65f17a6068c222e5986b1fd69f34bd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br /></td></tr>
<tr class="separator:a65f17a6068c222e5986b1fd69f34bd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a879317ffe7c431aba1333d2eacaab"><td class="memItemLeft" align="right" valign="top"><a id="a18a879317ffe7c431aba1333d2eacaab"></a>
typedef <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a6d591d2c425e4ef2d4cd42a040be25a1">This</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a18a879317ffe7c431aba1333d2eacaab">Reference</a></td></tr>
<tr class="memdesc:a18a879317ffe7c431aba1333d2eacaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant matrix value. <br /></td></tr>
<tr class="separator:a18a879317ffe7c431aba1333d2eacaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b07ee0a0ca85061e6a3d8306e092a7"><td class="memItemLeft" align="right" valign="top"><a id="a72b07ee0a0ca85061e6a3d8306e092a7"></a>
typedef const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a72b07ee0a0ca85061e6a3d8306e092a7">ConstReference</a></td></tr>
<tr class="memdesc:a72b07ee0a0ca85061e6a3d8306e092a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant matrix value. <br /></td></tr>
<tr class="separator:a72b07ee0a0ca85061e6a3d8306e092a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4164808f730b18f0f772e8904c562a89"><td class="memItemLeft" align="right" valign="top"><a id="a4164808f730b18f0f772e8904c562a89"></a>
typedef Element *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a></td></tr>
<tr class="memdesc:a4164808f730b18f0f772e8904c562a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br /></td></tr>
<tr class="separator:a4164808f730b18f0f772e8904c562a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816aca4ad4888412e9d5e9339b9b5fcb"><td class="memItemLeft" align="right" valign="top"><a id="a816aca4ad4888412e9d5e9339b9b5fcb"></a>
typedef const Element *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">ConstIterator</a></td></tr>
<tr class="memdesc:a816aca4ad4888412e9d5e9339b9b5fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br /></td></tr>
<tr class="separator:a816aca4ad4888412e9d5e9339b9b5fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8e44a329b04c220d865a66e33ebd605"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa8e44a329b04c220d865a66e33ebd605"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaa8e44a329b04c220d865a66e33ebd605">AddExprTrait_</a> = typename <a class="el" href="../../d4/dc4/structblaze_1_1AddExprTrait.html">AddExprTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:gaa8e44a329b04c220d865a66e33ebd605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/dc4/structblaze_1_1AddExprTrait.html" title="Evaluation of the return type of an addition expression.Via this type trait it is possible to evaluat...">AddExprTrait</a> class template.The AddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/dc4/structblaze_1_1AddExprTrait.html" title="Evaluation of the return type of an addition expression.Via this type trait it is possible to evaluat...">AddExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaa8e44a329b04c220d865a66e33ebd605">More...</a><br /></td></tr>
<tr class="separator:gaa8e44a329b04c220d865a66e33ebd605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga719d2bf697506ad8e36243d837d72c0c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga719d2bf697506ad8e36243d837d72c0c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga719d2bf697506ad8e36243d837d72c0c">AddTrait_</a> = typename <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html">AddTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga719d2bf697506ad8e36243d837d72c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.The AddTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga719d2bf697506ad8e36243d837d72c0c">More...</a><br /></td></tr>
<tr class="separator:ga719d2bf697506ad8e36243d837d72c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3507cda05675a7d310b22f91dce0059a"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga3507cda05675a7d310b22f91dce0059a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga3507cda05675a7d310b22f91dce0059a">ColumnExprTrait_</a> = typename <a class="el" href="../../dc/d61/structblaze_1_1ColumnExprTrait.html">ColumnExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga3507cda05675a7d310b22f91dce0059a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d61/structblaze_1_1ColumnExprTrait.html" title="Evaluation of the expression type type of a column operation.Via this type trait it is possible to ev...">ColumnExprTrait</a> type trait.The ColumnExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/d61/structblaze_1_1ColumnExprTrait.html" title="Evaluation of the expression type type of a column operation.Via this type trait it is possible to ev...">ColumnExprTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga3507cda05675a7d310b22f91dce0059a">More...</a><br /></td></tr>
<tr class="separator:ga3507cda05675a7d310b22f91dce0059a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaffe2e5a832863701a9bfdccc7402aa"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaeaffe2e5a832863701a9bfdccc7402aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaeaffe2e5a832863701a9bfdccc7402aa">ColumnTrait_</a> = typename <a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html">ColumnTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gaeaffe2e5a832863701a9bfdccc7402aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html" title="Base template for the ColumnTrait class. ">ColumnTrait</a> type trait.The ColumnTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html" title="Base template for the ColumnTrait class. ">ColumnTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaeaffe2e5a832863701a9bfdccc7402aa">More...</a><br /></td></tr>
<tr class="separator:gaeaffe2e5a832863701a9bfdccc7402aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fa52bdff3e1372cc0d2c43432ba44e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1fa52bdff3e1372cc0d2c43432ba44e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga1fa52bdff3e1372cc0d2c43432ba44e4">CrossExprTrait_</a> = typename <a class="el" href="../../d7/d57/structblaze_1_1CrossExprTrait.html">CrossExprTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga1fa52bdff3e1372cc0d2c43432ba44e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d57/structblaze_1_1CrossExprTrait.html" title="Evaluation of the return type of a cross product expression.Via this type trait it is possible to eva...">CrossExprTrait</a> class template.The CrossExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d57/structblaze_1_1CrossExprTrait.html" title="Evaluation of the return type of a cross product expression.Via this type trait it is possible to eva...">CrossExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga1fa52bdff3e1372cc0d2c43432ba44e4">More...</a><br /></td></tr>
<tr class="separator:ga1fa52bdff3e1372cc0d2c43432ba44e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb2ac508bc7cc89a27414852be39391"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1eb2ac508bc7cc89a27414852be39391"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga1eb2ac508bc7cc89a27414852be39391">CrossTrait_</a> = typename <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html">CrossTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga1eb2ac508bc7cc89a27414852be39391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.The CrossTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga1eb2ac508bc7cc89a27414852be39391">More...</a><br /></td></tr>
<tr class="separator:ga1eb2ac508bc7cc89a27414852be39391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5faf6f7664cf7c2827db00ef19fe0b8b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5faf6f7664cf7c2827db00ef19fe0b8b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">CTransExprTrait_</a> = typename <a class="el" href="../../d7/d23/structblaze_1_1CTransExprTrait.html">CTransExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga5faf6f7664cf7c2827db00ef19fe0b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d23/structblaze_1_1CTransExprTrait.html" title="Evaluation of the return type of a conjugate transpose expression.Via this type trait it is possible ...">CTransExprTrait</a> class template.The CTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d23/structblaze_1_1CTransExprTrait.html" title="Evaluation of the return type of a conjugate transpose expression.Via this type trait it is possible ...">CTransExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">More...</a><br /></td></tr>
<tr class="separator:ga5faf6f7664cf7c2827db00ef19fe0b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4770bac8581804b7523ba6797d7e5719"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4770bac8581804b7523ba6797d7e5719"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga4770bac8581804b7523ba6797d7e5719">DeclDiagExprTrait_</a> = typename <a class="el" href="../../d8/d5f/structblaze_1_1DeclDiagExprTrait.html">DeclDiagExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga4770bac8581804b7523ba6797d7e5719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d5f/structblaze_1_1DeclDiagExprTrait.html" title="Evaluation of the return type of a diagonal declaration (decldiag) expression.Via this type trait it ...">DeclDiagExprTrait</a> class template.The DeclDiagExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d5f/structblaze_1_1DeclDiagExprTrait.html" title="Evaluation of the return type of a diagonal declaration (decldiag) expression.Via this type trait it ...">DeclDiagExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga4770bac8581804b7523ba6797d7e5719">More...</a><br /></td></tr>
<tr class="separator:ga4770bac8581804b7523ba6797d7e5719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0258d9003acc1088542228f3b2ab7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5a0258d9003acc1088542228f3b2ab7e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga5a0258d9003acc1088542228f3b2ab7e">DeclHermExprTrait_</a> = typename <a class="el" href="../../d9/d38/structblaze_1_1DeclHermExprTrait.html">DeclHermExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga5a0258d9003acc1088542228f3b2ab7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/d38/structblaze_1_1DeclHermExprTrait.html" title="Evaluation of the return type of an Hermitian declaration (declherm) expression.Via this type trait i...">DeclHermExprTrait</a> class template.The DeclHermExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/d38/structblaze_1_1DeclHermExprTrait.html" title="Evaluation of the return type of an Hermitian declaration (declherm) expression.Via this type trait i...">DeclHermExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga5a0258d9003acc1088542228f3b2ab7e">More...</a><br /></td></tr>
<tr class="separator:ga5a0258d9003acc1088542228f3b2ab7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609ba68116aea8bdbf2c6b612c42dd42"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga609ba68116aea8bdbf2c6b612c42dd42"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga609ba68116aea8bdbf2c6b612c42dd42">DeclLowExprTrait_</a> = typename <a class="el" href="../../d1/d74/structblaze_1_1DeclLowExprTrait.html">DeclLowExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga609ba68116aea8bdbf2c6b612c42dd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d74/structblaze_1_1DeclLowExprTrait.html" title="Evaluation of the return type of a lower declaration (decllow) expression.Via this type trait it is p...">DeclLowExprTrait</a> class template.The DeclLowExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d74/structblaze_1_1DeclLowExprTrait.html" title="Evaluation of the return type of a lower declaration (decllow) expression.Via this type trait it is p...">DeclLowExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga609ba68116aea8bdbf2c6b612c42dd42">More...</a><br /></td></tr>
<tr class="separator:ga609ba68116aea8bdbf2c6b612c42dd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2f2754084b33dd5fbbfbdf73d783fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3d2f2754084b33dd5fbbfbdf73d783fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga3d2f2754084b33dd5fbbfbdf73d783fd">DeclSymExprTrait_</a> = typename <a class="el" href="../../d7/db6/structblaze_1_1DeclSymExprTrait.html">DeclSymExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga3d2f2754084b33dd5fbbfbdf73d783fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/db6/structblaze_1_1DeclSymExprTrait.html" title="Evaluation of the return type of a symmetry declaration (declsym) expression.Via this type trait it i...">DeclSymExprTrait</a> class template.The DeclSymExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/db6/structblaze_1_1DeclSymExprTrait.html" title="Evaluation of the return type of a symmetry declaration (declsym) expression.Via this type trait it i...">DeclSymExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga3d2f2754084b33dd5fbbfbdf73d783fd">More...</a><br /></td></tr>
<tr class="separator:ga3d2f2754084b33dd5fbbfbdf73d783fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a151739d0d6d857a98ed77a02256bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab9a151739d0d6d857a98ed77a02256bc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gab9a151739d0d6d857a98ed77a02256bc">DeclUppExprTrait_</a> = typename <a class="el" href="../../d2/d1f/structblaze_1_1DeclUppExprTrait.html">DeclUppExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gab9a151739d0d6d857a98ed77a02256bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d1f/structblaze_1_1DeclUppExprTrait.html" title="Evaluation of the return type of a upper declaration (declupp) expression.Via this type trait it is p...">DeclUppExprTrait</a> class template.The DeclUppExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d1f/structblaze_1_1DeclUppExprTrait.html" title="Evaluation of the return type of a upper declaration (declupp) expression.Via this type trait it is p...">DeclUppExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gab9a151739d0d6d857a98ed77a02256bc">More...</a><br /></td></tr>
<tr class="separator:gab9a151739d0d6d857a98ed77a02256bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08891a64ab248d7865e4e06a9c7978e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga08891a64ab248d7865e4e06a9c7978e5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga08891a64ab248d7865e4e06a9c7978e5">DerestrictTrait_</a> = typename <a class="el" href="../../d9/dc1/structblaze_1_1DerestrictTrait.html">DerestrictTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga08891a64ab248d7865e4e06a9c7978e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/dc1/structblaze_1_1DerestrictTrait.html" title="Evaluation of the return type of the derestrict function.Via this type trait it is possible to evalua...">DerestrictTrait</a> type trait.The DerestrictTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/dc1/structblaze_1_1DerestrictTrait.html" title="Evaluation of the return type of the derestrict function.Via this type trait it is possible to evalua...">DerestrictTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga08891a64ab248d7865e4e06a9c7978e5">More...</a><br /></td></tr>
<tr class="separator:ga08891a64ab248d7865e4e06a9c7978e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ea0d1ac87097ec85286eb4c87c5011d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0ea0d1ac87097ec85286eb4c87c5011d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">DivExprTrait_</a> = typename <a class="el" href="../../d7/d73/structblaze_1_1DivExprTrait.html">DivExprTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga0ea0d1ac87097ec85286eb4c87c5011d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d73/structblaze_1_1DivExprTrait.html" title="Evaluation of the resulting expression type of a division.Via this type trait it is possible to evalu...">DivExprTrait</a> class template.The DivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d73/structblaze_1_1DivExprTrait.html" title="Evaluation of the resulting expression type of a division.Via this type trait it is possible to evalu...">DivExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">More...</a><br /></td></tr>
<tr class="separator:ga0ea0d1ac87097ec85286eb4c87c5011d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d9930015ba302dafe10a7fde170d597"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9d9930015ba302dafe10a7fde170d597"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga9d9930015ba302dafe10a7fde170d597">DivTrait_</a> = typename <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html">DivTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga9d9930015ba302dafe10a7fde170d597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class. ">DivTrait</a> class template.The DivTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class. ">DivTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga9d9930015ba302dafe10a7fde170d597">More...</a><br /></td></tr>
<tr class="separator:ga9d9930015ba302dafe10a7fde170d597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a895a7c8d8dd1f2e695ec1adbc8738c"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga5a895a7c8d8dd1f2e695ec1adbc8738c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga5a895a7c8d8dd1f2e695ec1adbc8738c">DMatCTransExprTrait_</a> = typename <a class="el" href="../../d4/d7f/structblaze_1_1DMatCTransExprTrait.html">DMatCTransExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga5a895a7c8d8dd1f2e695ec1adbc8738c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/d7f/structblaze_1_1DMatCTransExprTrait.html" title="Evaluation of the expression type of a dense matrix conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix conjugate transpose operation. Given the row-major dense matrix type MT, the nested type Type corresponds to the resulting expression type. In case MT is not a row-major dense matrix type, the resulting Type is set to INVALID_TYPE. ">DMatCTransExprTrait</a> class template.The DMatCTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/d7f/structblaze_1_1DMatCTransExprTrait.html" title="Evaluation of the expression type of a dense matrix conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix conjugate transpose operation. Given the row-major dense matrix type MT, the nested type Type corresponds to the resulting expression type. In case MT is not a row-major dense matrix type, the resulting Type is set to INVALID_TYPE. ">DMatCTransExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga5a895a7c8d8dd1f2e695ec1adbc8738c">More...</a><br /></td></tr>
<tr class="separator:ga5a895a7c8d8dd1f2e695ec1adbc8738c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09b3532d734a6ae31861f943c297b41a"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga09b3532d734a6ae31861f943c297b41a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga09b3532d734a6ae31861f943c297b41a">DMatDeclDiagExprTrait_</a> = typename <a class="el" href="../../d5/dcc/structblaze_1_1DMatDeclDiagExprTrait.html">DMatDeclDiagExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga09b3532d734a6ae31861f943c297b41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/dcc/structblaze_1_1DMatDeclDiagExprTrait.html" title="Evaluation of the expression type of a dense matrix decldiag operation.Via this type trait it is poss...">DMatDeclDiagExprTrait</a> class template.The DMatDeclDiagExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/dcc/structblaze_1_1DMatDeclDiagExprTrait.html" title="Evaluation of the expression type of a dense matrix decldiag operation.Via this type trait it is poss...">DMatDeclDiagExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga09b3532d734a6ae31861f943c297b41a">More...</a><br /></td></tr>
<tr class="separator:ga09b3532d734a6ae31861f943c297b41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga633e99854b453470b51dfc64e702bcd6"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga633e99854b453470b51dfc64e702bcd6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga633e99854b453470b51dfc64e702bcd6">DMatDeclHermExprTrait_</a> = typename <a class="el" href="../../d0/d8e/structblaze_1_1DMatDeclHermExprTrait.html">DMatDeclHermExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga633e99854b453470b51dfc64e702bcd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/d8e/structblaze_1_1DMatDeclHermExprTrait.html" title="Evaluation of the expression type of a dense matrix declherm operation.Via this type trait it is poss...">DMatDeclHermExprTrait</a> class template.The DMatDeclHermExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/d8e/structblaze_1_1DMatDeclHermExprTrait.html" title="Evaluation of the expression type of a dense matrix declherm operation.Via this type trait it is poss...">DMatDeclHermExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga633e99854b453470b51dfc64e702bcd6">More...</a><br /></td></tr>
<tr class="separator:ga633e99854b453470b51dfc64e702bcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8bc22a329eabdd6da4c9528ab0303d4"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaf8bc22a329eabdd6da4c9528ab0303d4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaf8bc22a329eabdd6da4c9528ab0303d4">DMatDeclLowExprTrait_</a> = typename <a class="el" href="../../d1/d5c/structblaze_1_1DMatDeclLowExprTrait.html">DMatDeclLowExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gaf8bc22a329eabdd6da4c9528ab0303d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d5c/structblaze_1_1DMatDeclLowExprTrait.html" title="Evaluation of the expression type of a dense matrix decllow operation.Via this type trait it is possi...">DMatDeclLowExprTrait</a> class template.The DMatDeclLowExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d5c/structblaze_1_1DMatDeclLowExprTrait.html" title="Evaluation of the expression type of a dense matrix decllow operation.Via this type trait it is possi...">DMatDeclLowExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaf8bc22a329eabdd6da4c9528ab0303d4">More...</a><br /></td></tr>
<tr class="separator:gaf8bc22a329eabdd6da4c9528ab0303d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bcaced4e322d2dbd06a1f9bcbf9cf5d"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga7bcaced4e322d2dbd06a1f9bcbf9cf5d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga7bcaced4e322d2dbd06a1f9bcbf9cf5d">DMatDeclSymExprTrait_</a> = typename <a class="el" href="../../dd/d2a/structblaze_1_1DMatDeclSymExprTrait.html">DMatDeclSymExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga7bcaced4e322d2dbd06a1f9bcbf9cf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d2a/structblaze_1_1DMatDeclSymExprTrait.html" title="Evaluation of the expression type of a dense matrix declsym operation.Via this type trait it is possi...">DMatDeclSymExprTrait</a> class template.The DMatDeclSymExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d2a/structblaze_1_1DMatDeclSymExprTrait.html" title="Evaluation of the expression type of a dense matrix declsym operation.Via this type trait it is possi...">DMatDeclSymExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga7bcaced4e322d2dbd06a1f9bcbf9cf5d">More...</a><br /></td></tr>
<tr class="separator:ga7bcaced4e322d2dbd06a1f9bcbf9cf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga508457ccb1a1ed2d76e66d092dc10b30"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga508457ccb1a1ed2d76e66d092dc10b30"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga508457ccb1a1ed2d76e66d092dc10b30">DMatDeclUppExprTrait_</a> = typename <a class="el" href="../../d7/d21/structblaze_1_1DMatDeclUppExprTrait.html">DMatDeclUppExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga508457ccb1a1ed2d76e66d092dc10b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d21/structblaze_1_1DMatDeclUppExprTrait.html" title="Evaluation of the expression type of a dense matrix declupp operation.Via this type trait it is possi...">DMatDeclUppExprTrait</a> class template.The DMatDeclUppExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d21/structblaze_1_1DMatDeclUppExprTrait.html" title="Evaluation of the expression type of a dense matrix declupp operation.Via this type trait it is possi...">DMatDeclUppExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga508457ccb1a1ed2d76e66d092dc10b30">More...</a><br /></td></tr>
<tr class="separator:ga508457ccb1a1ed2d76e66d092dc10b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c1aa89364943fd5e72ddb44cbf4728"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaa0c1aa89364943fd5e72ddb44cbf4728"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaa0c1aa89364943fd5e72ddb44cbf4728">DMatDMatAddExprTrait_</a> = typename <a class="el" href="../../d8/da5/structblaze_1_1DMatDMatAddExprTrait.html">DMatDMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gaa0c1aa89364943fd5e72ddb44cbf4728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/da5/structblaze_1_1DMatDMatAddExprTrait.html" title="Evaluation of the expression type of a dense matrix/dense matrix addition.Via this type trait it is p...">DMatDMatAddExprTrait</a> class template.The DMatDMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/da5/structblaze_1_1DMatDMatAddExprTrait.html" title="Evaluation of the expression type of a dense matrix/dense matrix addition.Via this type trait it is p...">DMatDMatAddExprTrait</a> class template. For instance, given the row-major dense matrix types <em>MT1</em> and <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaa0c1aa89364943fd5e72ddb44cbf4728">More...</a><br /></td></tr>
<tr class="separator:gaa0c1aa89364943fd5e72ddb44cbf4728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac853b1712217c0e530a0b9e46d01d6d1"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gac853b1712217c0e530a0b9e46d01d6d1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gac853b1712217c0e530a0b9e46d01d6d1">DMatDMatMultExprTrait_</a> = typename <a class="el" href="../../d4/df1/structblaze_1_1DMatDMatMultExprTrait.html">DMatDMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gac853b1712217c0e530a0b9e46d01d6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/df1/structblaze_1_1DMatDMatMultExprTrait.html" title="Evaluation of the expression type of a dense matrix/dense matrix multiplication.Via this type trait i...">DMatDMatMultExprTrait</a> class template.The DMatDMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/df1/structblaze_1_1DMatDMatMultExprTrait.html" title="Evaluation of the expression type of a dense matrix/dense matrix multiplication.Via this type trait i...">DMatDMatMultExprTrait</a> class template. For instance, given the row-major dense matrix types <em>MT1</em> and <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gac853b1712217c0e530a0b9e46d01d6d1">More...</a><br /></td></tr>
<tr class="separator:gac853b1712217c0e530a0b9e46d01d6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga360941c1d1e7e4e27e284ba8df1eb9e8"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga360941c1d1e7e4e27e284ba8df1eb9e8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga360941c1d1e7e4e27e284ba8df1eb9e8">DMatDMatSubExprTrait_</a> = typename <a class="el" href="../../d3/d11/structblaze_1_1DMatDMatSubExprTrait.html">DMatDMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga360941c1d1e7e4e27e284ba8df1eb9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d3/d11/structblaze_1_1DMatDMatSubExprTrait.html" title="Evaluation of the expression type of a dense matrix/dense matrix subtraction.Via this type trait it i...">DMatDMatSubExprTrait</a> class template.The DMatDMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/d11/structblaze_1_1DMatDMatSubExprTrait.html" title="Evaluation of the expression type of a dense matrix/dense matrix subtraction.Via this type trait it i...">DMatDMatSubExprTrait</a> class template. For instance, given the row-major dense matrix types <em>MT1</em> and <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga360941c1d1e7e4e27e284ba8df1eb9e8">More...</a><br /></td></tr>
<tr class="separator:ga360941c1d1e7e4e27e284ba8df1eb9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5c29aab3a69ca62baa2a2c3172b364e"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:gac5c29aab3a69ca62baa2a2c3172b364e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gac5c29aab3a69ca62baa2a2c3172b364e">DMatDVecMultExprTrait_</a> = typename <a class="el" href="../../d5/d54/structblaze_1_1DMatDVecMultExprTrait.html">DMatDVecMultExprTrait</a>&lt; MT, VT &gt;::Type</td></tr>
<tr class="memdesc:gac5c29aab3a69ca62baa2a2c3172b364e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d54/structblaze_1_1DMatDVecMultExprTrait.html" title="Evaluation of the expression type of a dense matrix/dense vector multiplication.Via this type trait i...">DMatDVecMultExprTrait</a> class template.The DMatDVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d54/structblaze_1_1DMatDVecMultExprTrait.html" title="Evaluation of the expression type of a dense matrix/dense vector multiplication.Via this type trait i...">DMatDVecMultExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> and the non-transpose dense vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gac5c29aab3a69ca62baa2a2c3172b364e">More...</a><br /></td></tr>
<tr class="separator:gac5c29aab3a69ca62baa2a2c3172b364e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fc7a02e1ce509a94425521e49cf8d7"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gac6fc7a02e1ce509a94425521e49cf8d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gac6fc7a02e1ce509a94425521e49cf8d7">DMatEvalExprTrait_</a> = typename <a class="el" href="../../dd/d85/structblaze_1_1DMatEvalExprTrait.html">DMatEvalExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gac6fc7a02e1ce509a94425521e49cf8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d85/structblaze_1_1DMatEvalExprTrait.html" title="Evaluation of the expression type of a dense matrix evaluation operation.Via this type trait it is po...">DMatEvalExprTrait</a> class template.The DMatEvalExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d85/structblaze_1_1DMatEvalExprTrait.html" title="Evaluation of the expression type of a dense matrix evaluation operation.Via this type trait it is po...">DMatEvalExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gac6fc7a02e1ce509a94425521e49cf8d7">More...</a><br /></td></tr>
<tr class="separator:gac6fc7a02e1ce509a94425521e49cf8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga408fd9c6852ae6137c4f194ca7dc4acf"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename OP &gt; </td></tr>
<tr class="memitem:ga408fd9c6852ae6137c4f194ca7dc4acf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga408fd9c6852ae6137c4f194ca7dc4acf">DMatForEachExprTrait_</a> = typename <a class="el" href="../../d7/da6/structblaze_1_1DMatForEachExprTrait.html">DMatForEachExprTrait</a>&lt; MT, OP &gt;::Type</td></tr>
<tr class="memdesc:ga408fd9c6852ae6137c4f194ca7dc4acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/da6/structblaze_1_1DMatForEachExprTrait.html" title="Evaluation of the expression type of a dense matrix custom operation.Via this type trait it is possib...">DMatForEachExprTrait</a> class template.The DMatForEachExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/da6/structblaze_1_1DMatForEachExprTrait.html" title="Evaluation of the expression type of a dense matrix custom operation.Via this type trait it is possib...">DMatForEachExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> and the custom operation type <em>OP</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga408fd9c6852ae6137c4f194ca7dc4acf">More...</a><br /></td></tr>
<tr class="separator:ga408fd9c6852ae6137c4f194ca7dc4acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87ebe69430a1c039237529d5f254490c"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga87ebe69430a1c039237529d5f254490c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga87ebe69430a1c039237529d5f254490c">DMatInvExprTrait_</a> = typename <a class="el" href="../../da/d45/structblaze_1_1DMatInvExprTrait.html">DMatInvExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga87ebe69430a1c039237529d5f254490c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/d45/structblaze_1_1DMatInvExprTrait.html" title="Evaluation of the expression type of a dense matrix inversion operation.Via this type trait it is pos...">DMatInvExprTrait</a> class template.The DMatInvExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/d45/structblaze_1_1DMatInvExprTrait.html" title="Evaluation of the expression type of a dense matrix inversion operation.Via this type trait it is pos...">DMatInvExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga87ebe69430a1c039237529d5f254490c">More...</a><br /></td></tr>
<tr class="separator:ga87ebe69430a1c039237529d5f254490c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga595b7486bb807fdc67c5b25bb9a133c3"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename ST &gt; </td></tr>
<tr class="memitem:ga595b7486bb807fdc67c5b25bb9a133c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga595b7486bb807fdc67c5b25bb9a133c3">DMatScalarDivExprTrait_</a> = typename <a class="el" href="../../d8/d25/structblaze_1_1DMatScalarDivExprTrait.html">DMatScalarDivExprTrait</a>&lt; MT, ST &gt;::Type</td></tr>
<tr class="memdesc:ga595b7486bb807fdc67c5b25bb9a133c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d25/structblaze_1_1DMatScalarDivExprTrait.html" title="Evaluation of the expression type of a dense matrix/scalar division.Via this type trait it is possibl...">DMatScalarDivExprTrait</a> class template.The DMatScalarDivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d25/structblaze_1_1DMatScalarDivExprTrait.html" title="Evaluation of the expression type of a dense matrix/scalar division.Via this type trait it is possibl...">DMatScalarDivExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga595b7486bb807fdc67c5b25bb9a133c3">More...</a><br /></td></tr>
<tr class="separator:ga595b7486bb807fdc67c5b25bb9a133c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242fd0e98fabbc6ce608c52ef26d744c"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename ST &gt; </td></tr>
<tr class="memitem:ga242fd0e98fabbc6ce608c52ef26d744c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga242fd0e98fabbc6ce608c52ef26d744c">DMatScalarMultExprTrait_</a> = typename <a class="el" href="../../d1/da4/structblaze_1_1DMatScalarMultExprTrait.html">DMatScalarMultExprTrait</a>&lt; MT, ST &gt;::Type</td></tr>
<tr class="memdesc:ga242fd0e98fabbc6ce608c52ef26d744c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/da4/structblaze_1_1DMatScalarMultExprTrait.html" title="Evaluation of the expression type of a dense matrix/scalar multiplication.Via this type trait it is p...">DMatScalarMultExprTrait</a> class template.The DMatScalarMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/da4/structblaze_1_1DMatScalarMultExprTrait.html" title="Evaluation of the expression type of a dense matrix/scalar multiplication.Via this type trait it is p...">DMatScalarMultExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga242fd0e98fabbc6ce608c52ef26d744c">More...</a><br /></td></tr>
<tr class="separator:ga242fd0e98fabbc6ce608c52ef26d744c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc66f882ec58af8c9f00ea8653831827"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gafc66f882ec58af8c9f00ea8653831827"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gafc66f882ec58af8c9f00ea8653831827">DMatSerialExprTrait_</a> = typename <a class="el" href="../../d2/def/structblaze_1_1DMatSerialExprTrait.html">DMatSerialExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gafc66f882ec58af8c9f00ea8653831827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/def/structblaze_1_1DMatSerialExprTrait.html" title="Evaluation of the expression type of a dense matrix serial evaluation operation.Via this type trait i...">DMatSerialExprTrait</a> class template.The DMatSerialExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/def/structblaze_1_1DMatSerialExprTrait.html" title="Evaluation of the expression type of a dense matrix serial evaluation operation.Via this type trait i...">DMatSerialExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gafc66f882ec58af8c9f00ea8653831827">More...</a><br /></td></tr>
<tr class="separator:gafc66f882ec58af8c9f00ea8653831827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae154793291dbebfd788e461c630a761f"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gae154793291dbebfd788e461c630a761f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gae154793291dbebfd788e461c630a761f">DMatSMatAddExprTrait_</a> = typename <a class="el" href="../../da/dab/structblaze_1_1DMatSMatAddExprTrait.html">DMatSMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gae154793291dbebfd788e461c630a761f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/dab/structblaze_1_1DMatSMatAddExprTrait.html" title="Evaluation of the expression type of a dense matrix/sparse matrix addition.Via this type trait it is ...">DMatSMatAddExprTrait</a> class template.The DMatSMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/dab/structblaze_1_1DMatSMatAddExprTrait.html" title="Evaluation of the expression type of a dense matrix/sparse matrix addition.Via this type trait it is ...">DMatSMatAddExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gae154793291dbebfd788e461c630a761f">More...</a><br /></td></tr>
<tr class="separator:gae154793291dbebfd788e461c630a761f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14219e1f86a3a4492ce74ad9370c2192"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga14219e1f86a3a4492ce74ad9370c2192"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga14219e1f86a3a4492ce74ad9370c2192">DMatSMatMultExprTrait_</a> = typename <a class="el" href="../../d8/d84/structblaze_1_1DMatSMatMultExprTrait.html">DMatSMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga14219e1f86a3a4492ce74ad9370c2192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d84/structblaze_1_1DMatSMatMultExprTrait.html" title="Evaluation of the expression type of a dense matrix/sparse matrix multiplication.Via this type trait ...">DMatSMatMultExprTrait</a> class template.The DMatSMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d84/structblaze_1_1DMatSMatMultExprTrait.html" title="Evaluation of the expression type of a dense matrix/sparse matrix multiplication.Via this type trait ...">DMatSMatMultExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga14219e1f86a3a4492ce74ad9370c2192">More...</a><br /></td></tr>
<tr class="separator:ga14219e1f86a3a4492ce74ad9370c2192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbac8a344e7e2ca343986e35f510a22f"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gabbac8a344e7e2ca343986e35f510a22f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gabbac8a344e7e2ca343986e35f510a22f">DMatSMatSubExprTrait_</a> = typename <a class="el" href="../../da/d07/structblaze_1_1DMatSMatSubExprTrait.html">DMatSMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gabbac8a344e7e2ca343986e35f510a22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/d07/structblaze_1_1DMatSMatSubExprTrait.html" title="Evaluation of the expression type of a dense matrix/sparse matrix subtraction.Via this type trait it ...">DMatSMatSubExprTrait</a> class template.The DMatSMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/d07/structblaze_1_1DMatSMatSubExprTrait.html" title="Evaluation of the expression type of a dense matrix/sparse matrix subtraction.Via this type trait it ...">DMatSMatSubExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gabbac8a344e7e2ca343986e35f510a22f">More...</a><br /></td></tr>
<tr class="separator:gabbac8a344e7e2ca343986e35f510a22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa3b7de637b268d0e67fc93e56f25226"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:gaaa3b7de637b268d0e67fc93e56f25226"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaaa3b7de637b268d0e67fc93e56f25226">DMatSVecMultExprTrait_</a> = typename <a class="el" href="../../d8/d42/structblaze_1_1DMatSVecMultExprTrait.html">DMatSVecMultExprTrait</a>&lt; MT, VT &gt;::Type</td></tr>
<tr class="memdesc:gaaa3b7de637b268d0e67fc93e56f25226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d42/structblaze_1_1DMatSVecMultExprTrait.html" title="Evaluation of the expression type of a dense matrix/sparse vector multiplication.Via this type trait ...">DMatSVecMultExprTrait</a> class template.The DMatSVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d42/structblaze_1_1DMatSVecMultExprTrait.html" title="Evaluation of the expression type of a dense matrix/sparse vector multiplication.Via this type trait ...">DMatSVecMultExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> and the non-transpose sparse vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaaa3b7de637b268d0e67fc93e56f25226">More...</a><br /></td></tr>
<tr class="separator:gaaa3b7de637b268d0e67fc93e56f25226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade4c63fd7619f199e723ab7c8f55742a"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gade4c63fd7619f199e723ab7c8f55742a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gade4c63fd7619f199e723ab7c8f55742a">DMatTDMatAddExprTrait_</a> = typename <a class="el" href="../../d4/da3/structblaze_1_1DMatTDMatAddExprTrait.html">DMatTDMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gade4c63fd7619f199e723ab7c8f55742a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/da3/structblaze_1_1DMatTDMatAddExprTrait.html" title="Evaluation of the expression type of a dense matrix/transpose dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose dense matrix addition. Given the row-major dense matrix type MT1 and the column-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major dense matrix type or MT2 is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">DMatTDMatAddExprTrait</a> class template.The DMatTDMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/da3/structblaze_1_1DMatTDMatAddExprTrait.html" title="Evaluation of the expression type of a dense matrix/transpose dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose dense matrix addition. Given the row-major dense matrix type MT1 and the column-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major dense matrix type or MT2 is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">DMatTDMatAddExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gade4c63fd7619f199e723ab7c8f55742a">More...</a><br /></td></tr>
<tr class="separator:gade4c63fd7619f199e723ab7c8f55742a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ebc10307ae1c7896291da8fe8ddd0f8"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga1ebc10307ae1c7896291da8fe8ddd0f8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga1ebc10307ae1c7896291da8fe8ddd0f8">DMatTDMatMultExprTrait_</a> = typename <a class="el" href="../../d1/d3c/structblaze_1_1DMatTDMatMultExprTrait.html">DMatTDMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga1ebc10307ae1c7896291da8fe8ddd0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d3c/structblaze_1_1DMatTDMatMultExprTrait.html" title="Evaluation of the expression type of a dense matrix/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose dense matrix multiplication. Given the row-major dense matrix type MT1 and the column-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major dense matrix type or MT2 is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">DMatTDMatMultExprTrait</a> class template.The DMatTDMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d3c/structblaze_1_1DMatTDMatMultExprTrait.html" title="Evaluation of the expression type of a dense matrix/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose dense matrix multiplication. Given the row-major dense matrix type MT1 and the column-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major dense matrix type or MT2 is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">DMatTDMatMultExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga1ebc10307ae1c7896291da8fe8ddd0f8">More...</a><br /></td></tr>
<tr class="separator:ga1ebc10307ae1c7896291da8fe8ddd0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4db173608abb529bdf9c1655760b70a"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gae4db173608abb529bdf9c1655760b70a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gae4db173608abb529bdf9c1655760b70a">DMatTDMatSubExprTrait_</a> = typename <a class="el" href="../../d2/d21/structblaze_1_1DMatTDMatSubExprTrait.html">DMatTDMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gae4db173608abb529bdf9c1655760b70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d21/structblaze_1_1DMatTDMatSubExprTrait.html" title="Evaluation of the expression type of a dense matrix/transpose dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose dense matrix subtraction. Given the row-major dense matrix type MT1 and the column-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major dense matrix type or MT2 is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">DMatTDMatSubExprTrait</a> class template.The DMatTDMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d21/structblaze_1_1DMatTDMatSubExprTrait.html" title="Evaluation of the expression type of a dense matrix/transpose dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose dense matrix subtraction. Given the row-major dense matrix type MT1 and the column-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major dense matrix type or MT2 is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">DMatTDMatSubExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gae4db173608abb529bdf9c1655760b70a">More...</a><br /></td></tr>
<tr class="separator:gae4db173608abb529bdf9c1655760b70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694cb4d32f85cb636d8593401a15c4d6"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga694cb4d32f85cb636d8593401a15c4d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga694cb4d32f85cb636d8593401a15c4d6">DMatTransExprTrait_</a> = typename <a class="el" href="../../dd/d81/structblaze_1_1DMatTransExprTrait.html">DMatTransExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga694cb4d32f85cb636d8593401a15c4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d81/structblaze_1_1DMatTransExprTrait.html" title="Evaluation of the expression type of a dense matrix transpose operation.Via this type trait it is pos...">DMatTransExprTrait</a> class template.The DMatTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d81/structblaze_1_1DMatTransExprTrait.html" title="Evaluation of the expression type of a dense matrix transpose operation.Via this type trait it is pos...">DMatTransExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga694cb4d32f85cb636d8593401a15c4d6">More...</a><br /></td></tr>
<tr class="separator:ga694cb4d32f85cb636d8593401a15c4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d81e1eb70935b15a59922b9809a8330"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga3d81e1eb70935b15a59922b9809a8330"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga3d81e1eb70935b15a59922b9809a8330">DMatTSMatAddExprTrait_</a> = typename <a class="el" href="../../d6/dc3/structblaze_1_1DMatTSMatAddExprTrait.html">DMatTSMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga3d81e1eb70935b15a59922b9809a8330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d6/dc3/structblaze_1_1DMatTSMatAddExprTrait.html" title="Evaluation of the expression type of a dense matrix/transpose sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose sparse matrix addition. Given the row-major dense matrix type MT1 and the column-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major dense matrix type or MT2 is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">DMatTSMatAddExprTrait</a> class template.The DMatTSMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/dc3/structblaze_1_1DMatTSMatAddExprTrait.html" title="Evaluation of the expression type of a dense matrix/transpose sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose sparse matrix addition. Given the row-major dense matrix type MT1 and the column-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major dense matrix type or MT2 is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">DMatTSMatAddExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga3d81e1eb70935b15a59922b9809a8330">More...</a><br /></td></tr>
<tr class="separator:ga3d81e1eb70935b15a59922b9809a8330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3498cd4eec8cbe89d0e8cf6aaa99a3b"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaa3498cd4eec8cbe89d0e8cf6aaa99a3b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaa3498cd4eec8cbe89d0e8cf6aaa99a3b">DMatTSMatMultExprTrait_</a> = typename <a class="el" href="../../d7/d14/structblaze_1_1DMatTSMatMultExprTrait.html">DMatTSMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gaa3498cd4eec8cbe89d0e8cf6aaa99a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d14/structblaze_1_1DMatTSMatMultExprTrait.html" title="Evaluation of the expression type of a dense matrix/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/ transpose sparse matrix multiplication. Given the row-major dense matrix type MT1 and the column-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major dense matrix type or MT2 is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">DMatTSMatMultExprTrait</a> class template.The DMatTSMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d14/structblaze_1_1DMatTSMatMultExprTrait.html" title="Evaluation of the expression type of a dense matrix/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/ transpose sparse matrix multiplication. Given the row-major dense matrix type MT1 and the column-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major dense matrix type or MT2 is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">DMatTSMatMultExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaa3498cd4eec8cbe89d0e8cf6aaa99a3b">More...</a><br /></td></tr>
<tr class="separator:gaa3498cd4eec8cbe89d0e8cf6aaa99a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4113495f4fc99a43b57848545a202a77"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga4113495f4fc99a43b57848545a202a77"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga4113495f4fc99a43b57848545a202a77">DMatTSMatSubExprTrait_</a> = typename <a class="el" href="../../de/dc2/structblaze_1_1DMatTSMatSubExprTrait.html">DMatTSMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga4113495f4fc99a43b57848545a202a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/dc2/structblaze_1_1DMatTSMatSubExprTrait.html" title="Evaluation of the expression type of a dense matrix/transpose sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/ transpose sparse matrix subtraction. Given the row-major dense matrix type MT1 and the column-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major dense matrix type or MT2 is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">DMatTSMatSubExprTrait</a> class template.The DMatTSMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/dc2/structblaze_1_1DMatTSMatSubExprTrait.html" title="Evaluation of the expression type of a dense matrix/transpose sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/ transpose sparse matrix subtraction. Given the row-major dense matrix type MT1 and the column-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major dense matrix type or MT2 is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">DMatTSMatSubExprTrait</a> class template. For instance, given the row-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga4113495f4fc99a43b57848545a202a77">More...</a><br /></td></tr>
<tr class="separator:ga4113495f4fc99a43b57848545a202a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e02cf5d12fce8ab6feffe479752c41c"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga8e02cf5d12fce8ab6feffe479752c41c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga8e02cf5d12fce8ab6feffe479752c41c">DVecCTransExprTrait_</a> = typename <a class="el" href="../../d1/d31/structblaze_1_1DVecCTransExprTrait.html">DVecCTransExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:ga8e02cf5d12fce8ab6feffe479752c41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d31/structblaze_1_1DVecCTransExprTrait.html" title="Evaluation of the expression type of a dense vector conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector conjugate transpose operation. Given the non-transpose dense vector type VT, the nested type Type corresponds to the resulting expression type. In case VT is not a non-transpose dense vector type, the resulting Type is set to INVALID_TYPE. ">DVecCTransExprTrait</a> class template.The DVecCTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d31/structblaze_1_1DVecCTransExprTrait.html" title="Evaluation of the expression type of a dense vector conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector conjugate transpose operation. Given the non-transpose dense vector type VT, the nested type Type corresponds to the resulting expression type. In case VT is not a non-transpose dense vector type, the resulting Type is set to INVALID_TYPE. ">DVecCTransExprTrait</a> class template. For instance, given the non-transpose dense vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga8e02cf5d12fce8ab6feffe479752c41c">More...</a><br /></td></tr>
<tr class="separator:ga8e02cf5d12fce8ab6feffe479752c41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2666471d88d43c85aae9f30b59d8fa"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga5c2666471d88d43c85aae9f30b59d8fa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga5c2666471d88d43c85aae9f30b59d8fa">DVecDVecAddExprTrait_</a> = typename <a class="el" href="../../d3/d17/structblaze_1_1DVecDVecAddExprTrait.html">DVecDVecAddExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga5c2666471d88d43c85aae9f30b59d8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d3/d17/structblaze_1_1DVecDVecAddExprTrait.html" title="Evaluation of the expression type of a dense vector/dense vector addition.Via this type trait it is p...">DVecDVecAddExprTrait</a> class template.The DVecDVecAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/d17/structblaze_1_1DVecDVecAddExprTrait.html" title="Evaluation of the expression type of a dense vector/dense vector addition.Via this type trait it is p...">DVecDVecAddExprTrait</a> class template. For instance, given the non-transpose dense vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga5c2666471d88d43c85aae9f30b59d8fa">More...</a><br /></td></tr>
<tr class="separator:ga5c2666471d88d43c85aae9f30b59d8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f3a3a15088cd1143e3edb61d7a4edc6"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga6f3a3a15088cd1143e3edb61d7a4edc6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga6f3a3a15088cd1143e3edb61d7a4edc6">DVecDVecCrossExprTrait_</a> = typename <a class="el" href="../../de/d42/structblaze_1_1DVecDVecCrossExprTrait.html">DVecDVecCrossExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga6f3a3a15088cd1143e3edb61d7a4edc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d42/structblaze_1_1DVecDVecCrossExprTrait.html" title="Evaluation of the expression type of a dense vector/dense vector cross product.Via this type trait it...">DVecDVecCrossExprTrait</a> class template.The DVecDVecCrossExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d42/structblaze_1_1DVecDVecCrossExprTrait.html" title="Evaluation of the expression type of a dense vector/dense vector cross product.Via this type trait it...">DVecDVecCrossExprTrait</a> class template. For instance, given the non-transpose dense vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga6f3a3a15088cd1143e3edb61d7a4edc6">More...</a><br /></td></tr>
<tr class="separator:ga6f3a3a15088cd1143e3edb61d7a4edc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c2b18846be03fd2abc7bb166ce13f08"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga9c2b18846be03fd2abc7bb166ce13f08"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga9c2b18846be03fd2abc7bb166ce13f08">DVecDVecDivExprTrait_</a> = typename <a class="el" href="../../d5/d6d/structblaze_1_1DVecDVecDivExprTrait.html">DVecDVecDivExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga9c2b18846be03fd2abc7bb166ce13f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d6d/structblaze_1_1DVecDVecDivExprTrait.html" title="Evaluation of the expression type of a dense vector/dense vector division.Via this type trait it is p...">DVecDVecDivExprTrait</a> class template.The DVecDVecDivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d6d/structblaze_1_1DVecDVecDivExprTrait.html" title="Evaluation of the expression type of a dense vector/dense vector division.Via this type trait it is p...">DVecDVecDivExprTrait</a> class template. For instance, given the non-transpose dense vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga9c2b18846be03fd2abc7bb166ce13f08">More...</a><br /></td></tr>
<tr class="separator:ga9c2b18846be03fd2abc7bb166ce13f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a4a25531eb2e801d13d8aba39df9441"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga4a4a25531eb2e801d13d8aba39df9441"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga4a4a25531eb2e801d13d8aba39df9441">DVecDVecMultExprTrait_</a> = typename <a class="el" href="../../d9/d9b/structblaze_1_1DVecDVecMultExprTrait.html">DVecDVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga4a4a25531eb2e801d13d8aba39df9441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/d9b/structblaze_1_1DVecDVecMultExprTrait.html" title="Evaluation of the expression type of a dense vector/dense vector multiplication.Via this type trait i...">DVecDVecMultExprTrait</a> class template.The DVecDVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/d9b/structblaze_1_1DVecDVecMultExprTrait.html" title="Evaluation of the expression type of a dense vector/dense vector multiplication.Via this type trait i...">DVecDVecMultExprTrait</a> class template. For instance, given the non-transpose dense vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga4a4a25531eb2e801d13d8aba39df9441">More...</a><br /></td></tr>
<tr class="separator:ga4a4a25531eb2e801d13d8aba39df9441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab52c3500aa11114bbada11cd53e3a37e"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gab52c3500aa11114bbada11cd53e3a37e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gab52c3500aa11114bbada11cd53e3a37e">DVecDVecSubExprTrait_</a> = typename <a class="el" href="../../d4/d0f/structblaze_1_1DVecDVecSubExprTrait.html">DVecDVecSubExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:gab52c3500aa11114bbada11cd53e3a37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/d0f/structblaze_1_1DVecDVecSubExprTrait.html" title="Evaluation of the expression type of a dense vector/dense vector subtraction.Via this type trait it i...">DVecDVecSubExprTrait</a> class template.The DVecDVecSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/d0f/structblaze_1_1DVecDVecSubExprTrait.html" title="Evaluation of the expression type of a dense vector/dense vector subtraction.Via this type trait it i...">DVecDVecSubExprTrait</a> class template. For instance, given the non-transpose dense vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gab52c3500aa11114bbada11cd53e3a37e">More...</a><br /></td></tr>
<tr class="separator:gab52c3500aa11114bbada11cd53e3a37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98232215e1b21a6d525d3ebdd80d5e98"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga98232215e1b21a6d525d3ebdd80d5e98"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga98232215e1b21a6d525d3ebdd80d5e98">DVecEvalExprTrait_</a> = typename <a class="el" href="../../dc/d58/structblaze_1_1DVecEvalExprTrait.html">DVecEvalExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:ga98232215e1b21a6d525d3ebdd80d5e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d58/structblaze_1_1DVecEvalExprTrait.html" title="Evaluation of the expression type of a dense vector evaluation operation.Via this type trait it is po...">DVecEvalExprTrait</a> class template.The DVecEvalExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/d58/structblaze_1_1DVecEvalExprTrait.html" title="Evaluation of the expression type of a dense vector evaluation operation.Via this type trait it is po...">DVecEvalExprTrait</a> class template. For instance, given the non-transpose dense vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga98232215e1b21a6d525d3ebdd80d5e98">More...</a><br /></td></tr>
<tr class="separator:ga98232215e1b21a6d525d3ebdd80d5e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23a59d53d48232bea02ac199b6ab3116"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename OP &gt; </td></tr>
<tr class="memitem:ga23a59d53d48232bea02ac199b6ab3116"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga23a59d53d48232bea02ac199b6ab3116">DVecForEachExprTrait_</a> = typename <a class="el" href="../../db/db7/structblaze_1_1DVecForEachExprTrait.html">DVecForEachExprTrait</a>&lt; VT, OP &gt;::Type</td></tr>
<tr class="memdesc:ga23a59d53d48232bea02ac199b6ab3116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/db7/structblaze_1_1DVecForEachExprTrait.html" title="Evaluation of the expression type of a dense vector custom operation.Via this type trait it is possib...">DVecForEachExprTrait</a> class template.The DVecForEachExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/db7/structblaze_1_1DVecForEachExprTrait.html" title="Evaluation of the expression type of a dense vector custom operation.Via this type trait it is possib...">DVecForEachExprTrait</a> class template. For instance, given the non-transpose dense vector type <em>VT</em> and the custom operation type <em>OP</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga23a59d53d48232bea02ac199b6ab3116">More...</a><br /></td></tr>
<tr class="separator:ga23a59d53d48232bea02ac199b6ab3116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf28ad1c24eae514ebcdcc59dc7ea0098"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ST &gt; </td></tr>
<tr class="memitem:gaf28ad1c24eae514ebcdcc59dc7ea0098"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaf28ad1c24eae514ebcdcc59dc7ea0098">DVecScalarDivExprTrait_</a> = typename <a class="el" href="../../d4/dfb/structblaze_1_1DVecScalarDivExprTrait.html">DVecScalarDivExprTrait</a>&lt; VT, ST &gt;::Type</td></tr>
<tr class="memdesc:gaf28ad1c24eae514ebcdcc59dc7ea0098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/dfb/structblaze_1_1DVecScalarDivExprTrait.html" title="Evaluation of the expression type of a dense vector/scalar division.Via this type trait it is possibl...">DVecScalarDivExprTrait</a> class template.The DVecScalarDivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/dfb/structblaze_1_1DVecScalarDivExprTrait.html" title="Evaluation of the expression type of a dense vector/scalar division.Via this type trait it is possibl...">DVecScalarDivExprTrait</a> class template. For instance, given the non-transpose dense vector type <em>VT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaf28ad1c24eae514ebcdcc59dc7ea0098">More...</a><br /></td></tr>
<tr class="separator:gaf28ad1c24eae514ebcdcc59dc7ea0098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac599f7f17bd6bfac0ea8916deb0828b"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ST &gt; </td></tr>
<tr class="memitem:gaac599f7f17bd6bfac0ea8916deb0828b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaac599f7f17bd6bfac0ea8916deb0828b">DVecScalarMultExprTrait_</a> = typename <a class="el" href="../../d0/d2e/structblaze_1_1DVecScalarMultExprTrait.html">DVecScalarMultExprTrait</a>&lt; VT, ST &gt;::Type</td></tr>
<tr class="memdesc:gaac599f7f17bd6bfac0ea8916deb0828b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/d2e/structblaze_1_1DVecScalarMultExprTrait.html" title="Evaluation of the expression type of a dense vector/scalar multiplication.Via this type trait it is p...">DVecScalarMultExprTrait</a> class template.The DVecScalarMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/d2e/structblaze_1_1DVecScalarMultExprTrait.html" title="Evaluation of the expression type of a dense vector/scalar multiplication.Via this type trait it is p...">DVecScalarMultExprTrait</a> class template. For instance, given the non-transpose dense vector type <em>VT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaac599f7f17bd6bfac0ea8916deb0828b">More...</a><br /></td></tr>
<tr class="separator:gaac599f7f17bd6bfac0ea8916deb0828b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad42fd65a9d87bb3c8fbc45451aad721d"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gad42fd65a9d87bb3c8fbc45451aad721d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gad42fd65a9d87bb3c8fbc45451aad721d">DVecSerialExprTrait_</a> = typename <a class="el" href="../../db/dc9/structblaze_1_1DVecSerialExprTrait.html">DVecSerialExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:gad42fd65a9d87bb3c8fbc45451aad721d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/dc9/structblaze_1_1DVecSerialExprTrait.html" title="Evaluation of the expression type of a dense vector serial evaluation operation.Via this type trait i...">DVecSerialExprTrait</a> class template.The DVecSerialExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/dc9/structblaze_1_1DVecSerialExprTrait.html" title="Evaluation of the expression type of a dense vector serial evaluation operation.Via this type trait i...">DVecSerialExprTrait</a> class template. For instance, given the non-transpose dense vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gad42fd65a9d87bb3c8fbc45451aad721d">More...</a><br /></td></tr>
<tr class="separator:gad42fd65a9d87bb3c8fbc45451aad721d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765a4d8222442835c3f5ed282d510621"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga765a4d8222442835c3f5ed282d510621"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga765a4d8222442835c3f5ed282d510621">DVecSVecAddExprTrait_</a> = typename <a class="el" href="../../de/d85/structblaze_1_1DVecSVecAddExprTrait.html">DVecSVecAddExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga765a4d8222442835c3f5ed282d510621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d85/structblaze_1_1DVecSVecAddExprTrait.html" title="Evaluation of the expression type of a dense vector/sparse vector addition.Via this type trait it is ...">DVecSVecAddExprTrait</a> class template.The DVecSVecAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d85/structblaze_1_1DVecSVecAddExprTrait.html" title="Evaluation of the expression type of a dense vector/sparse vector addition.Via this type trait it is ...">DVecSVecAddExprTrait</a> class template. For instance, given the non-transpose dense vector type <em>VT1</em> and the non-transpose sparse vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga765a4d8222442835c3f5ed282d510621">More...</a><br /></td></tr>
<tr class="separator:ga765a4d8222442835c3f5ed282d510621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31ba9657d649f6f3b53f4e20b9ad40b7"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga31ba9657d649f6f3b53f4e20b9ad40b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga31ba9657d649f6f3b53f4e20b9ad40b7">DVecSVecCrossExprTrait_</a> = typename <a class="el" href="../../d1/d5e/structblaze_1_1DVecSVecCrossExprTrait.html">DVecSVecCrossExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga31ba9657d649f6f3b53f4e20b9ad40b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d5e/structblaze_1_1DVecSVecCrossExprTrait.html" title="Evaluation of the expression type of a dense vector/sparse vector cross product.Via this type trait i...">DVecSVecCrossExprTrait</a> class template.The DVecSVecCrossExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d5e/structblaze_1_1DVecSVecCrossExprTrait.html" title="Evaluation of the expression type of a dense vector/sparse vector cross product.Via this type trait i...">DVecSVecCrossExprTrait</a> class template. For instance, given the non-transpose dense vector type <em>VT1</em> and the non-transpose sparse vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga31ba9657d649f6f3b53f4e20b9ad40b7">More...</a><br /></td></tr>
<tr class="separator:ga31ba9657d649f6f3b53f4e20b9ad40b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9be78918c03eaa8f254972fc72382b75"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga9be78918c03eaa8f254972fc72382b75"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga9be78918c03eaa8f254972fc72382b75">DVecSVecMultExprTrait_</a> = typename <a class="el" href="../../d6/dad/structblaze_1_1DVecSVecMultExprTrait.html">DVecSVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga9be78918c03eaa8f254972fc72382b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d6/dad/structblaze_1_1DVecSVecMultExprTrait.html" title="Evaluation of the expression type of a dense vector/sparse vector multiplication.Via this type trait ...">DVecSVecMultExprTrait</a> class template.The DVecSVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/dad/structblaze_1_1DVecSVecMultExprTrait.html" title="Evaluation of the expression type of a dense vector/sparse vector multiplication.Via this type trait ...">DVecSVecMultExprTrait</a> class template. For instance, given the non-transpose dense vector type <em>VT1</em> and the non-transpose sparse vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga9be78918c03eaa8f254972fc72382b75">More...</a><br /></td></tr>
<tr class="separator:ga9be78918c03eaa8f254972fc72382b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fc85ccb29a0296752ea757118e12ffd"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga0fc85ccb29a0296752ea757118e12ffd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga0fc85ccb29a0296752ea757118e12ffd">DVecSVecSubExprTrait_</a> = typename <a class="el" href="../../d5/d38/structblaze_1_1DVecSVecSubExprTrait.html">DVecSVecSubExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga0fc85ccb29a0296752ea757118e12ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d38/structblaze_1_1DVecSVecSubExprTrait.html" title="Evaluation of the expression type of a dense vector/sparse vector subtraction.Via this type trait it ...">DVecSVecSubExprTrait</a> class template.The DVecSVecSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d38/structblaze_1_1DVecSVecSubExprTrait.html" title="Evaluation of the expression type of a dense vector/sparse vector subtraction.Via this type trait it ...">DVecSVecSubExprTrait</a> class template. For instance, given the non-transpose dense vector type <em>VT1</em> and the non-transpose sparse vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga0fc85ccb29a0296752ea757118e12ffd">More...</a><br /></td></tr>
<tr class="separator:ga0fc85ccb29a0296752ea757118e12ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8652f12f41d16d9bcfb0ed5bd5f60486"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga8652f12f41d16d9bcfb0ed5bd5f60486"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga8652f12f41d16d9bcfb0ed5bd5f60486">DVecTDVecMultExprTrait_</a> = typename <a class="el" href="../../d3/d92/structblaze_1_1DVecTDVecMultExprTrait.html">DVecTDVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga8652f12f41d16d9bcfb0ed5bd5f60486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d3/d92/structblaze_1_1DVecTDVecMultExprTrait.html" title="Evaluation of the expression type of a dense vector/transpose dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose dense vector multiplication (outer product). Given the non-transpose dense vector type VT1 and the transpose dense vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a non-transpose dense vector type or VT2 is not a transpose dense vector type, the resulting Type is set to INVALID_TYPE. ">DVecTDVecMultExprTrait</a> class template.The DVecTDVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/d92/structblaze_1_1DVecTDVecMultExprTrait.html" title="Evaluation of the expression type of a dense vector/transpose dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose dense vector multiplication (outer product). Given the non-transpose dense vector type VT1 and the transpose dense vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a non-transpose dense vector type or VT2 is not a transpose dense vector type, the resulting Type is set to INVALID_TYPE. ">DVecTDVecMultExprTrait</a> class template. For instance, given the non-transpose dense vector type <em>VT1</em> and the transpose dense vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga8652f12f41d16d9bcfb0ed5bd5f60486">More...</a><br /></td></tr>
<tr class="separator:ga8652f12f41d16d9bcfb0ed5bd5f60486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9747549ea361d68964c4a479c07e41c"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gae9747549ea361d68964c4a479c07e41c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gae9747549ea361d68964c4a479c07e41c">DVecTransExprTrait_</a> = typename <a class="el" href="../../dc/d90/structblaze_1_1DVecTransExprTrait.html">DVecTransExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:gae9747549ea361d68964c4a479c07e41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d90/structblaze_1_1DVecTransExprTrait.html" title="Evaluation of the expression type of a dense vector transpose operation.Via this type trait it is pos...">DVecTransExprTrait</a> class template.The DVecTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/d90/structblaze_1_1DVecTransExprTrait.html" title="Evaluation of the expression type of a dense vector transpose operation.Via this type trait it is pos...">DVecTransExprTrait</a> class template. For instance, given the non-transpose dense vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gae9747549ea361d68964c4a479c07e41c">More...</a><br /></td></tr>
<tr class="separator:gae9747549ea361d68964c4a479c07e41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54f87f070f0c3fa0c8996cff08ea113a"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga54f87f070f0c3fa0c8996cff08ea113a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga54f87f070f0c3fa0c8996cff08ea113a">DVecTSVecMultExprTrait_</a> = typename <a class="el" href="../../d8/d7a/structblaze_1_1DVecTSVecMultExprTrait.html">DVecTSVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga54f87f070f0c3fa0c8996cff08ea113a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d7a/structblaze_1_1DVecTSVecMultExprTrait.html" title="Evaluation of the expression type of a dense vector/transpose sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose sparse vector multiplication (outer product). Given the non-transpose dense vector type VT1 and the transpose sparse vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a non-transpose dense vector type or VT2 is not a transpose sparse vector type, the resulting Type is set to INVALID_TYPE. ">DVecTSVecMultExprTrait</a> class template.The DVecTSVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d7a/structblaze_1_1DVecTSVecMultExprTrait.html" title="Evaluation of the expression type of a dense vector/transpose sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose sparse vector multiplication (outer product). Given the non-transpose dense vector type VT1 and the transpose sparse vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a non-transpose dense vector type or VT2 is not a transpose sparse vector type, the resulting Type is set to INVALID_TYPE. ">DVecTSVecMultExprTrait</a> class template. For instance, given the non-transpose dense vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga54f87f070f0c3fa0c8996cff08ea113a">More...</a><br /></td></tr>
<tr class="separator:ga54f87f070f0c3fa0c8996cff08ea113a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d0e4cfa0e7313a34089a04d24b0411f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7d0e4cfa0e7313a34089a04d24b0411f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga7d0e4cfa0e7313a34089a04d24b0411f">EvalExprTrait_</a> = typename <a class="el" href="../../d9/dc7/structblaze_1_1EvalExprTrait.html">EvalExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga7d0e4cfa0e7313a34089a04d24b0411f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/dc7/structblaze_1_1EvalExprTrait.html" title="Evaluation of the return type of an evaluation expression.Via this type trait it is possible to evalu...">EvalExprTrait</a> class template.The EvalExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/dc7/structblaze_1_1EvalExprTrait.html" title="Evaluation of the return type of an evaluation expression.Via this type trait it is possible to evalu...">EvalExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga7d0e4cfa0e7313a34089a04d24b0411f">More...</a><br /></td></tr>
<tr class="separator:ga7d0e4cfa0e7313a34089a04d24b0411f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf3a8a759adda459d35a85e64c530b36"><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr class="memitem:gabf3a8a759adda459d35a85e64c530b36"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gabf3a8a759adda459d35a85e64c530b36">ForEachExprTrait_</a> = typename <a class="el" href="../../da/de4/structblaze_1_1ForEachExprTrait.html">ForEachExprTrait</a>&lt; T, OP &gt;::Type</td></tr>
<tr class="memdesc:gabf3a8a759adda459d35a85e64c530b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/de4/structblaze_1_1ForEachExprTrait.html" title="Evaluation of the return type of a forEach expression.Via this type trait it is possible to evaluate ...">ForEachExprTrait</a> class template.The ForEachExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/de4/structblaze_1_1ForEachExprTrait.html" title="Evaluation of the return type of a forEach expression.Via this type trait it is possible to evaluate ...">ForEachExprTrait</a> class template. For instance, given the data type <em>T</em> and custom operation type <em>OP</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gabf3a8a759adda459d35a85e64c530b36">More...</a><br /></td></tr>
<tr class="separator:gabf3a8a759adda459d35a85e64c530b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8e5eb6b8a316764bcef27bab8e72d92"><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr class="memitem:gae8e5eb6b8a316764bcef27bab8e72d92"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gae8e5eb6b8a316764bcef27bab8e72d92">ForEachTrait_</a> = typename <a class="el" href="../../db/de7/structblaze_1_1ForEachTrait.html">ForEachTrait</a>&lt; T, OP &gt;::Type</td></tr>
<tr class="memdesc:gae8e5eb6b8a316764bcef27bab8e72d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/de7/structblaze_1_1ForEachTrait.html" title="Base template for the ForEachTrait class.The ForEachTrait class template offers the possibility to se...">ForEachTrait</a> class template.The ForEachTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/de7/structblaze_1_1ForEachTrait.html" title="Base template for the ForEachTrait class.The ForEachTrait class template offers the possibility to se...">ForEachTrait</a> class template. For instance, given the type <em>T</em> and the custom operation type <em>OP</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gae8e5eb6b8a316764bcef27bab8e72d92">More...</a><br /></td></tr>
<tr class="separator:gae8e5eb6b8a316764bcef27bab8e72d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a679b1673372cf8cf5a9eec83fa2642"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4a679b1673372cf8cf5a9eec83fa2642"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga4a679b1673372cf8cf5a9eec83fa2642">ImagTrait_</a> = typename <a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html">ImagTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga4a679b1673372cf8cf5a9eec83fa2642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html" title="Base template for the ImagTrait class.The ImagTrait class template offers the possibility to select t...">ImagTrait</a> class template.The ImagTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html" title="Base template for the ImagTrait class.The ImagTrait class template offers the possibility to select t...">ImagTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga4a679b1673372cf8cf5a9eec83fa2642">More...</a><br /></td></tr>
<tr class="separator:ga4a679b1673372cf8cf5a9eec83fa2642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9ba0283695fcacf41ccca9e1d7913a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac9ba0283695fcacf41ccca9e1d7913a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gac9ba0283695fcacf41ccca9e1d7913a3">InvExprTrait_</a> = typename <a class="el" href="../../d1/d78/structblaze_1_1InvExprTrait.html">InvExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gac9ba0283695fcacf41ccca9e1d7913a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d78/structblaze_1_1InvExprTrait.html" title="Evaluation of the return type of an inversion expression.Via this type trait it is possible to evalua...">InvExprTrait</a> class template.The InvExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d78/structblaze_1_1InvExprTrait.html" title="Evaluation of the return type of an inversion expression.Via this type trait it is possible to evalua...">InvExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gac9ba0283695fcacf41ccca9e1d7913a3">More...</a><br /></td></tr>
<tr class="separator:gac9ba0283695fcacf41ccca9e1d7913a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafec740e235d29a5e1421fd282593f6de"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gafec740e235d29a5e1421fd282593f6de"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a> = typename <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:gafec740e235d29a5e1421fd282593f6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html" title="Evaluation of the resulting expression type of a multiplication.Via this type trait it is possible to...">MultExprTrait</a> class template.The MultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html" title="Evaluation of the resulting expression type of a multiplication.Via this type trait it is possible to...">MultExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">More...</a><br /></td></tr>
<tr class="separator:gafec740e235d29a5e1421fd282593f6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1236c0bfa656036b8a0224726100c008"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1236c0bfa656036b8a0224726100c008"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a> = typename <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga1236c0bfa656036b8a0224726100c008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.The MultTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">More...</a><br /></td></tr>
<tr class="separator:ga1236c0bfa656036b8a0224726100c008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae099d42e4a8c3bb4a0764c876c010813"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae099d42e4a8c3bb4a0764c876c010813"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gae099d42e4a8c3bb4a0764c876c010813">RealTrait_</a> = typename <a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html">RealTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gae099d42e4a8c3bb4a0764c876c010813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html" title="Base template for the RealTrait class.The RealTrait class template offers the possibility to select t...">RealTrait</a> class template.The RealTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html" title="Base template for the RealTrait class.The RealTrait class template offers the possibility to select t...">RealTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gae099d42e4a8c3bb4a0764c876c010813">More...</a><br /></td></tr>
<tr class="separator:gae099d42e4a8c3bb4a0764c876c010813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga614ee434bf313751eaa652afefd61c46"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga614ee434bf313751eaa652afefd61c46"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga614ee434bf313751eaa652afefd61c46">RowExprTrait_</a> = typename <a class="el" href="../../d7/d25/structblaze_1_1RowExprTrait.html">RowExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga614ee434bf313751eaa652afefd61c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d25/structblaze_1_1RowExprTrait.html" title="Evaluation of the expression type type of a row operation.Via this type trait it is possible to evalu...">RowExprTrait</a> type trait.The RowExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d25/structblaze_1_1RowExprTrait.html" title="Evaluation of the expression type type of a row operation.Via this type trait it is possible to evalu...">RowExprTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga614ee434bf313751eaa652afefd61c46">More...</a><br /></td></tr>
<tr class="separator:ga614ee434bf313751eaa652afefd61c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga488ff780f372a1c75e230257820d15c2"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga488ff780f372a1c75e230257820d15c2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga488ff780f372a1c75e230257820d15c2">RowTrait_</a> = typename <a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html">RowTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga488ff780f372a1c75e230257820d15c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html" title="Base template for the RowTrait class. ">RowTrait</a> type trait.The RowTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html" title="Base template for the RowTrait class. ">RowTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga488ff780f372a1c75e230257820d15c2">More...</a><br /></td></tr>
<tr class="separator:ga488ff780f372a1c75e230257820d15c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2733a1b59d0d852447f25dabcbf181c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2733a1b59d0d852447f25dabcbf181c0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga2733a1b59d0d852447f25dabcbf181c0">SerialExprTrait_</a> = typename <a class="el" href="../../d0/de8/structblaze_1_1SerialExprTrait.html">SerialExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga2733a1b59d0d852447f25dabcbf181c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/de8/structblaze_1_1SerialExprTrait.html" title="Evaluation of the return type of a serial evaluation expression.Via this type trait it is possible to...">SerialExprTrait</a> class template.The SerialExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/de8/structblaze_1_1SerialExprTrait.html" title="Evaluation of the return type of a serial evaluation expression.Via this type trait it is possible to...">SerialExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga2733a1b59d0d852447f25dabcbf181c0">More...</a><br /></td></tr>
<tr class="separator:ga2733a1b59d0d852447f25dabcbf181c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fcb791a905b547e9ea906803a1b1a07"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga1fcb791a905b547e9ea906803a1b1a07"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga1fcb791a905b547e9ea906803a1b1a07">SMatCTransExprTrait_</a> = typename <a class="el" href="../../d9/dad/structblaze_1_1SMatCTransExprTrait.html">SMatCTransExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga1fcb791a905b547e9ea906803a1b1a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/dad/structblaze_1_1SMatCTransExprTrait.html" title="Evaluation of the expression type of a sparse matrix conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix conjugate transpose operation. Given the row-major sparse matrix type MT, the nested type Type corresponds to the resulting expression type. In case MT is not a row-major sparse matrix type, the resulting Type is set to INVALID_TYPE. ">SMatCTransExprTrait</a> class template.The SMatCTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/dad/structblaze_1_1SMatCTransExprTrait.html" title="Evaluation of the expression type of a sparse matrix conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix conjugate transpose operation. Given the row-major sparse matrix type MT, the nested type Type corresponds to the resulting expression type. In case MT is not a row-major sparse matrix type, the resulting Type is set to INVALID_TYPE. ">SMatCTransExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga1fcb791a905b547e9ea906803a1b1a07">More...</a><br /></td></tr>
<tr class="separator:ga1fcb791a905b547e9ea906803a1b1a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75c79bd329c7ed2051b7d3d0a87e983e"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga75c79bd329c7ed2051b7d3d0a87e983e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga75c79bd329c7ed2051b7d3d0a87e983e">SMatDeclDiagExprTrait_</a> = typename <a class="el" href="../../d8/d70/structblaze_1_1SMatDeclDiagExprTrait.html">SMatDeclDiagExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga75c79bd329c7ed2051b7d3d0a87e983e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d70/structblaze_1_1SMatDeclDiagExprTrait.html" title="Evaluation of the expression type of a sparse matrix decldiag operation.Via this type trait it is pos...">SMatDeclDiagExprTrait</a> class template.The SMatDeclDiagExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d70/structblaze_1_1SMatDeclDiagExprTrait.html" title="Evaluation of the expression type of a sparse matrix decldiag operation.Via this type trait it is pos...">SMatDeclDiagExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga75c79bd329c7ed2051b7d3d0a87e983e">More...</a><br /></td></tr>
<tr class="separator:ga75c79bd329c7ed2051b7d3d0a87e983e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8079b0478d503461f7008ac627f6bb3"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gad8079b0478d503461f7008ac627f6bb3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gad8079b0478d503461f7008ac627f6bb3">SMatDeclHermExprTrait_</a> = typename <a class="el" href="../../d2/d9f/structblaze_1_1SMatDeclHermExprTrait.html">SMatDeclHermExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gad8079b0478d503461f7008ac627f6bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d9f/structblaze_1_1SMatDeclHermExprTrait.html" title="Evaluation of the expression type of a sparse matrix declherm operation.Via this type trait it is pos...">SMatDeclHermExprTrait</a> class template.The SMatDeclHermExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d9f/structblaze_1_1SMatDeclHermExprTrait.html" title="Evaluation of the expression type of a sparse matrix declherm operation.Via this type trait it is pos...">SMatDeclHermExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gad8079b0478d503461f7008ac627f6bb3">More...</a><br /></td></tr>
<tr class="separator:gad8079b0478d503461f7008ac627f6bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb7338fe7f91b8428f584a8110a7bef"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaebb7338fe7f91b8428f584a8110a7bef"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaebb7338fe7f91b8428f584a8110a7bef">SMatDeclLowExprTrait_</a> = typename <a class="el" href="../../d1/de6/structblaze_1_1SMatDeclLowExprTrait.html">SMatDeclLowExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gaebb7338fe7f91b8428f584a8110a7bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/de6/structblaze_1_1SMatDeclLowExprTrait.html" title="Evaluation of the expression type of a sparse matrix decllow operation.Via this type trait it is poss...">SMatDeclLowExprTrait</a> class template.The SMatDeclLowExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/de6/structblaze_1_1SMatDeclLowExprTrait.html" title="Evaluation of the expression type of a sparse matrix decllow operation.Via this type trait it is poss...">SMatDeclLowExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaebb7338fe7f91b8428f584a8110a7bef">More...</a><br /></td></tr>
<tr class="separator:gaebb7338fe7f91b8428f584a8110a7bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc3719f43bef1ec886358c7dac4644b"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga2bc3719f43bef1ec886358c7dac4644b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga2bc3719f43bef1ec886358c7dac4644b">SMatDeclSymExprTrait_</a> = typename <a class="el" href="../../d2/dc2/structblaze_1_1SMatDeclSymExprTrait.html">SMatDeclSymExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga2bc3719f43bef1ec886358c7dac4644b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/dc2/structblaze_1_1SMatDeclSymExprTrait.html" title="Evaluation of the expression type of a sparse matrix declsym operation.Via this type trait it is poss...">SMatDeclSymExprTrait</a> class template.The SMatDeclSymExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/dc2/structblaze_1_1SMatDeclSymExprTrait.html" title="Evaluation of the expression type of a sparse matrix declsym operation.Via this type trait it is poss...">SMatDeclSymExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga2bc3719f43bef1ec886358c7dac4644b">More...</a><br /></td></tr>
<tr class="separator:ga2bc3719f43bef1ec886358c7dac4644b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga629ad4c27414677efeecf2039f913ca6"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga629ad4c27414677efeecf2039f913ca6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga629ad4c27414677efeecf2039f913ca6">SMatDeclUppExprTrait_</a> = typename <a class="el" href="../../d3/d5a/structblaze_1_1SMatDeclUppExprTrait.html">SMatDeclUppExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga629ad4c27414677efeecf2039f913ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d3/d5a/structblaze_1_1SMatDeclUppExprTrait.html" title="Evaluation of the expression type of a sparse matrix declupp operation.Via this type trait it is poss...">SMatDeclUppExprTrait</a> class template.The SMatDeclUppExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/d5a/structblaze_1_1SMatDeclUppExprTrait.html" title="Evaluation of the expression type of a sparse matrix declupp operation.Via this type trait it is poss...">SMatDeclUppExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga629ad4c27414677efeecf2039f913ca6">More...</a><br /></td></tr>
<tr class="separator:ga629ad4c27414677efeecf2039f913ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0afe7f9abc0db7a1758a243e9abde829"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga0afe7f9abc0db7a1758a243e9abde829"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga0afe7f9abc0db7a1758a243e9abde829">SMatDMatAddExprTrait_</a> = typename <a class="el" href="../../d8/d14/structblaze_1_1SMatDMatAddExprTrait.html">SMatDMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga0afe7f9abc0db7a1758a243e9abde829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d14/structblaze_1_1SMatDMatAddExprTrait.html" title="Evaluation of the expression type of a sparse matrix/dense matrix addition.Via this type trait it is ...">SMatDMatAddExprTrait</a> class template.The SMatDMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d14/structblaze_1_1SMatDMatAddExprTrait.html" title="Evaluation of the expression type of a sparse matrix/dense matrix addition.Via this type trait it is ...">SMatDMatAddExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga0afe7f9abc0db7a1758a243e9abde829">More...</a><br /></td></tr>
<tr class="separator:ga0afe7f9abc0db7a1758a243e9abde829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0213d8339e7d7655204180b52d8d896f"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga0213d8339e7d7655204180b52d8d896f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga0213d8339e7d7655204180b52d8d896f">SMatDMatMultExprTrait_</a> = typename <a class="el" href="../../d8/d14/structblaze_1_1SMatDMatMultExprTrait.html">SMatDMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga0213d8339e7d7655204180b52d8d896f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d14/structblaze_1_1SMatDMatMultExprTrait.html" title="Evaluation of the expression type of a sparse matrix/dense matrix multiplication.Via this type trait ...">SMatDMatMultExprTrait</a> class template.The SMatDMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d14/structblaze_1_1SMatDMatMultExprTrait.html" title="Evaluation of the expression type of a sparse matrix/dense matrix multiplication.Via this type trait ...">SMatDMatMultExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga0213d8339e7d7655204180b52d8d896f">More...</a><br /></td></tr>
<tr class="separator:ga0213d8339e7d7655204180b52d8d896f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35fe2e06fd2ad6788f85e018704245ed"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga35fe2e06fd2ad6788f85e018704245ed"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga35fe2e06fd2ad6788f85e018704245ed">SMatDMatSubExprTrait_</a> = typename <a class="el" href="../../df/d1a/structblaze_1_1SMatDMatSubExprTrait.html">SMatDMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga35fe2e06fd2ad6788f85e018704245ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d1a/structblaze_1_1SMatDMatSubExprTrait.html" title="Evaluation of the expression type of a sparse matrix/dense matrix subtraction.Via this type trait it ...">SMatDMatSubExprTrait</a> class template.The SMatDMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d1a/structblaze_1_1SMatDMatSubExprTrait.html" title="Evaluation of the expression type of a sparse matrix/dense matrix subtraction.Via this type trait it ...">SMatDMatSubExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga35fe2e06fd2ad6788f85e018704245ed">More...</a><br /></td></tr>
<tr class="separator:ga35fe2e06fd2ad6788f85e018704245ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad248d5cbd0afd39566104ed9446d8d41"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:gad248d5cbd0afd39566104ed9446d8d41"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gad248d5cbd0afd39566104ed9446d8d41">SMatDVecMultExprTrait_</a> = typename <a class="el" href="../../d8/d40/structblaze_1_1SMatDVecMultExprTrait.html">SMatDVecMultExprTrait</a>&lt; MT, VT &gt;::Type</td></tr>
<tr class="memdesc:gad248d5cbd0afd39566104ed9446d8d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d40/structblaze_1_1SMatDVecMultExprTrait.html" title="Evaluation of the expression type of a sparse matrix/dense vector multiplication.Via this type trait ...">SMatDVecMultExprTrait</a> class template.The SMatDVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d40/structblaze_1_1SMatDVecMultExprTrait.html" title="Evaluation of the expression type of a sparse matrix/dense vector multiplication.Via this type trait ...">SMatDVecMultExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT</em> and the non-transpose dense vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gad248d5cbd0afd39566104ed9446d8d41">More...</a><br /></td></tr>
<tr class="separator:gad248d5cbd0afd39566104ed9446d8d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6256af4655f1a87524cc26ecce0dd3ef"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga6256af4655f1a87524cc26ecce0dd3ef"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga6256af4655f1a87524cc26ecce0dd3ef">SMatEvalExprTrait_</a> = typename <a class="el" href="../../d5/d64/structblaze_1_1SMatEvalExprTrait.html">SMatEvalExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga6256af4655f1a87524cc26ecce0dd3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d64/structblaze_1_1SMatEvalExprTrait.html" title="Evaluation of the expression type of a sparse matrix evaluation operation.Via this type trait it is p...">SMatEvalExprTrait</a> class template.The SMatEvalExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d64/structblaze_1_1SMatEvalExprTrait.html" title="Evaluation of the expression type of a sparse matrix evaluation operation.Via this type trait it is p...">SMatEvalExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga6256af4655f1a87524cc26ecce0dd3ef">More...</a><br /></td></tr>
<tr class="separator:ga6256af4655f1a87524cc26ecce0dd3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga883c25516d9836291547bbb14f6ce712"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename OP &gt; </td></tr>
<tr class="memitem:ga883c25516d9836291547bbb14f6ce712"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga883c25516d9836291547bbb14f6ce712">SMatForEachExprTrait_</a> = typename <a class="el" href="../../d6/d0f/structblaze_1_1SMatForEachExprTrait.html">SMatForEachExprTrait</a>&lt; MT, OP &gt;::Type</td></tr>
<tr class="memdesc:ga883c25516d9836291547bbb14f6ce712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d6/d0f/structblaze_1_1SMatForEachExprTrait.html" title="Evaluation of the expression type of a sparse matrix for-each operation.Via this type trait it is pos...">SMatForEachExprTrait</a> class template.The SMatForEachExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/d0f/structblaze_1_1SMatForEachExprTrait.html" title="Evaluation of the expression type of a sparse matrix for-each operation.Via this type trait it is pos...">SMatForEachExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT</em> and the custom operation type <em>OP</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga883c25516d9836291547bbb14f6ce712">More...</a><br /></td></tr>
<tr class="separator:ga883c25516d9836291547bbb14f6ce712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga418c5fc302350472e76f10b936ed089b"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename ST &gt; </td></tr>
<tr class="memitem:ga418c5fc302350472e76f10b936ed089b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga418c5fc302350472e76f10b936ed089b">SMatScalarDivExprTrait_</a> = typename <a class="el" href="../../de/d46/structblaze_1_1SMatScalarDivExprTrait.html">SMatScalarDivExprTrait</a>&lt; MT, ST &gt;::Type</td></tr>
<tr class="memdesc:ga418c5fc302350472e76f10b936ed089b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d46/structblaze_1_1SMatScalarDivExprTrait.html" title="Evaluation of the expression type of a sparse matrix/scalar division.Via this type trait it is possib...">SMatScalarDivExprTrait</a> class template.The SMatScalarDivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d46/structblaze_1_1SMatScalarDivExprTrait.html" title="Evaluation of the expression type of a sparse matrix/scalar division.Via this type trait it is possib...">SMatScalarDivExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga418c5fc302350472e76f10b936ed089b">More...</a><br /></td></tr>
<tr class="separator:ga418c5fc302350472e76f10b936ed089b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46872275ef66fea333b0db21815e144a"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename ST &gt; </td></tr>
<tr class="memitem:ga46872275ef66fea333b0db21815e144a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga46872275ef66fea333b0db21815e144a">SMatScalarMultExprTrait_</a> = typename <a class="el" href="../../d1/d4d/structblaze_1_1SMatScalarMultExprTrait.html">SMatScalarMultExprTrait</a>&lt; MT, ST &gt;::Type</td></tr>
<tr class="memdesc:ga46872275ef66fea333b0db21815e144a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d4d/structblaze_1_1SMatScalarMultExprTrait.html" title="Evaluation of the expression type of a sparse matrix/scalar multiplication.Via this type trait it is ...">SMatScalarMultExprTrait</a> class template.The SMatScalarMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d4d/structblaze_1_1SMatScalarMultExprTrait.html" title="Evaluation of the expression type of a sparse matrix/scalar multiplication.Via this type trait it is ...">SMatScalarMultExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga46872275ef66fea333b0db21815e144a">More...</a><br /></td></tr>
<tr class="separator:ga46872275ef66fea333b0db21815e144a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ef987eb958dd8e526445ece7ca91550"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga4ef987eb958dd8e526445ece7ca91550"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga4ef987eb958dd8e526445ece7ca91550">SMatSerialExprTrait_</a> = typename <a class="el" href="../../da/d8f/structblaze_1_1SMatSerialExprTrait.html">SMatSerialExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga4ef987eb958dd8e526445ece7ca91550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/d8f/structblaze_1_1SMatSerialExprTrait.html" title="Evaluation of the expression type of a sparse matrix serial evaluation operation.Via this type trait ...">SMatSerialExprTrait</a> class template.The SMatSerialExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/d8f/structblaze_1_1SMatSerialExprTrait.html" title="Evaluation of the expression type of a sparse matrix serial evaluation operation.Via this type trait ...">SMatSerialExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga4ef987eb958dd8e526445ece7ca91550">More...</a><br /></td></tr>
<tr class="separator:ga4ef987eb958dd8e526445ece7ca91550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ceac5c644ebdddac18a062ee749f143"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga3ceac5c644ebdddac18a062ee749f143"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga3ceac5c644ebdddac18a062ee749f143">SMatSMatAddExprTrait_</a> = typename <a class="el" href="../../d6/d9c/structblaze_1_1SMatSMatAddExprTrait.html">SMatSMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga3ceac5c644ebdddac18a062ee749f143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d6/d9c/structblaze_1_1SMatSMatAddExprTrait.html" title="Evaluation of the expression type of a sparse matrix/sparse matrix addition.Via this type trait it is...">SMatSMatAddExprTrait</a> class template.The SMatSMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/d9c/structblaze_1_1SMatSMatAddExprTrait.html" title="Evaluation of the expression type of a sparse matrix/sparse matrix addition.Via this type trait it is...">SMatSMatAddExprTrait</a> class template. For instance, given the row-major sparse matrix types <em>MT1</em> and <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga3ceac5c644ebdddac18a062ee749f143">More...</a><br /></td></tr>
<tr class="separator:ga3ceac5c644ebdddac18a062ee749f143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fa86cf2c31e97deef2e2b4456723c93"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga3fa86cf2c31e97deef2e2b4456723c93"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga3fa86cf2c31e97deef2e2b4456723c93">SMatSMatMultExprTrait_</a> = typename <a class="el" href="../../da/d59/structblaze_1_1SMatSMatMultExprTrait.html">SMatSMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga3fa86cf2c31e97deef2e2b4456723c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/d59/structblaze_1_1SMatSMatMultExprTrait.html" title="Evaluation of the expression type of a sparse matrix/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/sparse matrix multiplication. Given the two row-major sparse matrix types MT1 and MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 or MT2 is not a row-major sparse matrix, the resulting data type Type is set to INVALID_TYPE. ">SMatSMatMultExprTrait</a> class template.The SMatSMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/d59/structblaze_1_1SMatSMatMultExprTrait.html" title="Evaluation of the expression type of a sparse matrix/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/sparse matrix multiplication. Given the two row-major sparse matrix types MT1 and MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 or MT2 is not a row-major sparse matrix, the resulting data type Type is set to INVALID_TYPE. ">SMatSMatMultExprTrait</a> class template. For instance, given the row-major sparse matrix types <em>MT1</em> and <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga3fa86cf2c31e97deef2e2b4456723c93">More...</a><br /></td></tr>
<tr class="separator:ga3fa86cf2c31e97deef2e2b4456723c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9d78a27c796a53d628265549f56bf03"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gae9d78a27c796a53d628265549f56bf03"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gae9d78a27c796a53d628265549f56bf03">SMatSMatSubExprTrait_</a> = typename <a class="el" href="../../de/d43/structblaze_1_1SMatSMatSubExprTrait.html">SMatSMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gae9d78a27c796a53d628265549f56bf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d43/structblaze_1_1SMatSMatSubExprTrait.html" title="Evaluation of the expression type of a sparse matrix/sparse matrix subtraction.Via this type trait it...">SMatSMatSubExprTrait</a> class template.The SMatSMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d43/structblaze_1_1SMatSMatSubExprTrait.html" title="Evaluation of the expression type of a sparse matrix/sparse matrix subtraction.Via this type trait it...">SMatSMatSubExprTrait</a> class template. For instance, given the row-major sparse matrix types <em>MT1</em> and <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gae9d78a27c796a53d628265549f56bf03">More...</a><br /></td></tr>
<tr class="separator:gae9d78a27c796a53d628265549f56bf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ef4ecfba0527cb12fda03c41dc4e3c"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:gaa3ef4ecfba0527cb12fda03c41dc4e3c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaa3ef4ecfba0527cb12fda03c41dc4e3c">SMatSVecMultExprTrait_</a> = typename <a class="el" href="../../d8/d35/structblaze_1_1SMatSVecMultExprTrait.html">SMatSVecMultExprTrait</a>&lt; MT, VT &gt;::Type</td></tr>
<tr class="memdesc:gaa3ef4ecfba0527cb12fda03c41dc4e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d35/structblaze_1_1SMatSVecMultExprTrait.html" title="Evaluation of the expression type of a sparse matrix/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/sparse vector multiplication. Given the row-major sparse matrix type MT and the non-transpose sparse vector type VT, the nested type Type corresponds to the resulting expression type. In case either MT is not a row-major sparse matrix type or VT is not a non-transpose sparse vector type, the resulting data type Type is set to INVALID_TYPE. ">SMatSVecMultExprTrait</a> class template.The SMatSVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d35/structblaze_1_1SMatSVecMultExprTrait.html" title="Evaluation of the expression type of a sparse matrix/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/sparse vector multiplication. Given the row-major sparse matrix type MT and the non-transpose sparse vector type VT, the nested type Type corresponds to the resulting expression type. In case either MT is not a row-major sparse matrix type or VT is not a non-transpose sparse vector type, the resulting data type Type is set to INVALID_TYPE. ">SMatSVecMultExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT</em> and the non-transpose sparse vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaa3ef4ecfba0527cb12fda03c41dc4e3c">More...</a><br /></td></tr>
<tr class="separator:gaa3ef4ecfba0527cb12fda03c41dc4e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7147e50114d6952587bb68b7874cf730"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga7147e50114d6952587bb68b7874cf730"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga7147e50114d6952587bb68b7874cf730">SMatTDMatAddExprTrait_</a> = typename <a class="el" href="../../d4/d9f/structblaze_1_1SMatTDMatAddExprTrait.html">SMatTDMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga7147e50114d6952587bb68b7874cf730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/d9f/structblaze_1_1SMatTDMatAddExprTrait.html" title="Evaluation of the expression type of a sparse matrix/transpose dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose dense matrix addition. Given the row-major sparse matrix type MT1 and the column-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major sparse matrix type or MT2 is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">SMatTDMatAddExprTrait</a> class template.The SMatTDMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/d9f/structblaze_1_1SMatTDMatAddExprTrait.html" title="Evaluation of the expression type of a sparse matrix/transpose dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose dense matrix addition. Given the row-major sparse matrix type MT1 and the column-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major sparse matrix type or MT2 is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">SMatTDMatAddExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga7147e50114d6952587bb68b7874cf730">More...</a><br /></td></tr>
<tr class="separator:ga7147e50114d6952587bb68b7874cf730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga081bd44ecbef6eb55fcf4487647b32b4"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga081bd44ecbef6eb55fcf4487647b32b4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga081bd44ecbef6eb55fcf4487647b32b4">SMatTDMatMultExprTrait_</a> = typename <a class="el" href="../../d7/d9d/structblaze_1_1SMatTDMatMultExprTrait.html">SMatTDMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga081bd44ecbef6eb55fcf4487647b32b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d9d/structblaze_1_1SMatTDMatMultExprTrait.html" title="Evaluation of the expression type of a sparse matrix/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose dense matrix multiplication. Given the row-major sparse matrix type MT1 and the column-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major sparse matrix type or MT2 is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">SMatTDMatMultExprTrait</a> class template.The SMatTDMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d9d/structblaze_1_1SMatTDMatMultExprTrait.html" title="Evaluation of the expression type of a sparse matrix/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose dense matrix multiplication. Given the row-major sparse matrix type MT1 and the column-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major sparse matrix type or MT2 is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">SMatTDMatMultExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga081bd44ecbef6eb55fcf4487647b32b4">More...</a><br /></td></tr>
<tr class="separator:ga081bd44ecbef6eb55fcf4487647b32b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeabcd3d601c7150b276597b09ae3833c"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaeabcd3d601c7150b276597b09ae3833c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaeabcd3d601c7150b276597b09ae3833c">SMatTDMatSubExprTrait_</a> = typename <a class="el" href="../../d9/d76/structblaze_1_1SMatTDMatSubExprTrait.html">SMatTDMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gaeabcd3d601c7150b276597b09ae3833c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/d76/structblaze_1_1SMatTDMatSubExprTrait.html" title="Evaluation of the expression type of a sparse matrix/transpose dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose dense matrix subtraction. Given the row-major sparse matrix type MT1 and the column-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major sparse matrix type or MT2 is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">SMatTDMatSubExprTrait</a> class template.The SMatTDMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/d76/structblaze_1_1SMatTDMatSubExprTrait.html" title="Evaluation of the expression type of a sparse matrix/transpose dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose dense matrix subtraction. Given the row-major sparse matrix type MT1 and the column-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major sparse matrix type or MT2 is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">SMatTDMatSubExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaeabcd3d601c7150b276597b09ae3833c">More...</a><br /></td></tr>
<tr class="separator:gaeabcd3d601c7150b276597b09ae3833c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga130ce4aa7b101972d9d853b29eb011eb"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga130ce4aa7b101972d9d853b29eb011eb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga130ce4aa7b101972d9d853b29eb011eb">SMatTransExprTrait_</a> = typename <a class="el" href="../../d8/da2/structblaze_1_1SMatTransExprTrait.html">SMatTransExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga130ce4aa7b101972d9d853b29eb011eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/da2/structblaze_1_1SMatTransExprTrait.html" title="Evaluation of the expression type of a sparse matrix transpose operation.Via this type trait it is po...">SMatTransExprTrait</a> class template.The SMatTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/da2/structblaze_1_1SMatTransExprTrait.html" title="Evaluation of the expression type of a sparse matrix transpose operation.Via this type trait it is po...">SMatTransExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga130ce4aa7b101972d9d853b29eb011eb">More...</a><br /></td></tr>
<tr class="separator:ga130ce4aa7b101972d9d853b29eb011eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22c92fa0531945024c1a2fc31eca7cde"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga22c92fa0531945024c1a2fc31eca7cde"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga22c92fa0531945024c1a2fc31eca7cde">SMatTSMatAddExprTrait_</a> = typename <a class="el" href="../../dd/d48/structblaze_1_1SMatTSMatAddExprTrait.html">SMatTSMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga22c92fa0531945024c1a2fc31eca7cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d48/structblaze_1_1SMatTSMatAddExprTrait.html" title="Evaluation of the expression type of a sparse matrix/transpose sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose sparse matrix addition. Given the row-major sparse matrix type MT1 and the column-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major sparse matrix type or MT2 is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">SMatTSMatAddExprTrait</a> class template.The SMatTSMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d48/structblaze_1_1SMatTSMatAddExprTrait.html" title="Evaluation of the expression type of a sparse matrix/transpose sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose sparse matrix addition. Given the row-major sparse matrix type MT1 and the column-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major sparse matrix type or MT2 is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">SMatTSMatAddExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga22c92fa0531945024c1a2fc31eca7cde">More...</a><br /></td></tr>
<tr class="separator:ga22c92fa0531945024c1a2fc31eca7cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga645226b8aeb3ee944b01d496e1795727"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga645226b8aeb3ee944b01d496e1795727"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga645226b8aeb3ee944b01d496e1795727">SMatTSMatMultExprTrait_</a> = typename <a class="el" href="../../d7/dbb/structblaze_1_1SMatTSMatMultExprTrait.html">SMatTSMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga645226b8aeb3ee944b01d496e1795727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/dbb/structblaze_1_1SMatTSMatMultExprTrait.html" title="Evaluation of the expression type of a sparse matrix/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose sparse matrix multiplication. Given the row-major sparse matrix type MT1 and the column-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major sparse matrix type or MT2 is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">SMatTSMatMultExprTrait</a> class template.The SMatTSMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/dbb/structblaze_1_1SMatTSMatMultExprTrait.html" title="Evaluation of the expression type of a sparse matrix/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose sparse matrix multiplication. Given the row-major sparse matrix type MT1 and the column-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major sparse matrix type or MT2 is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">SMatTSMatMultExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga645226b8aeb3ee944b01d496e1795727">More...</a><br /></td></tr>
<tr class="separator:ga645226b8aeb3ee944b01d496e1795727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3289e26a18c9b1b0b5dd1be43d3bb972"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga3289e26a18c9b1b0b5dd1be43d3bb972"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga3289e26a18c9b1b0b5dd1be43d3bb972">SMatTSMatSubExprTrait_</a> = typename <a class="el" href="../../d2/da1/structblaze_1_1SMatTSMatSubExprTrait.html">SMatTSMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga3289e26a18c9b1b0b5dd1be43d3bb972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/da1/structblaze_1_1SMatTSMatSubExprTrait.html" title="Evaluation of the expression type of a sparse matrix/transpose sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose sparse matrix subtraction. Given the row-major sparse matrix type MT1 and the column-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major sparse matrix type or MT2 is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">SMatTSMatSubExprTrait</a> class template.The SMatTSMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/da1/structblaze_1_1SMatTSMatSubExprTrait.html" title="Evaluation of the expression type of a sparse matrix/transpose sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose sparse matrix subtraction. Given the row-major sparse matrix type MT1 and the column-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a row-major sparse matrix type or MT2 is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">SMatTSMatSubExprTrait</a> class template. For instance, given the row-major sparse matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga3289e26a18c9b1b0b5dd1be43d3bb972">More...</a><br /></td></tr>
<tr class="separator:ga3289e26a18c9b1b0b5dd1be43d3bb972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9375f8308fc6db4d92f3aea659d02cd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae9375f8308fc6db4d92f3aea659d02cd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gae9375f8308fc6db4d92f3aea659d02cd">SubExprTrait_</a> = typename <a class="el" href="../../db/d9b/structblaze_1_1SubExprTrait.html">SubExprTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:gae9375f8308fc6db4d92f3aea659d02cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/d9b/structblaze_1_1SubExprTrait.html" title="Evaluation of the return type of a subtraction expression.Via this type trait it is possible to evalu...">SubExprTrait</a> class template.The SubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/d9b/structblaze_1_1SubExprTrait.html" title="Evaluation of the return type of a subtraction expression.Via this type trait it is possible to evalu...">SubExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gae9375f8308fc6db4d92f3aea659d02cd">More...</a><br /></td></tr>
<tr class="separator:gae9375f8308fc6db4d92f3aea659d02cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fc4a18930642ac1da2025b6b31e0a19"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF&gt; </td></tr>
<tr class="memitem:ga3fc4a18930642ac1da2025b6b31e0a19"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga3fc4a18930642ac1da2025b6b31e0a19">SubmatrixExprTrait_</a> = typename <a class="el" href="../../d7/d6d/structblaze_1_1SubmatrixExprTrait.html">SubmatrixExprTrait</a>&lt; MT, AF &gt;::Type</td></tr>
<tr class="memdesc:ga3fc4a18930642ac1da2025b6b31e0a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d6d/structblaze_1_1SubmatrixExprTrait.html" title="Evaluation of the expression type type of a submatrix operation.Via this type trait it is possible to...">SubmatrixExprTrait</a> type trait.The SubmatrixExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d6d/structblaze_1_1SubmatrixExprTrait.html" title="Evaluation of the expression type type of a submatrix operation.Via this type trait it is possible to...">SubmatrixExprTrait</a> class template. For instance, given the matrix type <em>MT</em> and the alignment flag <em>AF</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga3fc4a18930642ac1da2025b6b31e0a19">More...</a><br /></td></tr>
<tr class="separator:ga3fc4a18930642ac1da2025b6b31e0a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dbad8079bcef022b18f2988da0d7beb"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga7dbad8079bcef022b18f2988da0d7beb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga7dbad8079bcef022b18f2988da0d7beb">SubmatrixTrait_</a> = typename <a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html">SubmatrixTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga7dbad8079bcef022b18f2988da0d7beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html" title="Base template for the SubmatrixTrait class. ">SubmatrixTrait</a> type trait.The SubmatrixTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html" title="Base template for the SubmatrixTrait class. ">SubmatrixTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga7dbad8079bcef022b18f2988da0d7beb">More...</a><br /></td></tr>
<tr class="separator:ga7dbad8079bcef022b18f2988da0d7beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49f2e308fdf9e6148a1fa373cd7605d8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga49f2e308fdf9e6148a1fa373cd7605d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga49f2e308fdf9e6148a1fa373cd7605d8">SubTrait_</a> = typename <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html">SubTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga49f2e308fdf9e6148a1fa373cd7605d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.The SubTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga49f2e308fdf9e6148a1fa373cd7605d8">More...</a><br /></td></tr>
<tr class="separator:ga49f2e308fdf9e6148a1fa373cd7605d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafabb36a96e9d948974930ead876b6dfa"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF&gt; </td></tr>
<tr class="memitem:gafabb36a96e9d948974930ead876b6dfa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gafabb36a96e9d948974930ead876b6dfa">SubvectorExprTrait_</a> = typename <a class="el" href="../../dd/df0/structblaze_1_1SubvectorExprTrait.html">SubvectorExprTrait</a>&lt; VT, AF &gt;::Type</td></tr>
<tr class="memdesc:gafabb36a96e9d948974930ead876b6dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/df0/structblaze_1_1SubvectorExprTrait.html" title="Evaluation of the expression type type of a subvector operation.Via this type trait it is possible to...">SubvectorExprTrait</a> type trait.The SubvectorExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/df0/structblaze_1_1SubvectorExprTrait.html" title="Evaluation of the expression type type of a subvector operation.Via this type trait it is possible to...">SubvectorExprTrait</a> class template. For instance, given the vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gafabb36a96e9d948974930ead876b6dfa">More...</a><br /></td></tr>
<tr class="separator:gafabb36a96e9d948974930ead876b6dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga305e56571fa64ea7dc4a0f513c7f42c8"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga305e56571fa64ea7dc4a0f513c7f42c8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga305e56571fa64ea7dc4a0f513c7f42c8">SubvectorTrait_</a> = typename <a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html">SubvectorTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:ga305e56571fa64ea7dc4a0f513c7f42c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html" title="Base template for the SubvectorTrait class. ">SubvectorTrait</a> type trait.The SubvectorTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html" title="Base template for the SubvectorTrait class. ">SubvectorTrait</a> class template. For instance, given the vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga305e56571fa64ea7dc4a0f513c7f42c8">More...</a><br /></td></tr>
<tr class="separator:ga305e56571fa64ea7dc4a0f513c7f42c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga133673a61efcfcafdcdaa2184c216548"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga133673a61efcfcafdcdaa2184c216548"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga133673a61efcfcafdcdaa2184c216548">SVecCTransExprTrait_</a> = typename <a class="el" href="../../d1/d83/structblaze_1_1SVecCTransExprTrait.html">SVecCTransExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:ga133673a61efcfcafdcdaa2184c216548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d83/structblaze_1_1SVecCTransExprTrait.html" title="Evaluation of the expression type of a sparse vector conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector conjugate transpose operation. Given the non-transpose sparse vector type VT, the nested type Type corresponds to the resulting expression type. In case VT is not a non-transpose sparse vector type, the resulting Type is set to INVALID_TYPE. ">SVecCTransExprTrait</a> class template.The SVecCTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d83/structblaze_1_1SVecCTransExprTrait.html" title="Evaluation of the expression type of a sparse vector conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector conjugate transpose operation. Given the non-transpose sparse vector type VT, the nested type Type corresponds to the resulting expression type. In case VT is not a non-transpose sparse vector type, the resulting Type is set to INVALID_TYPE. ">SVecCTransExprTrait</a> class template. For instance, given the non-transpose sparse vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga133673a61efcfcafdcdaa2184c216548">More...</a><br /></td></tr>
<tr class="separator:ga133673a61efcfcafdcdaa2184c216548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae4e5b85a4fbd0c7e4e074389064dd55"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gaae4e5b85a4fbd0c7e4e074389064dd55"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaae4e5b85a4fbd0c7e4e074389064dd55">SVecDVecAddExprTrait_</a> = typename <a class="el" href="../../db/dc3/structblaze_1_1SVecDVecAddExprTrait.html">SVecDVecAddExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:gaae4e5b85a4fbd0c7e4e074389064dd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/dc3/structblaze_1_1SVecDVecAddExprTrait.html" title="Evaluation of the expression type of a sparse vector/dense vector addition.Via this type trait it is ...">SVecDVecAddExprTrait</a> class template.The SVecDVecAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/dc3/structblaze_1_1SVecDVecAddExprTrait.html" title="Evaluation of the expression type of a sparse vector/dense vector addition.Via this type trait it is ...">SVecDVecAddExprTrait</a> class template. For instance, given the non-transpose sparse vector types <em>VT1</em> and the non-transpose dense vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaae4e5b85a4fbd0c7e4e074389064dd55">More...</a><br /></td></tr>
<tr class="separator:gaae4e5b85a4fbd0c7e4e074389064dd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dc73cc6e2826a08b3a30c948f3c409e"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga5dc73cc6e2826a08b3a30c948f3c409e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga5dc73cc6e2826a08b3a30c948f3c409e">SVecDVecCrossExprTrait_</a> = typename <a class="el" href="../../d7/ddb/structblaze_1_1SVecDVecCrossExprTrait.html">SVecDVecCrossExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga5dc73cc6e2826a08b3a30c948f3c409e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/ddb/structblaze_1_1SVecDVecCrossExprTrait.html" title="Evaluation of the expression type of a sparse vector/dense vector cross product.Via this type trait i...">SVecDVecCrossExprTrait</a> class template.The SVecDVecCrossExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/ddb/structblaze_1_1SVecDVecCrossExprTrait.html" title="Evaluation of the expression type of a sparse vector/dense vector cross product.Via this type trait i...">SVecDVecCrossExprTrait</a> class template. For instance, given the non-transpose sparse vector types <em>VT1</em> and the non-transpose dense vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga5dc73cc6e2826a08b3a30c948f3c409e">More...</a><br /></td></tr>
<tr class="separator:ga5dc73cc6e2826a08b3a30c948f3c409e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd28c13014ca55525c435ea3e1800ed"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga3dd28c13014ca55525c435ea3e1800ed"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga3dd28c13014ca55525c435ea3e1800ed">SVecDVecDivExprTrait_</a> = typename <a class="el" href="../../d1/db2/structblaze_1_1SVecDVecDivExprTrait.html">SVecDVecDivExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga3dd28c13014ca55525c435ea3e1800ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/db2/structblaze_1_1SVecDVecDivExprTrait.html" title="Evaluation of the expression type of a sparse vector/dense vector division.Via this type trait it is ...">SVecDVecDivExprTrait</a> class template.The SVecDVecDivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/db2/structblaze_1_1SVecDVecDivExprTrait.html" title="Evaluation of the expression type of a sparse vector/dense vector division.Via this type trait it is ...">SVecDVecDivExprTrait</a> class template. For instance, given the non-transpose sparse vector types <em>VT1</em> and the non-transpose dense vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga3dd28c13014ca55525c435ea3e1800ed">More...</a><br /></td></tr>
<tr class="separator:ga3dd28c13014ca55525c435ea3e1800ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ee3a37fcdbbd747f8f96e4c821f85e2"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga8ee3a37fcdbbd747f8f96e4c821f85e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga8ee3a37fcdbbd747f8f96e4c821f85e2">SVecDVecMultExprTrait_</a> = typename <a class="el" href="../../d1/d42/structblaze_1_1SVecDVecMultExprTrait.html">SVecDVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga8ee3a37fcdbbd747f8f96e4c821f85e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d42/structblaze_1_1SVecDVecMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/dense vector multiplication.Via this type trait ...">SVecDVecMultExprTrait</a> class template.The SVecDVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d42/structblaze_1_1SVecDVecMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/dense vector multiplication.Via this type trait ...">SVecDVecMultExprTrait</a> class template. For instance, given the non-transpose sparse vector types <em>VT1</em> and the non-transpose dense vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga8ee3a37fcdbbd747f8f96e4c821f85e2">More...</a><br /></td></tr>
<tr class="separator:ga8ee3a37fcdbbd747f8f96e4c821f85e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeee6b8424e0332b9b488aa7b0fd511c"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gadeee6b8424e0332b9b488aa7b0fd511c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gadeee6b8424e0332b9b488aa7b0fd511c">SVecDVecSubExprTrait_</a> = typename <a class="el" href="../../d7/d8a/structblaze_1_1SVecDVecSubExprTrait.html">SVecDVecSubExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:gadeee6b8424e0332b9b488aa7b0fd511c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d8a/structblaze_1_1SVecDVecSubExprTrait.html" title="Evaluation of the expression type of a sparse vector/dense vector subtraction.Via this type trait it ...">SVecDVecSubExprTrait</a> class template.The SVecDVecSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d8a/structblaze_1_1SVecDVecSubExprTrait.html" title="Evaluation of the expression type of a sparse vector/dense vector subtraction.Via this type trait it ...">SVecDVecSubExprTrait</a> class template. For instance, given the non-transpose sparse vector types <em>VT1</em> and the non-transpose dense vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gadeee6b8424e0332b9b488aa7b0fd511c">More...</a><br /></td></tr>
<tr class="separator:gadeee6b8424e0332b9b488aa7b0fd511c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69ede7b276f33ac54bb5a664c207f39e"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga69ede7b276f33ac54bb5a664c207f39e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga69ede7b276f33ac54bb5a664c207f39e">SVecEvalExprTrait_</a> = typename <a class="el" href="../../dd/d64/structblaze_1_1SVecEvalExprTrait.html">SVecEvalExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:ga69ede7b276f33ac54bb5a664c207f39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d64/structblaze_1_1SVecEvalExprTrait.html" title="Evaluation of the expression type of a sparse vector evaluation operation.Via this type trait it is p...">SVecEvalExprTrait</a> class template.The SVecEvalExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d64/structblaze_1_1SVecEvalExprTrait.html" title="Evaluation of the expression type of a sparse vector evaluation operation.Via this type trait it is p...">SVecEvalExprTrait</a> class template. For instance, given the non-transpose sparse vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga69ede7b276f33ac54bb5a664c207f39e">More...</a><br /></td></tr>
<tr class="separator:ga69ede7b276f33ac54bb5a664c207f39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a3b30025aa62404847de5603f5037d4"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename OP &gt; </td></tr>
<tr class="memitem:ga4a3b30025aa62404847de5603f5037d4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga4a3b30025aa62404847de5603f5037d4">SVecForEachExprTrait_</a> = typename <a class="el" href="../../d3/d06/structblaze_1_1SVecForEachExprTrait.html">SVecForEachExprTrait</a>&lt; VT, OP &gt;::Type</td></tr>
<tr class="memdesc:ga4a3b30025aa62404847de5603f5037d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d3/d06/structblaze_1_1SVecForEachExprTrait.html" title="Evaluation of the expression type of a sparse vector for-each operation.Via this type trait it is pos...">SVecForEachExprTrait</a> class template.The SVecForEachExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/d06/structblaze_1_1SVecForEachExprTrait.html" title="Evaluation of the expression type of a sparse vector for-each operation.Via this type trait it is pos...">SVecForEachExprTrait</a> class template. For instance, given the non-transpose sparse vector type <em>VT</em> and the custom operation type <em>OP</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga4a3b30025aa62404847de5603f5037d4">More...</a><br /></td></tr>
<tr class="separator:ga4a3b30025aa62404847de5603f5037d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9f596fa724c033b2934085b3764afa7"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ST &gt; </td></tr>
<tr class="memitem:gac9f596fa724c033b2934085b3764afa7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gac9f596fa724c033b2934085b3764afa7">SVecScalarDivExprTrait_</a> = typename <a class="el" href="../../d7/dd3/structblaze_1_1SVecScalarDivExprTrait.html">SVecScalarDivExprTrait</a>&lt; VT, ST &gt;::Type</td></tr>
<tr class="memdesc:gac9f596fa724c033b2934085b3764afa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/dd3/structblaze_1_1SVecScalarDivExprTrait.html" title="Evaluation of the expression type of a sparse vector/scalar division.Via this type trait it is possib...">SVecScalarDivExprTrait</a> class template.The SVecScalarDivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/dd3/structblaze_1_1SVecScalarDivExprTrait.html" title="Evaluation of the expression type of a sparse vector/scalar division.Via this type trait it is possib...">SVecScalarDivExprTrait</a> class template. For instance, given the non-transpose sparse vector type <em>VT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gac9f596fa724c033b2934085b3764afa7">More...</a><br /></td></tr>
<tr class="separator:gac9f596fa724c033b2934085b3764afa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65b87777d3bc07fa373170447fa3abb"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ST &gt; </td></tr>
<tr class="memitem:gad65b87777d3bc07fa373170447fa3abb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gad65b87777d3bc07fa373170447fa3abb">SVecScalarMultExprTrait_</a> = typename <a class="el" href="../../d5/d16/structblaze_1_1SVecScalarMultExprTrait.html">SVecScalarMultExprTrait</a>&lt; VT, ST &gt;::Type</td></tr>
<tr class="memdesc:gad65b87777d3bc07fa373170447fa3abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d16/structblaze_1_1SVecScalarMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/scalar multiplication.Via this type trait it is ...">SVecScalarMultExprTrait</a> class template.The SVecScalarMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d16/structblaze_1_1SVecScalarMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/scalar multiplication.Via this type trait it is ...">SVecScalarMultExprTrait</a> class template. For instance, given the non-transpose sparse vector type <em>VT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gad65b87777d3bc07fa373170447fa3abb">More...</a><br /></td></tr>
<tr class="separator:gad65b87777d3bc07fa373170447fa3abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad03db3322d65c5ae9dfac4586ceb6b"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gacad03db3322d65c5ae9dfac4586ceb6b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gacad03db3322d65c5ae9dfac4586ceb6b">SVecSerialExprTrait_</a> = typename <a class="el" href="../../d8/d06/structblaze_1_1SVecSerialExprTrait.html">SVecSerialExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:gacad03db3322d65c5ae9dfac4586ceb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d06/structblaze_1_1SVecSerialExprTrait.html" title="Evaluation of the expression type of a sparse vector serial evaluation operation.Via this type trait ...">SVecSerialExprTrait</a> class template.The SVecSerialExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d06/structblaze_1_1SVecSerialExprTrait.html" title="Evaluation of the expression type of a sparse vector serial evaluation operation.Via this type trait ...">SVecSerialExprTrait</a> class template. For instance, given the non-transpose sparse vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gacad03db3322d65c5ae9dfac4586ceb6b">More...</a><br /></td></tr>
<tr class="separator:gacad03db3322d65c5ae9dfac4586ceb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e307e63bfe9e884d391fa1aeff7d505"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga8e307e63bfe9e884d391fa1aeff7d505"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga8e307e63bfe9e884d391fa1aeff7d505">SVecSVecAddExprTrait_</a> = typename <a class="el" href="../../d3/dd9/structblaze_1_1SVecSVecAddExprTrait.html">SVecSVecAddExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga8e307e63bfe9e884d391fa1aeff7d505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d3/dd9/structblaze_1_1SVecSVecAddExprTrait.html" title="Evaluation of the expression type of a sparse vector/sparse vector addition.Via this type trait it is...">SVecSVecAddExprTrait</a> class template.The SVecSVecAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/dd9/structblaze_1_1SVecSVecAddExprTrait.html" title="Evaluation of the expression type of a sparse vector/sparse vector addition.Via this type trait it is...">SVecSVecAddExprTrait</a> class template. For instance, given the non-transpose sparse vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga8e307e63bfe9e884d391fa1aeff7d505">More...</a><br /></td></tr>
<tr class="separator:ga8e307e63bfe9e884d391fa1aeff7d505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ad0980660d32852ee67a1e8265d76d9"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga5ad0980660d32852ee67a1e8265d76d9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga5ad0980660d32852ee67a1e8265d76d9">SVecSVecCrossExprTrait_</a> = typename <a class="el" href="../../d4/ddd/structblaze_1_1SVecSVecCrossExprTrait.html">SVecSVecCrossExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga5ad0980660d32852ee67a1e8265d76d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/ddd/structblaze_1_1SVecSVecCrossExprTrait.html" title="Evaluation of the expression type of a sparse vector/sparse vector cross product.Via this type trait ...">SVecSVecCrossExprTrait</a> class template.The SVecSVecCrossExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/ddd/structblaze_1_1SVecSVecCrossExprTrait.html" title="Evaluation of the expression type of a sparse vector/sparse vector cross product.Via this type trait ...">SVecSVecCrossExprTrait</a> class template. For instance, given the non-transpose sparse vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga5ad0980660d32852ee67a1e8265d76d9">More...</a><br /></td></tr>
<tr class="separator:ga5ad0980660d32852ee67a1e8265d76d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ed1f80d8bc27e99dd41793399d0e885"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga4ed1f80d8bc27e99dd41793399d0e885"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga4ed1f80d8bc27e99dd41793399d0e885">SVecSVecMultExprTrait_</a> = typename <a class="el" href="../../d1/d94/structblaze_1_1SVecSVecMultExprTrait.html">SVecSVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga4ed1f80d8bc27e99dd41793399d0e885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d94/structblaze_1_1SVecSVecMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse vector multiplication. Given the two non-transpose sparse vector types VT1 and VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 or VT2 is not a non-transpose sparse vector type, the resulting Type is set to INVALID_TYPE. ">SVecSVecMultExprTrait</a> class template.The SVecSVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d94/structblaze_1_1SVecSVecMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse vector multiplication. Given the two non-transpose sparse vector types VT1 and VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 or VT2 is not a non-transpose sparse vector type, the resulting Type is set to INVALID_TYPE. ">SVecSVecMultExprTrait</a> class template. For instance, given the non-transpose sparse vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga4ed1f80d8bc27e99dd41793399d0e885">More...</a><br /></td></tr>
<tr class="separator:ga4ed1f80d8bc27e99dd41793399d0e885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10273b7c6b3835cc7a76cdbb29dad5db"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga10273b7c6b3835cc7a76cdbb29dad5db"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga10273b7c6b3835cc7a76cdbb29dad5db">SVecSVecSubExprTrait_</a> = typename <a class="el" href="../../d2/d3e/structblaze_1_1SVecSVecSubExprTrait.html">SVecSVecSubExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga10273b7c6b3835cc7a76cdbb29dad5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d3e/structblaze_1_1SVecSVecSubExprTrait.html" title="Evaluation of the expression type of a sparse vector/sparse vector subtraction.Via this type trait it...">SVecSVecSubExprTrait</a> class template.The SVecSVecSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d3e/structblaze_1_1SVecSVecSubExprTrait.html" title="Evaluation of the expression type of a sparse vector/sparse vector subtraction.Via this type trait it...">SVecSVecSubExprTrait</a> class template. For instance, given the non-transpose sparse vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga10273b7c6b3835cc7a76cdbb29dad5db">More...</a><br /></td></tr>
<tr class="separator:ga10273b7c6b3835cc7a76cdbb29dad5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b67b3acd20c01aa7c7c0024b1339c32"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga0b67b3acd20c01aa7c7c0024b1339c32"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga0b67b3acd20c01aa7c7c0024b1339c32">SVecTDVecMultExprTrait_</a> = typename <a class="el" href="../../db/dad/structblaze_1_1SVecTDVecMultExprTrait.html">SVecTDVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga0b67b3acd20c01aa7c7c0024b1339c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/dad/structblaze_1_1SVecTDVecMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/transpose dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose dense vector multiplication (outer product). Given the non-transpose sparse vector type VT1 and the transpose dense vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a non-transpose sparse vector type or VT2 is not a transpose dense vector type, the resulting Type is set to INVALID_TYPE. ">SVecTDVecMultExprTrait</a> class template.The SVecTDVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/dad/structblaze_1_1SVecTDVecMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/transpose dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose dense vector multiplication (outer product). Given the non-transpose sparse vector type VT1 and the transpose dense vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a non-transpose sparse vector type or VT2 is not a transpose dense vector type, the resulting Type is set to INVALID_TYPE. ">SVecTDVecMultExprTrait</a> class template. For instance, given the non-transpose sparse vector type <em>VT1</em> and the transpose dense vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga0b67b3acd20c01aa7c7c0024b1339c32">More...</a><br /></td></tr>
<tr class="separator:ga0b67b3acd20c01aa7c7c0024b1339c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93ff66faecb48311d2be4f4a2adabca8"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga93ff66faecb48311d2be4f4a2adabca8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga93ff66faecb48311d2be4f4a2adabca8">SVecTransExprTrait_</a> = typename <a class="el" href="../../dd/d9e/structblaze_1_1SVecTransExprTrait.html">SVecTransExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:ga93ff66faecb48311d2be4f4a2adabca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d9e/structblaze_1_1SVecTransExprTrait.html" title="Evaluation of the expression type of a sparse vector transpose operation.Via this type trait it is po...">SVecTransExprTrait</a> class template.The SVecTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d9e/structblaze_1_1SVecTransExprTrait.html" title="Evaluation of the expression type of a sparse vector transpose operation.Via this type trait it is po...">SVecTransExprTrait</a> class template. For instance, given the non-transpose sparse vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga93ff66faecb48311d2be4f4a2adabca8">More...</a><br /></td></tr>
<tr class="separator:ga93ff66faecb48311d2be4f4a2adabca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470c12abdd743b0a3f56748c12e5512d"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga470c12abdd743b0a3f56748c12e5512d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga470c12abdd743b0a3f56748c12e5512d">SVecTSVecMultExprTrait_</a> = typename <a class="el" href="../../db/d83/structblaze_1_1SVecTSVecMultExprTrait.html">SVecTSVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga470c12abdd743b0a3f56748c12e5512d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/d83/structblaze_1_1SVecTSVecMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/transpose sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose sparse vector multiplication (outer product). Given the non-transpose sparse vector type VT1 and the transpose sparse vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a non-transpose sparse vector type or VT2 is not a transpose sparse vector type, the resulting Type is set to INVALID_TYPE. ">SVecTSVecMultExprTrait</a> class template.The SVecTSVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/d83/structblaze_1_1SVecTSVecMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/transpose sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose sparse vector multiplication (outer product). Given the non-transpose sparse vector type VT1 and the transpose sparse vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a non-transpose sparse vector type or VT2 is not a transpose sparse vector type, the resulting Type is set to INVALID_TYPE. ">SVecTSVecMultExprTrait</a> class template. For instance, given the non-transpose sparse vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga470c12abdd743b0a3f56748c12e5512d">More...</a><br /></td></tr>
<tr class="separator:ga470c12abdd743b0a3f56748c12e5512d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd759c7d6962a19297734d9cb786f5ea"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gafd759c7d6962a19297734d9cb786f5ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gafd759c7d6962a19297734d9cb786f5ea">TDMatCTransExprTrait_</a> = typename <a class="el" href="../../d2/df2/structblaze_1_1TDMatCTransExprTrait.html">TDMatCTransExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gafd759c7d6962a19297734d9cb786f5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/df2/structblaze_1_1TDMatCTransExprTrait.html" title="Evaluation of the expression type of a dense matrix conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix conjugate transpose operation. Given the column-major dense matrix type MT, the nested type Type corresponds to the resulting expression type. In case MT is not a column-major dense matrix type, the resulting Type is set to INVALID_TYPE. ">TDMatCTransExprTrait</a> class template.The TDMatCTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/df2/structblaze_1_1TDMatCTransExprTrait.html" title="Evaluation of the expression type of a dense matrix conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix conjugate transpose operation. Given the column-major dense matrix type MT, the nested type Type corresponds to the resulting expression type. In case MT is not a column-major dense matrix type, the resulting Type is set to INVALID_TYPE. ">TDMatCTransExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gafd759c7d6962a19297734d9cb786f5ea">More...</a><br /></td></tr>
<tr class="separator:gafd759c7d6962a19297734d9cb786f5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f535e4806e16ace63f91b6d44a474be"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga2f535e4806e16ace63f91b6d44a474be"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga2f535e4806e16ace63f91b6d44a474be">TDMatDeclDiagExprTrait_</a> = typename <a class="el" href="../../df/dda/structblaze_1_1TDMatDeclDiagExprTrait.html">TDMatDeclDiagExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga2f535e4806e16ace63f91b6d44a474be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/dda/structblaze_1_1TDMatDeclDiagExprTrait.html" title="Evaluation of the expression type of a dense matrix decldiag operation.Via this type trait it is poss...">TDMatDeclDiagExprTrait</a> class template.The TDMatDeclDiagExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/dda/structblaze_1_1TDMatDeclDiagExprTrait.html" title="Evaluation of the expression type of a dense matrix decldiag operation.Via this type trait it is poss...">TDMatDeclDiagExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga2f535e4806e16ace63f91b6d44a474be">More...</a><br /></td></tr>
<tr class="separator:ga2f535e4806e16ace63f91b6d44a474be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d0fded6e919100532003055288b96a2"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga0d0fded6e919100532003055288b96a2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga0d0fded6e919100532003055288b96a2">TDMatDeclHermExprTrait_</a> = typename <a class="el" href="../../dc/d3b/structblaze_1_1TDMatDeclHermExprTrait.html">TDMatDeclHermExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga0d0fded6e919100532003055288b96a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d3b/structblaze_1_1TDMatDeclHermExprTrait.html" title="Evaluation of the expression type of a dense matrix declherm operation.Via this type trait it is poss...">TDMatDeclHermExprTrait</a> class template.The TDMatDeclHermExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/d3b/structblaze_1_1TDMatDeclHermExprTrait.html" title="Evaluation of the expression type of a dense matrix declherm operation.Via this type trait it is poss...">TDMatDeclHermExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga0d0fded6e919100532003055288b96a2">More...</a><br /></td></tr>
<tr class="separator:ga0d0fded6e919100532003055288b96a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae10bf6bf87e58c64e5b4120a319edc4"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaae10bf6bf87e58c64e5b4120a319edc4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaae10bf6bf87e58c64e5b4120a319edc4">TDMatDeclLowExprTrait_</a> = typename <a class="el" href="../../d8/d3d/structblaze_1_1TDMatDeclLowExprTrait.html">TDMatDeclLowExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gaae10bf6bf87e58c64e5b4120a319edc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d3d/structblaze_1_1TDMatDeclLowExprTrait.html" title="Evaluation of the expression type of a dense matrix decllow operation.Via this type trait it is possi...">TDMatDeclLowExprTrait</a> class template.The TDMatDeclLowExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d3d/structblaze_1_1TDMatDeclLowExprTrait.html" title="Evaluation of the expression type of a dense matrix decllow operation.Via this type trait it is possi...">TDMatDeclLowExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaae10bf6bf87e58c64e5b4120a319edc4">More...</a><br /></td></tr>
<tr class="separator:gaae10bf6bf87e58c64e5b4120a319edc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef30934265e476a219089556fe2cc467"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaef30934265e476a219089556fe2cc467"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaef30934265e476a219089556fe2cc467">TDMatDeclSymExprTrait_</a> = typename <a class="el" href="../../d6/dbf/structblaze_1_1TDMatDeclSymExprTrait.html">TDMatDeclSymExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gaef30934265e476a219089556fe2cc467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d6/dbf/structblaze_1_1TDMatDeclSymExprTrait.html" title="Evaluation of the expression type of a dense matrix declsym operation.Via this type trait it is possi...">TDMatDeclSymExprTrait</a> class template.The TDMatDeclSymExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/dbf/structblaze_1_1TDMatDeclSymExprTrait.html" title="Evaluation of the expression type of a dense matrix declsym operation.Via this type trait it is possi...">TDMatDeclSymExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaef30934265e476a219089556fe2cc467">More...</a><br /></td></tr>
<tr class="separator:gaef30934265e476a219089556fe2cc467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5623d14bd25a228af18826803a9e9d5d"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga5623d14bd25a228af18826803a9e9d5d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga5623d14bd25a228af18826803a9e9d5d">TDMatDeclUppExprTrait_</a> = typename <a class="el" href="../../d2/d16/structblaze_1_1TDMatDeclUppExprTrait.html">TDMatDeclUppExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga5623d14bd25a228af18826803a9e9d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d16/structblaze_1_1TDMatDeclUppExprTrait.html" title="Evaluation of the expression type of a dense matrix declupp operation.Via this type trait it is possi...">TDMatDeclUppExprTrait</a> class template.The TDMatDeclUppExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d16/structblaze_1_1TDMatDeclUppExprTrait.html" title="Evaluation of the expression type of a dense matrix declupp operation.Via this type trait it is possi...">TDMatDeclUppExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga5623d14bd25a228af18826803a9e9d5d">More...</a><br /></td></tr>
<tr class="separator:ga5623d14bd25a228af18826803a9e9d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7967b9abf9c726949d835c1dbaaa8818"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga7967b9abf9c726949d835c1dbaaa8818"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga7967b9abf9c726949d835c1dbaaa8818">TDMatDMatAddExprTrait_</a> = typename <a class="el" href="../../d3/d24/structblaze_1_1TDMatDMatAddExprTrait.html">TDMatDMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga7967b9abf9c726949d835c1dbaaa8818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d3/d24/structblaze_1_1TDMatDMatAddExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense matrix addition. Given the column-major dense matrix type MT1 and the row-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major dense matrix type or MT2 is not a row-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDMatDMatAddExprTrait</a> class template.The TDMatDMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/d24/structblaze_1_1TDMatDMatAddExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense matrix addition. Given the column-major dense matrix type MT1 and the row-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major dense matrix type or MT2 is not a row-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDMatDMatAddExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga7967b9abf9c726949d835c1dbaaa8818">More...</a><br /></td></tr>
<tr class="separator:ga7967b9abf9c726949d835c1dbaaa8818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6791f267ec38faded5ad31194f01412"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaf6791f267ec38faded5ad31194f01412"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaf6791f267ec38faded5ad31194f01412">TDMatDMatMultExprTrait_</a> = typename <a class="el" href="../../dd/d09/structblaze_1_1TDMatDMatMultExprTrait.html">TDMatDMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gaf6791f267ec38faded5ad31194f01412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d09/structblaze_1_1TDMatDMatMultExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense matrix multiplication. Given the column-major dense matrix type MT1 and the row-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major dense matrix type or MT2 is not a row-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDMatDMatMultExprTrait</a> class template.The TDMatDMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d09/structblaze_1_1TDMatDMatMultExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense matrix multiplication. Given the column-major dense matrix type MT1 and the row-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major dense matrix type or MT2 is not a row-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDMatDMatMultExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaf6791f267ec38faded5ad31194f01412">More...</a><br /></td></tr>
<tr class="separator:gaf6791f267ec38faded5ad31194f01412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34270e550e66762f65b24adabe1342c6"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga34270e550e66762f65b24adabe1342c6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga34270e550e66762f65b24adabe1342c6">TDMatDMatSubExprTrait_</a> = typename <a class="el" href="../../d0/d15/structblaze_1_1TDMatDMatSubExprTrait.html">TDMatDMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga34270e550e66762f65b24adabe1342c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/d15/structblaze_1_1TDMatDMatSubExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense matrix subtraction. Given the column-major dense matrix type MT1 and the row-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major dense matrix type or MT2 is not a row-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDMatDMatSubExprTrait</a> class template.The TDMatDMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/d15/structblaze_1_1TDMatDMatSubExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense matrix subtraction. Given the column-major dense matrix type MT1 and the row-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major dense matrix type or MT2 is not a row-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDMatDMatSubExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga34270e550e66762f65b24adabe1342c6">More...</a><br /></td></tr>
<tr class="separator:ga34270e550e66762f65b24adabe1342c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3eff453f8e304106eb915c6ea9f9824"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:gaa3eff453f8e304106eb915c6ea9f9824"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaa3eff453f8e304106eb915c6ea9f9824">TDMatDVecMultExprTrait_</a> = typename <a class="el" href="../../de/d6f/structblaze_1_1TDMatDVecMultExprTrait.html">TDMatDVecMultExprTrait</a>&lt; MT, VT &gt;::Type</td></tr>
<tr class="memdesc:gaa3eff453f8e304106eb915c6ea9f9824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d6f/structblaze_1_1TDMatDVecMultExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense vector multiplication. Given the column-major dense matrix type MT and the non-transpose dense vector type VT, the nested type Type corresponds to the resulting expression type. In case either MT is not a column-major dense matrix type or VT is not a non-transpose dense vector type, the resulting data type Type is set to INVALID_TYPE. ">TDMatDVecMultExprTrait</a> class template.The TDMatDVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d6f/structblaze_1_1TDMatDVecMultExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense vector multiplication. Given the column-major dense matrix type MT and the non-transpose dense vector type VT, the nested type Type corresponds to the resulting expression type. In case either MT is not a column-major dense matrix type or VT is not a non-transpose dense vector type, the resulting data type Type is set to INVALID_TYPE. ">TDMatDVecMultExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> and the non-transpose dense vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaa3eff453f8e304106eb915c6ea9f9824">More...</a><br /></td></tr>
<tr class="separator:gaa3eff453f8e304106eb915c6ea9f9824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga436ce70e4d5fcae402bf6226baaf8cd4"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga436ce70e4d5fcae402bf6226baaf8cd4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga436ce70e4d5fcae402bf6226baaf8cd4">TDMatEvalExprTrait_</a> = typename <a class="el" href="../../db/d34/structblaze_1_1TDMatEvalExprTrait.html">TDMatEvalExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga436ce70e4d5fcae402bf6226baaf8cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/d34/structblaze_1_1TDMatEvalExprTrait.html" title="Evaluation of the expression type of a dense matrix evaluation operation.Via this type trait it is po...">TDMatEvalExprTrait</a> class template.The TDMatEvalExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/d34/structblaze_1_1TDMatEvalExprTrait.html" title="Evaluation of the expression type of a dense matrix evaluation operation.Via this type trait it is po...">TDMatEvalExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga436ce70e4d5fcae402bf6226baaf8cd4">More...</a><br /></td></tr>
<tr class="separator:ga436ce70e4d5fcae402bf6226baaf8cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1de202d2fc1278da3baeb05a1b490967"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename OP &gt; </td></tr>
<tr class="memitem:ga1de202d2fc1278da3baeb05a1b490967"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga1de202d2fc1278da3baeb05a1b490967">TDMatForEachExprTrait_</a> = typename <a class="el" href="../../db/d2c/structblaze_1_1TDMatForEachExprTrait.html">TDMatForEachExprTrait</a>&lt; MT, OP &gt;::Type</td></tr>
<tr class="memdesc:ga1de202d2fc1278da3baeb05a1b490967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/d2c/structblaze_1_1TDMatForEachExprTrait.html" title="Evaluation of the expression type of a dense matrix custom operation.Via this type trait it is possib...">TDMatForEachExprTrait</a> class template.The TDMatForEachExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/d2c/structblaze_1_1TDMatForEachExprTrait.html" title="Evaluation of the expression type of a dense matrix custom operation.Via this type trait it is possib...">TDMatForEachExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> and the custom operation type <em>OP</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga1de202d2fc1278da3baeb05a1b490967">More...</a><br /></td></tr>
<tr class="separator:ga1de202d2fc1278da3baeb05a1b490967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38d974159e86cd43a43353980d56420d"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga38d974159e86cd43a43353980d56420d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga38d974159e86cd43a43353980d56420d">TDMatInvExprTrait_</a> = typename <a class="el" href="../../dd/dec/structblaze_1_1TDMatInvExprTrait.html">TDMatInvExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga38d974159e86cd43a43353980d56420d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/dec/structblaze_1_1TDMatInvExprTrait.html" title="Evaluation of the expression type of a dense matrix inversion operation.Via this type trait it is pos...">TDMatInvExprTrait</a> class template.The TDMatInvExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/dec/structblaze_1_1TDMatInvExprTrait.html" title="Evaluation of the expression type of a dense matrix inversion operation.Via this type trait it is pos...">TDMatInvExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga38d974159e86cd43a43353980d56420d">More...</a><br /></td></tr>
<tr class="separator:ga38d974159e86cd43a43353980d56420d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf50f728f2942427f3354d0e9cb8d17ce"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename ST &gt; </td></tr>
<tr class="memitem:gaf50f728f2942427f3354d0e9cb8d17ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaf50f728f2942427f3354d0e9cb8d17ce">TDMatScalarDivExprTrait_</a> = typename <a class="el" href="../../d8/da0/structblaze_1_1TDMatScalarDivExprTrait.html">TDMatScalarDivExprTrait</a>&lt; MT, ST &gt;::Type</td></tr>
<tr class="memdesc:gaf50f728f2942427f3354d0e9cb8d17ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/da0/structblaze_1_1TDMatScalarDivExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/scalar division.Via this type trait it ...">TDMatScalarDivExprTrait</a> class template.The TDMatScalarDivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/da0/structblaze_1_1TDMatScalarDivExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/scalar division.Via this type trait it ...">TDMatScalarDivExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaf50f728f2942427f3354d0e9cb8d17ce">More...</a><br /></td></tr>
<tr class="separator:gaf50f728f2942427f3354d0e9cb8d17ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8f939cbe403ed1365ebd417a965ddbe"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename ST &gt; </td></tr>
<tr class="memitem:gaf8f939cbe403ed1365ebd417a965ddbe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaf8f939cbe403ed1365ebd417a965ddbe">TDMatScalarMultExprTrait_</a> = typename <a class="el" href="../../da/d61/structblaze_1_1TDMatScalarMultExprTrait.html">TDMatScalarMultExprTrait</a>&lt; MT, ST &gt;::Type</td></tr>
<tr class="memdesc:gaf8f939cbe403ed1365ebd417a965ddbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/d61/structblaze_1_1TDMatScalarMultExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/scalar multiplication. Given the column-major dense matrix type MT and the scalar type ST, the nested type Type corresponds to the resulting expression type. In case either MT is not a column-major dense matrix type or ST is not a scalar type, the resulting Type is set to INVALID_TYPE. ">TDMatScalarMultExprTrait</a> class template.The TDMatScalarMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/d61/structblaze_1_1TDMatScalarMultExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/scalar multiplication. Given the column-major dense matrix type MT and the scalar type ST, the nested type Type corresponds to the resulting expression type. In case either MT is not a column-major dense matrix type or ST is not a scalar type, the resulting Type is set to INVALID_TYPE. ">TDMatScalarMultExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaf8f939cbe403ed1365ebd417a965ddbe">More...</a><br /></td></tr>
<tr class="separator:gaf8f939cbe403ed1365ebd417a965ddbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a018cec9247b605b525d241578e5f37"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga6a018cec9247b605b525d241578e5f37"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga6a018cec9247b605b525d241578e5f37">TDMatSerialExprTrait_</a> = typename <a class="el" href="../../d6/da0/structblaze_1_1TDMatSerialExprTrait.html">TDMatSerialExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga6a018cec9247b605b525d241578e5f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d6/da0/structblaze_1_1TDMatSerialExprTrait.html" title="Evaluation of the expression type of a dense matrix serial evaluation operation.Via this type trait i...">TDMatSerialExprTrait</a> class template.The TDMatSerialExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/da0/structblaze_1_1TDMatSerialExprTrait.html" title="Evaluation of the expression type of a dense matrix serial evaluation operation.Via this type trait i...">TDMatSerialExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga6a018cec9247b605b525d241578e5f37">More...</a><br /></td></tr>
<tr class="separator:ga6a018cec9247b605b525d241578e5f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd25dcd5d04b6fa0e9d39ac2864cbdd1"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gacd25dcd5d04b6fa0e9d39ac2864cbdd1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gacd25dcd5d04b6fa0e9d39ac2864cbdd1">TDMatSMatAddExprTrait_</a> = typename <a class="el" href="../../d0/d21/structblaze_1_1TDMatSMatAddExprTrait.html">TDMatSMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gacd25dcd5d04b6fa0e9d39ac2864cbdd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/d21/structblaze_1_1TDMatSMatAddExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse matrix addition. Given the column-major dense matrix type MT1 and the row-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major dense matrix type or MT2 is not a row-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDMatSMatAddExprTrait</a> class template.The TDMatSMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/d21/structblaze_1_1TDMatSMatAddExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse matrix addition. Given the column-major dense matrix type MT1 and the row-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major dense matrix type or MT2 is not a row-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDMatSMatAddExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gacd25dcd5d04b6fa0e9d39ac2864cbdd1">More...</a><br /></td></tr>
<tr class="separator:gacd25dcd5d04b6fa0e9d39ac2864cbdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e777ca3760e4b578471351ebdf5c592"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga3e777ca3760e4b578471351ebdf5c592"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga3e777ca3760e4b578471351ebdf5c592">TDMatSMatMultExprTrait_</a> = typename <a class="el" href="../../d7/d89/structblaze_1_1TDMatSMatMultExprTrait.html">TDMatSMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga3e777ca3760e4b578471351ebdf5c592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d89/structblaze_1_1TDMatSMatMultExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse matrix multiplication. Given the column-major dense matrix type MT1 and the row-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major dense matrix type or MT2 is not a row-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDMatSMatMultExprTrait</a> class template.The TDMatSMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d89/structblaze_1_1TDMatSMatMultExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse matrix multiplication. Given the column-major dense matrix type MT1 and the row-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major dense matrix type or MT2 is not a row-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDMatSMatMultExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga3e777ca3760e4b578471351ebdf5c592">More...</a><br /></td></tr>
<tr class="separator:ga3e777ca3760e4b578471351ebdf5c592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga201e7f9b2bf27056628c736b52cb20b9"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga201e7f9b2bf27056628c736b52cb20b9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga201e7f9b2bf27056628c736b52cb20b9">TDMatSMatSubExprTrait_</a> = typename <a class="el" href="../../dd/d90/structblaze_1_1TDMatSMatSubExprTrait.html">TDMatSMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga201e7f9b2bf27056628c736b52cb20b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d90/structblaze_1_1TDMatSMatSubExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse matrix subtraction. Given the column-major dense matrix type MT1 and the row-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major dense matrix type or MT2 is not a row-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDMatSMatSubExprTrait</a> class template.The TDMatSMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d90/structblaze_1_1TDMatSMatSubExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse matrix subtraction. Given the column-major dense matrix type MT1 and the row-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major dense matrix type or MT2 is not a row-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDMatSMatSubExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga201e7f9b2bf27056628c736b52cb20b9">More...</a><br /></td></tr>
<tr class="separator:ga201e7f9b2bf27056628c736b52cb20b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a4b72f04c172c916103bcf037384c10"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:ga1a4b72f04c172c916103bcf037384c10"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga1a4b72f04c172c916103bcf037384c10">TDMatSVecMultExprTrait_</a> = typename <a class="el" href="../../db/dee/structblaze_1_1TDMatSVecMultExprTrait.html">TDMatSVecMultExprTrait</a>&lt; MT, VT &gt;::Type</td></tr>
<tr class="memdesc:ga1a4b72f04c172c916103bcf037384c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/dee/structblaze_1_1TDMatSVecMultExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse vector multiplication. Given the column-major dense matrix type MT and the non-transpose sparse vector type VT, the nested type Type corresponds to the resulting expression type. In case either MT is not a column-major dense matrix type or VT is not a non-transpose sparse vector type, the resulting data type Type is set to INVALID_TYPE. ">TDMatSVecMultExprTrait</a> class template.The TDMatSVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/dee/structblaze_1_1TDMatSVecMultExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse vector multiplication. Given the column-major dense matrix type MT and the non-transpose sparse vector type VT, the nested type Type corresponds to the resulting expression type. In case either MT is not a column-major dense matrix type or VT is not a non-transpose sparse vector type, the resulting data type Type is set to INVALID_TYPE. ">TDMatSVecMultExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> and the non-transpose sparse vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga1a4b72f04c172c916103bcf037384c10">More...</a><br /></td></tr>
<tr class="separator:ga1a4b72f04c172c916103bcf037384c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9da1c3e32063a6c0e19f13a92b2590"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga9f9da1c3e32063a6c0e19f13a92b2590"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga9f9da1c3e32063a6c0e19f13a92b2590">TDMatTDMatAddExprTrait_</a> = typename <a class="el" href="../../dd/d14/structblaze_1_1TDMatTDMatAddExprTrait.html">TDMatTDMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga9f9da1c3e32063a6c0e19f13a92b2590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d14/structblaze_1_1TDMatTDMatAddExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/transpose dense matrix addition...">TDMatTDMatAddExprTrait</a> class template.The TDMatTDMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d14/structblaze_1_1TDMatTDMatAddExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/transpose dense matrix addition...">TDMatTDMatAddExprTrait</a> class template. For instance, given the column-major dense matrix types <em>MT1</em> and <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga9f9da1c3e32063a6c0e19f13a92b2590">More...</a><br /></td></tr>
<tr class="separator:ga9f9da1c3e32063a6c0e19f13a92b2590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd8359fd902d3a53e6d526fb02fc502a"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gabd8359fd902d3a53e6d526fb02fc502a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gabd8359fd902d3a53e6d526fb02fc502a">TDMatTDMatMultExprTrait_</a> = typename <a class="el" href="../../d4/ded/structblaze_1_1TDMatTDMatMultExprTrait.html">TDMatTDMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gabd8359fd902d3a53e6d526fb02fc502a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/ded/structblaze_1_1TDMatTDMatMultExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/transpose dense matrix multiplication...">TDMatTDMatMultExprTrait</a> class template.The TDMatTDMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/ded/structblaze_1_1TDMatTDMatMultExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/transpose dense matrix multiplication...">TDMatTDMatMultExprTrait</a> class template. For instance, given the column-major dense matrix types <em>MT1</em> and <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gabd8359fd902d3a53e6d526fb02fc502a">More...</a><br /></td></tr>
<tr class="separator:gabd8359fd902d3a53e6d526fb02fc502a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba0db363067ed2ceba0c92ca91cf5d41"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaba0db363067ed2ceba0c92ca91cf5d41"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaba0db363067ed2ceba0c92ca91cf5d41">TDMatTDMatSubExprTrait_</a> = typename <a class="el" href="../../d8/dfa/structblaze_1_1TDMatTDMatSubExprTrait.html">TDMatTDMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gaba0db363067ed2ceba0c92ca91cf5d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/dfa/structblaze_1_1TDMatTDMatSubExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/transpose dense matrix subtraction...">TDMatTDMatSubExprTrait</a> class template.The TDMatTDMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/dfa/structblaze_1_1TDMatTDMatSubExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/transpose dense matrix subtraction...">TDMatTDMatSubExprTrait</a> class template. For instance, given the column-major dense matrix types <em>MT1</em> and <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaba0db363067ed2ceba0c92ca91cf5d41">More...</a><br /></td></tr>
<tr class="separator:gaba0db363067ed2ceba0c92ca91cf5d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a0a2ceffd4b885ec189602c8e232bf"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gad2a0a2ceffd4b885ec189602c8e232bf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gad2a0a2ceffd4b885ec189602c8e232bf">TDMatTransExprTrait_</a> = typename <a class="el" href="../../db/df1/structblaze_1_1TDMatTransExprTrait.html">TDMatTransExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gad2a0a2ceffd4b885ec189602c8e232bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/df1/structblaze_1_1TDMatTransExprTrait.html" title="Evaluation of the expression type of a dense matrix transpose operation.Via this type trait it is pos...">TDMatTransExprTrait</a> class template.The TDMatTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/df1/structblaze_1_1TDMatTransExprTrait.html" title="Evaluation of the expression type of a dense matrix transpose operation.Via this type trait it is pos...">TDMatTransExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gad2a0a2ceffd4b885ec189602c8e232bf">More...</a><br /></td></tr>
<tr class="separator:gad2a0a2ceffd4b885ec189602c8e232bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cda405ec6700bc9e174dcb6b7c4dc1e"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga7cda405ec6700bc9e174dcb6b7c4dc1e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga7cda405ec6700bc9e174dcb6b7c4dc1e">TDMatTSMatAddExprTrait_</a> = typename <a class="el" href="../../df/da3/structblaze_1_1TDMatTSMatAddExprTrait.html">TDMatTSMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga7cda405ec6700bc9e174dcb6b7c4dc1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/da3/structblaze_1_1TDMatTSMatAddExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/transpose sparse matrix addition...">TDMatTSMatAddExprTrait</a> class template.The TDMatTSMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/da3/structblaze_1_1TDMatTSMatAddExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/transpose sparse matrix addition...">TDMatTSMatAddExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga7cda405ec6700bc9e174dcb6b7c4dc1e">More...</a><br /></td></tr>
<tr class="separator:ga7cda405ec6700bc9e174dcb6b7c4dc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab65e5b5af715332506548e01be81693f"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gab65e5b5af715332506548e01be81693f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gab65e5b5af715332506548e01be81693f">TDMatTSMatMultExprTrait_</a> = typename <a class="el" href="../../d0/dc5/structblaze_1_1TDMatTSMatMultExprTrait.html">TDMatTSMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gab65e5b5af715332506548e01be81693f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/dc5/structblaze_1_1TDMatTSMatMultExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/transpose sparse matrix multiplication...">TDMatTSMatMultExprTrait</a> class template.The TDMatTSMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/dc5/structblaze_1_1TDMatTSMatMultExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/transpose sparse matrix multiplication...">TDMatTSMatMultExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gab65e5b5af715332506548e01be81693f">More...</a><br /></td></tr>
<tr class="separator:gab65e5b5af715332506548e01be81693f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac16e6015d943d41a7f18e633f6d6e2a5"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gac16e6015d943d41a7f18e633f6d6e2a5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gac16e6015d943d41a7f18e633f6d6e2a5">TDMatTSMatSubExprTrait_</a> = typename <a class="el" href="../../dd/d8b/structblaze_1_1TDMatTSMatSubExprTrait.html">TDMatTSMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gac16e6015d943d41a7f18e633f6d6e2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d8b/structblaze_1_1TDMatTSMatSubExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/transpose sparse matrix subtraction...">TDMatTSMatSubExprTrait</a> class template.The TDMatTSMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d8b/structblaze_1_1TDMatTSMatSubExprTrait.html" title="Evaluation of the expression type of a transpose dense matrix/transpose sparse matrix subtraction...">TDMatTSMatSubExprTrait</a> class template. For instance, given the column-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gac16e6015d943d41a7f18e633f6d6e2a5">More...</a><br /></td></tr>
<tr class="separator:gac16e6015d943d41a7f18e633f6d6e2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29cb08ed6f3b8dea600daa7e2e1d49b9"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga29cb08ed6f3b8dea600daa7e2e1d49b9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga29cb08ed6f3b8dea600daa7e2e1d49b9">TDVecCTransExprTrait_</a> = typename <a class="el" href="../../d2/d3b/structblaze_1_1TDVecCTransExprTrait.html">TDVecCTransExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:ga29cb08ed6f3b8dea600daa7e2e1d49b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d3b/structblaze_1_1TDVecCTransExprTrait.html" title="Evaluation of the expression type of a dense vector conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector conjugate transpose operation. Given the transpose dense vector type VT, the nested type Type corresponds to the resulting expression type. In case VT is not a transpose dense vector type, the resulting Type is set to INVALID_TYPE. ">TDVecCTransExprTrait</a> class template.The TDVecCTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d3b/structblaze_1_1TDVecCTransExprTrait.html" title="Evaluation of the expression type of a dense vector conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector conjugate transpose operation. Given the transpose dense vector type VT, the nested type Type corresponds to the resulting expression type. In case VT is not a transpose dense vector type, the resulting Type is set to INVALID_TYPE. ">TDVecCTransExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga29cb08ed6f3b8dea600daa7e2e1d49b9">More...</a><br /></td></tr>
<tr class="separator:ga29cb08ed6f3b8dea600daa7e2e1d49b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53697018c300e5f64b48e0fb0fe97a5b"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:ga53697018c300e5f64b48e0fb0fe97a5b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga53697018c300e5f64b48e0fb0fe97a5b">TDVecDMatMultExprTrait_</a> = typename <a class="el" href="../../dc/d4b/structblaze_1_1TDVecDMatMultExprTrait.html">TDVecDMatMultExprTrait</a>&lt; VT, MT &gt;::Type</td></tr>
<tr class="memdesc:ga53697018c300e5f64b48e0fb0fe97a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d4b/structblaze_1_1TDVecDMatMultExprTrait.html" title="Evaluation of the expression type of a dense vector/dense matrix multiplication.Via this type trait i...">TDVecDMatMultExprTrait</a> class template.The TDVecDMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/d4b/structblaze_1_1TDVecDMatMultExprTrait.html" title="Evaluation of the expression type of a dense vector/dense matrix multiplication.Via this type trait i...">TDVecDMatMultExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT</em> and the row-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga53697018c300e5f64b48e0fb0fe97a5b">More...</a><br /></td></tr>
<tr class="separator:ga53697018c300e5f64b48e0fb0fe97a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f7959df85fc6527834265d579f5f31"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gac2f7959df85fc6527834265d579f5f31"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gac2f7959df85fc6527834265d579f5f31">TDVecDVecMultExprTrait_</a> = typename <a class="el" href="../../d2/d5e/structblaze_1_1TDVecDVecMultExprTrait.html">TDVecDVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:gac2f7959df85fc6527834265d579f5f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d5e/structblaze_1_1TDVecDVecMultExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/dense vector multiplication (inner product). Given the transpose dense vector type VT1 and the non-transpose dense vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a transpose dense vector type or VT2 is not a non-transpose dense vector type, the resulting Type is set to INVALID_TYPE. ">TDVecDVecMultExprTrait</a> class template.The TDVecDVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d5e/structblaze_1_1TDVecDVecMultExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/dense vector multiplication (inner product). Given the transpose dense vector type VT1 and the non-transpose dense vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a transpose dense vector type or VT2 is not a non-transpose dense vector type, the resulting Type is set to INVALID_TYPE. ">TDVecDVecMultExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT1</em> and non-transpose dense vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gac2f7959df85fc6527834265d579f5f31">More...</a><br /></td></tr>
<tr class="separator:gac2f7959df85fc6527834265d579f5f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadb30ba38b538fdb85e714835c3350c6"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gaadb30ba38b538fdb85e714835c3350c6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaadb30ba38b538fdb85e714835c3350c6">TDVecEvalExprTrait_</a> = typename <a class="el" href="../../d0/dc3/structblaze_1_1TDVecEvalExprTrait.html">TDVecEvalExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:gaadb30ba38b538fdb85e714835c3350c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/dc3/structblaze_1_1TDVecEvalExprTrait.html" title="Evaluation of the expression type of a dense vector evaluation operation.Via this type trait it is po...">TDVecEvalExprTrait</a> class template.The TDVecEvalExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/dc3/structblaze_1_1TDVecEvalExprTrait.html" title="Evaluation of the expression type of a dense vector evaluation operation.Via this type trait it is po...">TDVecEvalExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaadb30ba38b538fdb85e714835c3350c6">More...</a><br /></td></tr>
<tr class="separator:gaadb30ba38b538fdb85e714835c3350c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac7f26074e9049c2d15ed76874253722"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename OP &gt; </td></tr>
<tr class="memitem:gaac7f26074e9049c2d15ed76874253722"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaac7f26074e9049c2d15ed76874253722">TDVecForEachExprTrait_</a> = typename <a class="el" href="../../d0/dfb/structblaze_1_1TDVecForEachExprTrait.html">TDVecForEachExprTrait</a>&lt; VT, OP &gt;::Type</td></tr>
<tr class="memdesc:gaac7f26074e9049c2d15ed76874253722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/dfb/structblaze_1_1TDVecForEachExprTrait.html" title="Evaluation of the expression type of a dense vector custom operation.Via this type trait it is possib...">TDVecForEachExprTrait</a> class template.The TDVecForEachExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/dfb/structblaze_1_1TDVecForEachExprTrait.html" title="Evaluation of the expression type of a dense vector custom operation.Via this type trait it is possib...">TDVecForEachExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT</em> and the custom operation type <em>OP</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaac7f26074e9049c2d15ed76874253722">More...</a><br /></td></tr>
<tr class="separator:gaac7f26074e9049c2d15ed76874253722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7d9b751fc03b37de4b85a5c3580b3d6"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ST &gt; </td></tr>
<tr class="memitem:gae7d9b751fc03b37de4b85a5c3580b3d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gae7d9b751fc03b37de4b85a5c3580b3d6">TDVecScalarDivExprTrait_</a> = typename <a class="el" href="../../d3/d59/structblaze_1_1TDVecScalarDivExprTrait.html">TDVecScalarDivExprTrait</a>&lt; VT, ST &gt;::Type</td></tr>
<tr class="memdesc:gae7d9b751fc03b37de4b85a5c3580b3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d3/d59/structblaze_1_1TDVecScalarDivExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/scalar division.Via this type trait it ...">TDVecScalarDivExprTrait</a> class template.The TDVecScalarDivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/d59/structblaze_1_1TDVecScalarDivExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/scalar division.Via this type trait it ...">TDVecScalarDivExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gae7d9b751fc03b37de4b85a5c3580b3d6">More...</a><br /></td></tr>
<tr class="separator:gae7d9b751fc03b37de4b85a5c3580b3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa3d6d7f1dd3af236967642e5354f74e"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ST &gt; </td></tr>
<tr class="memitem:gafa3d6d7f1dd3af236967642e5354f74e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gafa3d6d7f1dd3af236967642e5354f74e">TDVecScalarMultExprTrait_</a> = typename <a class="el" href="../../d0/d39/structblaze_1_1TDVecScalarMultExprTrait.html">TDVecScalarMultExprTrait</a>&lt; VT, ST &gt;::Type</td></tr>
<tr class="memdesc:gafa3d6d7f1dd3af236967642e5354f74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/d39/structblaze_1_1TDVecScalarMultExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/scalar multiplication. Given the transpose dense vector type VT and the scalar type ST, the nested type Type corresponds to the resulting expression type. In case either VT is not a transpose dense vector type or ST is not a scalar type, the resulting Type is set to INVALID_TYPE. ">TDVecScalarMultExprTrait</a> class template.The TDVecScalarMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/d39/structblaze_1_1TDVecScalarMultExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/scalar multiplication. Given the transpose dense vector type VT and the scalar type ST, the nested type Type corresponds to the resulting expression type. In case either VT is not a transpose dense vector type or ST is not a scalar type, the resulting Type is set to INVALID_TYPE. ">TDVecScalarMultExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gafa3d6d7f1dd3af236967642e5354f74e">More...</a><br /></td></tr>
<tr class="separator:gafa3d6d7f1dd3af236967642e5354f74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10b32de1bfa9c9a034102d7596994cdd"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga10b32de1bfa9c9a034102d7596994cdd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga10b32de1bfa9c9a034102d7596994cdd">TDVecSerialExprTrait_</a> = typename <a class="el" href="../../d1/d35/structblaze_1_1TDVecSerialExprTrait.html">TDVecSerialExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:ga10b32de1bfa9c9a034102d7596994cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d35/structblaze_1_1TDVecSerialExprTrait.html" title="Evaluation of the expression type of a dense vector serial evaluation operation.Via this type trait i...">TDVecSerialExprTrait</a> class template.The TDVecSerialExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d35/structblaze_1_1TDVecSerialExprTrait.html" title="Evaluation of the expression type of a dense vector serial evaluation operation.Via this type trait i...">TDVecSerialExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga10b32de1bfa9c9a034102d7596994cdd">More...</a><br /></td></tr>
<tr class="separator:ga10b32de1bfa9c9a034102d7596994cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fa3fbf61e08bed4ef480a674cebc063"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:ga8fa3fbf61e08bed4ef480a674cebc063"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga8fa3fbf61e08bed4ef480a674cebc063">TDVecSMatMultExprTrait_</a> = typename <a class="el" href="../../dd/d02/structblaze_1_1TDVecSMatMultExprTrait.html">TDVecSMatMultExprTrait</a>&lt; VT, MT &gt;::Type</td></tr>
<tr class="memdesc:ga8fa3fbf61e08bed4ef480a674cebc063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d02/structblaze_1_1TDVecSMatMultExprTrait.html" title="Evaluation of the expression type of a dense vector/sparse matrix multiplication.Via this type trait ...">TDVecSMatMultExprTrait</a> class template.The TDVecSMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d02/structblaze_1_1TDVecSMatMultExprTrait.html" title="Evaluation of the expression type of a dense vector/sparse matrix multiplication.Via this type trait ...">TDVecSMatMultExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT</em> and the row-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga8fa3fbf61e08bed4ef480a674cebc063">More...</a><br /></td></tr>
<tr class="separator:ga8fa3fbf61e08bed4ef480a674cebc063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga547c9cdbbcdee97c9113ed2c8dcd74f5"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga547c9cdbbcdee97c9113ed2c8dcd74f5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga547c9cdbbcdee97c9113ed2c8dcd74f5">TDVecSVecMultExprTrait_</a> = typename <a class="el" href="../../d0/ded/structblaze_1_1TDVecSVecMultExprTrait.html">TDVecSVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga547c9cdbbcdee97c9113ed2c8dcd74f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/ded/structblaze_1_1TDVecSVecMultExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/sparse vector multiplication (inner product). Given the transpose dense vector type VT1 and the non-transpose sparse vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a transpose dense vector type or VT2 is not a non-transpose sparse vector type, the resulting Type is set to INVALID_TYPE. ">TDVecSVecMultExprTrait</a> class template.The TDVecSVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/ded/structblaze_1_1TDVecSVecMultExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/sparse vector multiplication (inner product). Given the transpose dense vector type VT1 and the non-transpose sparse vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a transpose dense vector type or VT2 is not a non-transpose sparse vector type, the resulting Type is set to INVALID_TYPE. ">TDVecSVecMultExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT1</em> and non-transpose sparse vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga547c9cdbbcdee97c9113ed2c8dcd74f5">More...</a><br /></td></tr>
<tr class="separator:ga547c9cdbbcdee97c9113ed2c8dcd74f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38851f0d8ac4265b2c580612855e1831"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:ga38851f0d8ac4265b2c580612855e1831"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga38851f0d8ac4265b2c580612855e1831">TDVecTDMatMultExprTrait_</a> = typename <a class="el" href="../../dc/dbe/structblaze_1_1TDVecTDMatMultExprTrait.html">TDVecTDMatMultExprTrait</a>&lt; VT, MT &gt;::Type</td></tr>
<tr class="memdesc:ga38851f0d8ac4265b2c580612855e1831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/dbe/structblaze_1_1TDVecTDMatMultExprTrait.html" title="Evaluation of the expression type of a dense vector/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose dense matrix multiplication. Given the transpose dense vector type VT and the column-major dense matrix type MT, the nested type Type corresponds to the resulting expression type. In case either VT is not a transpose dense vector type or MT is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDVecTDMatMultExprTrait</a> class template.The TDVecTDMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/dbe/structblaze_1_1TDVecTDMatMultExprTrait.html" title="Evaluation of the expression type of a dense vector/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose dense matrix multiplication. Given the transpose dense vector type VT and the column-major dense matrix type MT, the nested type Type corresponds to the resulting expression type. In case either VT is not a transpose dense vector type or MT is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDVecTDMatMultExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT</em> and the column-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga38851f0d8ac4265b2c580612855e1831">More...</a><br /></td></tr>
<tr class="separator:ga38851f0d8ac4265b2c580612855e1831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e5665c626144c8203e98e441c593060"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga1e5665c626144c8203e98e441c593060"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga1e5665c626144c8203e98e441c593060">TDVecTDVecAddExprTrait_</a> = typename <a class="el" href="../../d7/d48/structblaze_1_1TDVecTDVecAddExprTrait.html">TDVecTDVecAddExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga1e5665c626144c8203e98e441c593060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d48/structblaze_1_1TDVecTDVecAddExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/transpose dense vector addition...">TDVecTDVecAddExprTrait</a> class template.The TDVecTDVecAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d48/structblaze_1_1TDVecTDVecAddExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/transpose dense vector addition...">TDVecTDVecAddExprTrait</a> class template. For instance, given the transpose dense vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga1e5665c626144c8203e98e441c593060">More...</a><br /></td></tr>
<tr class="separator:ga1e5665c626144c8203e98e441c593060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f081857f46ed9022a1bf2afd32e22d9"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga6f081857f46ed9022a1bf2afd32e22d9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga6f081857f46ed9022a1bf2afd32e22d9">TDVecTDVecCrossExprTrait_</a> = typename <a class="el" href="../../dc/d92/structblaze_1_1TDVecTDVecCrossExprTrait.html">TDVecTDVecCrossExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga6f081857f46ed9022a1bf2afd32e22d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d92/structblaze_1_1TDVecTDVecCrossExprTrait.html" title="Evaluation of the expression type of a dense vector/dense vector cross product.Via this type trait it...">TDVecTDVecCrossExprTrait</a> class template.The TDVecTDVecCrossExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/d92/structblaze_1_1TDVecTDVecCrossExprTrait.html" title="Evaluation of the expression type of a dense vector/dense vector cross product.Via this type trait it...">TDVecTDVecCrossExprTrait</a> class template. For instance, given the transpose dense vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga6f081857f46ed9022a1bf2afd32e22d9">More...</a><br /></td></tr>
<tr class="separator:ga6f081857f46ed9022a1bf2afd32e22d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5896f1f10357a9751290cec5163e958"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gad5896f1f10357a9751290cec5163e958"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gad5896f1f10357a9751290cec5163e958">TDVecTDVecDivExprTrait_</a> = typename <a class="el" href="../../de/d70/structblaze_1_1TDVecTDVecDivExprTrait.html">TDVecTDVecDivExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:gad5896f1f10357a9751290cec5163e958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d70/structblaze_1_1TDVecTDVecDivExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/transpose dense vector division...">TDVecTDVecDivExprTrait</a> class template.The TDVecTDVecDivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d70/structblaze_1_1TDVecTDVecDivExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/transpose dense vector division...">TDVecTDVecDivExprTrait</a> class template. For instance, given the transpose dense vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gad5896f1f10357a9751290cec5163e958">More...</a><br /></td></tr>
<tr class="separator:gad5896f1f10357a9751290cec5163e958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga657a7ccb09c6c22a55b6992629701675"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga657a7ccb09c6c22a55b6992629701675"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga657a7ccb09c6c22a55b6992629701675">TDVecTDVecMultExprTrait_</a> = typename <a class="el" href="../../d4/d96/structblaze_1_1TDVecTDVecMultExprTrait.html">TDVecTDVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga657a7ccb09c6c22a55b6992629701675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/d96/structblaze_1_1TDVecTDVecMultExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/transpose dense vector multiplication...">TDVecTDVecMultExprTrait</a> class template.The TDVecTDVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/d96/structblaze_1_1TDVecTDVecMultExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/transpose dense vector multiplication...">TDVecTDVecMultExprTrait</a> class template. For instance, given the transpose dense vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga657a7ccb09c6c22a55b6992629701675">More...</a><br /></td></tr>
<tr class="separator:ga657a7ccb09c6c22a55b6992629701675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00d5f7c914bb5ea364f09935bb93c80"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gaa00d5f7c914bb5ea364f09935bb93c80"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaa00d5f7c914bb5ea364f09935bb93c80">TDVecTDVecSubExprTrait_</a> = typename <a class="el" href="../../d2/da4/structblaze_1_1TDVecTDVecSubExprTrait.html">TDVecTDVecSubExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:gaa00d5f7c914bb5ea364f09935bb93c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/da4/structblaze_1_1TDVecTDVecSubExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/transpose dense vector subtraction...">TDVecTDVecSubExprTrait</a> class template.The TDVecTDVecSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/da4/structblaze_1_1TDVecTDVecSubExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/transpose dense vector subtraction...">TDVecTDVecSubExprTrait</a> class template. For instance, given the transpose dense vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaa00d5f7c914bb5ea364f09935bb93c80">More...</a><br /></td></tr>
<tr class="separator:gaa00d5f7c914bb5ea364f09935bb93c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f0d52e8a4e519b0ee45461239715799"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga1f0d52e8a4e519b0ee45461239715799"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga1f0d52e8a4e519b0ee45461239715799">TDVecTransExprTrait_</a> = typename <a class="el" href="../../dc/d09/structblaze_1_1TDVecTransExprTrait.html">TDVecTransExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:ga1f0d52e8a4e519b0ee45461239715799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d09/structblaze_1_1TDVecTransExprTrait.html" title="Evaluation of the expression type of a dense vector transpose operation.Via this type trait it is pos...">TDVecTransExprTrait</a> class template.The TDVecTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/d09/structblaze_1_1TDVecTransExprTrait.html" title="Evaluation of the expression type of a dense vector transpose operation.Via this type trait it is pos...">TDVecTransExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga1f0d52e8a4e519b0ee45461239715799">More...</a><br /></td></tr>
<tr class="separator:ga1f0d52e8a4e519b0ee45461239715799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga411a24d6c37abaf3ab7dacf86dff988a"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:ga411a24d6c37abaf3ab7dacf86dff988a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga411a24d6c37abaf3ab7dacf86dff988a">TDVecTSMatMultExprTrait_</a> = typename <a class="el" href="../../df/d39/structblaze_1_1TDVecTSMatMultExprTrait.html">TDVecTSMatMultExprTrait</a>&lt; VT, MT &gt;::Type</td></tr>
<tr class="memdesc:ga411a24d6c37abaf3ab7dacf86dff988a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d39/structblaze_1_1TDVecTSMatMultExprTrait.html" title="Evaluation of the expression type of a dense vector/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose sparse matrix multiplication. Given the transpose dense vector type VT and the column-major sparse matrix type MT, the nested type Type corresponds to the resulting expression type. In case either VT is not a transpose dense vector type or MT is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDVecTSMatMultExprTrait</a> class template.The TDVecTSMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d39/structblaze_1_1TDVecTSMatMultExprTrait.html" title="Evaluation of the expression type of a dense vector/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose sparse matrix multiplication. Given the transpose dense vector type VT and the column-major sparse matrix type MT, the nested type Type corresponds to the resulting expression type. In case either VT is not a transpose dense vector type or MT is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TDVecTSMatMultExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT</em> and the column-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga411a24d6c37abaf3ab7dacf86dff988a">More...</a><br /></td></tr>
<tr class="separator:ga411a24d6c37abaf3ab7dacf86dff988a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga330523bf4b74b70ea52da6a1a67aaf4e"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga330523bf4b74b70ea52da6a1a67aaf4e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga330523bf4b74b70ea52da6a1a67aaf4e">TDVecTSVecAddExprTrait_</a> = typename <a class="el" href="../../db/db9/structblaze_1_1TDVecTSVecAddExprTrait.html">TDVecTSVecAddExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga330523bf4b74b70ea52da6a1a67aaf4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/db9/structblaze_1_1TDVecTSVecAddExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/transpose sparse vector addition...">TDVecTSVecAddExprTrait</a> class template.The TDVecTSVecAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/db9/structblaze_1_1TDVecTSVecAddExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/transpose sparse vector addition...">TDVecTSVecAddExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga330523bf4b74b70ea52da6a1a67aaf4e">More...</a><br /></td></tr>
<tr class="separator:ga330523bf4b74b70ea52da6a1a67aaf4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4070d40a5a71da0b0cad514908dc441"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gac4070d40a5a71da0b0cad514908dc441"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gac4070d40a5a71da0b0cad514908dc441">TDVecTSVecCrossExprTrait_</a> = typename <a class="el" href="../../d5/db3/structblaze_1_1TDVecTSVecCrossExprTrait.html">TDVecTSVecCrossExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:gac4070d40a5a71da0b0cad514908dc441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/db3/structblaze_1_1TDVecTSVecCrossExprTrait.html" title="Evaluation of the expression type of a dense vector/sparse vector cross product.Via this type trait i...">TDVecTSVecCrossExprTrait</a> class template.The TDVecTSVecCrossExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/db3/structblaze_1_1TDVecTSVecCrossExprTrait.html" title="Evaluation of the expression type of a dense vector/sparse vector cross product.Via this type trait i...">TDVecTSVecCrossExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gac4070d40a5a71da0b0cad514908dc441">More...</a><br /></td></tr>
<tr class="separator:gac4070d40a5a71da0b0cad514908dc441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga802d479e1391bfd3ce1f8e5f5a732a22"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga802d479e1391bfd3ce1f8e5f5a732a22"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga802d479e1391bfd3ce1f8e5f5a732a22">TDVecTSVecMultExprTrait_</a> = typename <a class="el" href="../../d4/da4/structblaze_1_1TDVecTSVecMultExprTrait.html">TDVecTSVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga802d479e1391bfd3ce1f8e5f5a732a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/da4/structblaze_1_1TDVecTSVecMultExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/transpose sparse vector multiplication...">TDVecTSVecMultExprTrait</a> class template.The TDVecTSVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/da4/structblaze_1_1TDVecTSVecMultExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/transpose sparse vector multiplication...">TDVecTSVecMultExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga802d479e1391bfd3ce1f8e5f5a732a22">More...</a><br /></td></tr>
<tr class="separator:ga802d479e1391bfd3ce1f8e5f5a732a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ceb62494b0de3ea80ac521eabed850"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga53ceb62494b0de3ea80ac521eabed850"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga53ceb62494b0de3ea80ac521eabed850">TDVecTSVecSubExprTrait_</a> = typename <a class="el" href="../../d8/dc3/structblaze_1_1TDVecTSVecSubExprTrait.html">TDVecTSVecSubExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga53ceb62494b0de3ea80ac521eabed850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/dc3/structblaze_1_1TDVecTSVecSubExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/transpose sparse vector subtraction...">TDVecTSVecSubExprTrait</a> class template.The TDVecTSVecSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/dc3/structblaze_1_1TDVecTSVecSubExprTrait.html" title="Evaluation of the expression type of a transpose dense vector/transpose sparse vector subtraction...">TDVecTSVecSubExprTrait</a> class template. For instance, given the transpose dense vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga53ceb62494b0de3ea80ac521eabed850">More...</a><br /></td></tr>
<tr class="separator:ga53ceb62494b0de3ea80ac521eabed850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0abaf03cc33775ce5bb24173eae3c84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad0abaf03cc33775ce5bb24173eae3c84"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gad0abaf03cc33775ce5bb24173eae3c84">TransExprTrait_</a> = typename <a class="el" href="../../d1/d9a/structblaze_1_1TransExprTrait.html">TransExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gad0abaf03cc33775ce5bb24173eae3c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d9a/structblaze_1_1TransExprTrait.html" title="Evaluation of the return type of a transpose expression.Via this type trait it is possible to evaluat...">TransExprTrait</a> class template.The TransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d9a/structblaze_1_1TransExprTrait.html" title="Evaluation of the return type of a transpose expression.Via this type trait it is possible to evaluat...">TransExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gad0abaf03cc33775ce5bb24173eae3c84">More...</a><br /></td></tr>
<tr class="separator:gad0abaf03cc33775ce5bb24173eae3c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9eaa1bc19f989540ef6ba3213c54960"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gac9eaa1bc19f989540ef6ba3213c54960"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gac9eaa1bc19f989540ef6ba3213c54960">TSMatCTransExprTrait_</a> = typename <a class="el" href="../../d8/de8/structblaze_1_1TSMatCTransExprTrait.html">TSMatCTransExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gac9eaa1bc19f989540ef6ba3213c54960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/de8/structblaze_1_1TSMatCTransExprTrait.html" title="Evaluation of the expression type of a sparse matrix conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix conjugate transpose operation. Given the column-major sparse matrix type MT, the nested type Type corresponds to the resulting expression type. In case MT is not a column-major sparse matrix type, the resulting Type is set to INVALID_TYPE. ">TSMatCTransExprTrait</a> class template.The TSMatCTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/de8/structblaze_1_1TSMatCTransExprTrait.html" title="Evaluation of the expression type of a sparse matrix conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix conjugate transpose operation. Given the column-major sparse matrix type MT, the nested type Type corresponds to the resulting expression type. In case MT is not a column-major sparse matrix type, the resulting Type is set to INVALID_TYPE. ">TSMatCTransExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gac9eaa1bc19f989540ef6ba3213c54960">More...</a><br /></td></tr>
<tr class="separator:gac9eaa1bc19f989540ef6ba3213c54960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e109eaf3b9e2afe9600a3c371aeed6"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga73e109eaf3b9e2afe9600a3c371aeed6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga73e109eaf3b9e2afe9600a3c371aeed6">TSMatDeclDiagExprTrait_</a> = typename <a class="el" href="../../db/d17/structblaze_1_1TSMatDeclDiagExprTrait.html">TSMatDeclDiagExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga73e109eaf3b9e2afe9600a3c371aeed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/d17/structblaze_1_1TSMatDeclDiagExprTrait.html" title="Evaluation of the expression type of a sparse matrix decldiag operation.Via this type trait it is pos...">TSMatDeclDiagExprTrait</a> class template.The TSMatDeclDiagExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/d17/structblaze_1_1TSMatDeclDiagExprTrait.html" title="Evaluation of the expression type of a sparse matrix decldiag operation.Via this type trait it is pos...">TSMatDeclDiagExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga73e109eaf3b9e2afe9600a3c371aeed6">More...</a><br /></td></tr>
<tr class="separator:ga73e109eaf3b9e2afe9600a3c371aeed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd9fb7188b09f73ae5eb3523df78651"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gafcd9fb7188b09f73ae5eb3523df78651"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gafcd9fb7188b09f73ae5eb3523df78651">TSMatDeclHermExprTrait_</a> = typename <a class="el" href="../../d0/d2f/structblaze_1_1TSMatDeclHermExprTrait.html">TSMatDeclHermExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gafcd9fb7188b09f73ae5eb3523df78651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/d2f/structblaze_1_1TSMatDeclHermExprTrait.html" title="Evaluation of the expression type of a sparse matrix declherm operation.Via this type trait it is pos...">TSMatDeclHermExprTrait</a> class template.The TSMatDeclHermExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/d2f/structblaze_1_1TSMatDeclHermExprTrait.html" title="Evaluation of the expression type of a sparse matrix declherm operation.Via this type trait it is pos...">TSMatDeclHermExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gafcd9fb7188b09f73ae5eb3523df78651">More...</a><br /></td></tr>
<tr class="separator:gafcd9fb7188b09f73ae5eb3523df78651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef6eba8103e5046881e6654fd1d77a31"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaef6eba8103e5046881e6654fd1d77a31"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaef6eba8103e5046881e6654fd1d77a31">TSMatDeclLowExprTrait_</a> = typename <a class="el" href="../../db/de3/structblaze_1_1TSMatDeclLowExprTrait.html">TSMatDeclLowExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gaef6eba8103e5046881e6654fd1d77a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/de3/structblaze_1_1TSMatDeclLowExprTrait.html" title="Evaluation of the expression type of a sparse matrix decllow operation.Via this type trait it is poss...">TSMatDeclLowExprTrait</a> class template.The TSMatDeclLowExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/de3/structblaze_1_1TSMatDeclLowExprTrait.html" title="Evaluation of the expression type of a sparse matrix decllow operation.Via this type trait it is poss...">TSMatDeclLowExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaef6eba8103e5046881e6654fd1d77a31">More...</a><br /></td></tr>
<tr class="separator:gaef6eba8103e5046881e6654fd1d77a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga442601c3d1e52d92d8f777bfb92bdfbe"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga442601c3d1e52d92d8f777bfb92bdfbe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga442601c3d1e52d92d8f777bfb92bdfbe">TSMatDeclSymExprTrait_</a> = typename <a class="el" href="../../dd/de4/structblaze_1_1TSMatDeclSymExprTrait.html">TSMatDeclSymExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga442601c3d1e52d92d8f777bfb92bdfbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/de4/structblaze_1_1TSMatDeclSymExprTrait.html" title="Evaluation of the expression type of a sparse matrix declsym operation.Via this type trait it is poss...">TSMatDeclSymExprTrait</a> class template.The TSMatDeclSymExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/de4/structblaze_1_1TSMatDeclSymExprTrait.html" title="Evaluation of the expression type of a sparse matrix declsym operation.Via this type trait it is poss...">TSMatDeclSymExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga442601c3d1e52d92d8f777bfb92bdfbe">More...</a><br /></td></tr>
<tr class="separator:ga442601c3d1e52d92d8f777bfb92bdfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dff374b9ec99fc747da708486dbb9a6"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga2dff374b9ec99fc747da708486dbb9a6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga2dff374b9ec99fc747da708486dbb9a6">TSMatDeclUppExprTrait_</a> = typename <a class="el" href="../../db/dd0/structblaze_1_1TSMatDeclUppExprTrait.html">TSMatDeclUppExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga2dff374b9ec99fc747da708486dbb9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/dd0/structblaze_1_1TSMatDeclUppExprTrait.html" title="Evaluation of the expression type of a sparse matrix declupp operation.Via this type trait it is poss...">TSMatDeclUppExprTrait</a> class template.The TSMatDeclUppExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/dd0/structblaze_1_1TSMatDeclUppExprTrait.html" title="Evaluation of the expression type of a sparse matrix declupp operation.Via this type trait it is poss...">TSMatDeclUppExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga2dff374b9ec99fc747da708486dbb9a6">More...</a><br /></td></tr>
<tr class="separator:ga2dff374b9ec99fc747da708486dbb9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23fcbe7ecd3ca2524874d8baaa4ce8a5"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga23fcbe7ecd3ca2524874d8baaa4ce8a5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga23fcbe7ecd3ca2524874d8baaa4ce8a5">TSMatDMatAddExprTrait_</a> = typename <a class="el" href="../../d1/d7a/structblaze_1_1TSMatDMatAddExprTrait.html">TSMatDMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga23fcbe7ecd3ca2524874d8baaa4ce8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d7a/structblaze_1_1TSMatDMatAddExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense matrix addition. Given the column-major sparse matrix type MT1 and the row-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major sparse matrix type or MT2 is not a row-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSMatDMatAddExprTrait</a> class template.The TSMatDMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d7a/structblaze_1_1TSMatDMatAddExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense matrix addition. Given the column-major sparse matrix type MT1 and the row-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major sparse matrix type or MT2 is not a row-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSMatDMatAddExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga23fcbe7ecd3ca2524874d8baaa4ce8a5">More...</a><br /></td></tr>
<tr class="separator:ga23fcbe7ecd3ca2524874d8baaa4ce8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadb49be073980544b0db67b2d3612eba"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaadb49be073980544b0db67b2d3612eba"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaadb49be073980544b0db67b2d3612eba">TSMatDMatMultExprTrait_</a> = typename <a class="el" href="../../d6/d45/structblaze_1_1TSMatDMatMultExprTrait.html">TSMatDMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gaadb49be073980544b0db67b2d3612eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d6/d45/structblaze_1_1TSMatDMatMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense matrix multiplication. Given the column-major sparse matrix type MT1 and the row-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major sparse matrix type or MT2 is not a row-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSMatDMatMultExprTrait</a> class template.The TSMatDMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/d45/structblaze_1_1TSMatDMatMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense matrix multiplication. Given the column-major sparse matrix type MT1 and the row-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major sparse matrix type or MT2 is not a row-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSMatDMatMultExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaadb49be073980544b0db67b2d3612eba">More...</a><br /></td></tr>
<tr class="separator:gaadb49be073980544b0db67b2d3612eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea9f9a3c21c8039e42272d1e7ffc1ac5"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaea9f9a3c21c8039e42272d1e7ffc1ac5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaea9f9a3c21c8039e42272d1e7ffc1ac5">TSMatDMatSubExprTrait_</a> = typename <a class="el" href="../../dc/df5/structblaze_1_1TSMatDMatSubExprTrait.html">TSMatDMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gaea9f9a3c21c8039e42272d1e7ffc1ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/df5/structblaze_1_1TSMatDMatSubExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense matrix subtraction. Given the column-major sparse matrix type MT1 and the row-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major sparse matrix type or MT2 is not a row-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSMatDMatSubExprTrait</a> class template.The TSMatDMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/df5/structblaze_1_1TSMatDMatSubExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense matrix subtraction. Given the column-major sparse matrix type MT1 and the row-major dense matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major sparse matrix type or MT2 is not a row-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSMatDMatSubExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaea9f9a3c21c8039e42272d1e7ffc1ac5">More...</a><br /></td></tr>
<tr class="separator:gaea9f9a3c21c8039e42272d1e7ffc1ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1c10bab5510819f6c791fe2306fcf71"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:gae1c10bab5510819f6c791fe2306fcf71"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gae1c10bab5510819f6c791fe2306fcf71">TSMatDVecMultExprTrait_</a> = typename <a class="el" href="../../d4/d6c/structblaze_1_1TSMatDVecMultExprTrait.html">TSMatDVecMultExprTrait</a>&lt; MT, VT &gt;::Type</td></tr>
<tr class="memdesc:gae1c10bab5510819f6c791fe2306fcf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/d6c/structblaze_1_1TSMatDVecMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense vector multiplication. Given the column-major sparse matrix type MT and the non-transpose dense vector type VT, the nested type Type corresponds to the resulting expression type. In case either MT is not a column-major sparse matrix type or VT is not a non-transpose dense vector type, the resulting data type Type is set to INVALID_TYPE. ">TSMatDVecMultExprTrait</a> class template.The TSMatDVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/d6c/structblaze_1_1TSMatDVecMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense vector multiplication. Given the column-major sparse matrix type MT and the non-transpose dense vector type VT, the nested type Type corresponds to the resulting expression type. In case either MT is not a column-major sparse matrix type or VT is not a non-transpose dense vector type, the resulting data type Type is set to INVALID_TYPE. ">TSMatDVecMultExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT</em> and the non-transpose dense vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gae1c10bab5510819f6c791fe2306fcf71">More...</a><br /></td></tr>
<tr class="separator:gae1c10bab5510819f6c791fe2306fcf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf22ae1980105c6d67a2857e49cad0ea"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gabf22ae1980105c6d67a2857e49cad0ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gabf22ae1980105c6d67a2857e49cad0ea">TSMatEvalExprTrait_</a> = typename <a class="el" href="../../d2/d16/structblaze_1_1TSMatEvalExprTrait.html">TSMatEvalExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gabf22ae1980105c6d67a2857e49cad0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d16/structblaze_1_1TSMatEvalExprTrait.html" title="Evaluation of the expression type of a sparse matrix evaluation operation.Via this type trait it is p...">TSMatEvalExprTrait</a> class template.The TSMatEvalExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d16/structblaze_1_1TSMatEvalExprTrait.html" title="Evaluation of the expression type of a sparse matrix evaluation operation.Via this type trait it is p...">TSMatEvalExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gabf22ae1980105c6d67a2857e49cad0ea">More...</a><br /></td></tr>
<tr class="separator:gabf22ae1980105c6d67a2857e49cad0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga667efefdd9dfa23d126f6625b92e2c5c"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename OP &gt; </td></tr>
<tr class="memitem:ga667efefdd9dfa23d126f6625b92e2c5c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga667efefdd9dfa23d126f6625b92e2c5c">TSMatForEachExprTrait_</a> = typename <a class="el" href="../../d1/ddd/structblaze_1_1TSMatForEachExprTrait.html">TSMatForEachExprTrait</a>&lt; MT, OP &gt;::Type</td></tr>
<tr class="memdesc:ga667efefdd9dfa23d126f6625b92e2c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/ddd/structblaze_1_1TSMatForEachExprTrait.html" title="Evaluation of the expression type of a sparse matrix for-each operation.Via this type trait it is pos...">TSMatForEachExprTrait</a> class template.The SMatForEachExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/d0f/structblaze_1_1SMatForEachExprTrait.html" title="Evaluation of the expression type of a sparse matrix for-each operation.Via this type trait it is pos...">SMatForEachExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT</em> and the custom operation type <em>OP</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga667efefdd9dfa23d126f6625b92e2c5c">More...</a><br /></td></tr>
<tr class="separator:ga667efefdd9dfa23d126f6625b92e2c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97dae9ce01897dbc18fc398480033a6a"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename ST &gt; </td></tr>
<tr class="memitem:ga97dae9ce01897dbc18fc398480033a6a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga97dae9ce01897dbc18fc398480033a6a">TSMatScalarDivExprTrait_</a> = typename <a class="el" href="../../d1/d6e/structblaze_1_1TSMatScalarDivExprTrait.html">TSMatScalarDivExprTrait</a>&lt; MT, ST &gt;::Type</td></tr>
<tr class="memdesc:ga97dae9ce01897dbc18fc398480033a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d6e/structblaze_1_1TSMatScalarDivExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/scalar division.Via this type trait it...">TSMatScalarDivExprTrait</a> class template.The TSMatScalarDivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d6e/structblaze_1_1TSMatScalarDivExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/scalar division.Via this type trait it...">TSMatScalarDivExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga97dae9ce01897dbc18fc398480033a6a">More...</a><br /></td></tr>
<tr class="separator:ga97dae9ce01897dbc18fc398480033a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaf823cca1c0fd3e87191ec0f73b8df7"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename ST &gt; </td></tr>
<tr class="memitem:gaeaf823cca1c0fd3e87191ec0f73b8df7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaeaf823cca1c0fd3e87191ec0f73b8df7">TSMatScalarMultExprTrait_</a> = typename <a class="el" href="../../df/d4f/structblaze_1_1TSMatScalarMultExprTrait.html">TSMatScalarMultExprTrait</a>&lt; MT, ST &gt;::Type</td></tr>
<tr class="memdesc:gaeaf823cca1c0fd3e87191ec0f73b8df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d4f/structblaze_1_1TSMatScalarMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/scalar multiplication. Given the column-major sparse matrix type MT and the scalar type ST, the nested type Type corresponds to the resulting expression type. In case either MT is not a column-major sparse matrix type or ST is not a scalar type, the resulting Type is set to INVALID_TYPE. ">TSMatScalarMultExprTrait</a> class template.The TSMatScalarMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d4f/structblaze_1_1TSMatScalarMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/scalar multiplication. Given the column-major sparse matrix type MT and the scalar type ST, the nested type Type corresponds to the resulting expression type. In case either MT is not a column-major sparse matrix type or ST is not a scalar type, the resulting Type is set to INVALID_TYPE. ">TSMatScalarMultExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaeaf823cca1c0fd3e87191ec0f73b8df7">More...</a><br /></td></tr>
<tr class="separator:gaeaf823cca1c0fd3e87191ec0f73b8df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad779c9ad01416cbdf7c4650fdd5159dd"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gad779c9ad01416cbdf7c4650fdd5159dd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gad779c9ad01416cbdf7c4650fdd5159dd">TSMatSerialExprTrait_</a> = typename <a class="el" href="../../db/d6c/structblaze_1_1TSMatSerialExprTrait.html">TSMatSerialExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gad779c9ad01416cbdf7c4650fdd5159dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/d6c/structblaze_1_1TSMatSerialExprTrait.html" title="Evaluation of the expression type of a sparse matrix serial evaluation operation.Via this type trait ...">TSMatSerialExprTrait</a> class template.The TSMatSerialExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/d6c/structblaze_1_1TSMatSerialExprTrait.html" title="Evaluation of the expression type of a sparse matrix serial evaluation operation.Via this type trait ...">TSMatSerialExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gad779c9ad01416cbdf7c4650fdd5159dd">More...</a><br /></td></tr>
<tr class="separator:gad779c9ad01416cbdf7c4650fdd5159dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad42bbdaf1f71866570b4cae03595912c"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gad42bbdaf1f71866570b4cae03595912c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gad42bbdaf1f71866570b4cae03595912c">TSMatSMatAddExprTrait_</a> = typename <a class="el" href="../../d3/df7/structblaze_1_1TSMatSMatAddExprTrait.html">TSMatSMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gad42bbdaf1f71866570b4cae03595912c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d3/df7/structblaze_1_1TSMatSMatAddExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse matrix addition. Given the column-major sparse matrix type MT1 and the row-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major sparse matrix type or MT2 is not a row-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSMatSMatAddExprTrait</a> class template.The TSMatSMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/df7/structblaze_1_1TSMatSMatAddExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse matrix addition. Given the column-major sparse matrix type MT1 and the row-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major sparse matrix type or MT2 is not a row-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSMatSMatAddExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gad42bbdaf1f71866570b4cae03595912c">More...</a><br /></td></tr>
<tr class="separator:gad42bbdaf1f71866570b4cae03595912c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga965d0c5a77407b57ed4be076e11b4251"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga965d0c5a77407b57ed4be076e11b4251"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga965d0c5a77407b57ed4be076e11b4251">TSMatSMatMultExprTrait_</a> = typename <a class="el" href="../../d7/d96/structblaze_1_1TSMatSMatMultExprTrait.html">TSMatSMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga965d0c5a77407b57ed4be076e11b4251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d96/structblaze_1_1TSMatSMatMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse matrix multiplication. Given the column-major sparse matrix type MT1 and the row-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major sparse matrix type or MT2 is not a row-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSMatSMatMultExprTrait</a> class template.The TSMatSMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d96/structblaze_1_1TSMatSMatMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse matrix multiplication. Given the column-major sparse matrix type MT1 and the row-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major sparse matrix type or MT2 is not a row-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSMatSMatMultExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga965d0c5a77407b57ed4be076e11b4251">More...</a><br /></td></tr>
<tr class="separator:ga965d0c5a77407b57ed4be076e11b4251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga307202ad7c82ca5601fdd0502d16d861"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga307202ad7c82ca5601fdd0502d16d861"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga307202ad7c82ca5601fdd0502d16d861">TSMatSMatSubExprTrait_</a> = typename <a class="el" href="../../de/de9/structblaze_1_1TSMatSMatSubExprTrait.html">TSMatSMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga307202ad7c82ca5601fdd0502d16d861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/de9/structblaze_1_1TSMatSMatSubExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse matrix subtraction. Given the column-major sparse matrix type MT1 and the row-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major sparse matrix type or MT2 is not a row-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSMatSMatSubExprTrait</a> class template.The TSMatSMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/de9/structblaze_1_1TSMatSMatSubExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse matrix subtraction. Given the column-major sparse matrix type MT1 and the row-major sparse matrix type MT2, the nested type Type corresponds to the resulting expression type. In case either MT1 is not a column-major sparse matrix type or MT2 is not a row-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSMatSMatSubExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga307202ad7c82ca5601fdd0502d16d861">More...</a><br /></td></tr>
<tr class="separator:ga307202ad7c82ca5601fdd0502d16d861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae35cb2dc8d6a0f1b3b0785031f7ded30"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:gae35cb2dc8d6a0f1b3b0785031f7ded30"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gae35cb2dc8d6a0f1b3b0785031f7ded30">TSMatSVecMultExprTrait_</a> = typename <a class="el" href="../../d4/dbc/structblaze_1_1TSMatSVecMultExprTrait.html">TSMatSVecMultExprTrait</a>&lt; MT, VT &gt;::Type</td></tr>
<tr class="memdesc:gae35cb2dc8d6a0f1b3b0785031f7ded30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/dbc/structblaze_1_1TSMatSVecMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse vector multiplication. Given the column-major sparse matrix type MT and the non-transpose sparse vector type VT, the nested type Type corresponds to the resulting expression type. In case either MT is not a column-major sparse matrix type or VT is not a non-transpose sparse vector type, the resulting data type Type is set to INVALID_TYPE. ">TSMatSVecMultExprTrait</a> class template.The TSMatSVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/dbc/structblaze_1_1TSMatSVecMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse vector multiplication. Given the column-major sparse matrix type MT and the non-transpose sparse vector type VT, the nested type Type corresponds to the resulting expression type. In case either MT is not a column-major sparse matrix type or VT is not a non-transpose sparse vector type, the resulting data type Type is set to INVALID_TYPE. ">TSMatSVecMultExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT</em> and the non-transpose sparse vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gae35cb2dc8d6a0f1b3b0785031f7ded30">More...</a><br /></td></tr>
<tr class="separator:gae35cb2dc8d6a0f1b3b0785031f7ded30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0482ccd21e4169c99e61ab679f8245e1"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga0482ccd21e4169c99e61ab679f8245e1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga0482ccd21e4169c99e61ab679f8245e1">TSMatTDMatAddExprTrait_</a> = typename <a class="el" href="../../dc/d27/structblaze_1_1TSMatTDMatAddExprTrait.html">TSMatTDMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga0482ccd21e4169c99e61ab679f8245e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d27/structblaze_1_1TSMatTDMatAddExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/transpose dense matrix addition...">TSMatTDMatAddExprTrait</a> class template.The TSMatTDMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/d27/structblaze_1_1TSMatTDMatAddExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/transpose dense matrix addition...">TSMatTDMatAddExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga0482ccd21e4169c99e61ab679f8245e1">More...</a><br /></td></tr>
<tr class="separator:ga0482ccd21e4169c99e61ab679f8245e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbe0ea7f54c8a81e7befec58db8322bd"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gadbe0ea7f54c8a81e7befec58db8322bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gadbe0ea7f54c8a81e7befec58db8322bd">TSMatTDMatMultExprTrait_</a> = typename <a class="el" href="../../d2/d13/structblaze_1_1TSMatTDMatMultExprTrait.html">TSMatTDMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gadbe0ea7f54c8a81e7befec58db8322bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d13/structblaze_1_1TSMatTDMatMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/transpose dense matrix multiplication...">TSMatTDMatMultExprTrait</a> class template.The TSMatTDMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d13/structblaze_1_1TSMatTDMatMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/transpose dense matrix multiplication...">TSMatTDMatMultExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gadbe0ea7f54c8a81e7befec58db8322bd">More...</a><br /></td></tr>
<tr class="separator:gadbe0ea7f54c8a81e7befec58db8322bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b3ddd60355c37acbe3526a88b7d55d4"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga8b3ddd60355c37acbe3526a88b7d55d4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga8b3ddd60355c37acbe3526a88b7d55d4">TSMatTDMatSubExprTrait_</a> = typename <a class="el" href="../../d0/db2/structblaze_1_1TSMatTDMatSubExprTrait.html">TSMatTDMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga8b3ddd60355c37acbe3526a88b7d55d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/db2/structblaze_1_1TSMatTDMatSubExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/transpose dense matrix subtraction...">TSMatTDMatSubExprTrait</a> class template.The TSMatTDMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/db2/structblaze_1_1TSMatTDMatSubExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/transpose dense matrix subtraction...">TSMatTDMatSubExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga8b3ddd60355c37acbe3526a88b7d55d4">More...</a><br /></td></tr>
<tr class="separator:ga8b3ddd60355c37acbe3526a88b7d55d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c16d66265dbc40c67d77b3d9fa1bbdb"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga2c16d66265dbc40c67d77b3d9fa1bbdb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga2c16d66265dbc40c67d77b3d9fa1bbdb">TSMatTransExprTrait_</a> = typename <a class="el" href="../../dd/df0/structblaze_1_1TSMatTransExprTrait.html">TSMatTransExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga2c16d66265dbc40c67d77b3d9fa1bbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/df0/structblaze_1_1TSMatTransExprTrait.html" title="Evaluation of the expression type of a sparse matrix transpose operation.Via this type trait it is po...">TSMatTransExprTrait</a> class template.The TSMatTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/df0/structblaze_1_1TSMatTransExprTrait.html" title="Evaluation of the expression type of a sparse matrix transpose operation.Via this type trait it is po...">TSMatTransExprTrait</a> class template. For instance, given the column-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga2c16d66265dbc40c67d77b3d9fa1bbdb">More...</a><br /></td></tr>
<tr class="separator:ga2c16d66265dbc40c67d77b3d9fa1bbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedef303bf41e171590558a77570db3a3"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaedef303bf41e171590558a77570db3a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaedef303bf41e171590558a77570db3a3">TSMatTSMatAddExprTrait_</a> = typename <a class="el" href="../../d4/d3f/structblaze_1_1TSMatTSMatAddExprTrait.html">TSMatTSMatAddExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gaedef303bf41e171590558a77570db3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/d3f/structblaze_1_1TSMatTSMatAddExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/transpose sparse matrix addition...">TSMatTSMatAddExprTrait</a> class template.The TSMatTSMatAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/d3f/structblaze_1_1TSMatTSMatAddExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/transpose sparse matrix addition...">TSMatTSMatAddExprTrait</a> class template. For instance, given the column-major sparse matrix types <em>MT1</em> and <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaedef303bf41e171590558a77570db3a3">More...</a><br /></td></tr>
<tr class="separator:gaedef303bf41e171590558a77570db3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae57125acf7b05378069cdb47b897e481"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gae57125acf7b05378069cdb47b897e481"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gae57125acf7b05378069cdb47b897e481">TSMatTSMatMultExprTrait_</a> = typename <a class="el" href="../../d8/d49/structblaze_1_1TSMatTSMatMultExprTrait.html">TSMatTSMatMultExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:gae57125acf7b05378069cdb47b897e481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d49/structblaze_1_1TSMatTSMatMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/transpose sparse matrix multiplication...">TSMatTSMatMultExprTrait</a> class template.The TSMatTSMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d49/structblaze_1_1TSMatTSMatMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/transpose sparse matrix multiplication...">TSMatTSMatMultExprTrait</a> class template. For instance, given the column-major sparse matrix types <em>MT1</em> and <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gae57125acf7b05378069cdb47b897e481">More...</a><br /></td></tr>
<tr class="separator:gae57125acf7b05378069cdb47b897e481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cfc508641f1b95da0bdb5cdedc8a09e"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga3cfc508641f1b95da0bdb5cdedc8a09e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga3cfc508641f1b95da0bdb5cdedc8a09e">TSMatTSMatSubExprTrait_</a> = typename <a class="el" href="../../d2/de0/structblaze_1_1TSMatTSMatSubExprTrait.html">TSMatTSMatSubExprTrait</a>&lt; MT1, MT2 &gt;::Type</td></tr>
<tr class="memdesc:ga3cfc508641f1b95da0bdb5cdedc8a09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/de0/structblaze_1_1TSMatTSMatSubExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/transpose sparse matrix subtraction...">TSMatTSMatSubExprTrait</a> class template.The TSMatTSMatSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/de0/structblaze_1_1TSMatTSMatSubExprTrait.html" title="Evaluation of the expression type of a transpose sparse matrix/transpose sparse matrix subtraction...">TSMatTSMatSubExprTrait</a> class template. For instance, given the column-major sparse matrix types <em>MT1</em> and <em>MT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga3cfc508641f1b95da0bdb5cdedc8a09e">More...</a><br /></td></tr>
<tr class="separator:ga3cfc508641f1b95da0bdb5cdedc8a09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ba1108625b36770654e4974312e2c05"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga6ba1108625b36770654e4974312e2c05"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga6ba1108625b36770654e4974312e2c05">TSVecCTransExprTrait_</a> = typename <a class="el" href="../../d0/d28/structblaze_1_1TSVecCTransExprTrait.html">TSVecCTransExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:ga6ba1108625b36770654e4974312e2c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/d28/structblaze_1_1TSVecCTransExprTrait.html" title="Evaluation of the expression type of a sparse vector conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector conjugate transpose operation. Given the transpose sparse vector type VT, the nested type Type corresponds to the resulting expression type. In case VT is not a transpose sparse vector type, the resulting Type is set to INVALID_TYPE. ">TSVecCTransExprTrait</a> class template.The TSVecCTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/d28/structblaze_1_1TSVecCTransExprTrait.html" title="Evaluation of the expression type of a sparse vector conjugate transpose operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector conjugate transpose operation. Given the transpose sparse vector type VT, the nested type Type corresponds to the resulting expression type. In case VT is not a transpose sparse vector type, the resulting Type is set to INVALID_TYPE. ">TSVecCTransExprTrait</a> class template. For instance, given the transpose sparse vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga6ba1108625b36770654e4974312e2c05">More...</a><br /></td></tr>
<tr class="separator:ga6ba1108625b36770654e4974312e2c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41b07ce2bba92714e1535524722e4864"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:ga41b07ce2bba92714e1535524722e4864"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga41b07ce2bba92714e1535524722e4864">TSVecDMatMultExprTrait_</a> = typename <a class="el" href="../../d6/d7b/structblaze_1_1TSVecDMatMultExprTrait.html">TSVecDMatMultExprTrait</a>&lt; VT, MT &gt;::Type</td></tr>
<tr class="memdesc:ga41b07ce2bba92714e1535524722e4864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d6/d7b/structblaze_1_1TSVecDMatMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/dense matrix multiplication.Via this type trait ...">TSVecDMatMultExprTrait</a> class template.The TSVecDMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/d7b/structblaze_1_1TSVecDMatMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/dense matrix multiplication.Via this type trait ...">TSVecDMatMultExprTrait</a> class template. For instance, given the transpose sparse vector type <em>VT</em> and the row-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga41b07ce2bba92714e1535524722e4864">More...</a><br /></td></tr>
<tr class="separator:ga41b07ce2bba92714e1535524722e4864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf425e1cb6558bbd7f281ec5d22e8dc"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga5cf425e1cb6558bbd7f281ec5d22e8dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga5cf425e1cb6558bbd7f281ec5d22e8dc">TSVecDVecMultExprTrait_</a> = typename <a class="el" href="../../d7/d75/structblaze_1_1TSVecDVecMultExprTrait.html">TSVecDVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga5cf425e1cb6558bbd7f281ec5d22e8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d75/structblaze_1_1TSVecDVecMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/dense vector multiplication (inner product). Given the transpose sparse vector type VT1 and the non-transpose dense vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a transpose sparse vector type or VT2 is not a non-transpose dense vector type, the resulting Type is set to INVALID_TYPE. ">TSVecDVecMultExprTrait</a> class template.The TSVecDVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d75/structblaze_1_1TSVecDVecMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/dense vector multiplication (inner product). Given the transpose sparse vector type VT1 and the non-transpose dense vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a transpose sparse vector type or VT2 is not a non-transpose dense vector type, the resulting Type is set to INVALID_TYPE. ">TSVecDVecMultExprTrait</a> class template. For instance, given the transpose sparse vector type <em>VT1</em> and non-transpose dense vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga5cf425e1cb6558bbd7f281ec5d22e8dc">More...</a><br /></td></tr>
<tr class="separator:ga5cf425e1cb6558bbd7f281ec5d22e8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga471284c913b969f9e2bcfc9512c21f68"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga471284c913b969f9e2bcfc9512c21f68"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga471284c913b969f9e2bcfc9512c21f68">TSVecEvalExprTrait_</a> = typename <a class="el" href="../../d8/dad/structblaze_1_1TSVecEvalExprTrait.html">TSVecEvalExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:ga471284c913b969f9e2bcfc9512c21f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/dad/structblaze_1_1TSVecEvalExprTrait.html" title="Evaluation of the expression type of a sparse vector evaluation operation.Via this type trait it is p...">TSVecEvalExprTrait</a> class template.The TSVecEvalExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/dad/structblaze_1_1TSVecEvalExprTrait.html" title="Evaluation of the expression type of a sparse vector evaluation operation.Via this type trait it is p...">TSVecEvalExprTrait</a> class template. For instance, given the transpose sparse vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga471284c913b969f9e2bcfc9512c21f68">More...</a><br /></td></tr>
<tr class="separator:ga471284c913b969f9e2bcfc9512c21f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a5bbe4b03fb2f26996d253208f5b04"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename OP &gt; </td></tr>
<tr class="memitem:ga40a5bbe4b03fb2f26996d253208f5b04"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga40a5bbe4b03fb2f26996d253208f5b04">TSVecForEachExprTrait_</a> = typename <a class="el" href="../../db/db8/structblaze_1_1TSVecForEachExprTrait.html">TSVecForEachExprTrait</a>&lt; VT, OP &gt;::Type</td></tr>
<tr class="memdesc:ga40a5bbe4b03fb2f26996d253208f5b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/db8/structblaze_1_1TSVecForEachExprTrait.html" title="Evaluation of the expression type of a sparse vector for-each operation.Via this type trait it is pos...">TSVecForEachExprTrait</a> class template.The TSVecForEachExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/db8/structblaze_1_1TSVecForEachExprTrait.html" title="Evaluation of the expression type of a sparse vector for-each operation.Via this type trait it is pos...">TSVecForEachExprTrait</a> class template. For instance, given the transpose sparse vector type <em>VT</em> and the custom operation type <em>OP</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga40a5bbe4b03fb2f26996d253208f5b04">More...</a><br /></td></tr>
<tr class="separator:ga40a5bbe4b03fb2f26996d253208f5b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8779334edcbee8fc6f3013e60c65dc2"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ST &gt; </td></tr>
<tr class="memitem:gac8779334edcbee8fc6f3013e60c65dc2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gac8779334edcbee8fc6f3013e60c65dc2">TSVecScalarDivExprTrait_</a> = typename <a class="el" href="../../d4/dfb/structblaze_1_1TSVecScalarDivExprTrait.html">TSVecScalarDivExprTrait</a>&lt; VT, ST &gt;::Type</td></tr>
<tr class="memdesc:gac8779334edcbee8fc6f3013e60c65dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/dfb/structblaze_1_1TSVecScalarDivExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/scalar division.Via this type trait it...">TSVecScalarDivExprTrait</a> class template.The TSVecScalarDivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/dfb/structblaze_1_1TSVecScalarDivExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/scalar division.Via this type trait it...">TSVecScalarDivExprTrait</a> class template. For instance, given the transpose sparse vector type <em>VT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gac8779334edcbee8fc6f3013e60c65dc2">More...</a><br /></td></tr>
<tr class="separator:gac8779334edcbee8fc6f3013e60c65dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga844cd6e282a548c517169aaf1a15d892"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ST &gt; </td></tr>
<tr class="memitem:ga844cd6e282a548c517169aaf1a15d892"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga844cd6e282a548c517169aaf1a15d892">TSVecScalarMultExprTrait_</a> = typename <a class="el" href="../../d6/d98/structblaze_1_1TSVecScalarMultExprTrait.html">TSVecScalarMultExprTrait</a>&lt; VT, ST &gt;::Type</td></tr>
<tr class="memdesc:ga844cd6e282a548c517169aaf1a15d892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d6/d98/structblaze_1_1TSVecScalarMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/scalar multiplication. Given the transpose sparse vector type VT and the scalar type ST, the nested type Type corresponds to the resulting expression type. In case either VT is not a transpose sparse vector type or ST is not a scalar type, the resulting Type is set to INVALID_TYPE. ">TSVecScalarMultExprTrait</a> class template.The TSVecScalarMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/d98/structblaze_1_1TSVecScalarMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/scalar multiplication. Given the transpose sparse vector type VT and the scalar type ST, the nested type Type corresponds to the resulting expression type. In case either VT is not a transpose sparse vector type or ST is not a scalar type, the resulting Type is set to INVALID_TYPE. ">TSVecScalarMultExprTrait</a> class template. For instance, given the transpose sparse vector type <em>VT</em> and the scalar type <em>ST</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga844cd6e282a548c517169aaf1a15d892">More...</a><br /></td></tr>
<tr class="separator:ga844cd6e282a548c517169aaf1a15d892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ff50d6f2ed7b76a7fbbed6428f88061"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga9ff50d6f2ed7b76a7fbbed6428f88061"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga9ff50d6f2ed7b76a7fbbed6428f88061">TSVecSerialExprTrait_</a> = typename <a class="el" href="../../d1/d84/structblaze_1_1TSVecSerialExprTrait.html">TSVecSerialExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:ga9ff50d6f2ed7b76a7fbbed6428f88061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d84/structblaze_1_1TSVecSerialExprTrait.html" title="Evaluation of the expression type of a sparse vector serial evaluation operation.Via this type trait ...">TSVecSerialExprTrait</a> class template.The TSVecSerialExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d84/structblaze_1_1TSVecSerialExprTrait.html" title="Evaluation of the expression type of a sparse vector serial evaluation operation.Via this type trait ...">TSVecSerialExprTrait</a> class template. For instance, given the transpose sparse vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga9ff50d6f2ed7b76a7fbbed6428f88061">More...</a><br /></td></tr>
<tr class="separator:ga9ff50d6f2ed7b76a7fbbed6428f88061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4da3162c3c5da7d783a88a6f8ea47633"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:ga4da3162c3c5da7d783a88a6f8ea47633"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga4da3162c3c5da7d783a88a6f8ea47633">TSVecSMatMultExprTrait_</a> = typename <a class="el" href="../../d7/daf/structblaze_1_1TSVecSMatMultExprTrait.html">TSVecSMatMultExprTrait</a>&lt; VT, MT &gt;::Type</td></tr>
<tr class="memdesc:ga4da3162c3c5da7d783a88a6f8ea47633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/daf/structblaze_1_1TSVecSMatMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse matrix multiplication. Given the transpose sparse vector type VT and the row-major sparse matrix type MT, the nested type Type corresponds to the resulting expression type. In case either VT is not a transpose sparse vector type or MT is not a row-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSVecSMatMultExprTrait</a> class template.The TSVecSMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/daf/structblaze_1_1TSVecSMatMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse matrix multiplication. Given the transpose sparse vector type VT and the row-major sparse matrix type MT, the nested type Type corresponds to the resulting expression type. In case either VT is not a transpose sparse vector type or MT is not a row-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSVecSMatMultExprTrait</a> class template. For instance, given the transpose sparse vector type <em>VT</em> and the row-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga4da3162c3c5da7d783a88a6f8ea47633">More...</a><br /></td></tr>
<tr class="separator:ga4da3162c3c5da7d783a88a6f8ea47633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf286be8bdfdce8891d07a11d71608f28"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gaf286be8bdfdce8891d07a11d71608f28"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaf286be8bdfdce8891d07a11d71608f28">TSVecSVecMultExprTrait_</a> = typename <a class="el" href="../../d5/d59/structblaze_1_1TSVecSVecMultExprTrait.html">TSVecSVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:gaf286be8bdfdce8891d07a11d71608f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d59/structblaze_1_1TSVecSVecMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/sparse vector multiplication (inner product). Given the transpose sparse vector type VT1 and the non-transpose sparse vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a transpose sparse vector type or VT2 is not a non-transpose sparse vector type, the resulting Type is set to INVALID_TYPE. ">TSVecSVecMultExprTrait</a> class template.The TSVecSVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d59/structblaze_1_1TSVecSVecMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/sparse vector multiplication (inner product). Given the transpose sparse vector type VT1 and the non-transpose sparse vector type VT2, the nested type Type corresponds to the resulting expression type. In case either VT1 is not a transpose sparse vector type or VT2 is not a non-transpose sparse vector type, the resulting Type is set to INVALID_TYPE. ">TSVecSVecMultExprTrait</a> class template. For instance, given the transpose sparse vector type <em>VT1</em> and non-transpose sparse vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaf286be8bdfdce8891d07a11d71608f28">More...</a><br /></td></tr>
<tr class="separator:gaf286be8bdfdce8891d07a11d71608f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58cf0de9ac8c57a55e9d1fdbc0602ba1"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:ga58cf0de9ac8c57a55e9d1fdbc0602ba1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga58cf0de9ac8c57a55e9d1fdbc0602ba1">TSVecTDMatMultExprTrait_</a> = typename <a class="el" href="../../dc/d8e/structblaze_1_1TSVecTDMatMultExprTrait.html">TSVecTDMatMultExprTrait</a>&lt; VT, MT &gt;::Type</td></tr>
<tr class="memdesc:ga58cf0de9ac8c57a55e9d1fdbc0602ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d8e/structblaze_1_1TSVecTDMatMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose dense matrix multiplication. Given the transpose sparse vector type VT and the column-major dense matrix type MT, the nested type Type corresponds to the resulting expression type. In case either VT is not a transpose sparse vector type or MT is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSVecTDMatMultExprTrait</a> class template.The TSVecTDMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/d8e/structblaze_1_1TSVecTDMatMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose dense matrix multiplication. Given the transpose sparse vector type VT and the column-major dense matrix type MT, the nested type Type corresponds to the resulting expression type. In case either VT is not a transpose sparse vector type or MT is not a column-major dense matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSVecTDMatMultExprTrait</a> class template. For instance, given the transpose sparse vector type <em>VT</em> and the column-major dense matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga58cf0de9ac8c57a55e9d1fdbc0602ba1">More...</a><br /></td></tr>
<tr class="separator:ga58cf0de9ac8c57a55e9d1fdbc0602ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fe71020b3d0ac473797893922d52875"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga4fe71020b3d0ac473797893922d52875"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga4fe71020b3d0ac473797893922d52875">TSVecTDVecAddExprTrait_</a> = typename <a class="el" href="../../d2/de5/structblaze_1_1TSVecTDVecAddExprTrait.html">TSVecTDVecAddExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga4fe71020b3d0ac473797893922d52875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/de5/structblaze_1_1TSVecTDVecAddExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/transpose dense vector addition...">TSVecTDVecAddExprTrait</a> class template.The TSVecTDVecAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/de5/structblaze_1_1TSVecTDVecAddExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/transpose dense vector addition...">TSVecTDVecAddExprTrait</a> class template. For instance, given the transpose sparse vector types <em>VT1</em> and the transpose dense vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga4fe71020b3d0ac473797893922d52875">More...</a><br /></td></tr>
<tr class="separator:ga4fe71020b3d0ac473797893922d52875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22d0742ae0bceb40c2eeb1d1bd586d25"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga22d0742ae0bceb40c2eeb1d1bd586d25"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga22d0742ae0bceb40c2eeb1d1bd586d25">TSVecTDVecCrossExprTrait_</a> = typename <a class="el" href="../../d0/d49/structblaze_1_1TSVecTDVecCrossExprTrait.html">TSVecTDVecCrossExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga22d0742ae0bceb40c2eeb1d1bd586d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/d49/structblaze_1_1TSVecTDVecCrossExprTrait.html" title="Evaluation of the expression type of a sparse vector/dense vector cross product.Via this type trait i...">TSVecTDVecCrossExprTrait</a> class template.The TSVecTDVecCrossExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/d49/structblaze_1_1TSVecTDVecCrossExprTrait.html" title="Evaluation of the expression type of a sparse vector/dense vector cross product.Via this type trait i...">TSVecTDVecCrossExprTrait</a> class template. For instance, given the transpose sparse vector types <em>VT1</em> and the transpose dense vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga22d0742ae0bceb40c2eeb1d1bd586d25">More...</a><br /></td></tr>
<tr class="separator:ga22d0742ae0bceb40c2eeb1d1bd586d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad00a17dba916f3e082d9a93df4f6b7d5"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gad00a17dba916f3e082d9a93df4f6b7d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gad00a17dba916f3e082d9a93df4f6b7d5">TSVecTDVecDivExprTrait_</a> = typename <a class="el" href="../../d2/d67/structblaze_1_1TSVecTDVecDivExprTrait.html">TSVecTDVecDivExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:gad00a17dba916f3e082d9a93df4f6b7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d67/structblaze_1_1TSVecTDVecDivExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/transpose dense vector division...">TSVecTDVecDivExprTrait</a> class template.The TSVecTDVecDivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d67/structblaze_1_1TSVecTDVecDivExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/transpose dense vector division...">TSVecTDVecDivExprTrait</a> class template. For instance, given the transpose sparse vector types <em>VT1</em> and the transpose dense vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gad00a17dba916f3e082d9a93df4f6b7d5">More...</a><br /></td></tr>
<tr class="separator:gad00a17dba916f3e082d9a93df4f6b7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6faec6af48ad1706146d84a9715af636"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga6faec6af48ad1706146d84a9715af636"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga6faec6af48ad1706146d84a9715af636">TSVecTDVecMultExprTrait_</a> = typename <a class="el" href="../../d3/da5/structblaze_1_1TSVecTDVecMultExprTrait.html">TSVecTDVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga6faec6af48ad1706146d84a9715af636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d3/da5/structblaze_1_1TSVecTDVecMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/transpose dense vector multiplication...">TSVecTDVecMultExprTrait</a> class template.The TSVecTDVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/da5/structblaze_1_1TSVecTDVecMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/transpose dense vector multiplication...">TSVecTDVecMultExprTrait</a> class template. For instance, given the transpose sparse vector types <em>VT1</em> and the transpose dense vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga6faec6af48ad1706146d84a9715af636">More...</a><br /></td></tr>
<tr class="separator:ga6faec6af48ad1706146d84a9715af636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab7ac451184b9c3e0f1e900dd946a86d"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gaab7ac451184b9c3e0f1e900dd946a86d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaab7ac451184b9c3e0f1e900dd946a86d">TSVecTDVecSubExprTrait_</a> = typename <a class="el" href="../../d3/d6e/structblaze_1_1TSVecTDVecSubExprTrait.html">TSVecTDVecSubExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:gaab7ac451184b9c3e0f1e900dd946a86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d3/d6e/structblaze_1_1TSVecTDVecSubExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/transpose dense vector subtraction...">TSVecTDVecSubExprTrait</a> class template.The TSVecTDVecSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/d6e/structblaze_1_1TSVecTDVecSubExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/transpose dense vector subtraction...">TSVecTDVecSubExprTrait</a> class template. For instance, given the transpose sparse vector types <em>VT1</em> and the transpose dense vector type <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaab7ac451184b9c3e0f1e900dd946a86d">More...</a><br /></td></tr>
<tr class="separator:gaab7ac451184b9c3e0f1e900dd946a86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe1b07964e39b76165ce95d3aa88b39a"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gabe1b07964e39b76165ce95d3aa88b39a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gabe1b07964e39b76165ce95d3aa88b39a">TSVecTransExprTrait_</a> = typename <a class="el" href="../../da/d0d/structblaze_1_1TSVecTransExprTrait.html">TSVecTransExprTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:gabe1b07964e39b76165ce95d3aa88b39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/d0d/structblaze_1_1TSVecTransExprTrait.html" title="Evaluation of the expression type of a sparse vector transpose operation.Via this type trait it is po...">TSVecTransExprTrait</a> class template.The TSVecTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/d0d/structblaze_1_1TSVecTransExprTrait.html" title="Evaluation of the expression type of a sparse vector transpose operation.Via this type trait it is po...">TSVecTransExprTrait</a> class template. For instance, given the transpose sparse vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gabe1b07964e39b76165ce95d3aa88b39a">More...</a><br /></td></tr>
<tr class="separator:gabe1b07964e39b76165ce95d3aa88b39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf11408a6d638879166eb0c113c9d888a"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:gaf11408a6d638879166eb0c113c9d888a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaf11408a6d638879166eb0c113c9d888a">TSVecTSMatMultExprTrait_</a> = typename <a class="el" href="../../d6/d8e/structblaze_1_1TSVecTSMatMultExprTrait.html">TSVecTSMatMultExprTrait</a>&lt; VT, MT &gt;::Type</td></tr>
<tr class="memdesc:gaf11408a6d638879166eb0c113c9d888a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d6/d8e/structblaze_1_1TSVecTSMatMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose sparse matrix multiplication. Given the transpose sparse vector type VT and the column-major sparse matrix type MT, the nested type Type corresponds to the resulting expression type. In case either VT is not a transpose sparse vector type or MT is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSVecTSMatMultExprTrait</a> class template.The TSVecTSMatMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/d8e/structblaze_1_1TSVecTSMatMultExprTrait.html" title="Evaluation of the expression type of a sparse vector/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose sparse matrix multiplication. Given the transpose sparse vector type VT and the column-major sparse matrix type MT, the nested type Type corresponds to the resulting expression type. In case either VT is not a transpose sparse vector type or MT is not a column-major sparse matrix type, the resulting data type Type is set to INVALID_TYPE. ">TSVecTSMatMultExprTrait</a> class template. For instance, given the transpose sparse vector type <em>VT</em> and the column-major sparse matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaf11408a6d638879166eb0c113c9d888a">More...</a><br /></td></tr>
<tr class="separator:gaf11408a6d638879166eb0c113c9d888a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427dcc7be00f58384059b339a062333b"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga427dcc7be00f58384059b339a062333b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga427dcc7be00f58384059b339a062333b">TSVecTSVecAddExprTrait_</a> = typename <a class="el" href="../../d8/d9f/structblaze_1_1TSVecTSVecAddExprTrait.html">TSVecTSVecAddExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga427dcc7be00f58384059b339a062333b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d9f/structblaze_1_1TSVecTSVecAddExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/transpose sparse vector addition...">TSVecTSVecAddExprTrait</a> class template.The TSVecTSVecAddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d9f/structblaze_1_1TSVecTSVecAddExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/transpose sparse vector addition...">TSVecTSVecAddExprTrait</a> class template. For instance, given the transpose sparse vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga427dcc7be00f58384059b339a062333b">More...</a><br /></td></tr>
<tr class="separator:ga427dcc7be00f58384059b339a062333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd7fd52d94c1daa6f2d6acf7eda21b80"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gafd7fd52d94c1daa6f2d6acf7eda21b80"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gafd7fd52d94c1daa6f2d6acf7eda21b80">TSVecTSVecCrossExprTrait_</a> = typename <a class="el" href="../../d0/d55/structblaze_1_1TSVecTSVecCrossExprTrait.html">TSVecTSVecCrossExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:gafd7fd52d94c1daa6f2d6acf7eda21b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/d55/structblaze_1_1TSVecTSVecCrossExprTrait.html" title="Evaluation of the expression type of a sparse vector/sparse vector cross product.Via this type trait ...">TSVecTSVecCrossExprTrait</a> class template.The TSVecTSVecCrossExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/d55/structblaze_1_1TSVecTSVecCrossExprTrait.html" title="Evaluation of the expression type of a sparse vector/sparse vector cross product.Via this type trait ...">TSVecTSVecCrossExprTrait</a> class template. For instance, given the transpose sparse vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gafd7fd52d94c1daa6f2d6acf7eda21b80">More...</a><br /></td></tr>
<tr class="separator:gafd7fd52d94c1daa6f2d6acf7eda21b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f3cdd4db827a2b75c313a9ad5d29637"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga9f3cdd4db827a2b75c313a9ad5d29637"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga9f3cdd4db827a2b75c313a9ad5d29637">TSVecTSVecMultExprTrait_</a> = typename <a class="el" href="../../d5/d8c/structblaze_1_1TSVecTSVecMultExprTrait.html">TSVecTSVecMultExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga9f3cdd4db827a2b75c313a9ad5d29637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d8c/structblaze_1_1TSVecTSVecMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/transpose sparse vector multiplication...">TSVecTSVecMultExprTrait</a> class template.The TSVecTSVecMultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d8c/structblaze_1_1TSVecTSVecMultExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/transpose sparse vector multiplication...">TSVecTSVecMultExprTrait</a> class template. For instance, given the transpose sparse vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga9f3cdd4db827a2b75c313a9ad5d29637">More...</a><br /></td></tr>
<tr class="separator:ga9f3cdd4db827a2b75c313a9ad5d29637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8403b5094d6467da28ddbb6926c71737"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga8403b5094d6467da28ddbb6926c71737"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga8403b5094d6467da28ddbb6926c71737">TSVecTSVecSubExprTrait_</a> = typename <a class="el" href="../../d2/d70/structblaze_1_1TSVecTSVecSubExprTrait.html">TSVecTSVecSubExprTrait</a>&lt; VT1, VT2 &gt;::Type</td></tr>
<tr class="memdesc:ga8403b5094d6467da28ddbb6926c71737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d70/structblaze_1_1TSVecTSVecSubExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/transpose sparse vector subtraction...">TSVecTSVecSubExprTrait</a> class template.The TSVecTSVecSubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d70/structblaze_1_1TSVecTSVecSubExprTrait.html" title="Evaluation of the expression type of a transpose sparse vector/transpose sparse vector subtraction...">TSVecTSVecSubExprTrait</a> class template. For instance, given the transpose sparse vector types <em>VT1</em> and <em>VT2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga8403b5094d6467da28ddbb6926c71737">More...</a><br /></td></tr>
<tr class="separator:ga8403b5094d6467da28ddbb6926c71737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b380783804d78aa5b21e51415cc3564"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga3b380783804d78aa5b21e51415cc3564"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga3b380783804d78aa5b21e51415cc3564">HighType_</a> = typename <a class="el" href="../../dc/d1e/structblaze_1_1HighType.html">HighType</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga3b380783804d78aa5b21e51415cc3564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d1e/structblaze_1_1HighType.html" title="Base template for the HighType type trait. ">HighType</a> type trait.The HighType_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/d1e/structblaze_1_1HighType.html" title="Base template for the HighType type trait. ">HighType</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga3b380783804d78aa5b21e51415cc3564">More...</a><br /></td></tr>
<tr class="separator:ga3b380783804d78aa5b21e51415cc3564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a3fa9d03c150105c91bf86867ae6777"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5a3fa9d03c150105c91bf86867ae6777"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga5a3fa9d03c150105c91bf86867ae6777">LowType_</a> = typename <a class="el" href="../../d5/d00/structblaze_1_1LowType.html">LowType</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga5a3fa9d03c150105c91bf86867ae6777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d00/structblaze_1_1LowType.html" title="Base template for the LowType type trait. ">LowType</a> type trait.The LowType_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d00/structblaze_1_1LowType.html" title="Base template for the LowType type trait. ">LowType</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga5a3fa9d03c150105c91bf86867ae6777">More...</a><br /></td></tr>
<tr class="separator:ga5a3fa9d03c150105c91bf86867ae6777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1054a603bf1d73c443e374227954a9b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1054a603bf1d73c443e374227954a9b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga1054a603bf1d73c443e374227954a9b5">RemoveAdaptor_</a> = typename <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html">RemoveAdaptor</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga1054a603bf1d73c443e374227954a9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html" title="Removal of top level adaptor types.In case the given type is an adaptor type (SymmetricMatrix, LowerMatrix, UpperMatrix, ...), the RemoveAdaptor type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved. ">RemoveAdaptor</a> type trait.The RemoveAdaptor_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html" title="Removal of top level adaptor types.In case the given type is an adaptor type (SymmetricMatrix, LowerMatrix, UpperMatrix, ...), the RemoveAdaptor type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved. ">RemoveAdaptor</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga1054a603bf1d73c443e374227954a9b5">More...</a><br /></td></tr>
<tr class="separator:ga1054a603bf1d73c443e374227954a9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21ed6b57b46e4eb4a400f581bca0f616"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga21ed6b57b46e4eb4a400f581bca0f616"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">UnderlyingBuiltin_</a> = typename <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html">UnderlyingBuiltin</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga21ed6b57b46e4eb4a400f581bca0f616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html" title="Evaluation of the underlying builtin element type of a given data type.Via this type trait it is poss...">UnderlyingBuiltin</a> type trait.The UnderlyingBuiltin_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html" title="Evaluation of the underlying builtin element type of a given data type.Via this type trait it is poss...">UnderlyingBuiltin</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">More...</a><br /></td></tr>
<tr class="separator:ga21ed6b57b46e4eb4a400f581bca0f616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d099d4d07f45ddddd62de3908b3be2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa1d099d4d07f45ddddd62de3908b3be2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaa1d099d4d07f45ddddd62de3908b3be2">UnderlyingElement_</a> = typename <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html">UnderlyingElement</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gaa1d099d4d07f45ddddd62de3908b3be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html" title="Evaluation of the element type of a given data type.Via this type trait it is possible to evaluate th...">UnderlyingElement</a> type trait.The UnderlyingElement_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html" title="Evaluation of the element type of a given data type.Via this type trait it is possible to evaluate th...">UnderlyingElement</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gaa1d099d4d07f45ddddd62de3908b3be2">More...</a><br /></td></tr>
<tr class="separator:gaa1d099d4d07f45ddddd62de3908b3be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e3f75bd557307b815516615471dc20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga11e3f75bd557307b815516615471dc20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga11e3f75bd557307b815516615471dc20">UnderlyingNumeric_</a> = typename <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html">UnderlyingNumeric</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga11e3f75bd557307b815516615471dc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html" title="Evaluation of the underlying numeric element type of a given data type.Via this type trait it is poss...">UnderlyingNumeric</a> type trait.The UnderlyingNumeric_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html" title="Evaluation of the underlying numeric element type of a given data type.Via this type trait it is poss...">UnderlyingNumeric</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga11e3f75bd557307b815516615471dc20">More...</a><br /></td></tr>
<tr class="separator:ga11e3f75bd557307b815516615471dc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab69bc69a73945474ec1e28eb904b4c40"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T  = void&gt; </td></tr>
<tr class="memitem:gab69bc69a73945474ec1e28eb904b4c40"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gab69bc69a73945474ec1e28eb904b4c40">DisableIfTrue_</a> = typename <a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html">DisableIfTrue</a>&lt; Condition, T &gt;::Type</td></tr>
<tr class="memdesc:gab69bc69a73945474ec1e28eb904b4c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary type for the <a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIfTrue class template is an auxiliary ...">DisableIfTrue</a> class template.The DisableIfTrue_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIfTrue class template is an auxiliary ...">DisableIfTrue</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d4/d3a/group__util.html#gab69bc69a73945474ec1e28eb904b4c40">More...</a><br /></td></tr>
<tr class="separator:gab69bc69a73945474ec1e28eb904b4c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebf93d6ed8011a7e73476b7d9c34f656"><td class="memTemplParams" colspan="2">template&lt;typename Condition , typename T  = void&gt; </td></tr>
<tr class="memitem:gaebf93d6ed8011a7e73476b7d9c34f656"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a> = typename <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; Condition, T &gt;::Type</td></tr>
<tr class="memdesc:gaebf93d6ed8011a7e73476b7d9c34f656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary type for the <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIf class template is an auxiliary tool...">DisableIf</a> class template.The DisableIf_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIf class template is an auxiliary tool...">DisableIf</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">More...</a><br /></td></tr>
<tr class="separator:gaebf93d6ed8011a7e73476b7d9c34f656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd728948d7bb8402576d198a5b219ed"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T  = void&gt; </td></tr>
<tr class="memitem:gaffd728948d7bb8402576d198a5b219ed"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaffd728948d7bb8402576d198a5b219ed">EnableIfTrue_</a> = typename <a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html">EnableIfTrue</a>&lt; Condition, T &gt;::Type</td></tr>
<tr class="memdesc:gaffd728948d7bb8402576d198a5b219ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary type for the <a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIfTrue class template is an auxiliary t...">EnableIfTrue</a> class template.The EnableIfTrue_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIfTrue class template is an auxiliary t...">EnableIfTrue</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d4/d3a/group__util.html#gaffd728948d7bb8402576d198a5b219ed">More...</a><br /></td></tr>
<tr class="separator:gaffd728948d7bb8402576d198a5b219ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4921d0157490569e91b4f48652561d2b"><td class="memTemplParams" colspan="2">template&lt;typename Condition , typename T  = void&gt; </td></tr>
<tr class="memitem:ga4921d0157490569e91b4f48652561d2b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a> = typename <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; Condition, T &gt;::Type</td></tr>
<tr class="memdesc:ga4921d0157490569e91b4f48652561d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIf class template is an auxiliary tool ...">EnableIf</a> class template.The EnableIf_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIf class template is an auxiliary tool ...">EnableIf</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">More...</a><br /></td></tr>
<tr class="separator:ga4921d0157490569e91b4f48652561d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e5b7b706f77970ca22837afa80d8ef"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga24e5b7b706f77970ca22837afa80d8ef">FalseType</a> = <a class="el" href="../../d4/d3a/group__util.html#gaac14970a620e557bc438e65b37004346">BoolConstant</a>&lt; false &gt;</td></tr>
<tr class="memdesc:ga24e5b7b706f77970ca22837afa80d8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type/value traits base class.The FalseType class is used as base class for type traits and value traits that evaluate to <em>false</em>. <br /></td></tr>
<tr class="separator:ga24e5b7b706f77970ca22837afa80d8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac14970a620e557bc438e65b37004346"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:gaac14970a620e557bc438e65b37004346"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaac14970a620e557bc438e65b37004346">BoolConstant</a> = <a class="el" href="../../de/d59/structblaze_1_1IntegralConstant.html">IntegralConstant</a>&lt; bool, B &gt;</td></tr>
<tr class="memdesc:gaac14970a620e557bc438e65b37004346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for a compile time constant boolean value.The BoolConstant class template represents a generic wrapper for a compile time constant boolean value. The value of a BoolConstant can be accessed via the nested <em>value</em> (which is guaranteed to be of type <code>bool</code>), the type can be accessed via the nested type definition <em>ValueType</em>.  <a href="../../d4/d3a/group__util.html#gaac14970a620e557bc438e65b37004346">More...</a><br /></td></tr>
<tr class="separator:gaac14970a620e557bc438e65b37004346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e8b3f04b070dc9e532f176e2d21087a"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga4e8b3f04b070dc9e532f176e2d21087a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga4e8b3f04b070dc9e532f176e2d21087a">IfTrue_</a> = typename <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; Condition, T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga4e8b3f04b070dc9e532f176e2d21087a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html" title="Compile time type selection.The IfTrue class template selects one of the two given types T1 and T2 de...">IfTrue</a> class template.The IfTrue_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html" title="Compile time type selection.The IfTrue class template selects one of the two given types T1 and T2 de...">IfTrue</a> class template. For instance, given the types <em>C</em>, <em>T1</em>, and <em>T2</em> the following two type definitions are identical:  <a href="../../d4/d3a/group__util.html#ga4e8b3f04b070dc9e532f176e2d21087a">More...</a><br /></td></tr>
<tr class="separator:ga4e8b3f04b070dc9e532f176e2d21087a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba6051ef1bc2e9d5a4722d0449a856a0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:gaba6051ef1bc2e9d5a4722d0449a856a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaba6051ef1bc2e9d5a4722d0449a856a0">If_</a> = typename <a class="el" href="../../d7/d0c/structblaze_1_1If.html">If</a>&lt; T1, T2, T3 &gt;::Type</td></tr>
<tr class="memdesc:gaba6051ef1bc2e9d5a4722d0449a856a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> class template.The If_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> class template. For instance, given the types <em>T1</em>, <em>T2</em>, and <em>T3</em> the following two type definitions are identical:  <a href="../../d4/d3a/group__util.html#gaba6051ef1bc2e9d5a4722d0449a856a0">More...</a><br /></td></tr>
<tr class="separator:gaba6051ef1bc2e9d5a4722d0449a856a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2da9ea9bd53246d80cc49aa7365b9e0c"><td class="memItemLeft" align="right" valign="top">
typedef std::shared_ptr&lt; <a class="el" href="../../dd/dc7/classblaze_1_1SystemClock.html">SystemClock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga2da9ea9bd53246d80cc49aa7365b9e0c">SystemClockID</a></td></tr>
<tr class="memdesc:ga2da9ea9bd53246d80cc49aa7365b9e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle for the system clock of the Blaze library. <br /></td></tr>
<tr class="separator:ga2da9ea9bd53246d80cc49aa7365b9e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b137edf32f2e47b381e4800eaa84798"><td class="memItemLeft" align="right" valign="top">
typedef std::shared_ptr&lt; const <a class="el" href="../../dd/dc7/classblaze_1_1SystemClock.html">SystemClock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga5b137edf32f2e47b381e4800eaa84798">ConstSystemClockID</a></td></tr>
<tr class="memdesc:ga5b137edf32f2e47b381e4800eaa84798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle for the system clock of the Blaze library. <br /></td></tr>
<tr class="separator:ga5b137edf32f2e47b381e4800eaa84798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga051a0e2cd81c0befe93b4fa1c0e29573"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga051a0e2cd81c0befe93b4fa1c0e29573">TrueType</a> = <a class="el" href="../../d4/d3a/group__util.html#gaac14970a620e557bc438e65b37004346">BoolConstant</a>&lt; true &gt;</td></tr>
<tr class="memdesc:ga051a0e2cd81c0befe93b4fa1c0e29573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits base class.The TrueType class is used as base class for type traits and value traits that evaluate to <em>true</em>. <br /></td></tr>
<tr class="separator:ga051a0e2cd81c0befe93b4fa1c0e29573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bfa48da1e61cdc782220984f8bd8080"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga7bfa48da1e61cdc782220984f8bd8080">byte_t</a> = unsigned char</td></tr>
<tr class="memdesc:ga7bfa48da1e61cdc782220984f8bd8080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte data type of the Blaze library.The <em>byte</em> data type is guaranteed to be an integral data type of size 1. <br /></td></tr>
<tr class="separator:ga7bfa48da1e61cdc782220984f8bd8080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa083a2327d8401d9c0597acef9c8e456"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaa083a2327d8401d9c0597acef9c8e456">large_t</a> = <a class="el" href="../../d8/dc7/classblaze_1_1int64__t.html">int64_t</a></td></tr>
<tr class="memdesc:gaa083a2327d8401d9c0597acef9c8e456"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest available signed integer data type. <br /></td></tr>
<tr class="separator:gaa083a2327d8401d9c0597acef9c8e456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bef1357e47d07efa71cb896c23517aa"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga5bef1357e47d07efa71cb896c23517aa">ularge_t</a> = <a class="el" href="../../d5/d68/classblaze_1_1uint64__t.html">uint64_t</a></td></tr>
<tr class="memdesc:ga5bef1357e47d07efa71cb896c23517aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest available unsigned integer data type. <br /></td></tr>
<tr class="separator:ga5bef1357e47d07efa71cb896c23517aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e302c5d830d74d70120fb0b0f85e949"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga1e302c5d830d74d70120fb0b0f85e949">id_t</a> = <a class="el" href="../../d4/d3a/group__util.html#ga5bef1357e47d07efa71cb896c23517aa">ularge_t</a></td></tr>
<tr class="memdesc:ga1e302c5d830d74d70120fb0b0f85e949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer data type for integral IDs. <br /></td></tr>
<tr class="separator:ga1e302c5d830d74d70120fb0b0f85e949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4d07e6853705c0c77730625effda54f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa4d07e6853705c0c77730625effda54f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaa4d07e6853705c0c77730625effda54f">AddConst_</a> = typename <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html">AddConst</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gaa4d07e6853705c0c77730625effda54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html" title="Addition of a top level &#39;const&#39; qualifier.The AddConst type trait adds a top level &#39;const&#39; qualifier ...">AddConst</a> type trait.The AddConst_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html" title="Addition of a top level &#39;const&#39; qualifier.The AddConst type trait adds a top level &#39;const&#39; qualifier ...">AddConst</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gaa4d07e6853705c0c77730625effda54f">More...</a><br /></td></tr>
<tr class="separator:gaa4d07e6853705c0c77730625effda54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929fa7c8723465e3db2d609625ca92cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga929fa7c8723465e3db2d609625ca92cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga929fa7c8723465e3db2d609625ca92cb">AddCV_</a> = typename <a class="el" href="../../df/d58/structblaze_1_1AddCV.html">AddCV</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga929fa7c8723465e3db2d609625ca92cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d58/structblaze_1_1AddCV.html" title="Addition of a top level &#39;const&#39; and &#39;volatile&#39; qualifier.The AddCV type trait adds both a top level &#39;...">AddCV</a> type trait.The AddCV_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d58/structblaze_1_1AddCV.html" title="Addition of a top level &#39;const&#39; and &#39;volatile&#39; qualifier.The AddCV type trait adds both a top level &#39;...">AddCV</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga929fa7c8723465e3db2d609625ca92cb">More...</a><br /></td></tr>
<tr class="separator:ga929fa7c8723465e3db2d609625ca92cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad44dfb9fe9000add409150fa4b7e9d63"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad44dfb9fe9000add409150fa4b7e9d63"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gad44dfb9fe9000add409150fa4b7e9d63">AddPointer_</a> = typename <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html">AddPointer</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gad44dfb9fe9000add409150fa4b7e9d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html" title="Addition of a top level pointer.The AddPointer type trait adds a top level pointer to the given type ...">AddPointer</a> type trait.The AddPointer_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html" title="Addition of a top level pointer.The AddPointer type trait adds a top level pointer to the given type ...">AddPointer</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gad44dfb9fe9000add409150fa4b7e9d63">More...</a><br /></td></tr>
<tr class="separator:gad44dfb9fe9000add409150fa4b7e9d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3a003331b1147d9cb4991a46b9ea37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1c3a003331b1147d9cb4991a46b9ea37"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga1c3a003331b1147d9cb4991a46b9ea37">AddReference_</a> = typename <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html">AddReference</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga1c3a003331b1147d9cb4991a46b9ea37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html" title="Addition of a top level reference.In case the given type T is not a reference type, the AddReference type trait adds a top level reference to the given type T. Else the resulting type Type is T. ">AddReference</a> type trait.The AddReference_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html" title="Addition of a top level reference.In case the given type T is not a reference type, the AddReference type trait adds a top level reference to the given type T. Else the resulting type Type is T. ">AddReference</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga1c3a003331b1147d9cb4991a46b9ea37">More...</a><br /></td></tr>
<tr class="separator:ga1c3a003331b1147d9cb4991a46b9ea37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8cbfccf4f9d689a42e5d670499911f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6a8cbfccf4f9d689a42e5d670499911f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga6a8cbfccf4f9d689a42e5d670499911f">AddVolatile_</a> = typename <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html">AddVolatile</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga6a8cbfccf4f9d689a42e5d670499911f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html" title="Addition of a top level &#39;volatile&#39; qualifier.The AddVolatile type trait adds a top level &#39;volatile&#39; q...">AddVolatile</a> type trait.The AddVolatile_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html" title="Addition of a top level &#39;volatile&#39; qualifier.The AddVolatile type trait adds a top level &#39;volatile&#39; q...">AddVolatile</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga6a8cbfccf4f9d689a42e5d670499911f">More...</a><br /></td></tr>
<tr class="separator:ga6a8cbfccf4f9d689a42e5d670499911f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c7cd3125c6a710a8e69ca26f4ea5b9"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga08c7cd3125c6a710a8e69ca26f4ea5b9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">CommonType_</a> = typename <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html">CommonType</a>&lt; T... &gt;::Type</td></tr>
<tr class="memdesc:ga08c7cd3125c6a710a8e69ca26f4ea5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html" title="Deduction of a type common to several types.The CommonType type trait deduces the result type of a mi...">CommonType</a> type trait.The CommonType_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html" title="Deduction of a type common to several types.The CommonType type trait deduces the result type of a mi...">CommonType</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">More...</a><br /></td></tr>
<tr class="separator:ga08c7cd3125c6a710a8e69ca26f4ea5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dc48f717dd98041ce6ebfb5a3642541"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1dc48f717dd98041ce6ebfb5a3642541"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga1dc48f717dd98041ce6ebfb5a3642541">Decay_</a> = typename <a class="el" href="../../df/dbe/structblaze_1_1Decay.html">Decay</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga1dc48f717dd98041ce6ebfb5a3642541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/dbe/structblaze_1_1Decay.html" title="Applies the type conversions for by-value function arguments.This type trait applies the type convers...">Decay</a> type trait.The Decay_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/dbe/structblaze_1_1Decay.html" title="Applies the type conversions for by-value function arguments.This type trait applies the type convers...">Decay</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga1dc48f717dd98041ce6ebfb5a3642541">More...</a><br /></td></tr>
<tr class="separator:ga1dc48f717dd98041ce6ebfb5a3642541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a76caf184ea9b940528ac368da1b577"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4a76caf184ea9b940528ac368da1b577"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga4a76caf184ea9b940528ac368da1b577">MakeSigned_</a> = typename <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html">MakeSigned</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga4a76caf184ea9b940528ac368da1b577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html" title="Compile time type conversion into a signed integral type.This type trait provides the feature to conv...">MakeSigned</a> type trait.The MakeSigned_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html" title="Compile time type conversion into a signed integral type.This type trait provides the feature to conv...">MakeSigned</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga4a76caf184ea9b940528ac368da1b577">More...</a><br /></td></tr>
<tr class="separator:ga4a76caf184ea9b940528ac368da1b577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d8cacb214951110d862d4183532c7d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7d8cacb214951110d862d4183532c7d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga7d8cacb214951110d862d4183532c7d7">MakeUnsigned_</a> = typename <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html">MakeUnsigned</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga7d8cacb214951110d862d4183532c7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html" title="Compile time type conversion into an unsigned integral type.This type trait provides the feature to c...">MakeUnsigned</a> type trait.The MakeUnsigned_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html" title="Compile time type conversion into an unsigned integral type.This type trait provides the feature to c...">MakeUnsigned</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga7d8cacb214951110d862d4183532c7d7">More...</a><br /></td></tr>
<tr class="separator:ga7d8cacb214951110d862d4183532c7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c53798803a90d594d0ef14e1481f1aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0c53798803a90d594d0ef14e1481f1aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga0c53798803a90d594d0ef14e1481f1aa">RemoveAllExtents_</a> = typename <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html">RemoveAllExtents</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga0c53798803a90d594d0ef14e1481f1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html" title="Removal of all array extents.The RemoveAllExtents type trait removes all array extents from the given...">RemoveAllExtents</a> type trait.The RemoveAllExtents_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html" title="Removal of all array extents.The RemoveAllExtents type trait removes all array extents from the given...">RemoveAllExtents</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga0c53798803a90d594d0ef14e1481f1aa">More...</a><br /></td></tr>
<tr class="separator:ga0c53798803a90d594d0ef14e1481f1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13fccfb14d335ce408ceab9457bf4df0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga13fccfb14d335ce408ceab9457bf4df0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga13fccfb14d335ce408ceab9457bf4df0">RemoveConst_</a> = typename <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html">RemoveConst</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga13fccfb14d335ce408ceab9457bf4df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> type trait.The RemoveConst_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga13fccfb14d335ce408ceab9457bf4df0">More...</a><br /></td></tr>
<tr class="separator:ga13fccfb14d335ce408ceab9457bf4df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf21820cc9ce037667f76051caf920c2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf21820cc9ce037667f76051caf920c2e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaf21820cc9ce037667f76051caf920c2e">RemoveCV_</a> = typename <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html">RemoveCV</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gaf21820cc9ce037667f76051caf920c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait.The RemoveCV_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gaf21820cc9ce037667f76051caf920c2e">More...</a><br /></td></tr>
<tr class="separator:gaf21820cc9ce037667f76051caf920c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbcd0119d3bddd693ffdb292c6e1a3a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacfbcd0119d3bddd693ffdb292c6e1a3a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gacfbcd0119d3bddd693ffdb292c6e1a3a">RemoveExtent_</a> = typename <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html">RemoveExtent</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gacfbcd0119d3bddd693ffdb292c6e1a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html" title="Removal of the top level array extent.The RemoveExtent type trait removes the top level array extent ...">RemoveExtent</a> type trait.The RemoveExtent_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html" title="Removal of the top level array extent.The RemoveExtent type trait removes the top level array extent ...">RemoveExtent</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gacfbcd0119d3bddd693ffdb292c6e1a3a">More...</a><br /></td></tr>
<tr class="separator:gacfbcd0119d3bddd693ffdb292c6e1a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6e489fdde969ad7931b740b73da1a97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac6e489fdde969ad7931b740b73da1a97"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gac6e489fdde969ad7931b740b73da1a97">RemovePointer_</a> = typename <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html">RemovePointer</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gac6e489fdde969ad7931b740b73da1a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html" title="Removal of pointer modifiers.The RemovePointer type trait removes any pointer modifiers from the give...">RemovePointer</a> type trait.The RemovePointer_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html" title="Removal of pointer modifiers.The RemovePointer type trait removes any pointer modifiers from the give...">RemovePointer</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gac6e489fdde969ad7931b740b73da1a97">More...</a><br /></td></tr>
<tr class="separator:gac6e489fdde969ad7931b740b73da1a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0beac6880fd0f492a1166e1c254e4cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa0beac6880fd0f492a1166e1c254e4cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaa0beac6880fd0f492a1166e1c254e4cb">RemoveReference_</a> = typename <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html">RemoveReference</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gaa0beac6880fd0f492a1166e1c254e4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html" title="Removal of reference modifiers.The RemoveReference type trait removes any reference modifiers from th...">RemoveReference</a> type trait.The RemoveReference_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html" title="Removal of reference modifiers.The RemoveReference type trait removes any reference modifiers from th...">RemoveReference</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gaa0beac6880fd0f492a1166e1c254e4cb">More...</a><br /></td></tr>
<tr class="separator:gaa0beac6880fd0f492a1166e1c254e4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada49326a8f411400855a3b6e376ab62d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gada49326a8f411400855a3b6e376ab62d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gada49326a8f411400855a3b6e376ab62d">RemoveVolatile_</a> = typename <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html">RemoveVolatile</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gada49326a8f411400855a3b6e376ab62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> type trait.The RemoveVolatile_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gada49326a8f411400855a3b6e376ab62d">More...</a><br /></td></tr>
<tr class="separator:gada49326a8f411400855a3b6e376ab62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga629e225abfa7be1f41cff40ecd17d5d5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga629e225abfa7be1f41cff40ecd17d5d5">InversionFlag</a> { <br />
&#160;&#160;<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5ac3740319e28f275c1b9fd29e1ac4f402">byLU</a> = 0, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a0a5e1212ca55699fbc1c19afad9afee6">byLDLT</a> = 1, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a9566686fdaf93d13a7905489fd7a53eb">byLDLH</a> = 2, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5ad05ff6d0175d8cf4a91ea39ddb7c67a2">byLLH</a> = 3, 
<br />
&#160;&#160;<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5adaef4901b1d62c57b7ecaef9fa0fdbce">asGeneral</a> = 4, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a53f1e0df9a2bb46e6e44b79cb7f37ca1">asSymmetric</a> = 5, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a0b79760c443ca06f987410e9db671090">asHermitian</a> = 6, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a2037964c1bde635a44bec66e041f460e">asLower</a> = 7, 
<br />
&#160;&#160;<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a1a71074238192f97c566b0de0a2ef232">asUniLower</a> = 8, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a422d84660adc423063d501b5dc8e8f97">asUpper</a> = 9, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5a59dbf6f76744b544df87274e70c9d826">asUniUpper</a> = 10, 
<a class="el" href="../../db/df0/group__dense__matrix.html#gga629e225abfa7be1f41cff40ecd17d5d5ab9559c7c7f5240b394de2072ef9c3de5">asDiagonal</a> = 11
<br />
 }<tr class="memdesc:ga629e225abfa7be1f41cff40ecd17d5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversion flag.The InversionFlag type enumeration represents the different types of matrix inversion algorithms that are available within the Blaze library. The following flags are available:  <a href="../../db/df0/group__dense__matrix.html#ga629e225abfa7be1f41cff40ecd17d5d5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga629e225abfa7be1f41cff40ecd17d5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80ba51df1c16662de4f801aef22974f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: bool { <b>smpAssignable</b> = !IsSMPAssignable&lt;Type&gt;::value
 }<tr class="memdesc:aa80ba51df1c16662de4f801aef22974f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for SMP assignments.  <a href="../../d2/de9/namespaceblaze.html#aa80ba51df1c16662de4f801aef22974f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa80ba51df1c16662de4f801aef22974f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad64366d49a029dfec828c27e0656858c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ad64366d49a029dfec828c27e0656858c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ad64366d49a029dfec828c27e0656858c">operator&lt;=</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ad64366d49a029dfec828c27e0656858c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="#ad64366d49a029dfec828c27e0656858c">More...</a><br /></td></tr>
<tr class="separator:ad64366d49a029dfec828c27e0656858c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad758ad59687b87663c017fe19eee961c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ad758ad59687b87663c017fe19eee961c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ad758ad59687b87663c017fe19eee961c">operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ad758ad59687b87663c017fe19eee961c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="#ad758ad59687b87663c017fe19eee961c">More...</a><br /></td></tr>
<tr class="separator:ad758ad59687b87663c017fe19eee961c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6b0ae6e6543208758f78731a1a87d5"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:a9e6b0ae6e6543208758f78731a1a87d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a9e6b0ae6e6543208758f78731a1a87d5">operator&gt;=</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:a9e6b0ae6e6543208758f78731a1a87d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="#a9e6b0ae6e6543208758f78731a1a87d5">More...</a><br /></td></tr>
<tr class="separator:a9e6b0ae6e6543208758f78731a1a87d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863334584b1a632888e4162ac4e1965b"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:a863334584b1a632888e4162ac4e1965b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a863334584b1a632888e4162ac4e1965b">operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:a863334584b1a632888e4162ac4e1965b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="#a863334584b1a632888e4162ac4e1965b">More...</a><br /></td></tr>
<tr class="separator:a863334584b1a632888e4162ac4e1965b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga25855a1d3c48eb1cb6f3f5a66842a85e">operator==</a> (T1 scalar, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a scalar value and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga25855a1d3c48eb1cb6f3f5a66842a85e">More...</a><br /></td></tr>
<tr class="separator:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8ab1683cf0ef1f675329a4d27d45751c">operator!=</a> (T1 scalar, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a scalar value and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga8ab1683cf0ef1f675329a4d27d45751c">More...</a><br /></td></tr>
<tr class="separator:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a38d325a718086ca9868451731c8e1a"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:a5a38d325a718086ca9868451731c8e1a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a5a38d325a718086ca9868451731c8e1a">operator&lt;=</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:a5a38d325a718086ca9868451731c8e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="#a5a38d325a718086ca9868451731c8e1a">More...</a><br /></td></tr>
<tr class="separator:a5a38d325a718086ca9868451731c8e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c62512759a851e43c57bffe569e23da"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:a7c62512759a851e43c57bffe569e23da"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a7c62512759a851e43c57bffe569e23da">operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:a7c62512759a851e43c57bffe569e23da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="#a7c62512759a851e43c57bffe569e23da">More...</a><br /></td></tr>
<tr class="separator:a7c62512759a851e43c57bffe569e23da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0ebf4f1d1c12bfda98557fcdefd5c6"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:a7c0ebf4f1d1c12bfda98557fcdefd5c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a7c0ebf4f1d1c12bfda98557fcdefd5c6">operator&gt;=</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:a7c0ebf4f1d1c12bfda98557fcdefd5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="#a7c0ebf4f1d1c12bfda98557fcdefd5c6">More...</a><br /></td></tr>
<tr class="separator:a7c0ebf4f1d1c12bfda98557fcdefd5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670fa090b177992074b4153c6de2673a"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:a670fa090b177992074b4153c6de2673a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a670fa090b177992074b4153c6de2673a">operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:a670fa090b177992074b4153c6de2673a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="#a670fa090b177992074b4153c6de2673a">More...</a><br /></td></tr>
<tr class="separator:a670fa090b177992074b4153c6de2673a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69a9b7ca9d7f7eb53ed37ddd2ee43874"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga69a9b7ca9d7f7eb53ed37ddd2ee43874"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT &gt;, const <a class="el" href="../../dc/dbe/classblaze_1_1DMatDeclDiagExpr.html">DMatDeclDiagExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga69a9b7ca9d7f7eb53ed37ddd2ee43874">decldiag</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga69a9b7ca9d7f7eb53ed37ddd2ee43874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-diagonal dense matrix expression <em>dm</em> as diagonal.  <a href="../../db/df0/group__dense__matrix.html#ga69a9b7ca9d7f7eb53ed37ddd2ee43874">More...</a><br /></td></tr>
<tr class="separator:ga69a9b7ca9d7f7eb53ed37ddd2ee43874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69a9b7ca9d7f7eb53ed37ddd2ee43874"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga69a9b7ca9d7f7eb53ed37ddd2ee43874"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT &gt;, const MT &amp;&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga69a9b7ca9d7f7eb53ed37ddd2ee43874">decldiag</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga69a9b7ca9d7f7eb53ed37ddd2ee43874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redeclares the given diagonal dense matrix expression <em>dm</em> as diagonal.  <a href="#ga69a9b7ca9d7f7eb53ed37ddd2ee43874">More...</a><br /></td></tr>
<tr class="separator:ga69a9b7ca9d7f7eb53ed37ddd2ee43874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d1c7499ea0f5524b537273a98f3c09c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7d1c7499ea0f5524b537273a98f3c09c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/daf/structblaze_1_1IsHermitian.html">IsHermitian</a>&lt; MT &gt;, const <a class="el" href="../../db/df9/classblaze_1_1DMatDeclHermExpr.html">DMatDeclHermExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7d1c7499ea0f5524b537273a98f3c09c">declherm</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga7d1c7499ea0f5524b537273a98f3c09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-Hermitian dense matrix expression <em>dm</em> as Hermitian.  <a href="../../db/df0/group__dense__matrix.html#ga7d1c7499ea0f5524b537273a98f3c09c">More...</a><br /></td></tr>
<tr class="separator:ga7d1c7499ea0f5524b537273a98f3c09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d1c7499ea0f5524b537273a98f3c09c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7d1c7499ea0f5524b537273a98f3c09c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d6/daf/structblaze_1_1IsHermitian.html">IsHermitian</a>&lt; MT &gt;, const MT &amp;&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga7d1c7499ea0f5524b537273a98f3c09c">declherm</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga7d1c7499ea0f5524b537273a98f3c09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redeclares the given Hermitian dense matrix expression <em>dm</em> as Hermitian.  <a href="#ga7d1c7499ea0f5524b537273a98f3c09c">More...</a><br /></td></tr>
<tr class="separator:ga7d1c7499ea0f5524b537273a98f3c09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7f9f220af2ef0545f54ff4b5c34b139"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gab7f9f220af2ef0545f54ff4b5c34b139"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT &gt;, const <a class="el" href="../../d8/d26/classblaze_1_1DMatDeclLowExpr.html">DMatDeclLowExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab7f9f220af2ef0545f54ff4b5c34b139">decllow</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gab7f9f220af2ef0545f54ff4b5c34b139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-lower dense matrix expression <em>dm</em> as lower.  <a href="../../db/df0/group__dense__matrix.html#gab7f9f220af2ef0545f54ff4b5c34b139">More...</a><br /></td></tr>
<tr class="separator:gab7f9f220af2ef0545f54ff4b5c34b139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7f9f220af2ef0545f54ff4b5c34b139"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gab7f9f220af2ef0545f54ff4b5c34b139"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT &gt;, const MT &amp;&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gab7f9f220af2ef0545f54ff4b5c34b139">decllow</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gab7f9f220af2ef0545f54ff4b5c34b139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redeclares the given lower dense matrix expression <em>dm</em> as lower.  <a href="#gab7f9f220af2ef0545f54ff4b5c34b139">More...</a><br /></td></tr>
<tr class="separator:gab7f9f220af2ef0545f54ff4b5c34b139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e0db5d90417a72a963f8dcbf3e3b6a2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga8e0db5d90417a72a963f8dcbf3e3b6a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; MT &gt;, const <a class="el" href="../../d2/db7/classblaze_1_1DMatDeclSymExpr.html">DMatDeclSymExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e0db5d90417a72a963f8dcbf3e3b6a2">declsym</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga8e0db5d90417a72a963f8dcbf3e3b6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-symmetric dense matrix expression <em>dm</em> as symmetric.  <a href="../../db/df0/group__dense__matrix.html#ga8e0db5d90417a72a963f8dcbf3e3b6a2">More...</a><br /></td></tr>
<tr class="separator:ga8e0db5d90417a72a963f8dcbf3e3b6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e0db5d90417a72a963f8dcbf3e3b6a2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga8e0db5d90417a72a963f8dcbf3e3b6a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; MT &gt;, const MT &amp;&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga8e0db5d90417a72a963f8dcbf3e3b6a2">declsym</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga8e0db5d90417a72a963f8dcbf3e3b6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redeclares the given symmetric dense matrix expression <em>dm</em> as symmetric.  <a href="#ga8e0db5d90417a72a963f8dcbf3e3b6a2">More...</a><br /></td></tr>
<tr class="separator:ga8e0db5d90417a72a963f8dcbf3e3b6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ebe177b75c6ea9edbd850b65591df1f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga8ebe177b75c6ea9edbd850b65591df1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT &gt;, const <a class="el" href="../../d5/d58/classblaze_1_1DMatDeclUppExpr.html">DMatDeclUppExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8ebe177b75c6ea9edbd850b65591df1f">declupp</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga8ebe177b75c6ea9edbd850b65591df1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-upper dense matrix expression <em>dm</em> as upper.  <a href="../../db/df0/group__dense__matrix.html#ga8ebe177b75c6ea9edbd850b65591df1f">More...</a><br /></td></tr>
<tr class="separator:ga8ebe177b75c6ea9edbd850b65591df1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ebe177b75c6ea9edbd850b65591df1f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga8ebe177b75c6ea9edbd850b65591df1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT &gt;, const MT &amp;&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga8ebe177b75c6ea9edbd850b65591df1f">declupp</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga8ebe177b75c6ea9edbd850b65591df1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redeclares the given upper dense matrix expression <em>dm</em> as upper.  <a href="#ga8ebe177b75c6ea9edbd850b65591df1f">More...</a><br /></td></tr>
<tr class="separator:ga8ebe177b75c6ea9edbd850b65591df1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b169a4b41e240ee939d6027dcf61c52"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga5b169a4b41e240ee939d6027dcf61c52"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d2d/classblaze_1_1DMatDMatAddExpr.html">DMatDMatAddExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga5b169a4b41e240ee939d6027dcf61c52">operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5b169a4b41e240ee939d6027dcf61c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two dense matrices with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga5b169a4b41e240ee939d6027dcf61c52">More...</a><br /></td></tr>
<tr class="separator:ga5b169a4b41e240ee939d6027dcf61c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c854306cabe36178ef984abdfc835f5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga8c854306cabe36178ef984abdfc835f5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d40/classblaze_1_1DMatDMatMultExpr.html">DMatDMatMultExpr</a>&lt; T1, T2, false, false, false, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8c854306cabe36178ef984abdfc835f5">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8c854306cabe36178ef984abdfc835f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two row-major dense matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga8c854306cabe36178ef984abdfc835f5">More...</a><br /></td></tr>
<tr class="separator:ga8c854306cabe36178ef984abdfc835f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7b2dabfa699f5714783cf446221758"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga1d7b2dabfa699f5714783cf446221758"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/ddb/classblaze_1_1DMatDMatSubExpr.html">DMatDMatSubExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1d7b2dabfa699f5714783cf446221758">operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1d7b2dabfa699f5714783cf446221758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two dense matrices with identical storage order ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga1d7b2dabfa699f5714783cf446221758">More...</a><br /></td></tr>
<tr class="separator:ga1d7b2dabfa699f5714783cf446221758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb316ba659766186b5348c4ffe0b59fe"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gacb316ba659766186b5348c4ffe0b59fe"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;, <a class="el" href="../../df/dce/classblaze_1_1DMatDVecMultExpr.html">DMatDVecMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gacb316ba659766186b5348c4ffe0b59fe">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gacb316ba659766186b5348c4ffe0b59fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_88.png"/>).  <a href="../../de/d90/group__dense__vector.html#gacb316ba659766186b5348c4ffe0b59fe">More...</a><br /></td></tr>
<tr class="separator:gacb316ba659766186b5348c4ffe0b59fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d8c8a472ce51608812b92a04c5e4047"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga3d8c8a472ce51608812b92a04c5e4047"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga3d8c8a472ce51608812b92a04c5e4047">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga3d8c8a472ce51608812b92a04c5e4047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense matrix-matrix multiplication expression and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_89.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga3d8c8a472ce51608812b92a04c5e4047">More...</a><br /></td></tr>
<tr class="separator:ga3d8c8a472ce51608812b92a04c5e4047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9f8190d38edb0e52d9c376da5486d6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gacb9f8190d38edb0e52d9c376da5486d6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d9a/classblaze_1_1DMatEvalExpr.html">DMatEvalExpr</a>&lt; MT, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gacb9f8190d38edb0e52d9c376da5486d6">eval</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gacb9f8190d38edb0e52d9c376da5486d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given dense matrix expression <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gacb9f8190d38edb0e52d9c376da5486d6">More...</a><br /></td></tr>
<tr class="separator:gacb9f8190d38edb0e52d9c376da5486d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbb0c018752c3e955e7ffbee96c415eb"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename OP &gt; </td></tr>
<tr class="memitem:gacbb0c018752c3e955e7ffbee96c415eb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, OP, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb">forEach</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm, OP op)</td></tr>
<tr class="memdesc:gacbb0c018752c3e955e7ffbee96c415eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gacbb0c018752c3e955e7ffbee96c415eb">More...</a><br /></td></tr>
<tr class="separator:gacbb0c018752c3e955e7ffbee96c415eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e4e90c6e2ed37ddea6203417c5596f5"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga8e4e90c6e2ed37ddea6203417c5596f5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d6/dae/structblaze_1_1Abs.html">Abs</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5">abs</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga8e4e90c6e2ed37ddea6203417c5596f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5">More...</a><br /></td></tr>
<tr class="separator:ga8e4e90c6e2ed37ddea6203417c5596f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7076fab6e413abbb8914e97c63c6ec60"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7076fab6e413abbb8914e97c63c6ec60"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d2/d67/structblaze_1_1Floor.html">Floor</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60">floor</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga7076fab6e413abbb8914e97c63c6ec60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60">More...</a><br /></td></tr>
<tr class="separator:ga7076fab6e413abbb8914e97c63c6ec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38cb77691633d93f6b0b2fc55146a04b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga38cb77691633d93f6b0b2fc55146a04b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../da/d9f/structblaze_1_1Ceil.html">Ceil</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b">ceil</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga38cb77691633d93f6b0b2fc55146a04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b">More...</a><br /></td></tr>
<tr class="separator:ga38cb77691633d93f6b0b2fc55146a04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69688d5359655080afd417a1d7fdbf40"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga69688d5359655080afd417a1d7fdbf40"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d23/structblaze_1_1Trunc.html">Trunc</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40">trunc</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga69688d5359655080afd417a1d7fdbf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40">More...</a><br /></td></tr>
<tr class="separator:ga69688d5359655080afd417a1d7fdbf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeda0fbc301f6a9849bd1aedb24e3c4bc"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaeda0fbc301f6a9849bd1aedb24e3c4bc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d83/structblaze_1_1Round.html">Round</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc">round</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaeda0fbc301f6a9849bd1aedb24e3c4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc">More...</a><br /></td></tr>
<tr class="separator:gaeda0fbc301f6a9849bd1aedb24e3c4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b5c9bdbb7e7ea2c008808d235f7055"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga23b5c9bdbb7e7ea2c008808d235f7055"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../db/ddf/structblaze_1_1Conj.html">Conj</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga23b5c9bdbb7e7ea2c008808d235f7055">conj</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga23b5c9bdbb7e7ea2c008808d235f7055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the complex conjugate of each single element of <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga23b5c9bdbb7e7ea2c008808d235f7055">More...</a><br /></td></tr>
<tr class="separator:ga23b5c9bdbb7e7ea2c008808d235f7055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48020f64de98036286379dacfa444750"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga48020f64de98036286379dacfa444750"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">CTransExprTrait_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga48020f64de98036286379dacfa444750">ctrans</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga48020f64de98036286379dacfa444750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate transpose matrix of <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga48020f64de98036286379dacfa444750">More...</a><br /></td></tr>
<tr class="separator:ga48020f64de98036286379dacfa444750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146e7401b84cc73dc213edc50bf3a236"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga146e7401b84cc73dc213edc50bf3a236"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../dd/df4/structblaze_1_1Real.html">Real</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga146e7401b84cc73dc213edc50bf3a236">real</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga146e7401b84cc73dc213edc50bf3a236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the real part of each single element of <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga146e7401b84cc73dc213edc50bf3a236">More...</a><br /></td></tr>
<tr class="separator:ga146e7401b84cc73dc213edc50bf3a236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga801fe45f59d396249b21d1e4f686f427"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga801fe45f59d396249b21d1e4f686f427"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/d61/structblaze_1_1Imag.html">Imag</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga801fe45f59d396249b21d1e4f686f427">imag</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga801fe45f59d396249b21d1e4f686f427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the imaginary part of each single element of <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga801fe45f59d396249b21d1e4f686f427">More...</a><br /></td></tr>
<tr class="separator:ga801fe45f59d396249b21d1e4f686f427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga660a4e2de4b63aac4181af49ac9160d8"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga660a4e2de4b63aac4181af49ac9160d8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d0/d06/structblaze_1_1Sqrt.html">Sqrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">sqrt</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga660a4e2de4b63aac4181af49ac9160d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">More...</a><br /></td></tr>
<tr class="separator:ga660a4e2de4b63aac4181af49ac9160d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e33f65ba5d0b7f32fe15b818d6914e6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga8e33f65ba5d0b7f32fe15b818d6914e6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/d20/structblaze_1_1InvSqrt.html">InvSqrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e33f65ba5d0b7f32fe15b818d6914e6">invsqrt</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga8e33f65ba5d0b7f32fe15b818d6914e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse square root of each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga8e33f65ba5d0b7f32fe15b818d6914e6">More...</a><br /></td></tr>
<tr class="separator:ga8e33f65ba5d0b7f32fe15b818d6914e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62c4f8c97f9e6fde1781a9ed1c0a1a62"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga62c4f8c97f9e6fde1781a9ed1c0a1a62"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d6/d4c/structblaze_1_1Cbrt.html">Cbrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62">cbrt</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga62c4f8c97f9e6fde1781a9ed1c0a1a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cubic root of each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62">More...</a><br /></td></tr>
<tr class="separator:ga62c4f8c97f9e6fde1781a9ed1c0a1a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga683192b628e107e6082a6b6876d62614"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga683192b628e107e6082a6b6876d62614"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d2/d2f/structblaze_1_1InvCbrt.html">InvCbrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga683192b628e107e6082a6b6876d62614">invcbrt</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga683192b628e107e6082a6b6876d62614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cubic root of each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga683192b628e107e6082a6b6876d62614">More...</a><br /></td></tr>
<tr class="separator:ga683192b628e107e6082a6b6876d62614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed4231fbd9f5b6bf46307753b34f039c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename DT &gt; </td></tr>
<tr class="memitem:gaed4231fbd9f5b6bf46307753b34f039c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../da/d15/structblaze_1_1Clamp.html">Clamp</a>&lt; DT &gt;, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaed4231fbd9f5b6bf46307753b34f039c">clamp</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>)</td></tr>
<tr class="memdesc:gaed4231fbd9f5b6bf46307753b34f039c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts each single element of the dense matrix <em>dm</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_94.png"/>.  <a href="../../db/df0/group__dense__matrix.html#gaed4231fbd9f5b6bf46307753b34f039c">More...</a><br /></td></tr>
<tr class="separator:gaed4231fbd9f5b6bf46307753b34f039c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b65a79150f5e9e3118257b2f77a0ed"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename ET &gt; </td></tr>
<tr class="memitem:ga04b65a79150f5e9e3118257b2f77a0ed"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/d41/structblaze_1_1Pow.html">Pow</a>&lt; ET &gt;, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga04b65a79150f5e9e3118257b2f77a0ed">pow</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm, ET <a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">exp</a>)</td></tr>
<tr class="memdesc:ga04b65a79150f5e9e3118257b2f77a0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponential value for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga04b65a79150f5e9e3118257b2f77a0ed">More...</a><br /></td></tr>
<tr class="separator:ga04b65a79150f5e9e3118257b2f77a0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3face2f497ce3065754db58ce162d4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gace3face2f497ce3065754db58ce162d4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/d45/structblaze_1_1Exp.html">Exp</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">exp</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gace3face2f497ce3065754db58ce162d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">More...</a><br /></td></tr>
<tr class="separator:gace3face2f497ce3065754db58ce162d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb31fcefbc91f1a5ec339dab928b5576"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gabb31fcefbc91f1a5ec339dab928b5576"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/dbb/structblaze_1_1Exp2.html">Exp2</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576">exp2</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gabb31fcefbc91f1a5ec339dab928b5576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gabb31fcefbc91f1a5ec339dab928b5576">More...</a><br /></td></tr>
<tr class="separator:gabb31fcefbc91f1a5ec339dab928b5576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad36748177b43e944319b880e50f238f2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad36748177b43e944319b880e50f238f2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../db/dc8/structblaze_1_1Exp10.html">Exp10</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2">exp10</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gad36748177b43e944319b880e50f238f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gad36748177b43e944319b880e50f238f2">More...</a><br /></td></tr>
<tr class="separator:gad36748177b43e944319b880e50f238f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8359ccb837055c7056c1eae56c45eb1a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga8359ccb837055c7056c1eae56c45eb1a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/d9c/structblaze_1_1Log.html">Log</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8359ccb837055c7056c1eae56c45eb1a">log</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga8359ccb837055c7056c1eae56c45eb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga8359ccb837055c7056c1eae56c45eb1a">More...</a><br /></td></tr>
<tr class="separator:ga8359ccb837055c7056c1eae56c45eb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba8707d555ca3ec8c6394d9724e2b504"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaba8707d555ca3ec8c6394d9724e2b504"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d5/dc7/structblaze_1_1Log2.html">Log2</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaba8707d555ca3ec8c6394d9724e2b504">log2</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaba8707d555ca3ec8c6394d9724e2b504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary logarithm for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gaba8707d555ca3ec8c6394d9724e2b504">More...</a><br /></td></tr>
<tr class="separator:gaba8707d555ca3ec8c6394d9724e2b504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979d59d108165583def861daf609d8ca"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga979d59d108165583def861daf609d8ca"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d33/structblaze_1_1Log10.html">Log10</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga979d59d108165583def861daf609d8ca">log10</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga979d59d108165583def861daf609d8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the common logarithm for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga979d59d108165583def861daf609d8ca">More...</a><br /></td></tr>
<tr class="separator:ga979d59d108165583def861daf609d8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a06568d5cd7314f4a0995a051d68062"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga0a06568d5cd7314f4a0995a051d68062"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d56/structblaze_1_1Sin.html">Sin</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga0a06568d5cd7314f4a0995a051d68062">sin</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga0a06568d5cd7314f4a0995a051d68062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga0a06568d5cd7314f4a0995a051d68062">More...</a><br /></td></tr>
<tr class="separator:ga0a06568d5cd7314f4a0995a051d68062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4eed6b2d7c8e03d3ba69de01a1e54ff"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gab4eed6b2d7c8e03d3ba69de01a1e54ff"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/dde/structblaze_1_1Asin.html">Asin</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab4eed6b2d7c8e03d3ba69de01a1e54ff">asin</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gab4eed6b2d7c8e03d3ba69de01a1e54ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse sine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gab4eed6b2d7c8e03d3ba69de01a1e54ff">More...</a><br /></td></tr>
<tr class="separator:gab4eed6b2d7c8e03d3ba69de01a1e54ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4111317de20c08c0a40b10182eee2539"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4111317de20c08c0a40b10182eee2539"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/d59/structblaze_1_1Sinh.html">Sinh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4111317de20c08c0a40b10182eee2539">sinh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga4111317de20c08c0a40b10182eee2539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga4111317de20c08c0a40b10182eee2539">More...</a><br /></td></tr>
<tr class="separator:ga4111317de20c08c0a40b10182eee2539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga974e5ff97f8d4c431684ca167bf5be3b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga974e5ff97f8d4c431684ca167bf5be3b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d0/d08/structblaze_1_1Asinh.html">Asinh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga974e5ff97f8d4c431684ca167bf5be3b">asinh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga974e5ff97f8d4c431684ca167bf5be3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga974e5ff97f8d4c431684ca167bf5be3b">More...</a><br /></td></tr>
<tr class="separator:ga974e5ff97f8d4c431684ca167bf5be3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6179f49533c111d0c1ed6b9181aabbe7"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga6179f49533c111d0c1ed6b9181aabbe7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/d0a/structblaze_1_1Cos.html">Cos</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga6179f49533c111d0c1ed6b9181aabbe7">cos</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga6179f49533c111d0c1ed6b9181aabbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga6179f49533c111d0c1ed6b9181aabbe7">More...</a><br /></td></tr>
<tr class="separator:ga6179f49533c111d0c1ed6b9181aabbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbea0b8e061ed390f6c7767c9104e40e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gabbea0b8e061ed390f6c7767c9104e40e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/db3/structblaze_1_1Acos.html">Acos</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gabbea0b8e061ed390f6c7767c9104e40e">acos</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gabbea0b8e061ed390f6c7767c9104e40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cosine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gabbea0b8e061ed390f6c7767c9104e40e">More...</a><br /></td></tr>
<tr class="separator:gabbea0b8e061ed390f6c7767c9104e40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb0cfa3ce6e0ca00ef6edf910149858"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga3cb0cfa3ce6e0ca00ef6edf910149858"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/db2/structblaze_1_1Cosh.html">Cosh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga3cb0cfa3ce6e0ca00ef6edf910149858">cosh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga3cb0cfa3ce6e0ca00ef6edf910149858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga3cb0cfa3ce6e0ca00ef6edf910149858">More...</a><br /></td></tr>
<tr class="separator:ga3cb0cfa3ce6e0ca00ef6edf910149858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdfd453cc8c85f2c9d65bc5d82eb52e5"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gafdfd453cc8c85f2c9d65bc5d82eb52e5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../dd/d35/structblaze_1_1Acosh.html">Acosh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gafdfd453cc8c85f2c9d65bc5d82eb52e5">acosh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gafdfd453cc8c85f2c9d65bc5d82eb52e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gafdfd453cc8c85f2c9d65bc5d82eb52e5">More...</a><br /></td></tr>
<tr class="separator:gafdfd453cc8c85f2c9d65bc5d82eb52e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90be532925f9874efae43a23918194ce"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga90be532925f9874efae43a23918194ce"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../db/d5e/structblaze_1_1Tan.html">Tan</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga90be532925f9874efae43a23918194ce">tan</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga90be532925f9874efae43a23918194ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga90be532925f9874efae43a23918194ce">More...</a><br /></td></tr>
<tr class="separator:ga90be532925f9874efae43a23918194ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab63e8615abfd73eea11c190846d8f14b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gab63e8615abfd73eea11c190846d8f14b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/dfc/structblaze_1_1Atan.html">Atan</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab63e8615abfd73eea11c190846d8f14b">atan</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gab63e8615abfd73eea11c190846d8f14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse tangent for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gab63e8615abfd73eea11c190846d8f14b">More...</a><br /></td></tr>
<tr class="separator:gab63e8615abfd73eea11c190846d8f14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3e7dda64b4203c08bf00bc0813b4d05"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac3e7dda64b4203c08bf00bc0813b4d05"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/db7/structblaze_1_1Tanh.html">Tanh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gac3e7dda64b4203c08bf00bc0813b4d05">tanh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gac3e7dda64b4203c08bf00bc0813b4d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gac3e7dda64b4203c08bf00bc0813b4d05">More...</a><br /></td></tr>
<tr class="separator:gac3e7dda64b4203c08bf00bc0813b4d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf39e95469abfd502a43219461590266a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf39e95469abfd502a43219461590266a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d4d/structblaze_1_1Atanh.html">Atanh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaf39e95469abfd502a43219461590266a">atanh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaf39e95469abfd502a43219461590266a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gaf39e95469abfd502a43219461590266a">More...</a><br /></td></tr>
<tr class="separator:gaf39e95469abfd502a43219461590266a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab93959cccb52b78dccb927b9ea0afafe"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gab93959cccb52b78dccb927b9ea0afafe"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../dd/d2c/structblaze_1_1Erf.html">Erf</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab93959cccb52b78dccb927b9ea0afafe">erf</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gab93959cccb52b78dccb927b9ea0afafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gab93959cccb52b78dccb927b9ea0afafe">More...</a><br /></td></tr>
<tr class="separator:gab93959cccb52b78dccb927b9ea0afafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8444088c1f7a23fe9ca5d44f8b736b6a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga8444088c1f7a23fe9ca5d44f8b736b6a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6a/classblaze_1_1DMatForEachExpr.html">DMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d5a/structblaze_1_1Erfc.html">Erfc</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8444088c1f7a23fe9ca5d44f8b736b6a">erfc</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga8444088c1f7a23fe9ca5d44f8b736b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complementary error function for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga8444088c1f7a23fe9ca5d44f8b736b6a">More...</a><br /></td></tr>
<tr class="separator:ga8444088c1f7a23fe9ca5d44f8b736b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f1c5357c878446236a3b6b3d0e107c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad2f1c5357c878446236a3b6b3d0e107c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d92/classblaze_1_1DMatInvExpr.html">DMatInvExpr</a>&lt; MT, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gad2f1c5357c878446236a3b6b3d0e107c">inv</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gad2f1c5357c878446236a3b6b3d0e107c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the inverse of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#gad2f1c5357c878446236a3b6b3d0e107c">More...</a><br /></td></tr>
<tr class="separator:gad2f1c5357c878446236a3b6b3d0e107c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3cd8bdcaaf316731c036deba11f2caa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:gaf3cd8bdcaaf316731c036deba11f2caa"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">DivExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaf3cd8bdcaaf316731c036deba11f2caa">operator/</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:gaf3cd8bdcaaf316731c036deba11f2caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the division of a dense matrix by a scalar value ( <img class="formulaInl" alt="$ A=B/s $" src="../../form_100.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaf3cd8bdcaaf316731c036deba11f2caa">More...</a><br /></td></tr>
<tr class="separator:gaf3cd8bdcaaf316731c036deba11f2caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3651e36c48fc68d45e799bef5163ea2e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga3651e36c48fc68d45e799bef5163ea2e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d8b/classblaze_1_1DMatScalarMultExpr.html">DMatScalarMultExpr</a>&lt; MT, <a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">UnderlyingBuiltin_</a>&lt; MT &gt;, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga3651e36c48fc68d45e799bef5163ea2e">operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga3651e36c48fc68d45e799bef5163ea2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a dense matrix ( <img class="formulaInl" alt="$ A = -B $" src="../../form_101.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga3651e36c48fc68d45e799bef5163ea2e">More...</a><br /></td></tr>
<tr class="separator:ga3651e36c48fc68d45e799bef5163ea2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9c6c94ca79de19a79b899e9bd4fe64"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga6c9c6c94ca79de19a79b899e9bd4fe64"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga6c9c6c94ca79de19a79b899e9bd4fe64">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga6c9c6c94ca79de19a79b899e9bd4fe64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense matrix and a scalar value ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_43.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga6c9c6c94ca79de19a79b899e9bd4fe64">More...</a><br /></td></tr>
<tr class="separator:ga6c9c6c94ca79de19a79b899e9bd4fe64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f085717ded20508025d1f1e1f753cdb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga4f085717ded20508025d1f1e1f753cdb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4f085717ded20508025d1f1e1f753cdb">operator*</a> (T1 scalar, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga4f085717ded20508025d1f1e1f753cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a dense matrix ( <img class="formulaInl" alt="$ A=s*B $" src="../../form_102.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga4f085717ded20508025d1f1e1f753cdb">More...</a><br /></td></tr>
<tr class="separator:ga4f085717ded20508025d1f1e1f753cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeac3b9aff5df5e547819e485321f4762"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaeac3b9aff5df5e547819e485321f4762"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dec/classblaze_1_1DMatSerialExpr.html">DMatSerialExpr</a>&lt; MT, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaeac3b9aff5df5e547819e485321f4762">serial</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaeac3b9aff5df5e547819e485321f4762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the serial evaluation of the given dense matrix expression <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gaeac3b9aff5df5e547819e485321f4762">More...</a><br /></td></tr>
<tr class="separator:gaeac3b9aff5df5e547819e485321f4762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694fc9c7f56eeb00d82c413d5d94cf77"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga694fc9c7f56eeb00d82c413d5d94cf77"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d65/classblaze_1_1DMatSMatAddExpr.html">DMatSMatAddExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga694fc9c7f56eeb00d82c413d5d94cf77">operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga694fc9c7f56eeb00d82c413d5d94cf77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a dense matrix and a sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga694fc9c7f56eeb00d82c413d5d94cf77">More...</a><br /></td></tr>
<tr class="separator:ga694fc9c7f56eeb00d82c413d5d94cf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39f46fd8e099778f075cef873b15947c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga39f46fd8e099778f075cef873b15947c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d65/classblaze_1_1DMatSMatAddExpr.html">DMatSMatAddExpr</a>&lt; T2, T1, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga39f46fd8e099778f075cef873b15947c">operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga39f46fd8e099778f075cef873b15947c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a sparse matrix and a dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga39f46fd8e099778f075cef873b15947c">More...</a><br /></td></tr>
<tr class="separator:ga39f46fd8e099778f075cef873b15947c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad2e626f5bc82316193a20e246705b88"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaad2e626f5bc82316193a20e246705b88"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/d2b/classblaze_1_1DMatSMatMultExpr.html">DMatSMatMultExpr</a>&lt; T1, T2, false, false, false, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaad2e626f5bc82316193a20e246705b88">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaad2e626f5bc82316193a20e246705b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaad2e626f5bc82316193a20e246705b88">More...</a><br /></td></tr>
<tr class="separator:gaad2e626f5bc82316193a20e246705b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f1afd8e1de67f79795d150708931b9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga02f1afd8e1de67f79795d150708931b9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/deb/classblaze_1_1DMatSMatSubExpr.html">DMatSMatSubExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga02f1afd8e1de67f79795d150708931b9">operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga02f1afd8e1de67f79795d150708931b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a dense matrix and a sparse matrix with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga02f1afd8e1de67f79795d150708931b9">More...</a><br /></td></tr>
<tr class="separator:ga02f1afd8e1de67f79795d150708931b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac606f8fa3f1df9a14aa303ae50f9beae"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gac606f8fa3f1df9a14aa303ae50f9beae"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T1 &gt;, <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt; &gt;, <a class="el" href="../../d7/d34/classblaze_1_1DMatSVecMultExpr.html">DMatSVecMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac606f8fa3f1df9a14aa303ae50f9beae">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gac606f8fa3f1df9a14aa303ae50f9beae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_88.png"/>).  <a href="../../de/d90/group__dense__vector.html#gac606f8fa3f1df9a14aa303ae50f9beae">More...</a><br /></td></tr>
<tr class="separator:gac606f8fa3f1df9a14aa303ae50f9beae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a4fe8ed77e301a17800b299a83f5fa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga08a4fe8ed77e301a17800b299a83f5fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T1 &gt; &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T2 &gt; &gt; &gt;, const <a class="el" href="../../df/dbe/classblaze_1_1DMatTDMatAddExpr.html">DMatTDMatAddExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga08a4fe8ed77e301a17800b299a83f5fa">operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga08a4fe8ed77e301a17800b299a83f5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major and a colum-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga08a4fe8ed77e301a17800b299a83f5fa">More...</a><br /></td></tr>
<tr class="separator:ga08a4fe8ed77e301a17800b299a83f5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe0f6bf94d6ac4714cd7258a456140f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1fe0f6bf94d6ac4714cd7258a456140f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T1 &gt; &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T2 &gt; &gt; &gt;, const <a class="el" href="../../df/dbe/classblaze_1_1DMatTDMatAddExpr.html">DMatTDMatAddExpr</a>&lt; T2, T1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1fe0f6bf94d6ac4714cd7258a456140f">operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1fe0f6bf94d6ac4714cd7258a456140f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga1fe0f6bf94d6ac4714cd7258a456140f">More...</a><br /></td></tr>
<tr class="separator:ga1fe0f6bf94d6ac4714cd7258a456140f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f992e6b1ce3d1bccc60ac34a38afbce"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga4f992e6b1ce3d1bccc60ac34a38afbce"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d8a/classblaze_1_1DMatTDMatMultExpr.html">DMatTDMatMultExpr</a>&lt; T1, T2, false, false, false, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4f992e6b1ce3d1bccc60ac34a38afbce">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4f992e6b1ce3d1bccc60ac34a38afbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga4f992e6b1ce3d1bccc60ac34a38afbce">More...</a><br /></td></tr>
<tr class="separator:ga4f992e6b1ce3d1bccc60ac34a38afbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b78e6b3967de95f80bb323923a38de4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5b78e6b3967de95f80bb323923a38de4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T1 &gt; &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T2 &gt; &gt; &gt;, const <a class="el" href="../../d8/d16/classblaze_1_1DMatTDMatSubExpr.html">DMatTDMatSubExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga5b78e6b3967de95f80bb323923a38de4">operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5b78e6b3967de95f80bb323923a38de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga5b78e6b3967de95f80bb323923a38de4">More...</a><br /></td></tr>
<tr class="separator:ga5b78e6b3967de95f80bb323923a38de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f4aef71c7832d132164838d3abad54c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2f4aef71c7832d132164838d3abad54c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T1 &gt; &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T2 &gt; &gt; &gt;, const <a class="el" href="../../d8/d16/classblaze_1_1DMatTDMatSubExpr.html">DMatTDMatSubExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga2f4aef71c7832d132164838d3abad54c">operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga2f4aef71c7832d132164838d3abad54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga2f4aef71c7832d132164838d3abad54c">More...</a><br /></td></tr>
<tr class="separator:ga2f4aef71c7832d132164838d3abad54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33cedfb37c70d3758406251f2389ecac"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga33cedfb37c70d3758406251f2389ecac"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/d86/classblaze_1_1DMatTransExpr.html">DMatTransExpr</a>&lt; MT,!SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga33cedfb37c70d3758406251f2389ecac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">More...</a><br /></td></tr>
<tr class="separator:ga33cedfb37c70d3758406251f2389ecac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9b2e3869791221577cba8ab897ad68"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gacb9b2e3869791221577cba8ab897ad68"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d61/classblaze_1_1DMatTSMatAddExpr.html">DMatTSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gacb9b2e3869791221577cba8ab897ad68">operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacb9b2e3869791221577cba8ab897ad68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gacb9b2e3869791221577cba8ab897ad68">More...</a><br /></td></tr>
<tr class="separator:gacb9b2e3869791221577cba8ab897ad68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1119e6cc68946e48a0620679bd6d06"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7f1119e6cc68946e48a0620679bd6d06"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d61/classblaze_1_1DMatTSMatAddExpr.html">DMatTSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7f1119e6cc68946e48a0620679bd6d06">operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7f1119e6cc68946e48a0620679bd6d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga7f1119e6cc68946e48a0620679bd6d06">More...</a><br /></td></tr>
<tr class="separator:ga7f1119e6cc68946e48a0620679bd6d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e3b505b7ed845f99d346d8d11a57769"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1e3b505b7ed845f99d346d8d11a57769"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/ddc/classblaze_1_1DMatTSMatMultExpr.html">DMatTSMatMultExpr</a>&lt; T1, T2, false, false, false, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1e3b505b7ed845f99d346d8d11a57769">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1e3b505b7ed845f99d346d8d11a57769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga1e3b505b7ed845f99d346d8d11a57769">More...</a><br /></td></tr>
<tr class="separator:ga1e3b505b7ed845f99d346d8d11a57769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a348f4c6ca1ff497f56003dd22cb66"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gad2a348f4c6ca1ff497f56003dd22cb66"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/d76/classblaze_1_1DMatTSMatSubExpr.html">DMatTSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gad2a348f4c6ca1ff497f56003dd22cb66">operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad2a348f4c6ca1ff497f56003dd22cb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gad2a348f4c6ca1ff497f56003dd22cb66">More...</a><br /></td></tr>
<tr class="separator:gad2a348f4c6ca1ff497f56003dd22cb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacade1745b146d7c63876fdd2bd755ce6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gacade1745b146d7c63876fdd2bd755ce6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/dc4/classblaze_1_1DVecDVecAddExpr.html">DVecDVecAddExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gacade1745b146d7c63876fdd2bd755ce6">operator+</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacade1745b146d7c63876fdd2bd755ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_103.png"/>).  <a href="../../de/d90/group__dense__vector.html#gacade1745b146d7c63876fdd2bd755ce6">More...</a><br /></td></tr>
<tr class="separator:gacade1745b146d7c63876fdd2bd755ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1770b0e8b860c52d8d625e53422cee96"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga1770b0e8b860c52d8d625e53422cee96"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/da6/classblaze_1_1DVecDVecCrossExpr.html">DVecDVecCrossExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga1770b0e8b860c52d8d625e53422cee96">operator%</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1770b0e8b860c52d8d625e53422cee96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_104.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga1770b0e8b860c52d8d625e53422cee96">More...</a><br /></td></tr>
<tr class="separator:ga1770b0e8b860c52d8d625e53422cee96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ae1e128530e0815556ce01b539f76b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaa3ae1e128530e0815556ce01b539f76b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/da6/classblaze_1_1DVecDVecCrossExpr.html">DVecDVecCrossExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa3ae1e128530e0815556ce01b539f76b">cross</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa3ae1e128530e0815556ce01b539f76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_104.png"/>).  <a href="../../de/d90/group__dense__vector.html#gaa3ae1e128530e0815556ce01b539f76b">More...</a><br /></td></tr>
<tr class="separator:gaa3ae1e128530e0815556ce01b539f76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3d91c1e9504042f41df62d0acba0507"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gac3d91c1e9504042f41df62d0acba0507"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d77/classblaze_1_1DVecDVecDivExpr.html">DVecDVecDivExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac3d91c1e9504042f41df62d0acba0507">operator/</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac3d91c1e9504042f41df62d0acba0507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the componentwise product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/\vec{c} $" src="../../form_106.png"/>).  <a href="../../de/d90/group__dense__vector.html#gac3d91c1e9504042f41df62d0acba0507">More...</a><br /></td></tr>
<tr class="separator:gac3d91c1e9504042f41df62d0acba0507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a0127d216ecef466edad068782d9e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaf6a0127d216ecef466edad068782d9e4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d76/classblaze_1_1DVecDVecMultExpr.html">DVecDVecMultExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaf6a0127d216ecef466edad068782d9e4">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf6a0127d216ecef466edad068782d9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_107.png"/>).  <a href="../../de/d90/group__dense__vector.html#gaf6a0127d216ecef466edad068782d9e4">More...</a><br /></td></tr>
<tr class="separator:gaf6a0127d216ecef466edad068782d9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0d441ba5993e9b6df62c534cec34c9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gafd0d441ba5993e9b6df62c534cec34c9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../de/d79/classblaze_1_1DVecDVecSubExpr.html">DVecDVecSubExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gafd0d441ba5993e9b6df62c534cec34c9">operator-</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gafd0d441ba5993e9b6df62c534cec34c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_108.png"/>).  <a href="../../de/d90/group__dense__vector.html#gafd0d441ba5993e9b6df62c534cec34c9">More...</a><br /></td></tr>
<tr class="separator:gafd0d441ba5993e9b6df62c534cec34c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9e162d0ea6b3e4493b9666c6730d690"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gab9e162d0ea6b3e4493b9666c6730d690"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/d94/classblaze_1_1DVecEvalExpr.html">DVecEvalExpr</a>&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gab9e162d0ea6b3e4493b9666c6730d690">eval</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gab9e162d0ea6b3e4493b9666c6730d690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given dense vector expression <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gab9e162d0ea6b3e4493b9666c6730d690">More...</a><br /></td></tr>
<tr class="separator:gab9e162d0ea6b3e4493b9666c6730d690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f4d09db265596c56dc5cb079c2c07c9"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename OP &gt; </td></tr>
<tr class="memitem:ga8f4d09db265596c56dc5cb079c2c07c9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, OP, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga8f4d09db265596c56dc5cb079c2c07c9">forEach</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv, OP op)</td></tr>
<tr class="memdesc:ga8f4d09db265596c56dc5cb079c2c07c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga8f4d09db265596c56dc5cb079c2c07c9">More...</a><br /></td></tr>
<tr class="separator:ga8f4d09db265596c56dc5cb079c2c07c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd7bba10f17c2f53f317a8438cfeb418"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gafd7bba10f17c2f53f317a8438cfeb418"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d6/dae/structblaze_1_1Abs.html">Abs</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gafd7bba10f17c2f53f317a8438cfeb418">abs</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gafd7bba10f17c2f53f317a8438cfeb418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gafd7bba10f17c2f53f317a8438cfeb418">More...</a><br /></td></tr>
<tr class="separator:gafd7bba10f17c2f53f317a8438cfeb418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga818d914b102e3f6c0e0775b3dc3819b1"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga818d914b102e3f6c0e0775b3dc3819b1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d2/d67/structblaze_1_1Floor.html">Floor</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga818d914b102e3f6c0e0775b3dc3819b1">floor</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga818d914b102e3f6c0e0775b3dc3819b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga818d914b102e3f6c0e0775b3dc3819b1">More...</a><br /></td></tr>
<tr class="separator:ga818d914b102e3f6c0e0775b3dc3819b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga421f07cf2933c538fec8a83aa29dac1c"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga421f07cf2933c538fec8a83aa29dac1c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../da/d9f/structblaze_1_1Ceil.html">Ceil</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga421f07cf2933c538fec8a83aa29dac1c">ceil</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga421f07cf2933c538fec8a83aa29dac1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga421f07cf2933c538fec8a83aa29dac1c">More...</a><br /></td></tr>
<tr class="separator:ga421f07cf2933c538fec8a83aa29dac1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc541864f28cdecf888a483c319450cb"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gadc541864f28cdecf888a483c319450cb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d23/structblaze_1_1Trunc.html">Trunc</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gadc541864f28cdecf888a483c319450cb">trunc</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gadc541864f28cdecf888a483c319450cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gadc541864f28cdecf888a483c319450cb">More...</a><br /></td></tr>
<tr class="separator:gadc541864f28cdecf888a483c319450cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5ecac85bc2e263956f6a2b71ca5fed"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4e5ecac85bc2e263956f6a2b71ca5fed"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d83/structblaze_1_1Round.html">Round</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4e5ecac85bc2e263956f6a2b71ca5fed">round</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga4e5ecac85bc2e263956f6a2b71ca5fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga4e5ecac85bc2e263956f6a2b71ca5fed">More...</a><br /></td></tr>
<tr class="separator:ga4e5ecac85bc2e263956f6a2b71ca5fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5016afb8a1c2628ea8ac993c0167bba0"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga5016afb8a1c2628ea8ac993c0167bba0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../db/ddf/structblaze_1_1Conj.html">Conj</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5016afb8a1c2628ea8ac993c0167bba0">conj</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga5016afb8a1c2628ea8ac993c0167bba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the complex conjugate of each single element of <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga5016afb8a1c2628ea8ac993c0167bba0">More...</a><br /></td></tr>
<tr class="separator:ga5016afb8a1c2628ea8ac993c0167bba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae702499b7bddc12298c96addd05d8449"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gae702499b7bddc12298c96addd05d8449"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">CTransExprTrait_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae702499b7bddc12298c96addd05d8449">ctrans</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gae702499b7bddc12298c96addd05d8449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate transpose vector of <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gae702499b7bddc12298c96addd05d8449">More...</a><br /></td></tr>
<tr class="separator:gae702499b7bddc12298c96addd05d8449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ac27950e2e5e526af1a317247f1dd02"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga5ac27950e2e5e526af1a317247f1dd02"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../dd/df4/structblaze_1_1Real.html">Real</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5ac27950e2e5e526af1a317247f1dd02">real</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga5ac27950e2e5e526af1a317247f1dd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the real part of each single element of <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga5ac27950e2e5e526af1a317247f1dd02">More...</a><br /></td></tr>
<tr class="separator:ga5ac27950e2e5e526af1a317247f1dd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d2e209bc3b23caf684048d5aaf05e5e"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7d2e209bc3b23caf684048d5aaf05e5e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d3/d61/structblaze_1_1Imag.html">Imag</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7d2e209bc3b23caf684048d5aaf05e5e">imag</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga7d2e209bc3b23caf684048d5aaf05e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the imaginary part of each single element of <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga7d2e209bc3b23caf684048d5aaf05e5e">More...</a><br /></td></tr>
<tr class="separator:ga7d2e209bc3b23caf684048d5aaf05e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cdb7b094e76d9b5647d6acb9569bd38"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4cdb7b094e76d9b5647d6acb9569bd38"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d0/d06/structblaze_1_1Sqrt.html">Sqrt</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4cdb7b094e76d9b5647d6acb9569bd38">sqrt</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga4cdb7b094e76d9b5647d6acb9569bd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga4cdb7b094e76d9b5647d6acb9569bd38">More...</a><br /></td></tr>
<tr class="separator:ga4cdb7b094e76d9b5647d6acb9569bd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga254fadfeed636c4299debb9b938d3ca7"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga254fadfeed636c4299debb9b938d3ca7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../df/d20/structblaze_1_1InvSqrt.html">InvSqrt</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga254fadfeed636c4299debb9b938d3ca7">invsqrt</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga254fadfeed636c4299debb9b938d3ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse square root of each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga254fadfeed636c4299debb9b938d3ca7">More...</a><br /></td></tr>
<tr class="separator:ga254fadfeed636c4299debb9b938d3ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadced64fa78f00961ed5289b090ff8ef0"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gadced64fa78f00961ed5289b090ff8ef0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d6/d4c/structblaze_1_1Cbrt.html">Cbrt</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gadced64fa78f00961ed5289b090ff8ef0">cbrt</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gadced64fa78f00961ed5289b090ff8ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cubic root of each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gadced64fa78f00961ed5289b090ff8ef0">More...</a><br /></td></tr>
<tr class="separator:gadced64fa78f00961ed5289b090ff8ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga222ed45ba36d15e5b902db11c85ec67f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga222ed45ba36d15e5b902db11c85ec67f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d2/d2f/structblaze_1_1InvCbrt.html">InvCbrt</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga222ed45ba36d15e5b902db11c85ec67f">invcbrt</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga222ed45ba36d15e5b902db11c85ec67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cubic root of each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga222ed45ba36d15e5b902db11c85ec67f">More...</a><br /></td></tr>
<tr class="separator:ga222ed45ba36d15e5b902db11c85ec67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f84cc1152672fc062b43518be95ab1c"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename DT &gt; </td></tr>
<tr class="memitem:ga8f84cc1152672fc062b43518be95ab1c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../da/d15/structblaze_1_1Clamp.html">Clamp</a>&lt; DT &gt;, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga8f84cc1152672fc062b43518be95ab1c">clamp</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>)</td></tr>
<tr class="memdesc:ga8f84cc1152672fc062b43518be95ab1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts each single element of the dense vector <em>dv</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_94.png"/>.  <a href="../../de/d90/group__dense__vector.html#ga8f84cc1152672fc062b43518be95ab1c">More...</a><br /></td></tr>
<tr class="separator:ga8f84cc1152672fc062b43518be95ab1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf572d5dc92c29ed60e2283cefd1d10cf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename ET &gt; </td></tr>
<tr class="memitem:gaf572d5dc92c29ed60e2283cefd1d10cf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d3/d41/structblaze_1_1Pow.html">Pow</a>&lt; ET &gt;, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaf572d5dc92c29ed60e2283cefd1d10cf">pow</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv, ET <a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">exp</a>)</td></tr>
<tr class="memdesc:gaf572d5dc92c29ed60e2283cefd1d10cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponential value for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gaf572d5dc92c29ed60e2283cefd1d10cf">More...</a><br /></td></tr>
<tr class="separator:gaf572d5dc92c29ed60e2283cefd1d10cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa272527c046f216852a83a5d94b9154f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa272527c046f216852a83a5d94b9154f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d4/d45/structblaze_1_1Exp.html">Exp</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa272527c046f216852a83a5d94b9154f">exp</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gaa272527c046f216852a83a5d94b9154f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gaa272527c046f216852a83a5d94b9154f">More...</a><br /></td></tr>
<tr class="separator:gaa272527c046f216852a83a5d94b9154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf83990a9f427aec173e224eaeab3d129"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaf83990a9f427aec173e224eaeab3d129"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../df/dbb/structblaze_1_1Exp2.html">Exp2</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaf83990a9f427aec173e224eaeab3d129">exp2</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gaf83990a9f427aec173e224eaeab3d129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gaf83990a9f427aec173e224eaeab3d129">More...</a><br /></td></tr>
<tr class="separator:gaf83990a9f427aec173e224eaeab3d129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8655df1d6323e10a8a730626fdb9a1f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gad8655df1d6323e10a8a730626fdb9a1f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../db/dc8/structblaze_1_1Exp10.html">Exp10</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gad8655df1d6323e10a8a730626fdb9a1f">exp10</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gad8655df1d6323e10a8a730626fdb9a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gad8655df1d6323e10a8a730626fdb9a1f">More...</a><br /></td></tr>
<tr class="separator:gad8655df1d6323e10a8a730626fdb9a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca2679cc12b62a715738fa84a28e4dfb"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaca2679cc12b62a715738fa84a28e4dfb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d3/d9c/structblaze_1_1Log.html">Log</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaca2679cc12b62a715738fa84a28e4dfb">log</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gaca2679cc12b62a715738fa84a28e4dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gaca2679cc12b62a715738fa84a28e4dfb">More...</a><br /></td></tr>
<tr class="separator:gaca2679cc12b62a715738fa84a28e4dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4279c29c4e74be42d14b1d0150d46366"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4279c29c4e74be42d14b1d0150d46366"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d5/dc7/structblaze_1_1Log2.html">Log2</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4279c29c4e74be42d14b1d0150d46366">log2</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga4279c29c4e74be42d14b1d0150d46366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary logarithm for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga4279c29c4e74be42d14b1d0150d46366">More...</a><br /></td></tr>
<tr class="separator:ga4279c29c4e74be42d14b1d0150d46366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55c25fa886f116df051075d26d1fb753"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga55c25fa886f116df051075d26d1fb753"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d33/structblaze_1_1Log10.html">Log10</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga55c25fa886f116df051075d26d1fb753">log10</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga55c25fa886f116df051075d26d1fb753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the common logarithm for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga55c25fa886f116df051075d26d1fb753">More...</a><br /></td></tr>
<tr class="separator:ga55c25fa886f116df051075d26d1fb753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ad1d012cd6ade6e72a9c8e25996b0a"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga46ad1d012cd6ade6e72a9c8e25996b0a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d56/structblaze_1_1Sin.html">Sin</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga46ad1d012cd6ade6e72a9c8e25996b0a">sin</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga46ad1d012cd6ade6e72a9c8e25996b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga46ad1d012cd6ade6e72a9c8e25996b0a">More...</a><br /></td></tr>
<tr class="separator:ga46ad1d012cd6ade6e72a9c8e25996b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6af9dd0b6755def231210676951297d"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gae6af9dd0b6755def231210676951297d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d3/dde/structblaze_1_1Asin.html">Asin</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae6af9dd0b6755def231210676951297d">asin</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gae6af9dd0b6755def231210676951297d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse sine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gae6af9dd0b6755def231210676951297d">More...</a><br /></td></tr>
<tr class="separator:gae6af9dd0b6755def231210676951297d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad84753c218d84ccad31c8876b33b6d55"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gad84753c218d84ccad31c8876b33b6d55"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d4/d59/structblaze_1_1Sinh.html">Sinh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gad84753c218d84ccad31c8876b33b6d55">sinh</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gad84753c218d84ccad31c8876b33b6d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gad84753c218d84ccad31c8876b33b6d55">More...</a><br /></td></tr>
<tr class="separator:gad84753c218d84ccad31c8876b33b6d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadef4058a35d186f861cf988108f3dc6c"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gadef4058a35d186f861cf988108f3dc6c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d0/d08/structblaze_1_1Asinh.html">Asinh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gadef4058a35d186f861cf988108f3dc6c">asinh</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gadef4058a35d186f861cf988108f3dc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gadef4058a35d186f861cf988108f3dc6c">More...</a><br /></td></tr>
<tr class="separator:gadef4058a35d186f861cf988108f3dc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga124488d50c3cdd9df01c2e3bee306c89"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga124488d50c3cdd9df01c2e3bee306c89"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../df/d0a/structblaze_1_1Cos.html">Cos</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga124488d50c3cdd9df01c2e3bee306c89">cos</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga124488d50c3cdd9df01c2e3bee306c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga124488d50c3cdd9df01c2e3bee306c89">More...</a><br /></td></tr>
<tr class="separator:ga124488d50c3cdd9df01c2e3bee306c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a9d491cb485f84cfe1b7e17bdc4eb61"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga8a9d491cb485f84cfe1b7e17bdc4eb61"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d4/db3/structblaze_1_1Acos.html">Acos</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga8a9d491cb485f84cfe1b7e17bdc4eb61">acos</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga8a9d491cb485f84cfe1b7e17bdc4eb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cosine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga8a9d491cb485f84cfe1b7e17bdc4eb61">More...</a><br /></td></tr>
<tr class="separator:ga8a9d491cb485f84cfe1b7e17bdc4eb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0739a7c3008cbbee9bfd8bab7d1fde94"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0739a7c3008cbbee9bfd8bab7d1fde94"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/db2/structblaze_1_1Cosh.html">Cosh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0739a7c3008cbbee9bfd8bab7d1fde94">cosh</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga0739a7c3008cbbee9bfd8bab7d1fde94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga0739a7c3008cbbee9bfd8bab7d1fde94">More...</a><br /></td></tr>
<tr class="separator:ga0739a7c3008cbbee9bfd8bab7d1fde94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86ca92cafeec451c51d086dec2adc292"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga86ca92cafeec451c51d086dec2adc292"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../dd/d35/structblaze_1_1Acosh.html">Acosh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga86ca92cafeec451c51d086dec2adc292">acosh</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga86ca92cafeec451c51d086dec2adc292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga86ca92cafeec451c51d086dec2adc292">More...</a><br /></td></tr>
<tr class="separator:ga86ca92cafeec451c51d086dec2adc292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad291232d8ea80c01ed82cbace35c05b2"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gad291232d8ea80c01ed82cbace35c05b2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../db/d5e/structblaze_1_1Tan.html">Tan</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gad291232d8ea80c01ed82cbace35c05b2">tan</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gad291232d8ea80c01ed82cbace35c05b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gad291232d8ea80c01ed82cbace35c05b2">More...</a><br /></td></tr>
<tr class="separator:gad291232d8ea80c01ed82cbace35c05b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac648bba175926a65e22fc2969a66bdb6"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gac648bba175926a65e22fc2969a66bdb6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../d4/dfc/structblaze_1_1Atan.html">Atan</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac648bba175926a65e22fc2969a66bdb6">atan</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gac648bba175926a65e22fc2969a66bdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse tangent for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gac648bba175926a65e22fc2969a66bdb6">More...</a><br /></td></tr>
<tr class="separator:gac648bba175926a65e22fc2969a66bdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d86ae5602340261c1b7c8d69edef69b"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0d86ae5602340261c1b7c8d69edef69b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../df/db7/structblaze_1_1Tanh.html">Tanh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0d86ae5602340261c1b7c8d69edef69b">tanh</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga0d86ae5602340261c1b7c8d69edef69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga0d86ae5602340261c1b7c8d69edef69b">More...</a><br /></td></tr>
<tr class="separator:ga0d86ae5602340261c1b7c8d69edef69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b135c95e689c60ec05d3c929215a092"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga5b135c95e689c60ec05d3c929215a092"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d4d/structblaze_1_1Atanh.html">Atanh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5b135c95e689c60ec05d3c929215a092">atanh</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga5b135c95e689c60ec05d3c929215a092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga5b135c95e689c60ec05d3c929215a092">More...</a><br /></td></tr>
<tr class="separator:ga5b135c95e689c60ec05d3c929215a092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d044e236e7617cfd99904a49311158"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa1d044e236e7617cfd99904a49311158"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../dd/d2c/structblaze_1_1Erf.html">Erf</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa1d044e236e7617cfd99904a49311158">erf</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gaa1d044e236e7617cfd99904a49311158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gaa1d044e236e7617cfd99904a49311158">More...</a><br /></td></tr>
<tr class="separator:gaa1d044e236e7617cfd99904a49311158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab965ee2325e1b323a58e52b30016455f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gab965ee2325e1b323a58e52b30016455f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d92/classblaze_1_1DVecForEachExpr.html">DVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d5a/structblaze_1_1Erfc.html">Erfc</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gab965ee2325e1b323a58e52b30016455f">erfc</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gab965ee2325e1b323a58e52b30016455f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complementary error function for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gab965ee2325e1b323a58e52b30016455f">More...</a><br /></td></tr>
<tr class="separator:gab965ee2325e1b323a58e52b30016455f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e85213787fa5d09b8e61e715cc96d1f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga4e85213787fa5d09b8e61e715cc96d1f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">DivExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4e85213787fa5d09b8e61e715cc96d1f">operator/</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga4e85213787fa5d09b8e61e715cc96d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the divison of a dense vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_109.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga4e85213787fa5d09b8e61e715cc96d1f">More...</a><br /></td></tr>
<tr class="separator:ga4e85213787fa5d09b8e61e715cc96d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aa1c7c4c32523b5eef9a7db1d4d5429"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga5aa1c7c4c32523b5eef9a7db1d4d5429"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/de8/classblaze_1_1DVecScalarMultExpr.html">DVecScalarMultExpr</a>&lt; VT, <a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">UnderlyingBuiltin_</a>&lt; VT &gt;, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5aa1c7c4c32523b5eef9a7db1d4d5429">operator-</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga5aa1c7c4c32523b5eef9a7db1d4d5429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a dense vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_110.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga5aa1c7c4c32523b5eef9a7db1d4d5429">More...</a><br /></td></tr>
<tr class="separator:ga5aa1c7c4c32523b5eef9a7db1d4d5429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad48087c374a4174e152824449de63cdc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gad48087c374a4174e152824449de63cdc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gad48087c374a4174e152824449de63cdc">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:gad48087c374a4174e152824449de63cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_51.png"/>).  <a href="../../de/d90/group__dense__vector.html#gad48087c374a4174e152824449de63cdc">More...</a><br /></td></tr>
<tr class="separator:gad48087c374a4174e152824449de63cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5630508682d993ee2fd965600287f9e1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga5630508682d993ee2fd965600287f9e1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5630508682d993ee2fd965600287f9e1">operator*</a> (T1 scalar, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga5630508682d993ee2fd965600287f9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_111.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga5630508682d993ee2fd965600287f9e1">More...</a><br /></td></tr>
<tr class="separator:ga5630508682d993ee2fd965600287f9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2668e5cb0df05ba8a40057211bcc67"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:a6f2668e5cb0df05ba8a40057211bcc67"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/de8/classblaze_1_1DVecScalarMultExpr.html">DVecScalarMultExpr</a>&lt; VT, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a6f2668e5cb0df05ba8a40057211bcc67">normalize</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:a6f2668e5cb0df05ba8a40057211bcc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalization of the dense vector ( <img class="formulaInl" alt="$|\vec{a}|=1$" src="../../form_112.png"/>).  <a href="#a6f2668e5cb0df05ba8a40057211bcc67">More...</a><br /></td></tr>
<tr class="separator:a6f2668e5cb0df05ba8a40057211bcc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a1d35bad76c6eb7ade972e00ffd6f27"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga1a1d35bad76c6eb7ade972e00ffd6f27"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/dc4/classblaze_1_1DVecSerialExpr.html">DVecSerialExpr</a>&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga1a1d35bad76c6eb7ade972e00ffd6f27">serial</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga1a1d35bad76c6eb7ade972e00ffd6f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the serial evaluation of the given dense vector expression <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga1a1d35bad76c6eb7ade972e00ffd6f27">More...</a><br /></td></tr>
<tr class="separator:ga1a1d35bad76c6eb7ade972e00ffd6f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac46fecdd6785f66d7521f88db40dd1b9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gac46fecdd6785f66d7521f88db40dd1b9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d67/classblaze_1_1DVecSVecAddExpr.html">DVecSVecAddExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac46fecdd6785f66d7521f88db40dd1b9">operator+</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac46fecdd6785f66d7521f88db40dd1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_103.png"/>).  <a href="../../de/d90/group__dense__vector.html#gac46fecdd6785f66d7521f88db40dd1b9">More...</a><br /></td></tr>
<tr class="separator:gac46fecdd6785f66d7521f88db40dd1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga362d09a6d64deafb689d21a6f7559c78"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga362d09a6d64deafb689d21a6f7559c78"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d67/classblaze_1_1DVecSVecAddExpr.html">DVecSVecAddExpr</a>&lt; T2, T1, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga362d09a6d64deafb689d21a6f7559c78">operator+</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga362d09a6d64deafb689d21a6f7559c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_103.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga362d09a6d64deafb689d21a6f7559c78">More...</a><br /></td></tr>
<tr class="separator:ga362d09a6d64deafb689d21a6f7559c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4a4714164897e1129c0836eb90c7992"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaa4a4714164897e1129c0836eb90c7992"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/da6/classblaze_1_1DVecSVecCrossExpr.html">DVecSVecCrossExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa4a4714164897e1129c0836eb90c7992">operator%</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa4a4714164897e1129c0836eb90c7992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_104.png"/>).  <a href="../../de/d90/group__dense__vector.html#gaa4a4714164897e1129c0836eb90c7992">More...</a><br /></td></tr>
<tr class="separator:gaa4a4714164897e1129c0836eb90c7992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf8c05ed0eb0b4b5253b175aafa76bb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga5cf8c05ed0eb0b4b5253b175aafa76bb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/da6/classblaze_1_1DVecSVecCrossExpr.html">DVecSVecCrossExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5cf8c05ed0eb0b4b5253b175aafa76bb">cross</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5cf8c05ed0eb0b4b5253b175aafa76bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_104.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga5cf8c05ed0eb0b4b5253b175aafa76bb">More...</a><br /></td></tr>
<tr class="separator:ga5cf8c05ed0eb0b4b5253b175aafa76bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../de/dd2/classblaze_1_1DVecSVecMultExpr.html">DVecSVecMultExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gab3fbcd035fcb7ffda672fbc102afb585">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab3fbcd035fcb7ffda672fbc102afb585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_107.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gab3fbcd035fcb7ffda672fbc102afb585">More...</a><br /></td></tr>
<tr class="separator:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/de0/classblaze_1_1DVecSVecSubExpr.html">DVecSVecSubExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4d9d2740625e6b7d83d77e0284ae21e4">operator-</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_108.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga4d9d2740625e6b7d83d77e0284ae21e4">More...</a><br /></td></tr>
<tr class="separator:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga282c791c739c8c0d1d8e7c82bf0391ad"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga282c791c739c8c0d1d8e7c82bf0391ad"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/dcd/classblaze_1_1DVecTDVecMultExpr.html">DVecTDVecMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga282c791c739c8c0d1d8e7c82bf0391ad">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga282c791c739c8c0d1d8e7c82bf0391ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the outer product of two dense vectors ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_113.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga282c791c739c8c0d1d8e7c82bf0391ad">More...</a><br /></td></tr>
<tr class="separator:ga282c791c739c8c0d1d8e7c82bf0391ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e5a90bbef3aed0d646c7658e9130252"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga6e5a90bbef3aed0d646c7658e9130252"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/db6/classblaze_1_1DVecTransExpr.html">DVecTransExpr</a>&lt; VT,!TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga6e5a90bbef3aed0d646c7658e9130252">trans</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga6e5a90bbef3aed0d646c7658e9130252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given dense vector.  <a href="../../de/d90/group__dense__vector.html#ga6e5a90bbef3aed0d646c7658e9130252">More...</a><br /></td></tr>
<tr class="separator:ga6e5a90bbef3aed0d646c7658e9130252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd2a470dd21fec4c42c12135e2bcbb4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaebd2a470dd21fec4c42c12135e2bcbb4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/da5/classblaze_1_1DVecTSVecMultExpr.html">DVecTSVecMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaebd2a470dd21fec4c42c12135e2bcbb4">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaebd2a470dd21fec4c42c12135e2bcbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the dense vector-sparse vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_113.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaebd2a470dd21fec4c42c12135e2bcbb4">More...</a><br /></td></tr>
<tr class="separator:gaebd2a470dd21fec4c42c12135e2bcbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24d22f5812d106f439ea9d7e72cd78d8"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga24d22f5812d106f439ea9d7e72cd78d8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dd7/classblaze_1_1SVecTransExpr.html">SVecTransExpr</a>&lt; VT,!TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga24d22f5812d106f439ea9d7e72cd78d8">trans</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga24d22f5812d106f439ea9d7e72cd78d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given sparse vector.  <a href="../../d6/d2f/group__sparse__vector.html#ga24d22f5812d106f439ea9d7e72cd78d8">More...</a><br /></td></tr>
<tr class="separator:ga24d22f5812d106f439ea9d7e72cd78d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c5bf80756338642cfcaff18b96ff7e6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga9c5bf80756338642cfcaff18b96ff7e6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/d09/classblaze_1_1SMatTransExpr.html">SMatTransExpr</a>&lt; MT,!SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga9c5bf80756338642cfcaff18b96ff7e6">trans</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga9c5bf80756338642cfcaff18b96ff7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given sparse matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga9c5bf80756338642cfcaff18b96ff7e6">More...</a><br /></td></tr>
<tr class="separator:ga9c5bf80756338642cfcaff18b96ff7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43666f6cb23c23f8cff15a5195ce2852"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga43666f6cb23c23f8cff15a5195ce2852"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/ddd/classblaze_1_1SVecSerialExpr.html">SVecSerialExpr</a>&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga43666f6cb23c23f8cff15a5195ce2852">serial</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga43666f6cb23c23f8cff15a5195ce2852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the serial evaluation of the given sparse vector expression <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga43666f6cb23c23f8cff15a5195ce2852">More...</a><br /></td></tr>
<tr class="separator:ga43666f6cb23c23f8cff15a5195ce2852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ccba470284d1a9e137ff88b09be550e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga5ccba470284d1a9e137ff88b09be550e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/dc8/classblaze_1_1SMatSerialExpr.html">SMatSerialExpr</a>&lt; MT, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga5ccba470284d1a9e137ff88b09be550e">serial</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga5ccba470284d1a9e137ff88b09be550e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the serial evaluation of the given sparse matrix expression <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga5ccba470284d1a9e137ff88b09be550e">More...</a><br /></td></tr>
<tr class="separator:ga5ccba470284d1a9e137ff88b09be550e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5335cfd53f63e8ffb35b5fe2ffc25aea"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename OP &gt; </td></tr>
<tr class="memitem:ga5335cfd53f63e8ffb35b5fe2ffc25aea"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, OP, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga5335cfd53f63e8ffb35b5fe2ffc25aea">forEach</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv, OP op)</td></tr>
<tr class="memdesc:ga5335cfd53f63e8ffb35b5fe2ffc25aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga5335cfd53f63e8ffb35b5fe2ffc25aea">More...</a><br /></td></tr>
<tr class="separator:ga5335cfd53f63e8ffb35b5fe2ffc25aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22ca357aeee42c5e4177238755fc158f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename OP &gt; </td></tr>
<tr class="memitem:ga22ca357aeee42c5e4177238755fc158f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, OP, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga22ca357aeee42c5e4177238755fc158f">forEach</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm, OP op)</td></tr>
<tr class="memdesc:ga22ca357aeee42c5e4177238755fc158f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga22ca357aeee42c5e4177238755fc158f">More...</a><br /></td></tr>
<tr class="separator:ga22ca357aeee42c5e4177238755fc158f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83307ec51c557abe636bf98cf539b77a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga83307ec51c557abe636bf98cf539b77a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga83307ec51c557abe636bf98cf539b77a">ctranspose</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix)</td></tr>
<tr class="memdesc:ga83307ec51c557abe636bf98cf539b77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place conjugate transpose of the given matrix.  <a href="../../dd/d7a/group__matrix.html#ga83307ec51c557abe636bf98cf539b77a">More...</a><br /></td></tr>
<tr class="separator:ga83307ec51c557abe636bf98cf539b77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d22caf00780add553e8ef31199bbc6d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4d22caf00780add553e8ef31199bbc6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT &gt;, const <a class="el" href="../../d1/d98/classblaze_1_1SMatDeclDiagExpr.html">SMatDeclDiagExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4d22caf00780add553e8ef31199bbc6d">decldiag</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga4d22caf00780add553e8ef31199bbc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-diagonal sparse matrix expression <em>sm</em> as diagonal.  <a href="../../d0/d45/group__sparse__matrix.html#ga4d22caf00780add553e8ef31199bbc6d">More...</a><br /></td></tr>
<tr class="separator:ga4d22caf00780add553e8ef31199bbc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d22caf00780add553e8ef31199bbc6d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4d22caf00780add553e8ef31199bbc6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT &gt;, const MT &amp;&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga4d22caf00780add553e8ef31199bbc6d">decldiag</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga4d22caf00780add553e8ef31199bbc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redeclares the given diagonal sparse matrix expression <em>sm</em> as diagonal.  <a href="#ga4d22caf00780add553e8ef31199bbc6d">More...</a><br /></td></tr>
<tr class="separator:ga4d22caf00780add553e8ef31199bbc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648c564eb671f51f21076710551b20f4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga648c564eb671f51f21076710551b20f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/daf/structblaze_1_1IsHermitian.html">IsHermitian</a>&lt; MT &gt;, const <a class="el" href="../../d9/d8a/classblaze_1_1SMatDeclHermExpr.html">SMatDeclHermExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga648c564eb671f51f21076710551b20f4">declherm</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga648c564eb671f51f21076710551b20f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-Hermitian sparse matrix expression <em>sm</em> as Hermitian.  <a href="../../d0/d45/group__sparse__matrix.html#ga648c564eb671f51f21076710551b20f4">More...</a><br /></td></tr>
<tr class="separator:ga648c564eb671f51f21076710551b20f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648c564eb671f51f21076710551b20f4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga648c564eb671f51f21076710551b20f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d6/daf/structblaze_1_1IsHermitian.html">IsHermitian</a>&lt; MT &gt;, const MT &amp;&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga648c564eb671f51f21076710551b20f4">declherm</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga648c564eb671f51f21076710551b20f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redeclares the given Hermitian sparse matrix expression <em>sm</em> as Hermitian.  <a href="#ga648c564eb671f51f21076710551b20f4">More...</a><br /></td></tr>
<tr class="separator:ga648c564eb671f51f21076710551b20f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae87fc98150845d427d4f991b02e29d6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaae87fc98150845d427d4f991b02e29d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT &gt;, const <a class="el" href="../../d3/d3c/classblaze_1_1SMatDeclLowExpr.html">SMatDeclLowExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaae87fc98150845d427d4f991b02e29d6">decllow</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaae87fc98150845d427d4f991b02e29d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-lower sparse matrix expression <em>sm</em> as lower.  <a href="../../d0/d45/group__sparse__matrix.html#gaae87fc98150845d427d4f991b02e29d6">More...</a><br /></td></tr>
<tr class="separator:gaae87fc98150845d427d4f991b02e29d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae87fc98150845d427d4f991b02e29d6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaae87fc98150845d427d4f991b02e29d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT &gt;, const MT &amp;&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gaae87fc98150845d427d4f991b02e29d6">decllow</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaae87fc98150845d427d4f991b02e29d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redeclares the given lower sparse matrix expression <em>sm</em> as lower.  <a href="#gaae87fc98150845d427d4f991b02e29d6">More...</a><br /></td></tr>
<tr class="separator:gaae87fc98150845d427d4f991b02e29d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae57991e440a9182c47df1bdb5a7b3777"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae57991e440a9182c47df1bdb5a7b3777"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; MT &gt;, const <a class="el" href="../../da/da0/classblaze_1_1SMatDeclSymExpr.html">SMatDeclSymExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gae57991e440a9182c47df1bdb5a7b3777">declsym</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gae57991e440a9182c47df1bdb5a7b3777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-symmetric sparse matrix expression <em>sm</em> as symmetric.  <a href="../../d0/d45/group__sparse__matrix.html#gae57991e440a9182c47df1bdb5a7b3777">More...</a><br /></td></tr>
<tr class="separator:gae57991e440a9182c47df1bdb5a7b3777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae57991e440a9182c47df1bdb5a7b3777"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae57991e440a9182c47df1bdb5a7b3777"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; MT &gt;, const MT &amp;&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gae57991e440a9182c47df1bdb5a7b3777">declsym</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gae57991e440a9182c47df1bdb5a7b3777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redeclares the given symmetric sparse matrix expression <em>sm</em> as symmetric.  <a href="#gae57991e440a9182c47df1bdb5a7b3777">More...</a><br /></td></tr>
<tr class="separator:gae57991e440a9182c47df1bdb5a7b3777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2bcedc4df50276d86ae996d5e14db46"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf2bcedc4df50276d86ae996d5e14db46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT &gt;, const <a class="el" href="../../d5/df5/classblaze_1_1SMatDeclUppExpr.html">SMatDeclUppExpr</a>&lt; MT, SO &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaf2bcedc4df50276d86ae996d5e14db46">declupp</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaf2bcedc4df50276d86ae996d5e14db46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given non-upper sparse matrix expression <em>sm</em> as upper.  <a href="../../d0/d45/group__sparse__matrix.html#gaf2bcedc4df50276d86ae996d5e14db46">More...</a><br /></td></tr>
<tr class="separator:gaf2bcedc4df50276d86ae996d5e14db46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2bcedc4df50276d86ae996d5e14db46"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf2bcedc4df50276d86ae996d5e14db46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT &gt;, const MT &amp;&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gaf2bcedc4df50276d86ae996d5e14db46">declupp</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaf2bcedc4df50276d86ae996d5e14db46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redeclares the given upper sparse matrix expression <em>sm</em> as upper.  <a href="#gaf2bcedc4df50276d86ae996d5e14db46">More...</a><br /></td></tr>
<tr class="separator:gaf2bcedc4df50276d86ae996d5e14db46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf770138077bc9a101f7da6571a58c1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gabaf770138077bc9a101f7da6571a58c1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/dc5/classblaze_1_1SMatDMatMultExpr.html">SMatDMatMultExpr</a>&lt; T1, T2, false, false, false, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gabaf770138077bc9a101f7da6571a58c1">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabaf770138077bc9a101f7da6571a58c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gabaf770138077bc9a101f7da6571a58c1">More...</a><br /></td></tr>
<tr class="separator:gabaf770138077bc9a101f7da6571a58c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7889e29abeda750915b8c5a2fc061242"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga7889e29abeda750915b8c5a2fc061242"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/db6/classblaze_1_1SMatDMatSubExpr.html">SMatDMatSubExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7889e29abeda750915b8c5a2fc061242">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7889e29abeda750915b8c5a2fc061242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a sparse matrix and a dense matrix with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga7889e29abeda750915b8c5a2fc061242">More...</a><br /></td></tr>
<tr class="separator:ga7889e29abeda750915b8c5a2fc061242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6274b71ae257037e9d8bb92a02fd478"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gac6274b71ae257037e9d8bb92a02fd478"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;, <a class="el" href="../../d5/d53/classblaze_1_1SMatDVecMultExpr.html">SMatDVecMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac6274b71ae257037e9d8bb92a02fd478">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gac6274b71ae257037e9d8bb92a02fd478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_88.png"/>).  <a href="../../de/d90/group__dense__vector.html#gac6274b71ae257037e9d8bb92a02fd478">More...</a><br /></td></tr>
<tr class="separator:gac6274b71ae257037e9d8bb92a02fd478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156d3b5aeb7dca588038aa425f90fbbe"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga156d3b5aeb7dca588038aa425f90fbbe"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga156d3b5aeb7dca588038aa425f90fbbe">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga156d3b5aeb7dca588038aa425f90fbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse matrix-matrix multiplication expression and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_89.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga156d3b5aeb7dca588038aa425f90fbbe">More...</a><br /></td></tr>
<tr class="separator:ga156d3b5aeb7dca588038aa425f90fbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae18cc9f2429336161ac3cdc8087b0fd2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae18cc9f2429336161ac3cdc8087b0fd2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/da4/classblaze_1_1SMatEvalExpr.html">SMatEvalExpr</a>&lt; MT, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gae18cc9f2429336161ac3cdc8087b0fd2">eval</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gae18cc9f2429336161ac3cdc8087b0fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given sparse matrix expression <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gae18cc9f2429336161ac3cdc8087b0fd2">More...</a><br /></td></tr>
<tr class="separator:gae18cc9f2429336161ac3cdc8087b0fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1e7ea11bb8081ffe32dd392262fa5a6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa1e7ea11bb8081ffe32dd392262fa5a6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d6/dae/structblaze_1_1Abs.html">Abs</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa1e7ea11bb8081ffe32dd392262fa5a6">abs</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaa1e7ea11bb8081ffe32dd392262fa5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaa1e7ea11bb8081ffe32dd392262fa5a6">More...</a><br /></td></tr>
<tr class="separator:gaa1e7ea11bb8081ffe32dd392262fa5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga358be78cf8b2a53deada8c0c8ae6f8a5"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga358be78cf8b2a53deada8c0c8ae6f8a5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d2/d67/structblaze_1_1Floor.html">Floor</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga358be78cf8b2a53deada8c0c8ae6f8a5">floor</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga358be78cf8b2a53deada8c0c8ae6f8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga358be78cf8b2a53deada8c0c8ae6f8a5">More...</a><br /></td></tr>
<tr class="separator:ga358be78cf8b2a53deada8c0c8ae6f8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaada72ea153bb5e043f70d41581d27a82"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaada72ea153bb5e043f70d41581d27a82"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../da/d9f/structblaze_1_1Ceil.html">Ceil</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaada72ea153bb5e043f70d41581d27a82">ceil</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaada72ea153bb5e043f70d41581d27a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaada72ea153bb5e043f70d41581d27a82">More...</a><br /></td></tr>
<tr class="separator:gaada72ea153bb5e043f70d41581d27a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029ccca19a29c1a54b6715de4a5b4982"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga029ccca19a29c1a54b6715de4a5b4982"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d23/structblaze_1_1Trunc.html">Trunc</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga029ccca19a29c1a54b6715de4a5b4982">trunc</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga029ccca19a29c1a54b6715de4a5b4982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga029ccca19a29c1a54b6715de4a5b4982">More...</a><br /></td></tr>
<tr class="separator:ga029ccca19a29c1a54b6715de4a5b4982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf00020b2c03a0c9c62f5ddb682d2765d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf00020b2c03a0c9c62f5ddb682d2765d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d83/structblaze_1_1Round.html">Round</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaf00020b2c03a0c9c62f5ddb682d2765d">round</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaf00020b2c03a0c9c62f5ddb682d2765d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaf00020b2c03a0c9c62f5ddb682d2765d">More...</a><br /></td></tr>
<tr class="separator:gaf00020b2c03a0c9c62f5ddb682d2765d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34213ece5d2649ff1eed14be29160671"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga34213ece5d2649ff1eed14be29160671"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../db/ddf/structblaze_1_1Conj.html">Conj</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga34213ece5d2649ff1eed14be29160671">conj</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga34213ece5d2649ff1eed14be29160671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the complex conjugate of each single element of <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga34213ece5d2649ff1eed14be29160671">More...</a><br /></td></tr>
<tr class="separator:ga34213ece5d2649ff1eed14be29160671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2bd5f850fb678bdc31e41d840de9510"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad2bd5f850fb678bdc31e41d840de9510"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">CTransExprTrait_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gad2bd5f850fb678bdc31e41d840de9510">ctrans</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gad2bd5f850fb678bdc31e41d840de9510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate transpose matrix of <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gad2bd5f850fb678bdc31e41d840de9510">More...</a><br /></td></tr>
<tr class="separator:gad2bd5f850fb678bdc31e41d840de9510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8c02698aee64e2916bb86755d6a98cc"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf8c02698aee64e2916bb86755d6a98cc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../dd/df4/structblaze_1_1Real.html">Real</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaf8c02698aee64e2916bb86755d6a98cc">real</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaf8c02698aee64e2916bb86755d6a98cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the real parts of each single element of <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaf8c02698aee64e2916bb86755d6a98cc">More...</a><br /></td></tr>
<tr class="separator:gaf8c02698aee64e2916bb86755d6a98cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd3250ab45273ee41e204887b67542d6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gacd3250ab45273ee41e204887b67542d6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/d61/structblaze_1_1Imag.html">Imag</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gacd3250ab45273ee41e204887b67542d6">imag</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gacd3250ab45273ee41e204887b67542d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the imaginary parts of each single element of <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gacd3250ab45273ee41e204887b67542d6">More...</a><br /></td></tr>
<tr class="separator:gacd3250ab45273ee41e204887b67542d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeb91b0d7402619f999384384217328a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gafeb91b0d7402619f999384384217328a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d0/d06/structblaze_1_1Sqrt.html">Sqrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gafeb91b0d7402619f999384384217328a">sqrt</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gafeb91b0d7402619f999384384217328a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gafeb91b0d7402619f999384384217328a">More...</a><br /></td></tr>
<tr class="separator:gafeb91b0d7402619f999384384217328a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9c7ceebe89f74089dae4fc14ec0b4e9"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa9c7ceebe89f74089dae4fc14ec0b4e9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/d20/structblaze_1_1InvSqrt.html">InvSqrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa9c7ceebe89f74089dae4fc14ec0b4e9">invsqrt</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaa9c7ceebe89f74089dae4fc14ec0b4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse square root of each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaa9c7ceebe89f74089dae4fc14ec0b4e9">More...</a><br /></td></tr>
<tr class="separator:gaa9c7ceebe89f74089dae4fc14ec0b4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a8595eb108e7db65b840639c1876f29"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4a8595eb108e7db65b840639c1876f29"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d6/d4c/structblaze_1_1Cbrt.html">Cbrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4a8595eb108e7db65b840639c1876f29">cbrt</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga4a8595eb108e7db65b840639c1876f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cubic root of each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga4a8595eb108e7db65b840639c1876f29">More...</a><br /></td></tr>
<tr class="separator:ga4a8595eb108e7db65b840639c1876f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bcce93825df78b16f67a4e987165066"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4bcce93825df78b16f67a4e987165066"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d2/d2f/structblaze_1_1InvCbrt.html">InvCbrt</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4bcce93825df78b16f67a4e987165066">invcbrt</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga4bcce93825df78b16f67a4e987165066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cubic root of each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga4bcce93825df78b16f67a4e987165066">More...</a><br /></td></tr>
<tr class="separator:ga4bcce93825df78b16f67a4e987165066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37c9b2975d69391340b27767a56addc"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename DT &gt; </td></tr>
<tr class="memitem:gab37c9b2975d69391340b27767a56addc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../da/d15/structblaze_1_1Clamp.html">Clamp</a>&lt; DT &gt;, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gab37c9b2975d69391340b27767a56addc">clamp</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>)</td></tr>
<tr class="memdesc:gab37c9b2975d69391340b27767a56addc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts each single element of the sparse matrix <em>sm</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_94.png"/>.  <a href="../../d0/d45/group__sparse__matrix.html#gab37c9b2975d69391340b27767a56addc">More...</a><br /></td></tr>
<tr class="separator:gab37c9b2975d69391340b27767a56addc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d48ddafc58459876471f1cd1400660"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename ET &gt; </td></tr>
<tr class="memitem:ga39d48ddafc58459876471f1cd1400660"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/d41/structblaze_1_1Pow.html">Pow</a>&lt; ET &gt;, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga39d48ddafc58459876471f1cd1400660">pow</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm, ET <a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">exp</a>)</td></tr>
<tr class="memdesc:ga39d48ddafc58459876471f1cd1400660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponential value for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga39d48ddafc58459876471f1cd1400660">More...</a><br /></td></tr>
<tr class="separator:ga39d48ddafc58459876471f1cd1400660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f88b09a654056d8c02f29e886884485"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7f88b09a654056d8c02f29e886884485"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/d45/structblaze_1_1Exp.html">Exp</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga7f88b09a654056d8c02f29e886884485">exp</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga7f88b09a654056d8c02f29e886884485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga7f88b09a654056d8c02f29e886884485">More...</a><br /></td></tr>
<tr class="separator:ga7f88b09a654056d8c02f29e886884485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d6c42bcba2324f95299765cfa4eaedd"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga6d6c42bcba2324f95299765cfa4eaedd"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/dbb/structblaze_1_1Exp2.html">Exp2</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga6d6c42bcba2324f95299765cfa4eaedd">exp2</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga6d6c42bcba2324f95299765cfa4eaedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga6d6c42bcba2324f95299765cfa4eaedd">More...</a><br /></td></tr>
<tr class="separator:ga6d6c42bcba2324f95299765cfa4eaedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa173a14545cd73289534917fc96ff7cb"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa173a14545cd73289534917fc96ff7cb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../db/dc8/structblaze_1_1Exp10.html">Exp10</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa173a14545cd73289534917fc96ff7cb">exp10</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaa173a14545cd73289534917fc96ff7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaa173a14545cd73289534917fc96ff7cb">More...</a><br /></td></tr>
<tr class="separator:gaa173a14545cd73289534917fc96ff7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10cff4f15dda50d6b49aa1f7bc032282"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga10cff4f15dda50d6b49aa1f7bc032282"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/d9c/structblaze_1_1Log.html">Log</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga10cff4f15dda50d6b49aa1f7bc032282">log</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga10cff4f15dda50d6b49aa1f7bc032282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga10cff4f15dda50d6b49aa1f7bc032282">More...</a><br /></td></tr>
<tr class="separator:ga10cff4f15dda50d6b49aa1f7bc032282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44459bed8c0394e623f85e7060736f1f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga44459bed8c0394e623f85e7060736f1f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d33/structblaze_1_1Log10.html">Log10</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga44459bed8c0394e623f85e7060736f1f">log10</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga44459bed8c0394e623f85e7060736f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary logarithm for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga44459bed8c0394e623f85e7060736f1f">More...</a><br /></td></tr>
<tr class="separator:ga44459bed8c0394e623f85e7060736f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7d576f2bca1424a5fd5f57da21a85c3"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad7d576f2bca1424a5fd5f57da21a85c3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d5/dc7/structblaze_1_1Log2.html">Log2</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gad7d576f2bca1424a5fd5f57da21a85c3">log2</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gad7d576f2bca1424a5fd5f57da21a85c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the common logarithm for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gad7d576f2bca1424a5fd5f57da21a85c3">More...</a><br /></td></tr>
<tr class="separator:gad7d576f2bca1424a5fd5f57da21a85c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a45f5774abd4565a54493af5d233260"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7a45f5774abd4565a54493af5d233260"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d56/structblaze_1_1Sin.html">Sin</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga7a45f5774abd4565a54493af5d233260">sin</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga7a45f5774abd4565a54493af5d233260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga7a45f5774abd4565a54493af5d233260">More...</a><br /></td></tr>
<tr class="separator:ga7a45f5774abd4565a54493af5d233260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68febffb11ae18361479f5af5ac38b19"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga68febffb11ae18361479f5af5ac38b19"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d3/dde/structblaze_1_1Asin.html">Asin</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga68febffb11ae18361479f5af5ac38b19">asin</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga68febffb11ae18361479f5af5ac38b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse sine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga68febffb11ae18361479f5af5ac38b19">More...</a><br /></td></tr>
<tr class="separator:ga68febffb11ae18361479f5af5ac38b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73fb5d6b6ea84ae2d5598f78e55553d2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga73fb5d6b6ea84ae2d5598f78e55553d2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/d59/structblaze_1_1Sinh.html">Sinh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga73fb5d6b6ea84ae2d5598f78e55553d2">sinh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga73fb5d6b6ea84ae2d5598f78e55553d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga73fb5d6b6ea84ae2d5598f78e55553d2">More...</a><br /></td></tr>
<tr class="separator:ga73fb5d6b6ea84ae2d5598f78e55553d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd7d165a5bf6c8dd5c2ba42f43d9970"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaffd7d165a5bf6c8dd5c2ba42f43d9970"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d0/d08/structblaze_1_1Asinh.html">Asinh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaffd7d165a5bf6c8dd5c2ba42f43d9970">asinh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaffd7d165a5bf6c8dd5c2ba42f43d9970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaffd7d165a5bf6c8dd5c2ba42f43d9970">More...</a><br /></td></tr>
<tr class="separator:gaffd7d165a5bf6c8dd5c2ba42f43d9970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4acdc829fc0fae8ec14bf6e1f862519c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4acdc829fc0fae8ec14bf6e1f862519c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/d0a/structblaze_1_1Cos.html">Cos</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4acdc829fc0fae8ec14bf6e1f862519c">cos</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga4acdc829fc0fae8ec14bf6e1f862519c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga4acdc829fc0fae8ec14bf6e1f862519c">More...</a><br /></td></tr>
<tr class="separator:ga4acdc829fc0fae8ec14bf6e1f862519c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82409239e21c5f9625391762bf7e068b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga82409239e21c5f9625391762bf7e068b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/db3/structblaze_1_1Acos.html">Acos</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga82409239e21c5f9625391762bf7e068b">acos</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga82409239e21c5f9625391762bf7e068b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cosine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga82409239e21c5f9625391762bf7e068b">More...</a><br /></td></tr>
<tr class="separator:ga82409239e21c5f9625391762bf7e068b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21427441f4e8fc6f208f7e3cb6ed7160"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga21427441f4e8fc6f208f7e3cb6ed7160"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/db2/structblaze_1_1Cosh.html">Cosh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga21427441f4e8fc6f208f7e3cb6ed7160">cosh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga21427441f4e8fc6f208f7e3cb6ed7160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga21427441f4e8fc6f208f7e3cb6ed7160">More...</a><br /></td></tr>
<tr class="separator:ga21427441f4e8fc6f208f7e3cb6ed7160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69eacda66e1bcfa22a3e8e6f9df8b748"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga69eacda66e1bcfa22a3e8e6f9df8b748"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../dd/d35/structblaze_1_1Acosh.html">Acosh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga69eacda66e1bcfa22a3e8e6f9df8b748">acosh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga69eacda66e1bcfa22a3e8e6f9df8b748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga69eacda66e1bcfa22a3e8e6f9df8b748">More...</a><br /></td></tr>
<tr class="separator:ga69eacda66e1bcfa22a3e8e6f9df8b748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d261d1a314d04ac889f8d2255cc8ee"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga86d261d1a314d04ac889f8d2255cc8ee"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../db/d5e/structblaze_1_1Tan.html">Tan</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga86d261d1a314d04ac889f8d2255cc8ee">tan</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga86d261d1a314d04ac889f8d2255cc8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga86d261d1a314d04ac889f8d2255cc8ee">More...</a><br /></td></tr>
<tr class="separator:ga86d261d1a314d04ac889f8d2255cc8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3b6d1c85c3210ff3aa8cfe70e1e2c39"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa3b6d1c85c3210ff3aa8cfe70e1e2c39"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../d4/dfc/structblaze_1_1Atan.html">Atan</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa3b6d1c85c3210ff3aa8cfe70e1e2c39">atan</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaa3b6d1c85c3210ff3aa8cfe70e1e2c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse tangent for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaa3b6d1c85c3210ff3aa8cfe70e1e2c39">More...</a><br /></td></tr>
<tr class="separator:gaa3b6d1c85c3210ff3aa8cfe70e1e2c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga096a2c65eccc14ba47e321c6f371e609"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga096a2c65eccc14ba47e321c6f371e609"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../df/db7/structblaze_1_1Tanh.html">Tanh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga096a2c65eccc14ba47e321c6f371e609">tanh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga096a2c65eccc14ba47e321c6f371e609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga096a2c65eccc14ba47e321c6f371e609">More...</a><br /></td></tr>
<tr class="separator:ga096a2c65eccc14ba47e321c6f371e609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a297caa44dd4912432dff03822ddb6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf7a297caa44dd4912432dff03822ddb6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d4d/structblaze_1_1Atanh.html">Atanh</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaf7a297caa44dd4912432dff03822ddb6">atanh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaf7a297caa44dd4912432dff03822ddb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaf7a297caa44dd4912432dff03822ddb6">More...</a><br /></td></tr>
<tr class="separator:gaf7a297caa44dd4912432dff03822ddb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcea433c7ecf6b394f3d4d00ba3bb92a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gadcea433c7ecf6b394f3d4d00ba3bb92a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../dd/d2c/structblaze_1_1Erf.html">Erf</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gadcea433c7ecf6b394f3d4d00ba3bb92a">erf</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gadcea433c7ecf6b394f3d4d00ba3bb92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gadcea433c7ecf6b394f3d4d00ba3bb92a">More...</a><br /></td></tr>
<tr class="separator:gadcea433c7ecf6b394f3d4d00ba3bb92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ae8c92dafa626cb72f234fabfb239c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga99ae8c92dafa626cb72f234fabfb239c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d35/classblaze_1_1SMatForEachExpr.html">SMatForEachExpr</a>&lt; MT, <a class="el" href="../../de/d5a/structblaze_1_1Erfc.html">Erfc</a>, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga99ae8c92dafa626cb72f234fabfb239c">erfc</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga99ae8c92dafa626cb72f234fabfb239c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complementary error function for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga99ae8c92dafa626cb72f234fabfb239c">More...</a><br /></td></tr>
<tr class="separator:ga99ae8c92dafa626cb72f234fabfb239c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcdfd60edc63a07bdb86e1592fbdcd41"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:gadcdfd60edc63a07bdb86e1592fbdcd41"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">DivExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gadcdfd60edc63a07bdb86e1592fbdcd41">operator/</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:gadcdfd60edc63a07bdb86e1592fbdcd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the division of a sparse matrix by a scalar value ( <img class="formulaInl" alt="$ A=B/s $" src="../../form_100.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gadcdfd60edc63a07bdb86e1592fbdcd41">More...</a><br /></td></tr>
<tr class="separator:gadcdfd60edc63a07bdb86e1592fbdcd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6030a90ba2a81dd899d35c9de718a662"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga6030a90ba2a81dd899d35c9de718a662"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d6e/classblaze_1_1SMatScalarMultExpr.html">SMatScalarMultExpr</a>&lt; MT, <a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">UnderlyingBuiltin_</a>&lt; MT &gt;, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga6030a90ba2a81dd899d35c9de718a662">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga6030a90ba2a81dd899d35c9de718a662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a sparse matrix ( <img class="formulaInl" alt="$ A = -B $" src="../../form_101.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga6030a90ba2a81dd899d35c9de718a662">More...</a><br /></td></tr>
<tr class="separator:ga6030a90ba2a81dd899d35c9de718a662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga290b0b2bbf69a2061d54e62b7ca6d842"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga290b0b2bbf69a2061d54e62b7ca6d842"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga290b0b2bbf69a2061d54e62b7ca6d842">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga290b0b2bbf69a2061d54e62b7ca6d842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse matrix and a scalar value ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_43.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga290b0b2bbf69a2061d54e62b7ca6d842">More...</a><br /></td></tr>
<tr class="separator:ga290b0b2bbf69a2061d54e62b7ca6d842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7863549ad292599fbd054279d31b743"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gaa7863549ad292599fbd054279d31b743"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa7863549ad292599fbd054279d31b743">operator*</a> (T1 scalar, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:gaa7863549ad292599fbd054279d31b743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a sparse matrix ( <img class="formulaInl" alt="$ A=s*B $" src="../../form_102.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaa7863549ad292599fbd054279d31b743">More...</a><br /></td></tr>
<tr class="separator:gaa7863549ad292599fbd054279d31b743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6d0bef279f8d41722214ba0a93c191"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9d6d0bef279f8d41722214ba0a93c191"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d18/classblaze_1_1SMatSMatAddExpr.html">SMatSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga9d6d0bef279f8d41722214ba0a93c191">operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga9d6d0bef279f8d41722214ba0a93c191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga9d6d0bef279f8d41722214ba0a93c191">More...</a><br /></td></tr>
<tr class="separator:ga9d6d0bef279f8d41722214ba0a93c191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7be5ba7d99f09441c139d426c172ad7f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7be5ba7d99f09441c139d426c172ad7f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d13/classblaze_1_1SMatSMatMultExpr.html">SMatSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga7be5ba7d99f09441c139d426c172ad7f">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7be5ba7d99f09441c139d426c172ad7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga7be5ba7d99f09441c139d426c172ad7f">More...</a><br /></td></tr>
<tr class="separator:ga7be5ba7d99f09441c139d426c172ad7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b71cdd1a878c14f672b47a3522575e1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1b71cdd1a878c14f672b47a3522575e1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d92/classblaze_1_1SMatSMatSubExpr.html">SMatSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga1b71cdd1a878c14f672b47a3522575e1">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1b71cdd1a878c14f672b47a3522575e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga1b71cdd1a878c14f672b47a3522575e1">More...</a><br /></td></tr>
<tr class="separator:ga1b71cdd1a878c14f672b47a3522575e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fb4b558abb822b9cad9398d200a81b9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2fb4b558abb822b9cad9398d200a81b9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T1 &gt;, <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt; &gt;, <a class="el" href="../../d6/dbf/classblaze_1_1SMatSVecMultExpr.html">SMatSVecMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga2fb4b558abb822b9cad9398d200a81b9">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga2fb4b558abb822b9cad9398d200a81b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=B*\vec{c} $" src="../../form_114.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga2fb4b558abb822b9cad9398d200a81b9">More...</a><br /></td></tr>
<tr class="separator:ga2fb4b558abb822b9cad9398d200a81b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20777c4f2b4f7e24a5130dc8041b5e93"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga20777c4f2b4f7e24a5130dc8041b5e93"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d43/classblaze_1_1SMatTDMatMultExpr.html">SMatTDMatMultExpr</a>&lt; T1, T2, false, false, false, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga20777c4f2b4f7e24a5130dc8041b5e93">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga20777c4f2b4f7e24a5130dc8041b5e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga20777c4f2b4f7e24a5130dc8041b5e93">More...</a><br /></td></tr>
<tr class="separator:ga20777c4f2b4f7e24a5130dc8041b5e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1720d2f0702c0f77bc4991a287d98d1e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1720d2f0702c0f77bc4991a287d98d1e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/de7/classblaze_1_1SMatTDMatSubExpr.html">SMatTDMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1720d2f0702c0f77bc4991a287d98d1e">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1720d2f0702c0f77bc4991a287d98d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga1720d2f0702c0f77bc4991a287d98d1e">More...</a><br /></td></tr>
<tr class="separator:ga1720d2f0702c0f77bc4991a287d98d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga112e886e84bf2d9155a12623fa1131a9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga112e886e84bf2d9155a12623fa1131a9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d9c/classblaze_1_1SMatTSMatAddExpr.html">SMatTSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga112e886e84bf2d9155a12623fa1131a9">operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga112e886e84bf2d9155a12623fa1131a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga112e886e84bf2d9155a12623fa1131a9">More...</a><br /></td></tr>
<tr class="separator:ga112e886e84bf2d9155a12623fa1131a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf69176ce01c8deed13b6288d04e7fb4e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaf69176ce01c8deed13b6288d04e7fb4e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d9c/classblaze_1_1SMatTSMatAddExpr.html">SMatTSMatAddExpr</a>&lt; T2, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaf69176ce01c8deed13b6288d04e7fb4e">operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf69176ce01c8deed13b6288d04e7fb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaf69176ce01c8deed13b6288d04e7fb4e">More...</a><br /></td></tr>
<tr class="separator:gaf69176ce01c8deed13b6288d04e7fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fc17104bcd6eac213fcc2574e68eff7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga4fc17104bcd6eac213fcc2574e68eff7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/dc8/classblaze_1_1SMatTSMatMultExpr.html">SMatTSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4fc17104bcd6eac213fcc2574e68eff7">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4fc17104bcd6eac213fcc2574e68eff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga4fc17104bcd6eac213fcc2574e68eff7">More...</a><br /></td></tr>
<tr class="separator:ga4fc17104bcd6eac213fcc2574e68eff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f555464ba008c823eab85d659a2abe"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gac7f555464ba008c823eab85d659a2abe"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/dad/classblaze_1_1SMatTSMatSubExpr.html">SMatTSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gac7f555464ba008c823eab85d659a2abe">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac7f555464ba008c823eab85d659a2abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gac7f555464ba008c823eab85d659a2abe">More...</a><br /></td></tr>
<tr class="separator:gac7f555464ba008c823eab85d659a2abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga087b32c6580d7bcc2b62605e767f9c04"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga087b32c6580d7bcc2b62605e767f9c04"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/dbd/classblaze_1_1SVecDVecCrossExpr.html">SVecDVecCrossExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga087b32c6580d7bcc2b62605e767f9c04">operator%</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga087b32c6580d7bcc2b62605e767f9c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_104.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga087b32c6580d7bcc2b62605e767f9c04">More...</a><br /></td></tr>
<tr class="separator:ga087b32c6580d7bcc2b62605e767f9c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga474d2e6f14c48cff8b22df989ec6ceb8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga474d2e6f14c48cff8b22df989ec6ceb8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/dbd/classblaze_1_1SVecDVecCrossExpr.html">SVecDVecCrossExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga474d2e6f14c48cff8b22df989ec6ceb8">cross</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga474d2e6f14c48cff8b22df989ec6ceb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_104.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga474d2e6f14c48cff8b22df989ec6ceb8">More...</a><br /></td></tr>
<tr class="separator:ga474d2e6f14c48cff8b22df989ec6ceb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a6f7e07f63ad66b6eb51e0f905b262"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga16a6f7e07f63ad66b6eb51e0f905b262"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/d84/classblaze_1_1SVecDVecDivExpr.html">SVecDVecDivExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga16a6f7e07f63ad66b6eb51e0f905b262">operator/</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga16a6f7e07f63ad66b6eb51e0f905b262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the componentwise division of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/\vec{c} $" src="../../form_106.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga16a6f7e07f63ad66b6eb51e0f905b262">More...</a><br /></td></tr>
<tr class="separator:ga16a6f7e07f63ad66b6eb51e0f905b262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/dd1/classblaze_1_1SVecDVecMultExpr.html">SVecDVecMultExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga931bca871bc8961db7f2a7b5d9892b3c">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_107.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga931bca871bc8961db7f2a7b5d9892b3c">More...</a><br /></td></tr>
<tr class="separator:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e490c7a24853b803499ba9e3becaa50"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga5e490c7a24853b803499ba9e3becaa50"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d09/classblaze_1_1SVecDVecSubExpr.html">SVecDVecSubExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5e490c7a24853b803499ba9e3becaa50">operator-</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5e490c7a24853b803499ba9e3becaa50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_108.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga5e490c7a24853b803499ba9e3becaa50">More...</a><br /></td></tr>
<tr class="separator:ga5e490c7a24853b803499ba9e3becaa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a411c9688799b2ef0f334c98f216cf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gac9a411c9688799b2ef0f334c98f216cf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d7/d39/classblaze_1_1SVecEvalExpr.html">SVecEvalExpr</a>&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gac9a411c9688799b2ef0f334c98f216cf">eval</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gac9a411c9688799b2ef0f334c98f216cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given sparse vector expression <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gac9a411c9688799b2ef0f334c98f216cf">More...</a><br /></td></tr>
<tr class="separator:gac9a411c9688799b2ef0f334c98f216cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12bf426f167f5481c4feebc43a9a8482"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga12bf426f167f5481c4feebc43a9a8482"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d6/dae/structblaze_1_1Abs.html">Abs</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga12bf426f167f5481c4feebc43a9a8482">abs</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga12bf426f167f5481c4feebc43a9a8482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga8e4e90c6e2ed37ddea6203417c5596f5" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga12bf426f167f5481c4feebc43a9a8482">More...</a><br /></td></tr>
<tr class="separator:ga12bf426f167f5481c4feebc43a9a8482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4476803c0078f250cf58c75988b3300"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gae4476803c0078f250cf58c75988b3300"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d2/d67/structblaze_1_1Floor.html">Floor</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gae4476803c0078f250cf58c75988b3300">floor</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gae4476803c0078f250cf58c75988b3300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7076fab6e413abbb8914e97c63c6ec60" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gae4476803c0078f250cf58c75988b3300">More...</a><br /></td></tr>
<tr class="separator:gae4476803c0078f250cf58c75988b3300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58bf3f2280518d504484e73bec2f2aac"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga58bf3f2280518d504484e73bec2f2aac"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../da/d9f/structblaze_1_1Ceil.html">Ceil</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga58bf3f2280518d504484e73bec2f2aac">ceil</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga58bf3f2280518d504484e73bec2f2aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga38cb77691633d93f6b0b2fc55146a04b" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga58bf3f2280518d504484e73bec2f2aac">More...</a><br /></td></tr>
<tr class="separator:ga58bf3f2280518d504484e73bec2f2aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b59758cfaf20aab089ccef01a0aff5"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa9b59758cfaf20aab089ccef01a0aff5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d23/structblaze_1_1Trunc.html">Trunc</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa9b59758cfaf20aab089ccef01a0aff5">trunc</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa9b59758cfaf20aab089ccef01a0aff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga69688d5359655080afd417a1d7fdbf40" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaa9b59758cfaf20aab089ccef01a0aff5">More...</a><br /></td></tr>
<tr class="separator:gaa9b59758cfaf20aab089ccef01a0aff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a477b6462fa4487d576cee6d29c4647"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4a477b6462fa4487d576cee6d29c4647"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d83/structblaze_1_1Round.html">Round</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga4a477b6462fa4487d576cee6d29c4647">round</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga4a477b6462fa4487d576cee6d29c4647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaeda0fbc301f6a9849bd1aedb24e3c4bc" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga4a477b6462fa4487d576cee6d29c4647">More...</a><br /></td></tr>
<tr class="separator:ga4a477b6462fa4487d576cee6d29c4647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239740b57eef26f1c51149555e42cdf6"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga239740b57eef26f1c51149555e42cdf6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../db/ddf/structblaze_1_1Conj.html">Conj</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga239740b57eef26f1c51149555e42cdf6">conj</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga239740b57eef26f1c51149555e42cdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the complex conjugate of each single element of <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga239740b57eef26f1c51149555e42cdf6">More...</a><br /></td></tr>
<tr class="separator:ga239740b57eef26f1c51149555e42cdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34b56aa4ff0b88f6007de1b8d4325e66"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga34b56aa4ff0b88f6007de1b8d4325e66"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">CTransExprTrait_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga34b56aa4ff0b88f6007de1b8d4325e66">ctrans</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga34b56aa4ff0b88f6007de1b8d4325e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate transpose vector of <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga34b56aa4ff0b88f6007de1b8d4325e66">More...</a><br /></td></tr>
<tr class="separator:ga34b56aa4ff0b88f6007de1b8d4325e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga594d9851390c1868273c0c96ba597148"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga594d9851390c1868273c0c96ba597148"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../dd/df4/structblaze_1_1Real.html">Real</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga594d9851390c1868273c0c96ba597148">real</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga594d9851390c1868273c0c96ba597148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the real parts of each single element of <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga594d9851390c1868273c0c96ba597148">More...</a><br /></td></tr>
<tr class="separator:ga594d9851390c1868273c0c96ba597148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c533177d921d01b6de1379197887bd9"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga6c533177d921d01b6de1379197887bd9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d3/d61/structblaze_1_1Imag.html">Imag</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga6c533177d921d01b6de1379197887bd9">imag</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga6c533177d921d01b6de1379197887bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the imaginary parts of each single element of <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga6c533177d921d01b6de1379197887bd9">More...</a><br /></td></tr>
<tr class="separator:ga6c533177d921d01b6de1379197887bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d268b55675338442e09c1793b9babaf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga8d268b55675338442e09c1793b9babaf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d0/d06/structblaze_1_1Sqrt.html">Sqrt</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga8d268b55675338442e09c1793b9babaf">sqrt</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga8d268b55675338442e09c1793b9babaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga8d268b55675338442e09c1793b9babaf">More...</a><br /></td></tr>
<tr class="separator:ga8d268b55675338442e09c1793b9babaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a4edc5deb886e04bc4370a17288ebda"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga1a4edc5deb886e04bc4370a17288ebda"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../df/d20/structblaze_1_1InvSqrt.html">InvSqrt</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga1a4edc5deb886e04bc4370a17288ebda">invsqrt</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga1a4edc5deb886e04bc4370a17288ebda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse square root of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga1a4edc5deb886e04bc4370a17288ebda">More...</a><br /></td></tr>
<tr class="separator:ga1a4edc5deb886e04bc4370a17288ebda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63114862aa4525da36987abcac3f988e"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga63114862aa4525da36987abcac3f988e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d6/d4c/structblaze_1_1Cbrt.html">Cbrt</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga63114862aa4525da36987abcac3f988e">cbrt</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga63114862aa4525da36987abcac3f988e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cubic root of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga63114862aa4525da36987abcac3f988e">More...</a><br /></td></tr>
<tr class="separator:ga63114862aa4525da36987abcac3f988e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5230ab98b6b5b74dddc967c3cb5cd4"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7b5230ab98b6b5b74dddc967c3cb5cd4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d2/d2f/structblaze_1_1InvCbrt.html">InvCbrt</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga7b5230ab98b6b5b74dddc967c3cb5cd4">invcbrt</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga7b5230ab98b6b5b74dddc967c3cb5cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cubic root of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga7b5230ab98b6b5b74dddc967c3cb5cd4">More...</a><br /></td></tr>
<tr class="separator:ga7b5230ab98b6b5b74dddc967c3cb5cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7009f03f63d7f48601313e4c3f7c58cf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename DT &gt; </td></tr>
<tr class="memitem:ga7009f03f63d7f48601313e4c3f7c58cf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../da/d15/structblaze_1_1Clamp.html">Clamp</a>&lt; DT &gt;, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga7009f03f63d7f48601313e4c3f7c58cf">clamp</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>)</td></tr>
<tr class="memdesc:ga7009f03f63d7f48601313e4c3f7c58cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts each single element of the sparse vector <em>sv</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_94.png"/>.  <a href="../../d6/d2f/group__sparse__vector.html#ga7009f03f63d7f48601313e4c3f7c58cf">More...</a><br /></td></tr>
<tr class="separator:ga7009f03f63d7f48601313e4c3f7c58cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7e6f523449f9aad9b21fb6f9230482"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename ET &gt; </td></tr>
<tr class="memitem:gafc7e6f523449f9aad9b21fb6f9230482"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d3/d41/structblaze_1_1Pow.html">Pow</a>&lt; ET &gt;, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gafc7e6f523449f9aad9b21fb6f9230482">pow</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv, ET <a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">exp</a>)</td></tr>
<tr class="memdesc:gafc7e6f523449f9aad9b21fb6f9230482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponential value for each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gafc7e6f523449f9aad9b21fb6f9230482">More...</a><br /></td></tr>
<tr class="separator:gafc7e6f523449f9aad9b21fb6f9230482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5a1c951e51200ce5aa27bd4e524513"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaef5a1c951e51200ce5aa27bd4e524513"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d4/d45/structblaze_1_1Exp.html">Exp</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaef5a1c951e51200ce5aa27bd4e524513">exp</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaef5a1c951e51200ce5aa27bd4e524513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaef5a1c951e51200ce5aa27bd4e524513">More...</a><br /></td></tr>
<tr class="separator:gaef5a1c951e51200ce5aa27bd4e524513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e15e57286f3d65931a995aa8c507763"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7e15e57286f3d65931a995aa8c507763"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../df/dbb/structblaze_1_1Exp2.html">Exp2</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga7e15e57286f3d65931a995aa8c507763">exp2</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga7e15e57286f3d65931a995aa8c507763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga7e15e57286f3d65931a995aa8c507763">More...</a><br /></td></tr>
<tr class="separator:ga7e15e57286f3d65931a995aa8c507763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7454714c18c2e09d74208439ce23329c"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7454714c18c2e09d74208439ce23329c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../db/dc8/structblaze_1_1Exp10.html">Exp10</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga7454714c18c2e09d74208439ce23329c">exp10</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga7454714c18c2e09d74208439ce23329c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga7454714c18c2e09d74208439ce23329c">More...</a><br /></td></tr>
<tr class="separator:ga7454714c18c2e09d74208439ce23329c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58630c948cf33ddbb0357b413b762da0"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga58630c948cf33ddbb0357b413b762da0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d3/d9c/structblaze_1_1Log.html">Log</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga58630c948cf33ddbb0357b413b762da0">log</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga58630c948cf33ddbb0357b413b762da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga58630c948cf33ddbb0357b413b762da0">More...</a><br /></td></tr>
<tr class="separator:ga58630c948cf33ddbb0357b413b762da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9755aee62b7f897ca4b989a68941f62d"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga9755aee62b7f897ca4b989a68941f62d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d5/dc7/structblaze_1_1Log2.html">Log2</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga9755aee62b7f897ca4b989a68941f62d">log2</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga9755aee62b7f897ca4b989a68941f62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary logarithm of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga9755aee62b7f897ca4b989a68941f62d">More...</a><br /></td></tr>
<tr class="separator:ga9755aee62b7f897ca4b989a68941f62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e412d9508a0e2a11db2a06b2bae9139"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7e412d9508a0e2a11db2a06b2bae9139"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d33/structblaze_1_1Log10.html">Log10</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga7e412d9508a0e2a11db2a06b2bae9139">log10</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga7e412d9508a0e2a11db2a06b2bae9139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the common logarithm of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga7e412d9508a0e2a11db2a06b2bae9139">More...</a><br /></td></tr>
<tr class="separator:ga7e412d9508a0e2a11db2a06b2bae9139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05688072c6eb9dd3fa320436e4f7454b"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga05688072c6eb9dd3fa320436e4f7454b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d56/structblaze_1_1Sin.html">Sin</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga05688072c6eb9dd3fa320436e4f7454b">sin</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga05688072c6eb9dd3fa320436e4f7454b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga05688072c6eb9dd3fa320436e4f7454b">More...</a><br /></td></tr>
<tr class="separator:ga05688072c6eb9dd3fa320436e4f7454b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6bbcafad45cfd32de71c639302dc2d2"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa6bbcafad45cfd32de71c639302dc2d2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d3/dde/structblaze_1_1Asin.html">Asin</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa6bbcafad45cfd32de71c639302dc2d2">asin</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa6bbcafad45cfd32de71c639302dc2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse sine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaa6bbcafad45cfd32de71c639302dc2d2">More...</a><br /></td></tr>
<tr class="separator:gaa6bbcafad45cfd32de71c639302dc2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78ff3907a282c8c9d2a3504f47ff2e88"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga78ff3907a282c8c9d2a3504f47ff2e88"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d4/d59/structblaze_1_1Sinh.html">Sinh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga78ff3907a282c8c9d2a3504f47ff2e88">sinh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga78ff3907a282c8c9d2a3504f47ff2e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga78ff3907a282c8c9d2a3504f47ff2e88">More...</a><br /></td></tr>
<tr class="separator:ga78ff3907a282c8c9d2a3504f47ff2e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacba48bd0943ed4a3cfdac37783181901"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gacba48bd0943ed4a3cfdac37783181901"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d0/d08/structblaze_1_1Asinh.html">Asinh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gacba48bd0943ed4a3cfdac37783181901">asinh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gacba48bd0943ed4a3cfdac37783181901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gacba48bd0943ed4a3cfdac37783181901">More...</a><br /></td></tr>
<tr class="separator:gacba48bd0943ed4a3cfdac37783181901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd003f585a00dbd748b1f3b032248ac3"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gabd003f585a00dbd748b1f3b032248ac3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../df/d0a/structblaze_1_1Cos.html">Cos</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gabd003f585a00dbd748b1f3b032248ac3">cos</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gabd003f585a00dbd748b1f3b032248ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gabd003f585a00dbd748b1f3b032248ac3">More...</a><br /></td></tr>
<tr class="separator:gabd003f585a00dbd748b1f3b032248ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga908a6a95de702b8f46bb094996561ff2"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga908a6a95de702b8f46bb094996561ff2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d4/db3/structblaze_1_1Acos.html">Acos</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga908a6a95de702b8f46bb094996561ff2">acos</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga908a6a95de702b8f46bb094996561ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cosine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga908a6a95de702b8f46bb094996561ff2">More...</a><br /></td></tr>
<tr class="separator:ga908a6a95de702b8f46bb094996561ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33373deb5e0df60b71d771203ac4e258"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga33373deb5e0df60b71d771203ac4e258"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/db2/structblaze_1_1Cosh.html">Cosh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga33373deb5e0df60b71d771203ac4e258">cosh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga33373deb5e0df60b71d771203ac4e258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga33373deb5e0df60b71d771203ac4e258">More...</a><br /></td></tr>
<tr class="separator:ga33373deb5e0df60b71d771203ac4e258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2744d46900d42eb6dba263d22e609c70"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga2744d46900d42eb6dba263d22e609c70"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../dd/d35/structblaze_1_1Acosh.html">Acosh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga2744d46900d42eb6dba263d22e609c70">acosh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga2744d46900d42eb6dba263d22e609c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga2744d46900d42eb6dba263d22e609c70">More...</a><br /></td></tr>
<tr class="separator:ga2744d46900d42eb6dba263d22e609c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga347939d6d6ba192be1e180d147114b5d"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga347939d6d6ba192be1e180d147114b5d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../db/d5e/structblaze_1_1Tan.html">Tan</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga347939d6d6ba192be1e180d147114b5d">tan</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga347939d6d6ba192be1e180d147114b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga347939d6d6ba192be1e180d147114b5d">More...</a><br /></td></tr>
<tr class="separator:ga347939d6d6ba192be1e180d147114b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe8b24bb897deadf6d721884552aa91b"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gabe8b24bb897deadf6d721884552aa91b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../d4/dfc/structblaze_1_1Atan.html">Atan</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gabe8b24bb897deadf6d721884552aa91b">atan</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gabe8b24bb897deadf6d721884552aa91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse tangent of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gabe8b24bb897deadf6d721884552aa91b">More...</a><br /></td></tr>
<tr class="separator:gabe8b24bb897deadf6d721884552aa91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffb58728bf05e0f93d41e1d92cedb87a"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaffb58728bf05e0f93d41e1d92cedb87a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../df/db7/structblaze_1_1Tanh.html">Tanh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaffb58728bf05e0f93d41e1d92cedb87a">tanh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaffb58728bf05e0f93d41e1d92cedb87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaffb58728bf05e0f93d41e1d92cedb87a">More...</a><br /></td></tr>
<tr class="separator:gaffb58728bf05e0f93d41e1d92cedb87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14450639e7ef92fb69d60fe7b96c634a"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga14450639e7ef92fb69d60fe7b96c634a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d4d/structblaze_1_1Atanh.html">Atanh</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga14450639e7ef92fb69d60fe7b96c634a">atanh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga14450639e7ef92fb69d60fe7b96c634a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga14450639e7ef92fb69d60fe7b96c634a">More...</a><br /></td></tr>
<tr class="separator:ga14450639e7ef92fb69d60fe7b96c634a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79dd61da5c22c4ecd148dad78b808a39"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga79dd61da5c22c4ecd148dad78b808a39"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../dd/d2c/structblaze_1_1Erf.html">Erf</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga79dd61da5c22c4ecd148dad78b808a39">erf</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga79dd61da5c22c4ecd148dad78b808a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga79dd61da5c22c4ecd148dad78b808a39">More...</a><br /></td></tr>
<tr class="separator:ga79dd61da5c22c4ecd148dad78b808a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69a6ea271abeafac0ffd43c9c2a14c2"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa69a6ea271abeafac0ffd43c9c2a14c2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d18/classblaze_1_1SVecForEachExpr.html">SVecForEachExpr</a>&lt; VT, <a class="el" href="../../de/d5a/structblaze_1_1Erfc.html">Erfc</a>, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa69a6ea271abeafac0ffd43c9c2a14c2">erfc</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa69a6ea271abeafac0ffd43c9c2a14c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complementary error function of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaa69a6ea271abeafac0ffd43c9c2a14c2">More...</a><br /></td></tr>
<tr class="separator:gaa69a6ea271abeafac0ffd43c9c2a14c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7ac67053f35e26f45e7b8db4844333"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga0c7ac67053f35e26f45e7b8db4844333"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">DivExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga0c7ac67053f35e26f45e7b8db4844333">operator/</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga0c7ac67053f35e26f45e7b8db4844333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the divison of a sparse vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_109.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga0c7ac67053f35e26f45e7b8db4844333">More...</a><br /></td></tr>
<tr class="separator:ga0c7ac67053f35e26f45e7b8db4844333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga108e929136114735b41e82824fcf1d98"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga108e929136114735b41e82824fcf1d98"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d7/dc2/classblaze_1_1SVecScalarMultExpr.html">SVecScalarMultExpr</a>&lt; VT, <a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">UnderlyingBuiltin_</a>&lt; VT &gt;, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga108e929136114735b41e82824fcf1d98">operator-</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga108e929136114735b41e82824fcf1d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a sparse vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_110.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga108e929136114735b41e82824fcf1d98">More...</a><br /></td></tr>
<tr class="separator:ga108e929136114735b41e82824fcf1d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga568fe866cdb766ef08e4696b675cc697"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga568fe866cdb766ef08e4696b675cc697"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga568fe866cdb766ef08e4696b675cc697">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga568fe866cdb766ef08e4696b675cc697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_51.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga568fe866cdb766ef08e4696b675cc697">More...</a><br /></td></tr>
<tr class="separator:ga568fe866cdb766ef08e4696b675cc697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31f12956746f757f22c89e9460732ed0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga31f12956746f757f22c89e9460732ed0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga31f12956746f757f22c89e9460732ed0">operator*</a> (T1 scalar, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga31f12956746f757f22c89e9460732ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_111.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga31f12956746f757f22c89e9460732ed0">More...</a><br /></td></tr>
<tr class="separator:ga31f12956746f757f22c89e9460732ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455459c9ffcc5dc1f4c2a9f46597c9c7"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:a455459c9ffcc5dc1f4c2a9f46597c9c7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d7/dc2/classblaze_1_1SVecScalarMultExpr.html">SVecScalarMultExpr</a>&lt; VT, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a455459c9ffcc5dc1f4c2a9f46597c9c7">normalize</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:a455459c9ffcc5dc1f4c2a9f46597c9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalization of the sparse vector ( <img class="formulaInl" alt="$|\vec{a}|=1$" src="../../form_112.png"/>).  <a href="#a455459c9ffcc5dc1f4c2a9f46597c9c7">More...</a><br /></td></tr>
<tr class="separator:a455459c9ffcc5dc1f4c2a9f46597c9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3012773ba555712c006466a901f2b7b6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga3012773ba555712c006466a901f2b7b6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d63/classblaze_1_1SVecSVecAddExpr.html">SVecSVecAddExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga3012773ba555712c006466a901f2b7b6">operator+</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3012773ba555712c006466a901f2b7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_103.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga3012773ba555712c006466a901f2b7b6">More...</a><br /></td></tr>
<tr class="separator:ga3012773ba555712c006466a901f2b7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe9a0bc59629418c73503b1ebdeeb87"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga7fe9a0bc59629418c73503b1ebdeeb87"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d7d/classblaze_1_1SVecSVecCrossExpr.html">SVecSVecCrossExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7fe9a0bc59629418c73503b1ebdeeb87">operator%</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7fe9a0bc59629418c73503b1ebdeeb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_104.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga7fe9a0bc59629418c73503b1ebdeeb87">More...</a><br /></td></tr>
<tr class="separator:ga7fe9a0bc59629418c73503b1ebdeeb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba1fd4abcf41b9e589f4a2af9a4d22f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaeba1fd4abcf41b9e589f4a2af9a4d22f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d7d/classblaze_1_1SVecSVecCrossExpr.html">SVecSVecCrossExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaeba1fd4abcf41b9e589f4a2af9a4d22f">cross</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaeba1fd4abcf41b9e589f4a2af9a4d22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_104.png"/>).  <a href="../../de/d90/group__dense__vector.html#gaeba1fd4abcf41b9e589f4a2af9a4d22f">More...</a><br /></td></tr>
<tr class="separator:gaeba1fd4abcf41b9e589f4a2af9a4d22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccf01f6322bcd426a734b284aa123b8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaaccf01f6322bcd426a734b284aa123b8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/ddb/classblaze_1_1SVecSVecMultExpr.html">SVecSVecMultExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaaccf01f6322bcd426a734b284aa123b8">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaaccf01f6322bcd426a734b284aa123b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise multiplication of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_107.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gaaccf01f6322bcd426a734b284aa123b8">More...</a><br /></td></tr>
<tr class="separator:gaaccf01f6322bcd426a734b284aa123b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../de/d48/classblaze_1_1SVecSVecSubExpr.html">SVecSVecSubExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga1a9bad0a58b194a184fa8b9e14618a4f">operator-</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_108.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga1a9bad0a58b194a184fa8b9e14618a4f">More...</a><br /></td></tr>
<tr class="separator:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa25c477c724abcfb4503afc172a51c3f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa25c477c724abcfb4503afc172a51c3f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d3b/classblaze_1_1SVecTDVecMultExpr.html">SVecTDVecMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa25c477c724abcfb4503afc172a51c3f">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa25c477c724abcfb4503afc172a51c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the sparse vector-dense vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_113.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaa25c477c724abcfb4503afc172a51c3f">More...</a><br /></td></tr>
<tr class="separator:gaa25c477c724abcfb4503afc172a51c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab41594bee8f746276b88e56b2b92051"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaab41594bee8f746276b88e56b2b92051"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d04/classblaze_1_1SVecTSVecMultExpr.html">SVecTSVecMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaab41594bee8f746276b88e56b2b92051">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaab41594bee8f746276b88e56b2b92051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the sparse vector-sparse vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_113.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaab41594bee8f746276b88e56b2b92051">More...</a><br /></td></tr>
<tr class="separator:gaab41594bee8f746276b88e56b2b92051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f51f828a45bfd3717c4836eca156cf2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga3f51f828a45bfd3717c4836eca156cf2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/dc9/classblaze_1_1TDMatDMatMultExpr.html">TDMatDMatMultExpr</a>&lt; T1, T2, false, false, false, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga3f51f828a45bfd3717c4836eca156cf2">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3f51f828a45bfd3717c4836eca156cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga3f51f828a45bfd3717c4836eca156cf2">More...</a><br /></td></tr>
<tr class="separator:ga3f51f828a45bfd3717c4836eca156cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae36cb4846ed61e895ecc1a4ea4ea2696"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae36cb4846ed61e895ecc1a4ea4ea2696"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;, <a class="el" href="../../dc/dd4/classblaze_1_1TDMatDVecMultExpr.html">TDMatDVecMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae36cb4846ed61e895ecc1a4ea4ea2696">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gae36cb4846ed61e895ecc1a4ea4ea2696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_88.png"/>).  <a href="../../de/d90/group__dense__vector.html#gae36cb4846ed61e895ecc1a4ea4ea2696">More...</a><br /></td></tr>
<tr class="separator:gae36cb4846ed61e895ecc1a4ea4ea2696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b0a2b26e02f2ca345af2094585db4be"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga4b0a2b26e02f2ca345af2094585db4be"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d0c/classblaze_1_1TDMatSMatAddExpr.html">TDMatSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4b0a2b26e02f2ca345af2094585db4be">operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4b0a2b26e02f2ca345af2094585db4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga4b0a2b26e02f2ca345af2094585db4be">More...</a><br /></td></tr>
<tr class="separator:ga4b0a2b26e02f2ca345af2094585db4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d0526756a2befd345af87726c5014e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga72d0526756a2befd345af87726c5014e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d0c/classblaze_1_1TDMatSMatAddExpr.html">TDMatSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga72d0526756a2befd345af87726c5014e">operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga72d0526756a2befd345af87726c5014e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga72d0526756a2befd345af87726c5014e">More...</a><br /></td></tr>
<tr class="separator:ga72d0526756a2befd345af87726c5014e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d5d53a3ea2376b071c78d77e07406f3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2d5d53a3ea2376b071c78d77e07406f3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/dfb/classblaze_1_1TDMatSMatMultExpr.html">TDMatSMatMultExpr</a>&lt; T1, T2, false, false, false, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga2d5d53a3ea2376b071c78d77e07406f3">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga2d5d53a3ea2376b071c78d77e07406f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga2d5d53a3ea2376b071c78d77e07406f3">More...</a><br /></td></tr>
<tr class="separator:ga2d5d53a3ea2376b071c78d77e07406f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa31b65149566c26b3f8d9d75ca24c6e5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa31b65149566c26b3f8d9d75ca24c6e5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/d5b/classblaze_1_1TDMatSMatSubExpr.html">TDMatSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa31b65149566c26b3f8d9d75ca24c6e5">operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa31b65149566c26b3f8d9d75ca24c6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaa31b65149566c26b3f8d9d75ca24c6e5">More...</a><br /></td></tr>
<tr class="separator:gaa31b65149566c26b3f8d9d75ca24c6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f85fd74caa3871e99fdeab94c218d0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae9f85fd74caa3871e99fdeab94c218d0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;, <a class="el" href="../../d4/d0b/classblaze_1_1TDMatSVecMultExpr.html">TDMatSVecMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae9f85fd74caa3871e99fdeab94c218d0">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gae9f85fd74caa3871e99fdeab94c218d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_88.png"/>).  <a href="../../de/d90/group__dense__vector.html#gae9f85fd74caa3871e99fdeab94c218d0">More...</a><br /></td></tr>
<tr class="separator:gae9f85fd74caa3871e99fdeab94c218d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e16ab37a11a6e772f652c5ce572ad59"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5e16ab37a11a6e772f652c5ce572ad59"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6f/classblaze_1_1TDMatTDMatMultExpr.html">TDMatTDMatMultExpr</a>&lt; T1, T2, false, false, false, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga5e16ab37a11a6e772f652c5ce572ad59">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5e16ab37a11a6e772f652c5ce572ad59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two column-major dense matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga5e16ab37a11a6e772f652c5ce572ad59">More...</a><br /></td></tr>
<tr class="separator:ga5e16ab37a11a6e772f652c5ce572ad59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cf4741ea9d35452a1112c108f72471f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9cf4741ea9d35452a1112c108f72471f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d9c/classblaze_1_1TDMatTSMatMultExpr.html">TDMatTSMatMultExpr</a>&lt; T1, T2, false, false, false, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga9cf4741ea9d35452a1112c108f72471f">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga9cf4741ea9d35452a1112c108f72471f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga9cf4741ea9d35452a1112c108f72471f">More...</a><br /></td></tr>
<tr class="separator:ga9cf4741ea9d35452a1112c108f72471f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b9b3a1df77bc0cd91c0297db3cacd15"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9b9b3a1df77bc0cd91c0297db3cacd15"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;, <a class="el" href="../../d8/d47/classblaze_1_1TDVecDMatMultExpr.html">TDVecDMatMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga9b9b3a1df77bc0cd91c0297db3cacd15">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga9b9b3a1df77bc0cd91c0297db3cacd15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a row-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga9b9b3a1df77bc0cd91c0297db3cacd15">More...</a><br /></td></tr>
<tr class="separator:ga9b9b3a1df77bc0cd91c0297db3cacd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3197e6f1b58c3a6fa1a9fa90b222261a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga3197e6f1b58c3a6fa1a9fa90b222261a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga3197e6f1b58c3a6fa1a9fa90b222261a">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga3197e6f1b58c3a6fa1a9fa90b222261a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a dense matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_117.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga3197e6f1b58c3a6fa1a9fa90b222261a">More...</a><br /></td></tr>
<tr class="separator:ga3197e6f1b58c3a6fa1a9fa90b222261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1953db9322377dfe0a9d07808968d9d2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1953db9322377dfe0a9d07808968d9d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; TDVecDVecMultExprHelper&lt; T1, T2 &gt;, const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga1953db9322377dfe0a9d07808968d9d2">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1953db9322377dfe0a9d07808968d9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default multiplication operator for the scalar product (inner product) of two dense vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_119.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga1953db9322377dfe0a9d07808968d9d2">More...</a><br /></td></tr>
<tr class="separator:ga1953db9322377dfe0a9d07808968d9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1953db9322377dfe0a9d07808968d9d2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1953db9322377dfe0a9d07808968d9d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; TDVecDVecMultExprHelper&lt; T1, T2 &gt;, const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga1953db9322377dfe0a9d07808968d9d2">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1953db9322377dfe0a9d07808968d9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD optimized multiplication operator for the scalar product (inner product) of two dense vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_119.png"/>).  <a href="#ga1953db9322377dfe0a9d07808968d9d2">More...</a><br /></td></tr>
<tr class="separator:ga1953db9322377dfe0a9d07808968d9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7de67d38434231a5f6a712a0be83ca31"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7de67d38434231a5f6a712a0be83ca31"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T2 &gt;, <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt; &gt;, <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7de67d38434231a5f6a712a0be83ca31">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga7de67d38434231a5f6a712a0be83ca31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga7de67d38434231a5f6a712a0be83ca31">More...</a><br /></td></tr>
<tr class="separator:ga7de67d38434231a5f6a712a0be83ca31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb233178c3e51fb15a2ca0968146f9b7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gadb233178c3e51fb15a2ca0968146f9b7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gadb233178c3e51fb15a2ca0968146f9b7">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:gadb233178c3e51fb15a2ca0968146f9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a sparse matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_117.png"/>).  <a href="../../de/d90/group__dense__vector.html#gadb233178c3e51fb15a2ca0968146f9b7">More...</a><br /></td></tr>
<tr class="separator:gadb233178c3e51fb15a2ca0968146f9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa10c43fbf3fd4cb8d559a4800006de9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gafa10c43fbf3fd4cb8d559a4800006de9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gafa10c43fbf3fd4cb8d559a4800006de9">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gafa10c43fbf3fd4cb8d559a4800006de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of a dense and a sparse vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_119.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gafa10c43fbf3fd4cb8d559a4800006de9">More...</a><br /></td></tr>
<tr class="separator:gafa10c43fbf3fd4cb8d559a4800006de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga209020467da5fef99d7cb44d22094e19"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga209020467da5fef99d7cb44d22094e19"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;, <a class="el" href="../../db/de4/classblaze_1_1TDVecTDMatMultExpr.html">TDVecTDMatMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga209020467da5fef99d7cb44d22094e19">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga209020467da5fef99d7cb44d22094e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a column-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga209020467da5fef99d7cb44d22094e19">More...</a><br /></td></tr>
<tr class="separator:ga209020467da5fef99d7cb44d22094e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9687234a3702cb5d47a825d51809e923"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9687234a3702cb5d47a825d51809e923"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;, <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga9687234a3702cb5d47a825d51809e923">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga9687234a3702cb5d47a825d51809e923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga9687234a3702cb5d47a825d51809e923">More...</a><br /></td></tr>
<tr class="separator:ga9687234a3702cb5d47a825d51809e923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaca1b39c157e1254d81907f506829b52"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaaca1b39c157e1254d81907f506829b52"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/ddb/classblaze_1_1TSMatDMatMultExpr.html">TSMatDMatMultExpr</a>&lt; T1, T2, false, false, false, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaaca1b39c157e1254d81907f506829b52">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaaca1b39c157e1254d81907f506829b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaaca1b39c157e1254d81907f506829b52">More...</a><br /></td></tr>
<tr class="separator:gaaca1b39c157e1254d81907f506829b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a19e16624e4520852a11d2a443d1ba5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2a19e16624e4520852a11d2a443d1ba5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d71/classblaze_1_1TSMatDMatSubExpr.html">TSMatDMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga2a19e16624e4520852a11d2a443d1ba5">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga2a19e16624e4520852a11d2a443d1ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga2a19e16624e4520852a11d2a443d1ba5">More...</a><br /></td></tr>
<tr class="separator:ga2a19e16624e4520852a11d2a443d1ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606b6915f14ddb392f4d24640f3fc71d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga606b6915f14ddb392f4d24640f3fc71d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T1 &gt;, <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt; &gt;, <a class="el" href="../../dc/ddb/classblaze_1_1TSMatDVecMultExpr.html">TSMatDVecMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga606b6915f14ddb392f4d24640f3fc71d">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga606b6915f14ddb392f4d24640f3fc71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_88.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga606b6915f14ddb392f4d24640f3fc71d">More...</a><br /></td></tr>
<tr class="separator:ga606b6915f14ddb392f4d24640f3fc71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d0ec5eb55760f5c13f4f3311c7c8db"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa8d0ec5eb55760f5c13f4f3311c7c8db"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/dc3/classblaze_1_1TSMatSMatMultExpr.html">TSMatSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa8d0ec5eb55760f5c13f4f3311c7c8db">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa8d0ec5eb55760f5c13f4f3311c7c8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaa8d0ec5eb55760f5c13f4f3311c7c8db">More...</a><br /></td></tr>
<tr class="separator:gaa8d0ec5eb55760f5c13f4f3311c7c8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62ef8d85c5124466413b19db53823068"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga62ef8d85c5124466413b19db53823068"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d0d/classblaze_1_1TSMatSMatSubExpr.html">TSMatSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga62ef8d85c5124466413b19db53823068">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga62ef8d85c5124466413b19db53823068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga62ef8d85c5124466413b19db53823068">More...</a><br /></td></tr>
<tr class="separator:ga62ef8d85c5124466413b19db53823068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d224a32415cdc958195e6232074795d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0d224a32415cdc958195e6232074795d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;, <a class="el" href="../../de/d16/classblaze_1_1TSMatSVecMultExpr.html">TSMatSVecMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga0d224a32415cdc958195e6232074795d">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga0d224a32415cdc958195e6232074795d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_88.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga0d224a32415cdc958195e6232074795d">More...</a><br /></td></tr>
<tr class="separator:ga0d224a32415cdc958195e6232074795d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga233c439afd6ee03cd0859bd44269e2c5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga233c439afd6ee03cd0859bd44269e2c5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d9f/classblaze_1_1TSMatTDMatMultExpr.html">TSMatTDMatMultExpr</a>&lt; T1, T2, false, false, false, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga233c439afd6ee03cd0859bd44269e2c5">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga233c439afd6ee03cd0859bd44269e2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga233c439afd6ee03cd0859bd44269e2c5">More...</a><br /></td></tr>
<tr class="separator:ga233c439afd6ee03cd0859bd44269e2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1672d9c402ae8df5b15063e9905e9b1d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1672d9c402ae8df5b15063e9905e9b1d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d90/classblaze_1_1TSMatTSMatAddExpr.html">TSMatTSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga1672d9c402ae8df5b15063e9905e9b1d">operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1672d9c402ae8df5b15063e9905e9b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_85.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga1672d9c402ae8df5b15063e9905e9b1d">More...</a><br /></td></tr>
<tr class="separator:ga1672d9c402ae8df5b15063e9905e9b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69ea4f1b211288029950a99e1e109971"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga69ea4f1b211288029950a99e1e109971"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/dec/classblaze_1_1TSMatTSMatMultExpr.html">TSMatTSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga69ea4f1b211288029950a99e1e109971">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga69ea4f1b211288029950a99e1e109971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_86.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga69ea4f1b211288029950a99e1e109971">More...</a><br /></td></tr>
<tr class="separator:ga69ea4f1b211288029950a99e1e109971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01d7793334fbcfec19fae5365a921d4a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga01d7793334fbcfec19fae5365a921d4a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d3f/classblaze_1_1TSMatTSMatSubExpr.html">TSMatTSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga01d7793334fbcfec19fae5365a921d4a">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga01d7793334fbcfec19fae5365a921d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_87.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga01d7793334fbcfec19fae5365a921d4a">More...</a><br /></td></tr>
<tr class="separator:ga01d7793334fbcfec19fae5365a921d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5432998c612b5dc4e417cea2fecaa2fb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5432998c612b5dc4e417cea2fecaa2fb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;, <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga5432998c612b5dc4e417cea2fecaa2fb">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga5432998c612b5dc4e417cea2fecaa2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a row-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga5432998c612b5dc4e417cea2fecaa2fb">More...</a><br /></td></tr>
<tr class="separator:ga5432998c612b5dc4e417cea2fecaa2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc7f6375bbc349e8a2d03e2ac42105b7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gacc7f6375bbc349e8a2d03e2ac42105b7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gacc7f6375bbc349e8a2d03e2ac42105b7">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:gacc7f6375bbc349e8a2d03e2ac42105b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a dense matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_117.png"/>).  <a href="../../de/d90/group__dense__vector.html#gacc7f6375bbc349e8a2d03e2ac42105b7">More...</a><br /></td></tr>
<tr class="separator:gacc7f6375bbc349e8a2d03e2ac42105b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d15f54904aeb15d1fd91c7fa8845f8d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9d15f54904aeb15d1fd91c7fa8845f8d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga9d15f54904aeb15d1fd91c7fa8845f8d">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga9d15f54904aeb15d1fd91c7fa8845f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of a sparse and a dense vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_119.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga9d15f54904aeb15d1fd91c7fa8845f8d">More...</a><br /></td></tr>
<tr class="separator:ga9d15f54904aeb15d1fd91c7fa8845f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0de5eb385b83bb7bc876dd563de01e99"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0de5eb385b83bb7bc876dd563de01e99"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;, <a class="el" href="../../d1/da7/classblaze_1_1TSVecSMatMultExpr.html">TSVecSMatMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga0de5eb385b83bb7bc876dd563de01e99">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga0de5eb385b83bb7bc876dd563de01e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga0de5eb385b83bb7bc876dd563de01e99">More...</a><br /></td></tr>
<tr class="separator:ga0de5eb385b83bb7bc876dd563de01e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1293580b64ed52a65885fd4e4355e15f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga1293580b64ed52a65885fd4e4355e15f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga1293580b64ed52a65885fd4e4355e15f">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga1293580b64ed52a65885fd4e4355e15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a sparse matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_117.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga1293580b64ed52a65885fd4e4355e15f">More...</a><br /></td></tr>
<tr class="separator:ga1293580b64ed52a65885fd4e4355e15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e9d01a4510e70baec3884409a1e5c0a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0e9d01a4510e70baec3884409a1e5c0a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga0e9d01a4510e70baec3884409a1e5c0a">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0e9d01a4510e70baec3884409a1e5c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of two sparse vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_119.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga0e9d01a4510e70baec3884409a1e5c0a">More...</a><br /></td></tr>
<tr class="separator:ga0e9d01a4510e70baec3884409a1e5c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bc93b1389f9ddbd225ffeab3fd2c8b3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0bc93b1389f9ddbd225ffeab3fd2c8b3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T2 &gt;, <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt; &gt;, <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0bc93b1389f9ddbd225ffeab3fd2c8b3">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga0bc93b1389f9ddbd225ffeab3fd2c8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a column-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga0bc93b1389f9ddbd225ffeab3fd2c8b3">More...</a><br /></td></tr>
<tr class="separator:ga0bc93b1389f9ddbd225ffeab3fd2c8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c8233b9db1f47343d52c4002bf9c512"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga6c8233b9db1f47343d52c4002bf9c512"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; T2 &gt;, <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt; &gt;, <a class="el" href="../../df/d31/classblaze_1_1TSVecTSMatMultExpr.html">TSVecTSMatMultExpr</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga6c8233b9db1f47343d52c4002bf9c512">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga6c8233b9db1f47343d52c4002bf9c512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_116.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga6c8233b9db1f47343d52c4002bf9c512">More...</a><br /></td></tr>
<tr class="separator:ga6c8233b9db1f47343d52c4002bf9c512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1425959f644eecd4d8a17f4c3b3220a"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gab1425959f644eecd4d8a17f4c3b3220a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab1425959f644eecd4d8a17f4c3b3220a">determineColumns</a> (<a class="el" href="../../d8/dd9/classblaze_1_1initializer__list.html">initializer_list</a>&lt; <a class="el" href="../../d8/dd9/classblaze_1_1initializer__list.html">initializer_list</a>&lt; Type &gt; &gt; list) noexcept</td></tr>
<tr class="memdesc:gab1425959f644eecd4d8a17f4c3b3220a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the maximum number of columns specified by the given initializer list.  <a href="../../de/df1/group__math.html#gab1425959f644eecd4d8a17f4c3b3220a">More...</a><br /></td></tr>
<tr class="separator:gab1425959f644eecd4d8a17f4c3b3220a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab426d893b23888cae7ef5e270a22b3"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO, typename MT2 &gt; </td></tr>
<tr class="memitem:gadab426d893b23888cae7ef5e270a22b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gadab426d893b23888cae7ef5e270a22b3">unmrq</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;C, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;A, char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT2 &gt; *tau)</td></tr>
<tr class="memdesc:gadab426d893b23888cae7ef5e270a22b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a RQ decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gadab426d893b23888cae7ef5e270a22b3">More...</a><br /></td></tr>
<tr class="separator:gadab426d893b23888cae7ef5e270a22b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e47d11c126b8289b93e01b1e89cd8e8"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga7e47d11c126b8289b93e01b1e89cd8e8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7e47d11c126b8289b93e01b1e89cd8e8">erf</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(erf(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga7e47d11c126b8289b93e01b1e89cd8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the error function of the represented element.  <a href="../../de/df1/group__math.html#ga7e47d11c126b8289b93e01b1e89cd8e8">More...</a><br /></td></tr>
<tr class="separator:ga7e47d11c126b8289b93e01b1e89cd8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc2b2b1ffee88696c64f83d83a4d81da"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gafc2b2b1ffee88696c64f83d83a4d81da"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gafc2b2b1ffee88696c64f83d83a4d81da">erfc</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(erfc(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:gafc2b2b1ffee88696c64f83d83a4d81da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the complementary error function of the represented element.  <a href="../../de/df1/group__math.html#gafc2b2b1ffee88696c64f83d83a4d81da">More...</a><br /></td></tr>
<tr class="separator:gafc2b2b1ffee88696c64f83d83a4d81da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb8155b9a2cd60299756402c877e598"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename MT , bool SO&gt; </td></tr>
<tr class="memitem:a3eb8155b9a2cd60299756402c877e598"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a3eb8155b9a2cd60299756402c877e598">serialize</a> (<a class="el" href="../../dd/d14/classblaze_1_1Archive.html">Archive</a> &amp;archive, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:a3eb8155b9a2cd60299756402c877e598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given matrix and writes it to the archive.  <a href="#a3eb8155b9a2cd60299756402c877e598">More...</a><br /></td></tr>
<tr class="separator:a3eb8155b9a2cd60299756402c877e598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9963c898337ff56c101fac8a1997513f"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename MT , bool SO&gt; </td></tr>
<tr class="memitem:a9963c898337ff56c101fac8a1997513f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a9963c898337ff56c101fac8a1997513f">deserialize</a> (<a class="el" href="../../dd/d14/classblaze_1_1Archive.html">Archive</a> &amp;archive, <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:a9963c898337ff56c101fac8a1997513f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes a matrix from the given archive.  <a href="#a9963c898337ff56c101fac8a1997513f">More...</a><br /></td></tr>
<tr class="separator:a9963c898337ff56c101fac8a1997513f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34083587480905fa636afb2190918892"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename VT , bool TF&gt; </td></tr>
<tr class="memitem:a34083587480905fa636afb2190918892"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a34083587480905fa636afb2190918892">serialize</a> (<a class="el" href="../../dd/d14/classblaze_1_1Archive.html">Archive</a> &amp;archive, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:a34083587480905fa636afb2190918892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given vector and writes it to the archive.  <a href="#a34083587480905fa636afb2190918892">More...</a><br /></td></tr>
<tr class="separator:a34083587480905fa636afb2190918892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67f16ca20411912924171d84ee37413"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ac67f16ca20411912924171d84ee37413"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ac67f16ca20411912924171d84ee37413">deserialize</a> (<a class="el" href="../../dd/d14/classblaze_1_1Archive.html">Archive</a> &amp;archive, <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:ac67f16ca20411912924171d84ee37413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes a vector from the given archive.  <a href="#ac67f16ca20411912924171d84ee37413">More...</a><br /></td></tr>
<tr class="separator:ac67f16ca20411912924171d84ee37413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2971f5afad31edbb861ffd5828125457"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga2971f5afad31edbb861ffd5828125457"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga2971f5afad31edbb861ffd5828125457">clear</a> (Type &amp;clearable)</td></tr>
<tr class="memdesc:ga2971f5afad31edbb861ffd5828125457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given value/object to the default state.  <a href="../../da/d5b/group__math__shims.html#ga2971f5afad31edbb861ffd5828125457">More...</a><br /></td></tr>
<tr class="separator:ga2971f5afad31edbb861ffd5828125457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga360f528d39c5da321e21cabf2a5de975"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga360f528d39c5da321e21cabf2a5de975"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt; T &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga360f528d39c5da321e21cabf2a5de975">conj</a> (T a) noexcept</td></tr>
<tr class="memdesc:ga360f528d39c5da321e21cabf2a5de975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the conjugate of the given value/object.  <a href="../../da/d5b/group__math__shims.html#ga360f528d39c5da321e21cabf2a5de975">More...</a><br /></td></tr>
<tr class="separator:ga360f528d39c5da321e21cabf2a5de975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab000552f031178737cd6684ba61d7a4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab000552f031178737cd6684ba61d7a4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#gab000552f031178737cd6684ba61d7a4d">conjugate</a> (T &amp;a) noexcept(<a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T &gt;::value)</td></tr>
<tr class="memdesc:gab000552f031178737cd6684ba61d7a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place conjugation of the given value/object.  <a href="../../da/d5b/group__math__shims.html#gab000552f031178737cd6684ba61d7a4d">More...</a><br /></td></tr>
<tr class="separator:gab000552f031178737cd6684ba61d7a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5353be4ad68d7007bf37a5cc56de5c5e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5353be4ad68d7007bf37a5cc56de5c5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga5353be4ad68d7007bf37a5cc56de5c5e">cswap</a> (T &amp;a, T &amp;b) noexcept(<a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T &gt;::value)</td></tr>
<tr class="memdesc:ga5353be4ad68d7007bf37a5cc56de5c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping two conjugated values/objects.  <a href="../../da/d5b/group__math__shims.html#ga5353be4ad68d7007bf37a5cc56de5c5e">More...</a><br /></td></tr>
<tr class="separator:ga5353be4ad68d7007bf37a5cc56de5c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cea4214b09438b454af619bec44c87b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga8cea4214b09438b454af619bec44c87b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga8cea4214b09438b454af619bec44c87b">equal</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ga8cea4214b09438b454af619bec44c87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic equality check.  <a href="../../da/d5b/group__math__shims.html#ga8cea4214b09438b454af619bec44c87b">More...</a><br /></td></tr>
<tr class="separator:ga8cea4214b09438b454af619bec44c87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab54517bc62ff6666932c8e52bfe7fce4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = EnableIf_&lt; IsBuiltin&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:gab54517bc62ff6666932c8e52bfe7fce4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#gab54517bc62ff6666932c8e52bfe7fce4">invcbrt</a> (T a) noexcept -&gt; decltype(<a class="el" href="../../db/df0/group__dense__matrix.html#gad2f1c5357c878446236a3b6b3d0e107c">inv</a>(<a class="el" href="../../db/df0/group__dense__matrix.html#ga62c4f8c97f9e6fde1781a9ed1c0a1a62">cbrt</a>(a)))</td></tr>
<tr class="memdesc:gab54517bc62ff6666932c8e52bfe7fce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse cubic root of the given built-in value.  <a href="../../da/d5b/group__math__shims.html#gab54517bc62ff6666932c8e52bfe7fce4">More...</a><br /></td></tr>
<tr class="separator:gab54517bc62ff6666932c8e52bfe7fce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga199b782722063ba89103d541634fd373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga199b782722063ba89103d541634fd373">inv</a> (float a) noexcept</td></tr>
<tr class="memdesc:ga199b782722063ba89103d541634fd373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverting the given single precision value.  <a href="../../da/d5b/group__math__shims.html#ga199b782722063ba89103d541634fd373">More...</a><br /></td></tr>
<tr class="separator:ga199b782722063ba89103d541634fd373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad248cb986249709d8ed18f4c13eb4154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#gad248cb986249709d8ed18f4c13eb4154">inv</a> (double a) noexcept</td></tr>
<tr class="memdesc:gad248cb986249709d8ed18f4c13eb4154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverting the given double precision value.  <a href="../../da/d5b/group__math__shims.html#gad248cb986249709d8ed18f4c13eb4154">More...</a><br /></td></tr>
<tr class="separator:gad248cb986249709d8ed18f4c13eb4154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02c750544bd9312639ecb293f520b271"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga02c750544bd9312639ecb293f520b271">inv</a> (long double a) noexcept</td></tr>
<tr class="memdesc:ga02c750544bd9312639ecb293f520b271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverting the given extended precision value.  <a href="../../da/d5b/group__math__shims.html#ga02c750544bd9312639ecb293f520b271">More...</a><br /></td></tr>
<tr class="separator:ga02c750544bd9312639ecb293f520b271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a9913702d722493acba888658e6312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> complex&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#gae9a9913702d722493acba888658e6312">inv</a> (const complex&lt; float &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:gae9a9913702d722493acba888658e6312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverting the given single precision complex number.  <a href="../../da/d5b/group__math__shims.html#gae9a9913702d722493acba888658e6312">More...</a><br /></td></tr>
<tr class="separator:gae9a9913702d722493acba888658e6312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8f86b26560ea916fde125fffa9e1ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga2c8f86b26560ea916fde125fffa9e1ea">inv</a> (const complex&lt; double &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ga2c8f86b26560ea916fde125fffa9e1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverting the given double precision complex number.  <a href="../../da/d5b/group__math__shims.html#ga2c8f86b26560ea916fde125fffa9e1ea">More...</a><br /></td></tr>
<tr class="separator:ga2c8f86b26560ea916fde125fffa9e1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14b62a008bba88ef556d15c8e2a3b9b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> complex&lt; long double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga14b62a008bba88ef556d15c8e2a3b9b1">inv</a> (const complex&lt; long double &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ga14b62a008bba88ef556d15c8e2a3b9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverting the given extended precision complex number.  <a href="../../da/d5b/group__math__shims.html#ga14b62a008bba88ef556d15c8e2a3b9b1">More...</a><br /></td></tr>
<tr class="separator:ga14b62a008bba88ef556d15c8e2a3b9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c0a1b8671eb9a41feb623c07c2e06e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga1c0a1b8671eb9a41feb623c07c2e06e1">invert</a> (float &amp;a) noexcept</td></tr>
<tr class="memdesc:ga1c0a1b8671eb9a41feb623c07c2e06e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the given single precision value.  <a href="../../da/d5b/group__math__shims.html#ga1c0a1b8671eb9a41feb623c07c2e06e1">More...</a><br /></td></tr>
<tr class="separator:ga1c0a1b8671eb9a41feb623c07c2e06e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1bfe926a2feca38a25202d0e9ad1ad1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#gaa1bfe926a2feca38a25202d0e9ad1ad1">invert</a> (double &amp;a) noexcept</td></tr>
<tr class="memdesc:gaa1bfe926a2feca38a25202d0e9ad1ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the given double precision value.  <a href="../../da/d5b/group__math__shims.html#gaa1bfe926a2feca38a25202d0e9ad1ad1">More...</a><br /></td></tr>
<tr class="separator:gaa1bfe926a2feca38a25202d0e9ad1ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68676c5a8d52eeba2b67b6d79654ba66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga68676c5a8d52eeba2b67b6d79654ba66">invert</a> (long double &amp;a) noexcept</td></tr>
<tr class="memdesc:ga68676c5a8d52eeba2b67b6d79654ba66"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the given extended precision value.  <a href="../../da/d5b/group__math__shims.html#ga68676c5a8d52eeba2b67b6d79654ba66">More...</a><br /></td></tr>
<tr class="separator:ga68676c5a8d52eeba2b67b6d79654ba66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabedd0e225cea29603584ae19c82bc000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#gabedd0e225cea29603584ae19c82bc000">invert</a> (complex&lt; float &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:gabedd0e225cea29603584ae19c82bc000"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the given single precision complex number.  <a href="../../da/d5b/group__math__shims.html#gabedd0e225cea29603584ae19c82bc000">More...</a><br /></td></tr>
<tr class="separator:gabedd0e225cea29603584ae19c82bc000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8005cd2529f3488662eecc15af3123cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga8005cd2529f3488662eecc15af3123cb">invert</a> (complex&lt; double &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ga8005cd2529f3488662eecc15af3123cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the given double precision complex number.  <a href="../../da/d5b/group__math__shims.html#ga8005cd2529f3488662eecc15af3123cb">More...</a><br /></td></tr>
<tr class="separator:ga8005cd2529f3488662eecc15af3123cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8704f22dab0a0c8983d3720f051c0085"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga8704f22dab0a0c8983d3720f051c0085">invert</a> (complex&lt; long double &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ga8704f22dab0a0c8983d3720f051c0085"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the given extended precision complex number.  <a href="../../da/d5b/group__math__shims.html#ga8704f22dab0a0c8983d3720f051c0085">More...</a><br /></td></tr>
<tr class="separator:ga8704f22dab0a0c8983d3720f051c0085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad3ff738ac027a0432960bf061fee5f9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = EnableIf_&lt; IsBuiltin&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:gaad3ff738ac027a0432960bf061fee5f9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#gaad3ff738ac027a0432960bf061fee5f9">invsqrt</a> (T a) noexcept -&gt; decltype(<a class="el" href="../../db/df0/group__dense__matrix.html#gad2f1c5357c878446236a3b6b3d0e107c">inv</a>(<a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">sqrt</a>(a)))</td></tr>
<tr class="memdesc:gaad3ff738ac027a0432960bf061fee5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse square root of the given built-in value.  <a href="../../da/d5b/group__math__shims.html#gaad3ff738ac027a0432960bf061fee5f9">More...</a><br /></td></tr>
<tr class="separator:gaad3ff738ac027a0432960bf061fee5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04488927d263a72d7538568c7145d455"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = EnableIf_&lt; IsBuiltin&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga04488927d263a72d7538568c7145d455"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga04488927d263a72d7538568c7145d455">invsqrt</a> (const complex&lt; T &gt; &amp;a) noexcept -&gt; decltype(<a class="el" href="../../db/df0/group__dense__matrix.html#gad2f1c5357c878446236a3b6b3d0e107c">inv</a>(<a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">sqrt</a>(a)))</td></tr>
<tr class="memdesc:ga04488927d263a72d7538568c7145d455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse square root of the given complex number.  <a href="../../da/d5b/group__math__shims.html#ga04488927d263a72d7538568c7145d455">More...</a><br /></td></tr>
<tr class="separator:ga04488927d263a72d7538568c7145d455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0a76b5b7a46fc79462315ad55ff8e5c"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gac0a76b5b7a46fc79462315ad55ff8e5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#gac0a76b5b7a46fc79462315ad55ff8e5c">isDefault</a> (const Type &amp;v) noexcept(<a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt; Type &gt;::value)</td></tr>
<tr class="memdesc:gac0a76b5b7a46fc79462315ad55ff8e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given value/object is in default state.  <a href="../../da/d5b/group__math__shims.html#gac0a76b5b7a46fc79462315ad55ff8e5c">More...</a><br /></td></tr>
<tr class="separator:gac0a76b5b7a46fc79462315ad55ff8e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e92c3733e47dc9c30a0103f5e40094"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename  = EnableIf_&lt; IsNumeric&lt;Type&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga16e92c3733e47dc9c30a0103f5e40094"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga16e92c3733e47dc9c30a0103f5e40094">isDivisor</a> (const Type &amp;v)</td></tr>
<tr class="memdesc:ga16e92c3733e47dc9c30a0103f5e40094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given value/object is a valid divisor.  <a href="../../da/d5b/group__math__shims.html#ga16e92c3733e47dc9c30a0103f5e40094">More...</a><br /></td></tr>
<tr class="separator:ga16e92c3733e47dc9c30a0103f5e40094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga006b7bd9fb4eac18760c8e09e976db8b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga006b7bd9fb4eac18760c8e09e976db8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga006b7bd9fb4eac18760c8e09e976db8b">isnan</a> (T a) noexcept</td></tr>
<tr class="memdesc:ga006b7bd9fb4eac18760c8e09e976db8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform independent implementation of the C99 <em>isnan</em> function.  <a href="../../da/d5b/group__math__shims.html#ga006b7bd9fb4eac18760c8e09e976db8b">More...</a><br /></td></tr>
<tr class="separator:ga006b7bd9fb4eac18760c8e09e976db8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga150647c2273bfbfe7e9d69677dc41edb"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga150647c2273bfbfe7e9d69677dc41edb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Type &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga150647c2273bfbfe7e9d69677dc41edb">isOne</a> (const Type &amp;v)</td></tr>
<tr class="memdesc:ga150647c2273bfbfe7e9d69677dc41edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given value/object represents the numeric value 1.  <a href="../../da/d5b/group__math__shims.html#ga150647c2273bfbfe7e9d69677dc41edb">More...</a><br /></td></tr>
<tr class="separator:ga150647c2273bfbfe7e9d69677dc41edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d5c0b3c1d5e5c92b47dd0c7d317b65b"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga1d5c0b3c1d5e5c92b47dd0c7d317b65b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga1d5c0b3c1d5e5c92b47dd0c7d317b65b">isReal</a> (const Type &amp;v) noexcept</td></tr>
<tr class="memdesc:ga1d5c0b3c1d5e5c92b47dd0c7d317b65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given value/object represents a real number.  <a href="../../da/d5b/group__math__shims.html#ga1d5c0b3c1d5e5c92b47dd0c7d317b65b">More...</a><br /></td></tr>
<tr class="separator:ga1d5c0b3c1d5e5c92b47dd0c7d317b65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga175ba5107c7888a0b939bf405f10627e"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga175ba5107c7888a0b939bf405f10627e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Type &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga175ba5107c7888a0b939bf405f10627e">isZero</a> (const Type &amp;v) noexcept</td></tr>
<tr class="memdesc:ga175ba5107c7888a0b939bf405f10627e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given value/object represents the numeric value 0.  <a href="../../da/d5b/group__math__shims.html#ga175ba5107c7888a0b939bf405f10627e">More...</a><br /></td></tr>
<tr class="separator:ga175ba5107c7888a0b939bf405f10627e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad66b4e88ab692c8f4ca217656cb9bcf1"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gad66b4e88ab692c8f4ca217656cb9bcf1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#gad66b4e88ab692c8f4ca217656cb9bcf1">reset</a> (Type &amp;resettable)</td></tr>
<tr class="memdesc:gad66b4e88ab692c8f4ca217656cb9bcf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given value/object to the default value.  <a href="../../da/d5b/group__math__shims.html#gad66b4e88ab692c8f4ca217656cb9bcf1">More...</a><br /></td></tr>
<tr class="separator:gad66b4e88ab692c8f4ca217656cb9bcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7bb5398d7334800a7c18fea44c81183"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab7bb5398d7334800a7c18fea44c81183"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt; T &gt;, <a class="el" href="../../d1/da9/structblaze_1_1IsComplex.html">IsComplex</a>&lt; T &gt; &gt;, const T &amp;&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#gab7bb5398d7334800a7c18fea44c81183">serial</a> (const T &amp;a) noexcept</td></tr>
<tr class="memdesc:gab7bb5398d7334800a7c18fea44c81183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formal serialization of the evaluation of the given argument.  <a href="../../da/d5b/group__math__shims.html#gab7bb5398d7334800a7c18fea44c81183">More...</a><br /></td></tr>
<tr class="separator:gab7bb5398d7334800a7c18fea44c81183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa91503eae2e88ade137a6af9c4794d4c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa91503eae2e88ade137a6af9c4794d4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#gaa91503eae2e88ade137a6af9c4794d4c">sq</a> (const T &amp;a) noexcept(noexcept(a *a))</td></tr>
<tr class="memdesc:gaa91503eae2e88ade137a6af9c4794d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squaring the given value/object.  <a href="../../da/d5b/group__math__shims.html#gaa91503eae2e88ade137a6af9c4794d4c">More...</a><br /></td></tr>
<tr class="separator:gaa91503eae2e88ade137a6af9c4794d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd762d5ea2952498de10a96d8ff8b77d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../dd/d00/classblaze_1_1SIMDuint8.html">SIMDuint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gadd762d5ea2952498de10a96d8ff8b77d">abs</a> (const <a class="el" href="../../d0/df2/classblaze_1_1SIMDint8.html">SIMDint8</a> &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gadd762d5ea2952498de10a96d8ff8b77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value of a vector of 8-bit signed integral values.  <a href="../../dc/d7b/group__simd.html#gadd762d5ea2952498de10a96d8ff8b77d">More...</a><br /></td></tr>
<tr class="separator:gadd762d5ea2952498de10a96d8ff8b77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae67c535f692ec1e1fdb5ba330550f818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d5/d05/classblaze_1_1SIMDuint16.html">SIMDuint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gae67c535f692ec1e1fdb5ba330550f818">abs</a> (const <a class="el" href="../../d5/d4c/classblaze_1_1SIMDint16.html">SIMDint16</a> &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gae67c535f692ec1e1fdb5ba330550f818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value of a vector of 16-bit signed integral values.  <a href="../../dc/d7b/group__simd.html#gae67c535f692ec1e1fdb5ba330550f818">More...</a><br /></td></tr>
<tr class="separator:gae67c535f692ec1e1fdb5ba330550f818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8524a77d9cdb784b6020c9dfdba02765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d8/d06/classblaze_1_1SIMDuint32.html">SIMDuint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga8524a77d9cdb784b6020c9dfdba02765">abs</a> (const <a class="el" href="../../db/dca/classblaze_1_1SIMDint32.html">SIMDint32</a> &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga8524a77d9cdb784b6020c9dfdba02765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value of a vector of 32-bit signed integral values.  <a href="../../dc/d7b/group__simd.html#ga8524a77d9cdb784b6020c9dfdba02765">More...</a><br /></td></tr>
<tr class="separator:ga8524a77d9cdb784b6020c9dfdba02765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff8c093b793361ec84f6340dafe1b447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d1/d32/classblaze_1_1SIMDuint64.html">SIMDuint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaff8c093b793361ec84f6340dafe1b447">abs</a> (const <a class="el" href="../../d0/d16/classblaze_1_1SIMDint64.html">SIMDint64</a> &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gaff8c093b793361ec84f6340dafe1b447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value of a vector of 64-bit signed integral values.  <a href="../../dc/d7b/group__simd.html#gaff8c093b793361ec84f6340dafe1b447">More...</a><br /></td></tr>
<tr class="separator:gaff8c093b793361ec84f6340dafe1b447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga622f83d986141689ab5b430880e7b063"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga622f83d986141689ab5b430880e7b063"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga622f83d986141689ab5b430880e7b063">acos</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga622f83d986141689ab5b430880e7b063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse cosine of a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga622f83d986141689ab5b430880e7b063">More...</a><br /></td></tr>
<tr class="separator:ga622f83d986141689ab5b430880e7b063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacab4bbb6e466607dbff3f2e16fc4991d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacab4bbb6e466607dbff3f2e16fc4991d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gacab4bbb6e466607dbff3f2e16fc4991d">acos</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gacab4bbb6e466607dbff3f2e16fc4991d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse cosine of a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gacab4bbb6e466607dbff3f2e16fc4991d">More...</a><br /></td></tr>
<tr class="separator:gacab4bbb6e466607dbff3f2e16fc4991d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b7f8c0496e3a1fb00f69bf606bc95c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6b7f8c0496e3a1fb00f69bf606bc95c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga6b7f8c0496e3a1fb00f69bf606bc95c0">acosh</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga6b7f8c0496e3a1fb00f69bf606bc95c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse hyperbolic cosine of a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga6b7f8c0496e3a1fb00f69bf606bc95c0">More...</a><br /></td></tr>
<tr class="separator:ga6b7f8c0496e3a1fb00f69bf606bc95c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcebc7e839aa6f009fe3dc30f099f43d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafcebc7e839aa6f009fe3dc30f099f43d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gafcebc7e839aa6f009fe3dc30f099f43d">acosh</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gafcebc7e839aa6f009fe3dc30f099f43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse hyperbolic cosine of a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gafcebc7e839aa6f009fe3dc30f099f43d">More...</a><br /></td></tr>
<tr class="separator:gafcebc7e839aa6f009fe3dc30f099f43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8178128d757c9e69fa89036a58b500f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8178128d757c9e69fa89036a58b500f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga8178128d757c9e69fa89036a58b500f6">operator+</a> (const SIMDi8&lt; T &gt; &amp;a, const SIMDi8&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga8178128d757c9e69fa89036a58b500f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of 8-bit integral SIMD values of the same type.  <a href="../../dc/d7b/group__simd.html#ga8178128d757c9e69fa89036a58b500f6">More...</a><br /></td></tr>
<tr class="separator:ga8178128d757c9e69fa89036a58b500f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6559f74c2abfc76b5bed68b20b8fe78"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaf6559f74c2abfc76b5bed68b20b8fe78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../dd/d00/classblaze_1_1SIMDuint8.html">SIMDuint8</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaf6559f74c2abfc76b5bed68b20b8fe78">operator+</a> (const SIMDi8&lt; T1 &gt; &amp;a, const SIMDi8&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gaf6559f74c2abfc76b5bed68b20b8fe78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of 8-bit integral SIMD values of different type.  <a href="../../dc/d7b/group__simd.html#gaf6559f74c2abfc76b5bed68b20b8fe78">More...</a><br /></td></tr>
<tr class="separator:gaf6559f74c2abfc76b5bed68b20b8fe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga761ddb4bb89b162f1f646f65025a81e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga761ddb4bb89b162f1f646f65025a81e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga761ddb4bb89b162f1f646f65025a81e5">operator+</a> (const SIMDci8&lt; T &gt; &amp;a, const SIMDci8&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga761ddb4bb89b162f1f646f65025a81e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of 8-bit integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga761ddb4bb89b162f1f646f65025a81e5">More...</a><br /></td></tr>
<tr class="separator:ga761ddb4bb89b162f1f646f65025a81e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga854799c571c7b7b9b5d6f1ca002f321c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga854799c571c7b7b9b5d6f1ca002f321c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga854799c571c7b7b9b5d6f1ca002f321c">operator+</a> (const SIMDi16&lt; T &gt; &amp;a, const SIMDi16&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga854799c571c7b7b9b5d6f1ca002f321c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of 16-bit integral SIMD values of the same type.  <a href="../../dc/d7b/group__simd.html#ga854799c571c7b7b9b5d6f1ca002f321c">More...</a><br /></td></tr>
<tr class="separator:ga854799c571c7b7b9b5d6f1ca002f321c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19059281d695151aeaa637f220ffe40a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga19059281d695151aeaa637f220ffe40a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d5/d05/classblaze_1_1SIMDuint16.html">SIMDuint16</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga19059281d695151aeaa637f220ffe40a">operator+</a> (const SIMDi16&lt; T1 &gt; &amp;a, const SIMDi16&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga19059281d695151aeaa637f220ffe40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of 16-bit integral SIMD values of different type.  <a href="../../dc/d7b/group__simd.html#ga19059281d695151aeaa637f220ffe40a">More...</a><br /></td></tr>
<tr class="separator:ga19059281d695151aeaa637f220ffe40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga664ba32762e2710ff58c7204b71a11ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga664ba32762e2710ff58c7204b71a11ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga664ba32762e2710ff58c7204b71a11ec">operator+</a> (const SIMDci16&lt; T &gt; &amp;a, const SIMDci16&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga664ba32762e2710ff58c7204b71a11ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of 16-bit integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga664ba32762e2710ff58c7204b71a11ec">More...</a><br /></td></tr>
<tr class="separator:ga664ba32762e2710ff58c7204b71a11ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaba5ec8a22894878610e0b102cd97d30"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaaba5ec8a22894878610e0b102cd97d30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaaba5ec8a22894878610e0b102cd97d30">operator+</a> (const SIMDi32&lt; T &gt; &amp;a, const SIMDi32&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gaaba5ec8a22894878610e0b102cd97d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of 32-bit integral SIMD values of the same type.  <a href="../../dc/d7b/group__simd.html#gaaba5ec8a22894878610e0b102cd97d30">More...</a><br /></td></tr>
<tr class="separator:gaaba5ec8a22894878610e0b102cd97d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f97c55ae391d978d36849cb0a8c50dc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9f97c55ae391d978d36849cb0a8c50dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d8/d06/classblaze_1_1SIMDuint32.html">SIMDuint32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga9f97c55ae391d978d36849cb0a8c50dc">operator+</a> (const SIMDi32&lt; T1 &gt; &amp;a, const SIMDi32&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga9f97c55ae391d978d36849cb0a8c50dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of 32-bit integral SIMD values of different type.  <a href="../../dc/d7b/group__simd.html#ga9f97c55ae391d978d36849cb0a8c50dc">More...</a><br /></td></tr>
<tr class="separator:ga9f97c55ae391d978d36849cb0a8c50dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8fa1e7145fc8b44268fe129a88535b4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab8fa1e7145fc8b44268fe129a88535b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gab8fa1e7145fc8b44268fe129a88535b4">operator+</a> (const SIMDci32&lt; T &gt; &amp;a, const SIMDci32&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gab8fa1e7145fc8b44268fe129a88535b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of 32-bit integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#gab8fa1e7145fc8b44268fe129a88535b4">More...</a><br /></td></tr>
<tr class="separator:gab8fa1e7145fc8b44268fe129a88535b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e6ee91bb3d5c81e0b7afc0b6f749061"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2e6ee91bb3d5c81e0b7afc0b6f749061"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga2e6ee91bb3d5c81e0b7afc0b6f749061">operator+</a> (const SIMDi64&lt; T &gt; &amp;a, const SIMDi64&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga2e6ee91bb3d5c81e0b7afc0b6f749061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of 64-bit integral SIMD values of the same type.  <a href="../../dc/d7b/group__simd.html#ga2e6ee91bb3d5c81e0b7afc0b6f749061">More...</a><br /></td></tr>
<tr class="separator:ga2e6ee91bb3d5c81e0b7afc0b6f749061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ebe02dfe9a0a87a5c38c448928116ff"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7ebe02dfe9a0a87a5c38c448928116ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d1/d32/classblaze_1_1SIMDuint64.html">SIMDuint64</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga7ebe02dfe9a0a87a5c38c448928116ff">operator+</a> (const SIMDi64&lt; T1 &gt; &amp;a, const SIMDi64&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga7ebe02dfe9a0a87a5c38c448928116ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of 64-bit integral SIMD values of different type.  <a href="../../dc/d7b/group__simd.html#ga7ebe02dfe9a0a87a5c38c448928116ff">More...</a><br /></td></tr>
<tr class="separator:ga7ebe02dfe9a0a87a5c38c448928116ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a59d055ecc69d944c84ce59f9ec4ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga27a59d055ecc69d944c84ce59f9ec4ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga27a59d055ecc69d944c84ce59f9ec4ec">operator+</a> (const SIMDci64&lt; T &gt; &amp;a, const SIMDci64&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga27a59d055ecc69d944c84ce59f9ec4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of 64-bit integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga27a59d055ecc69d944c84ce59f9ec4ec">More...</a><br /></td></tr>
<tr class="separator:ga27a59d055ecc69d944c84ce59f9ec4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf736303277d29ca38dfc51fdf31be2af"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaf736303277d29ca38dfc51fdf31be2af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaf736303277d29ca38dfc51fdf31be2af">operator+</a> (const SIMDf32&lt; T1 &gt; &amp;a, const SIMDf32&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gaf736303277d29ca38dfc51fdf31be2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of single precision floating point SIMD values.  <a href="../../dc/d7b/group__simd.html#gaf736303277d29ca38dfc51fdf31be2af">More...</a><br /></td></tr>
<tr class="separator:gaf736303277d29ca38dfc51fdf31be2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e40a780bc59eaf411decd26126dd012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga9e40a780bc59eaf411decd26126dd012">operator+</a> (const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;a, const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga9e40a780bc59eaf411decd26126dd012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of single precision complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga9e40a780bc59eaf411decd26126dd012">More...</a><br /></td></tr>
<tr class="separator:ga9e40a780bc59eaf411decd26126dd012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e3e4c69f78f33e6ffdc30d4cda91b85"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7e3e4c69f78f33e6ffdc30d4cda91b85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga7e3e4c69f78f33e6ffdc30d4cda91b85">operator+</a> (const SIMDf64&lt; T1 &gt; &amp;a, const SIMDf64&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga7e3e4c69f78f33e6ffdc30d4cda91b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of double precision floating point SIMD values.  <a href="../../dc/d7b/group__simd.html#ga7e3e4c69f78f33e6ffdc30d4cda91b85">More...</a><br /></td></tr>
<tr class="separator:ga7e3e4c69f78f33e6ffdc30d4cda91b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf553068a92bae700ef9b8932be1fc90f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaf553068a92bae700ef9b8932be1fc90f">operator+</a> (const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;a, const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gaf553068a92bae700ef9b8932be1fc90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors of double precision complex SIMD values.  <a href="../../dc/d7b/group__simd.html#gaf553068a92bae700ef9b8932be1fc90f">More...</a><br /></td></tr>
<tr class="separator:gaf553068a92bae700ef9b8932be1fc90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e8b55136caff190508b1958ca5d60c8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0e8b55136caff190508b1958ca5d60c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga0e8b55136caff190508b1958ca5d60c8">asin</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga0e8b55136caff190508b1958ca5d60c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse sine of a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga0e8b55136caff190508b1958ca5d60c8">More...</a><br /></td></tr>
<tr class="separator:ga0e8b55136caff190508b1958ca5d60c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef545169dbe274a5ef347e8c02231feb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaef545169dbe274a5ef347e8c02231feb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaef545169dbe274a5ef347e8c02231feb">asin</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gaef545169dbe274a5ef347e8c02231feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse sine of a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gaef545169dbe274a5ef347e8c02231feb">More...</a><br /></td></tr>
<tr class="separator:gaef545169dbe274a5ef347e8c02231feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd13e03954d3b19f685916bd6b0f8f87"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacd13e03954d3b19f685916bd6b0f8f87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gacd13e03954d3b19f685916bd6b0f8f87">asinh</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gacd13e03954d3b19f685916bd6b0f8f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse hyperbolic sine of a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#gacd13e03954d3b19f685916bd6b0f8f87">More...</a><br /></td></tr>
<tr class="separator:gacd13e03954d3b19f685916bd6b0f8f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d29a9d70c44a373ac3c9e625f6c5c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga31d29a9d70c44a373ac3c9e625f6c5c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga31d29a9d70c44a373ac3c9e625f6c5c2">asinh</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga31d29a9d70c44a373ac3c9e625f6c5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse hyperbolic sine of a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga31d29a9d70c44a373ac3c9e625f6c5c2">More...</a><br /></td></tr>
<tr class="separator:ga31d29a9d70c44a373ac3c9e625f6c5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0e179a051fd9bfd1f1864a9c15aef2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9f0e179a051fd9bfd1f1864a9c15aef2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga9f0e179a051fd9bfd1f1864a9c15aef2">atan</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga9f0e179a051fd9bfd1f1864a9c15aef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse tangent of a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga9f0e179a051fd9bfd1f1864a9c15aef2">More...</a><br /></td></tr>
<tr class="separator:ga9f0e179a051fd9bfd1f1864a9c15aef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad957ce6a6a4dd747fefb328240d2f3f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad957ce6a6a4dd747fefb328240d2f3f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gad957ce6a6a4dd747fefb328240d2f3f8">atan</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gad957ce6a6a4dd747fefb328240d2f3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse tangent of a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gad957ce6a6a4dd747fefb328240d2f3f8">More...</a><br /></td></tr>
<tr class="separator:gad957ce6a6a4dd747fefb328240d2f3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac02fb696666f8656914620c103be8ab7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac02fb696666f8656914620c103be8ab7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gac02fb696666f8656914620c103be8ab7">atanh</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gac02fb696666f8656914620c103be8ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse hyperbolic tangent of a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#gac02fb696666f8656914620c103be8ab7">More...</a><br /></td></tr>
<tr class="separator:gac02fb696666f8656914620c103be8ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeabbfaa9a1ebf8177a0b12c154335f19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaeabbfaa9a1ebf8177a0b12c154335f19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaeabbfaa9a1ebf8177a0b12c154335f19">atanh</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gaeabbfaa9a1ebf8177a0b12c154335f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse hyperbolic tangent of a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gaeabbfaa9a1ebf8177a0b12c154335f19">More...</a><br /></td></tr>
<tr class="separator:gaeabbfaa9a1ebf8177a0b12c154335f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf22ac092d0ae494c075fc1898e13c409"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaf22ac092d0ae494c075fc1898e13c409"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> T1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaf22ac092d0ae494c075fc1898e13c409">operator+=</a> (<a class="el" href="../../d4/d96/structblaze_1_1SIMDPack.html">SIMDPack</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../d4/d96/structblaze_1_1SIMDPack.html">SIMDPack</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf22ac092d0ae494c075fc1898e13c409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of two SIMD packs.  <a href="../../dc/d7b/group__simd.html#gaf22ac092d0ae494c075fc1898e13c409">More...</a><br /></td></tr>
<tr class="separator:gaf22ac092d0ae494c075fc1898e13c409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fe610b7012ce915a2bb685c28a42cba"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga4fe610b7012ce915a2bb685c28a42cba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> T1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga4fe610b7012ce915a2bb685c28a42cba">operator-=</a> (<a class="el" href="../../d4/d96/structblaze_1_1SIMDPack.html">SIMDPack</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../d4/d96/structblaze_1_1SIMDPack.html">SIMDPack</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4fe610b7012ce915a2bb685c28a42cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of two SIMD packs.  <a href="../../dc/d7b/group__simd.html#ga4fe610b7012ce915a2bb685c28a42cba">More...</a><br /></td></tr>
<tr class="separator:ga4fe610b7012ce915a2bb685c28a42cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75b237922aaaf8e3ab270a23c37add0d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga75b237922aaaf8e3ab270a23c37add0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> T1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga75b237922aaaf8e3ab270a23c37add0d">operator*=</a> (<a class="el" href="../../d4/d96/structblaze_1_1SIMDPack.html">SIMDPack</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../d4/d96/structblaze_1_1SIMDPack.html">SIMDPack</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga75b237922aaaf8e3ab270a23c37add0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication of two SIMD packs.  <a href="../../dc/d7b/group__simd.html#ga75b237922aaaf8e3ab270a23c37add0d">More...</a><br /></td></tr>
<tr class="separator:ga75b237922aaaf8e3ab270a23c37add0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e07a45c2c5f39d504b623165069f5c8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2e07a45c2c5f39d504b623165069f5c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> T1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga2e07a45c2c5f39d504b623165069f5c8">operator/=</a> (<a class="el" href="../../d4/d96/structblaze_1_1SIMDPack.html">SIMDPack</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../d4/d96/structblaze_1_1SIMDPack.html">SIMDPack</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga2e07a45c2c5f39d504b623165069f5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of two SIMD packs.  <a href="../../dc/d7b/group__simd.html#ga2e07a45c2c5f39d504b623165069f5c8">More...</a><br /></td></tr>
<tr class="separator:ga2e07a45c2c5f39d504b623165069f5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf254e1976c440694483e97dbc2d1cc13"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf254e1976c440694483e97dbc2d1cc13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaf254e1976c440694483e97dbc2d1cc13">cbrt</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gaf254e1976c440694483e97dbc2d1cc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cubic root for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#gaf254e1976c440694483e97dbc2d1cc13">More...</a><br /></td></tr>
<tr class="separator:gaf254e1976c440694483e97dbc2d1cc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83beb1e4e91328cabdcc17bdc8bba59b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga83beb1e4e91328cabdcc17bdc8bba59b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga83beb1e4e91328cabdcc17bdc8bba59b">cbrt</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga83beb1e4e91328cabdcc17bdc8bba59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cubic root for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga83beb1e4e91328cabdcc17bdc8bba59b">More...</a><br /></td></tr>
<tr class="separator:ga83beb1e4e91328cabdcc17bdc8bba59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd47435eea4c81423447536cb6f9e6c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadcd47435eea4c81423447536cb6f9e6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gadcd47435eea4c81423447536cb6f9e6c">ceil</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gadcd47435eea4c81423447536cb6f9e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not less than the given value for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#gadcd47435eea4c81423447536cb6f9e6c">More...</a><br /></td></tr>
<tr class="separator:gadcd47435eea4c81423447536cb6f9e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecf631c9d3fc5b547bf4490ccb6587a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaecf631c9d3fc5b547bf4490ccb6587a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaecf631c9d3fc5b547bf4490ccb6587a6">ceil</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gaecf631c9d3fc5b547bf4490ccb6587a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not less than the given value for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gaecf631c9d3fc5b547bf4490ccb6587a6">More...</a><br /></td></tr>
<tr class="separator:gaecf631c9d3fc5b547bf4490ccb6587a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1527f8525354af7e65412fe5fe09afab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1527f8525354af7e65412fe5fe09afab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga1527f8525354af7e65412fe5fe09afab">conj</a> (const SIMDi8&lt; T &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ga1527f8525354af7e65412fe5fe09afab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate of a vector of 8-bit integral values.  <a href="../../dc/d7b/group__simd.html#ga1527f8525354af7e65412fe5fe09afab">More...</a><br /></td></tr>
<tr class="separator:ga1527f8525354af7e65412fe5fe09afab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef67d09a92a63e27e4fe29c829093598"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaef67d09a92a63e27e4fe29c829093598"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaef67d09a92a63e27e4fe29c829093598">conj</a> (const SIMDi16&lt; T &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:gaef67d09a92a63e27e4fe29c829093598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate of a vector of 16-bit integral values.  <a href="../../dc/d7b/group__simd.html#gaef67d09a92a63e27e4fe29c829093598">More...</a><br /></td></tr>
<tr class="separator:gaef67d09a92a63e27e4fe29c829093598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c431a4df137275d5270bb61202177f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../db/d30/classblaze_1_1SIMDcint16.html">SIMDcint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga15c431a4df137275d5270bb61202177f">conj</a> (const <a class="el" href="../../db/d30/classblaze_1_1SIMDcint16.html">SIMDcint16</a> &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga15c431a4df137275d5270bb61202177f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate of a vector of 16-bit integral complex values.  <a href="../../dc/d7b/group__simd.html#ga15c431a4df137275d5270bb61202177f">More...</a><br /></td></tr>
<tr class="separator:ga15c431a4df137275d5270bb61202177f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b4e899bb419660c89774326342c9b18"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2b4e899bb419660c89774326342c9b18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga2b4e899bb419660c89774326342c9b18">conj</a> (const SIMDi32&lt; T &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ga2b4e899bb419660c89774326342c9b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate of a vector of 32-bit integral values.  <a href="../../dc/d7b/group__simd.html#ga2b4e899bb419660c89774326342c9b18">More...</a><br /></td></tr>
<tr class="separator:ga2b4e899bb419660c89774326342c9b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ca222e5179f2feba4add7c36a67486"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../dc/d39/classblaze_1_1SIMDcint32.html">SIMDcint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga30ca222e5179f2feba4add7c36a67486">conj</a> (const <a class="el" href="../../dc/d39/classblaze_1_1SIMDcint32.html">SIMDcint32</a> &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga30ca222e5179f2feba4add7c36a67486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate of a vector of 32-bit integral complex values.  <a href="../../dc/d7b/group__simd.html#ga30ca222e5179f2feba4add7c36a67486">More...</a><br /></td></tr>
<tr class="separator:ga30ca222e5179f2feba4add7c36a67486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d662e86c83de78631bbd84e72e28e86"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3d662e86c83de78631bbd84e72e28e86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga3d662e86c83de78631bbd84e72e28e86">conj</a> (const SIMDi64&lt; T &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ga3d662e86c83de78631bbd84e72e28e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate of a vector of 64-bit integral values.  <a href="../../dc/d7b/group__simd.html#ga3d662e86c83de78631bbd84e72e28e86">More...</a><br /></td></tr>
<tr class="separator:ga3d662e86c83de78631bbd84e72e28e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga011298f2b104a97372d0c947b6989276"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga011298f2b104a97372d0c947b6989276"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga011298f2b104a97372d0c947b6989276">conj</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ga011298f2b104a97372d0c947b6989276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate of a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga011298f2b104a97372d0c947b6989276">More...</a><br /></td></tr>
<tr class="separator:ga011298f2b104a97372d0c947b6989276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb1d449ff8403dd3aa8d9e163a8a1bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga1cb1d449ff8403dd3aa8d9e163a8a1bd">conj</a> (const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga1cb1d449ff8403dd3aa8d9e163a8a1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate of a vector of single precision complex values.  <a href="../../dc/d7b/group__simd.html#ga1cb1d449ff8403dd3aa8d9e163a8a1bd">More...</a><br /></td></tr>
<tr class="separator:ga1cb1d449ff8403dd3aa8d9e163a8a1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9603f02ceaa470805d0231368fb8eb2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac9603f02ceaa470805d0231368fb8eb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gac9603f02ceaa470805d0231368fb8eb2">conj</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:gac9603f02ceaa470805d0231368fb8eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate of a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gac9603f02ceaa470805d0231368fb8eb2">More...</a><br /></td></tr>
<tr class="separator:gac9603f02ceaa470805d0231368fb8eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb0fae387f4ba0ea77d6b99c3175a461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaeb0fae387f4ba0ea77d6b99c3175a461">conj</a> (const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gaeb0fae387f4ba0ea77d6b99c3175a461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate of a vector of double precision complex values.  <a href="../../dc/d7b/group__simd.html#gaeb0fae387f4ba0ea77d6b99c3175a461">More...</a><br /></td></tr>
<tr class="separator:gaeb0fae387f4ba0ea77d6b99c3175a461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20fb04066e19468e2556efdb937349fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga20fb04066e19468e2556efdb937349fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga20fb04066e19468e2556efdb937349fe">cos</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga20fb04066e19468e2556efdb937349fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cosine of a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga20fb04066e19468e2556efdb937349fe">More...</a><br /></td></tr>
<tr class="separator:ga20fb04066e19468e2556efdb937349fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36deb551fcbb80080774a55c466ff5fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga36deb551fcbb80080774a55c466ff5fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga36deb551fcbb80080774a55c466ff5fb">cos</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga36deb551fcbb80080774a55c466ff5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cosine of a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga36deb551fcbb80080774a55c466ff5fb">More...</a><br /></td></tr>
<tr class="separator:ga36deb551fcbb80080774a55c466ff5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d7725dfca2700eec4e78d1c7bbc0d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf2d7725dfca2700eec4e78d1c7bbc0d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaf2d7725dfca2700eec4e78d1c7bbc0d0">cosh</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gaf2d7725dfca2700eec4e78d1c7bbc0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic cosine of a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#gaf2d7725dfca2700eec4e78d1c7bbc0d0">More...</a><br /></td></tr>
<tr class="separator:gaf2d7725dfca2700eec4e78d1c7bbc0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6d1da13b9e11efd884c67151614006"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1b6d1da13b9e11efd884c67151614006"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga1b6d1da13b9e11efd884c67151614006">cosh</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga1b6d1da13b9e11efd884c67151614006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic cosine of a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga1b6d1da13b9e11efd884c67151614006">More...</a><br /></td></tr>
<tr class="separator:ga1b6d1da13b9e11efd884c67151614006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4b7c996f3dd4e279b6b4d533471f9ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../db/dca/classblaze_1_1SIMDint32.html">SIMDint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gad4b7c996f3dd4e279b6b4d533471f9ad">operator/</a> (const <a class="el" href="../../db/dca/classblaze_1_1SIMDint32.html">SIMDint32</a> &amp;a, const <a class="el" href="../../db/dca/classblaze_1_1SIMDint32.html">SIMDint32</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gad4b7c996f3dd4e279b6b4d533471f9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of two vectors of 32-bit signed integral SIMD values.  <a href="../../dc/d7b/group__simd.html#gad4b7c996f3dd4e279b6b4d533471f9ad">More...</a><br /></td></tr>
<tr class="separator:gad4b7c996f3dd4e279b6b4d533471f9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdf9c6b565d6147d88d849d7d6f8308b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../dc/d39/classblaze_1_1SIMDcint32.html">SIMDcint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gacdf9c6b565d6147d88d849d7d6f8308b">operator/</a> (const <a class="el" href="../../dc/d39/classblaze_1_1SIMDcint32.html">SIMDcint32</a> &amp;a, const <a class="el" href="../../db/dca/classblaze_1_1SIMDint32.html">SIMDint32</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gacdf9c6b565d6147d88d849d7d6f8308b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of 32-bit signed integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#gacdf9c6b565d6147d88d849d7d6f8308b">More...</a><br /></td></tr>
<tr class="separator:gacdf9c6b565d6147d88d849d7d6f8308b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4abf9ed2c1d2eb78ab49010f4288170f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d0/d16/classblaze_1_1SIMDint64.html">SIMDint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga4abf9ed2c1d2eb78ab49010f4288170f">operator/</a> (const <a class="el" href="../../d0/d16/classblaze_1_1SIMDint64.html">SIMDint64</a> &amp;a, const <a class="el" href="../../d0/d16/classblaze_1_1SIMDint64.html">SIMDint64</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga4abf9ed2c1d2eb78ab49010f4288170f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of two vectors of 64-bit signed integral SIMD values.  <a href="../../dc/d7b/group__simd.html#ga4abf9ed2c1d2eb78ab49010f4288170f">More...</a><br /></td></tr>
<tr class="separator:ga4abf9ed2c1d2eb78ab49010f4288170f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db2a85384e91b4cac4f2e926466c87d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d7/df7/classblaze_1_1SIMDcint64.html">SIMDcint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga0db2a85384e91b4cac4f2e926466c87d">operator/</a> (const <a class="el" href="../../d7/df7/classblaze_1_1SIMDcint64.html">SIMDcint64</a> &amp;a, const <a class="el" href="../../d0/d16/classblaze_1_1SIMDint64.html">SIMDint64</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga0db2a85384e91b4cac4f2e926466c87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of 64-bit signed integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga0db2a85384e91b4cac4f2e926466c87d">More...</a><br /></td></tr>
<tr class="separator:ga0db2a85384e91b4cac4f2e926466c87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad20bdb35d3385ae922380d7eacec43"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gafad20bdb35d3385ae922380d7eacec43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gafad20bdb35d3385ae922380d7eacec43">operator/</a> (const SIMDf32&lt; T1 &gt; &amp;a, const SIMDf32&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gafad20bdb35d3385ae922380d7eacec43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of two vectors of single precision floating point SIMD values.  <a href="../../dc/d7b/group__simd.html#gafad20bdb35d3385ae922380d7eacec43">More...</a><br /></td></tr>
<tr class="separator:gafad20bdb35d3385ae922380d7eacec43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b59bba775e5fe7318b271f4bca85488"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga1b59bba775e5fe7318b271f4bca85488">operator/</a> (const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;a, const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga1b59bba775e5fe7318b271f4bca85488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of single precision floating point values complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga1b59bba775e5fe7318b271f4bca85488">More...</a><br /></td></tr>
<tr class="separator:ga1b59bba775e5fe7318b271f4bca85488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad12c7ab6e60dfddb5580c7b8bf803225"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gad12c7ab6e60dfddb5580c7b8bf803225"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gad12c7ab6e60dfddb5580c7b8bf803225">operator/</a> (const SIMDf64&lt; T1 &gt; &amp;a, const SIMDf64&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gad12c7ab6e60dfddb5580c7b8bf803225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of two vectors of double precision floating point SIMD values.  <a href="../../dc/d7b/group__simd.html#gad12c7ab6e60dfddb5580c7b8bf803225">More...</a><br /></td></tr>
<tr class="separator:gad12c7ab6e60dfddb5580c7b8bf803225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga119f63b2035344c7aaa987992ab123f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga119f63b2035344c7aaa987992ab123f2">operator/</a> (const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;a, const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga119f63b2035344c7aaa987992ab123f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of double precision floating point values complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga119f63b2035344c7aaa987992ab123f2">More...</a><br /></td></tr>
<tr class="separator:ga119f63b2035344c7aaa987992ab123f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c42131104c8b4a5c94f0febfb57a501"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1c42131104c8b4a5c94f0febfb57a501"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga1c42131104c8b4a5c94f0febfb57a501">erf</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga1c42131104c8b4a5c94f0febfb57a501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga1c42131104c8b4a5c94f0febfb57a501">More...</a><br /></td></tr>
<tr class="separator:ga1c42131104c8b4a5c94f0febfb57a501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ed00a87ebb085a05fed9177449fc1ee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8ed00a87ebb085a05fed9177449fc1ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga8ed00a87ebb085a05fed9177449fc1ee">erf</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga8ed00a87ebb085a05fed9177449fc1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga8ed00a87ebb085a05fed9177449fc1ee">More...</a><br /></td></tr>
<tr class="separator:ga8ed00a87ebb085a05fed9177449fc1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ae4253ce4a4acbfbf78547e6ab43ac9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6ae4253ce4a4acbfbf78547e6ab43ac9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga6ae4253ce4a4acbfbf78547e6ab43ac9">erfc</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga6ae4253ce4a4acbfbf78547e6ab43ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complementary error function for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga6ae4253ce4a4acbfbf78547e6ab43ac9">More...</a><br /></td></tr>
<tr class="separator:ga6ae4253ce4a4acbfbf78547e6ab43ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19b20f04cd405fea2ba94e8afed71700"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga19b20f04cd405fea2ba94e8afed71700"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga19b20f04cd405fea2ba94e8afed71700">erfc</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga19b20f04cd405fea2ba94e8afed71700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complementary error function for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga19b20f04cd405fea2ba94e8afed71700">More...</a><br /></td></tr>
<tr class="separator:ga19b20f04cd405fea2ba94e8afed71700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ece9a9680ec3021102ca30c143e83f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad3ece9a9680ec3021102ca30c143e83f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gad3ece9a9680ec3021102ca30c143e83f">exp</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gad3ece9a9680ec3021102ca30c143e83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#gad3ece9a9680ec3021102ca30c143e83f">More...</a><br /></td></tr>
<tr class="separator:gad3ece9a9680ec3021102ca30c143e83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47abbcea54e6cabf93cd21131289da92"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga47abbcea54e6cabf93cd21131289da92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga47abbcea54e6cabf93cd21131289da92">exp</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga47abbcea54e6cabf93cd21131289da92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ e^x $" src="../../form_95.png"/> for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga47abbcea54e6cabf93cd21131289da92">More...</a><br /></td></tr>
<tr class="separator:ga47abbcea54e6cabf93cd21131289da92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ebb17bd4e5a6fe66962bb56b1763df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga45ebb17bd4e5a6fe66962bb56b1763df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga45ebb17bd4e5a6fe66962bb56b1763df">exp10</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga45ebb17bd4e5a6fe66962bb56b1763df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga45ebb17bd4e5a6fe66962bb56b1763df">More...</a><br /></td></tr>
<tr class="separator:ga45ebb17bd4e5a6fe66962bb56b1763df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9ebf073cfa817949c851e4e3da7a4f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa9ebf073cfa817949c851e4e3da7a4f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaa9ebf073cfa817949c851e4e3da7a4f7">exp10</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gaa9ebf073cfa817949c851e4e3da7a4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_97.png"/> for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gaa9ebf073cfa817949c851e4e3da7a4f7">More...</a><br /></td></tr>
<tr class="separator:gaa9ebf073cfa817949c851e4e3da7a4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae325448400257df29b5e3b46c4356e38"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae325448400257df29b5e3b46c4356e38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gae325448400257df29b5e3b46c4356e38">exp2</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gae325448400257df29b5e3b46c4356e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#gae325448400257df29b5e3b46c4356e38">More...</a><br /></td></tr>
<tr class="separator:gae325448400257df29b5e3b46c4356e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd67a07310ed8226fbaed8b8ee652aa7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadd67a07310ed8226fbaed8b8ee652aa7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gadd67a07310ed8226fbaed8b8ee652aa7">exp2</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gadd67a07310ed8226fbaed8b8ee652aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_96.png"/> for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gadd67a07310ed8226fbaed8b8ee652aa7">More...</a><br /></td></tr>
<tr class="separator:gadd67a07310ed8226fbaed8b8ee652aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fffeb8d0393157454c51237661802e1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4fffeb8d0393157454c51237661802e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga4fffeb8d0393157454c51237661802e1">floor</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga4fffeb8d0393157454c51237661802e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than the given value for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga4fffeb8d0393157454c51237661802e1">More...</a><br /></td></tr>
<tr class="separator:ga4fffeb8d0393157454c51237661802e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70854858c37d71cc58635bb12237dea9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga70854858c37d71cc58635bb12237dea9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga70854858c37d71cc58635bb12237dea9">floor</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga70854858c37d71cc58635bb12237dea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than the given value for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga70854858c37d71cc58635bb12237dea9">More...</a><br /></td></tr>
<tr class="separator:ga70854858c37d71cc58635bb12237dea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8673d433016c9c0ed820d3d4a7ecc85e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8673d433016c9c0ed820d3d4a7ecc85e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga8673d433016c9c0ed820d3d4a7ecc85e">invcbrt</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga8673d433016c9c0ed820d3d4a7ecc85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cubic root for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga8673d433016c9c0ed820d3d4a7ecc85e">More...</a><br /></td></tr>
<tr class="separator:ga8673d433016c9c0ed820d3d4a7ecc85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d3e62e0325abdad310032d31c3b52e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga11d3e62e0325abdad310032d31c3b52e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga11d3e62e0325abdad310032d31c3b52e">invcbrt</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga11d3e62e0325abdad310032d31c3b52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cubic root for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga11d3e62e0325abdad310032d31c3b52e">More...</a><br /></td></tr>
<tr class="separator:ga11d3e62e0325abdad310032d31c3b52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0686f58396b67cb90bde875bd9482624"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0686f58396b67cb90bde875bd9482624"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga0686f58396b67cb90bde875bd9482624">invsqrt</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga0686f58396b67cb90bde875bd9482624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse square root for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga0686f58396b67cb90bde875bd9482624">More...</a><br /></td></tr>
<tr class="separator:ga0686f58396b67cb90bde875bd9482624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a9714405673111b08b183affdf55a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga63a9714405673111b08b183affdf55a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga63a9714405673111b08b183affdf55a2">invsqrt</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga63a9714405673111b08b183affdf55a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse square root for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga63a9714405673111b08b183affdf55a2">More...</a><br /></td></tr>
<tr class="separator:ga63a9714405673111b08b183affdf55a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a4f91650b74b5a9e9f75644de855a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac4a4f91650b74b5a9e9f75644de855a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 1UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDint8, SIMDuint8 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gac4a4f91650b74b5a9e9f75644de855a9">loada</a> (const T *address) noexcept</td></tr>
<tr class="memdesc:gac4a4f91650b74b5a9e9f75644de855a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 1-byte integral values.  <a href="../../dc/d7b/group__simd.html#gac4a4f91650b74b5a9e9f75644de855a9">More...</a><br /></td></tr>
<tr class="separator:gac4a4f91650b74b5a9e9f75644de855a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404fa5fb3449f8075ac59e90b82c4008"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga404fa5fb3449f8075ac59e90b82c4008"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 1UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDcint8, SIMDcuint8 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga404fa5fb3449f8075ac59e90b82c4008">loada</a> (const complex&lt; T &gt; *address) noexcept</td></tr>
<tr class="memdesc:ga404fa5fb3449f8075ac59e90b82c4008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 1-byte integral complex values.  <a href="../../dc/d7b/group__simd.html#ga404fa5fb3449f8075ac59e90b82c4008">More...</a><br /></td></tr>
<tr class="separator:ga404fa5fb3449f8075ac59e90b82c4008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a4f91650b74b5a9e9f75644de855a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac4a4f91650b74b5a9e9f75644de855a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 2UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDint16, SIMDuint16 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gac4a4f91650b74b5a9e9f75644de855a9">loada</a> (const T *address) noexcept</td></tr>
<tr class="memdesc:gac4a4f91650b74b5a9e9f75644de855a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 2-byte integral values.  <a href="#gac4a4f91650b74b5a9e9f75644de855a9">More...</a><br /></td></tr>
<tr class="separator:gac4a4f91650b74b5a9e9f75644de855a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404fa5fb3449f8075ac59e90b82c4008"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga404fa5fb3449f8075ac59e90b82c4008"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 2UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDcint16, SIMDcuint16 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga404fa5fb3449f8075ac59e90b82c4008">loada</a> (const complex&lt; T &gt; *address) noexcept</td></tr>
<tr class="memdesc:ga404fa5fb3449f8075ac59e90b82c4008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 2-byte integral complex values.  <a href="#ga404fa5fb3449f8075ac59e90b82c4008">More...</a><br /></td></tr>
<tr class="separator:ga404fa5fb3449f8075ac59e90b82c4008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a4f91650b74b5a9e9f75644de855a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac4a4f91650b74b5a9e9f75644de855a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 4UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDint32, SIMDuint32 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gac4a4f91650b74b5a9e9f75644de855a9">loada</a> (const T *address) noexcept</td></tr>
<tr class="memdesc:gac4a4f91650b74b5a9e9f75644de855a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 4-byte integral values.  <a href="#gac4a4f91650b74b5a9e9f75644de855a9">More...</a><br /></td></tr>
<tr class="separator:gac4a4f91650b74b5a9e9f75644de855a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404fa5fb3449f8075ac59e90b82c4008"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga404fa5fb3449f8075ac59e90b82c4008"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 4UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDcint32, SIMDcuint32 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga404fa5fb3449f8075ac59e90b82c4008">loada</a> (const complex&lt; T &gt; *address) noexcept</td></tr>
<tr class="memdesc:ga404fa5fb3449f8075ac59e90b82c4008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 4-byte integral complex values.  <a href="#ga404fa5fb3449f8075ac59e90b82c4008">More...</a><br /></td></tr>
<tr class="separator:ga404fa5fb3449f8075ac59e90b82c4008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a4f91650b74b5a9e9f75644de855a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac4a4f91650b74b5a9e9f75644de855a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 8UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDint64, SIMDuint64 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gac4a4f91650b74b5a9e9f75644de855a9">loada</a> (const T *address) noexcept</td></tr>
<tr class="memdesc:gac4a4f91650b74b5a9e9f75644de855a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 8-byte integral values.  <a href="#gac4a4f91650b74b5a9e9f75644de855a9">More...</a><br /></td></tr>
<tr class="separator:gac4a4f91650b74b5a9e9f75644de855a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404fa5fb3449f8075ac59e90b82c4008"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga404fa5fb3449f8075ac59e90b82c4008"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 8UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDcint64, SIMDcuint64 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga404fa5fb3449f8075ac59e90b82c4008">loada</a> (const complex&lt; T &gt; *address) noexcept</td></tr>
<tr class="memdesc:ga404fa5fb3449f8075ac59e90b82c4008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 8-byte integral complex values.  <a href="#ga404fa5fb3449f8075ac59e90b82c4008">More...</a><br /></td></tr>
<tr class="separator:ga404fa5fb3449f8075ac59e90b82c4008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a24ce541d635ac71bf1202e5662a737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga2a24ce541d635ac71bf1202e5662a737">loada</a> (const float *address) noexcept</td></tr>
<tr class="memdesc:ga2a24ce541d635ac71bf1202e5662a737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 'float' values.  <a href="../../dc/d7b/group__simd.html#ga2a24ce541d635ac71bf1202e5662a737">More...</a><br /></td></tr>
<tr class="separator:ga2a24ce541d635ac71bf1202e5662a737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5e9b6a66052fb47d1e1c79a92a9e56e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaf5e9b6a66052fb47d1e1c79a92a9e56e">loada</a> (const complex&lt; float &gt; *address) noexcept</td></tr>
<tr class="memdesc:gaf5e9b6a66052fb47d1e1c79a92a9e56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 'complex&lt;float&gt;' values.  <a href="../../dc/d7b/group__simd.html#gaf5e9b6a66052fb47d1e1c79a92a9e56e">More...</a><br /></td></tr>
<tr class="separator:gaf5e9b6a66052fb47d1e1c79a92a9e56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga808d5d841561730410d061bf57b6b3d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga808d5d841561730410d061bf57b6b3d1">loada</a> (const double *address) noexcept</td></tr>
<tr class="memdesc:ga808d5d841561730410d061bf57b6b3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 'double' values.  <a href="../../dc/d7b/group__simd.html#ga808d5d841561730410d061bf57b6b3d1">More...</a><br /></td></tr>
<tr class="separator:ga808d5d841561730410d061bf57b6b3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9d2d041f7d1a7669b9d62685ead758e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gae9d2d041f7d1a7669b9d62685ead758e">loada</a> (const complex&lt; double &gt; *address) noexcept</td></tr>
<tr class="memdesc:gae9d2d041f7d1a7669b9d62685ead758e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 'complex&lt;double&gt;' values.  <a href="../../dc/d7b/group__simd.html#gae9d2d041f7d1a7669b9d62685ead758e">More...</a><br /></td></tr>
<tr class="separator:gae9d2d041f7d1a7669b9d62685ead758e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 1UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDint8, SIMDuint8 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga5f63e61aa59bef1a8fdb4d001c5f8308">loadu</a> (const T *address) noexcept</td></tr>
<tr class="memdesc:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 1-byte integral values.  <a href="../../dc/d7b/group__simd.html#ga5f63e61aa59bef1a8fdb4d001c5f8308">More...</a><br /></td></tr>
<tr class="separator:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8da21dcf40da70f6a44976dfeccda5d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac8da21dcf40da70f6a44976dfeccda5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 1UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDcint8, SIMDcuint8 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gac8da21dcf40da70f6a44976dfeccda5d">loadu</a> (const complex&lt; T &gt; *address) noexcept</td></tr>
<tr class="memdesc:gac8da21dcf40da70f6a44976dfeccda5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 1-byte integral complex values.  <a href="../../dc/d7b/group__simd.html#gac8da21dcf40da70f6a44976dfeccda5d">More...</a><br /></td></tr>
<tr class="separator:gac8da21dcf40da70f6a44976dfeccda5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 2UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDint16, SIMDuint16 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga5f63e61aa59bef1a8fdb4d001c5f8308">loadu</a> (const T *address) noexcept</td></tr>
<tr class="memdesc:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 2-byte integral values.  <a href="#ga5f63e61aa59bef1a8fdb4d001c5f8308">More...</a><br /></td></tr>
<tr class="separator:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8da21dcf40da70f6a44976dfeccda5d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac8da21dcf40da70f6a44976dfeccda5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 2UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDcint16, SIMDcuint16 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gac8da21dcf40da70f6a44976dfeccda5d">loadu</a> (const complex&lt; T &gt; *address) noexcept</td></tr>
<tr class="memdesc:gac8da21dcf40da70f6a44976dfeccda5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 2-byte integral complex values.  <a href="#gac8da21dcf40da70f6a44976dfeccda5d">More...</a><br /></td></tr>
<tr class="separator:gac8da21dcf40da70f6a44976dfeccda5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 4UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDint32, SIMDuint32 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga5f63e61aa59bef1a8fdb4d001c5f8308">loadu</a> (const T *address) noexcept</td></tr>
<tr class="memdesc:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 4-byte integral values.  <a href="#ga5f63e61aa59bef1a8fdb4d001c5f8308">More...</a><br /></td></tr>
<tr class="separator:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8da21dcf40da70f6a44976dfeccda5d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac8da21dcf40da70f6a44976dfeccda5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 4UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDcint32, SIMDcuint32 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gac8da21dcf40da70f6a44976dfeccda5d">loadu</a> (const complex&lt; T &gt; *address) noexcept</td></tr>
<tr class="memdesc:gac8da21dcf40da70f6a44976dfeccda5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 4-byte integral complex values.  <a href="#gac8da21dcf40da70f6a44976dfeccda5d">More...</a><br /></td></tr>
<tr class="separator:gac8da21dcf40da70f6a44976dfeccda5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 8UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDint64, SIMDuint64 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga5f63e61aa59bef1a8fdb4d001c5f8308">loadu</a> (const T *address) noexcept</td></tr>
<tr class="memdesc:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 8-byte integral values.  <a href="#ga5f63e61aa59bef1a8fdb4d001c5f8308">More...</a><br /></td></tr>
<tr class="separator:ga5f63e61aa59bef1a8fdb4d001c5f8308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8da21dcf40da70f6a44976dfeccda5d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac8da21dcf40da70f6a44976dfeccda5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 8UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDcint64, SIMDcuint64 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gac8da21dcf40da70f6a44976dfeccda5d">loadu</a> (const complex&lt; T &gt; *address) noexcept</td></tr>
<tr class="memdesc:gac8da21dcf40da70f6a44976dfeccda5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 8-byte integral complex values.  <a href="#gac8da21dcf40da70f6a44976dfeccda5d">More...</a><br /></td></tr>
<tr class="separator:gac8da21dcf40da70f6a44976dfeccda5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ac3a8787393e95fc775380733210e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga27ac3a8787393e95fc775380733210e4">loadu</a> (const float *address) noexcept</td></tr>
<tr class="memdesc:ga27ac3a8787393e95fc775380733210e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 'float' values.  <a href="../../dc/d7b/group__simd.html#ga27ac3a8787393e95fc775380733210e4">More...</a><br /></td></tr>
<tr class="separator:ga27ac3a8787393e95fc775380733210e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27704940d8fc000a9f95c48477ca804c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga27704940d8fc000a9f95c48477ca804c">loadu</a> (const complex&lt; float &gt; *address) noexcept</td></tr>
<tr class="memdesc:ga27704940d8fc000a9f95c48477ca804c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 'complex&lt;float&gt;' values.  <a href="../../dc/d7b/group__simd.html#ga27704940d8fc000a9f95c48477ca804c">More...</a><br /></td></tr>
<tr class="separator:ga27704940d8fc000a9f95c48477ca804c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914ee03aa7724b8139ba21e1337c1861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga914ee03aa7724b8139ba21e1337c1861">loadu</a> (const double *address) noexcept</td></tr>
<tr class="memdesc:ga914ee03aa7724b8139ba21e1337c1861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 'double' values.  <a href="../../dc/d7b/group__simd.html#ga914ee03aa7724b8139ba21e1337c1861">More...</a><br /></td></tr>
<tr class="separator:ga914ee03aa7724b8139ba21e1337c1861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac66d1d0731d4882a12afc5bba781ab7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gac66d1d0731d4882a12afc5bba781ab7a">loadu</a> (const complex&lt; double &gt; *address) noexcept</td></tr>
<tr class="memdesc:gac66d1d0731d4882a12afc5bba781ab7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 'complex&lt;double&gt;' values.  <a href="../../dc/d7b/group__simd.html#gac66d1d0731d4882a12afc5bba781ab7a">More...</a><br /></td></tr>
<tr class="separator:gac66d1d0731d4882a12afc5bba781ab7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac058c45840c70b23b214bfd8bd38a695"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac058c45840c70b23b214bfd8bd38a695"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gac058c45840c70b23b214bfd8bd38a695">log</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gac058c45840c70b23b214bfd8bd38a695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#gac058c45840c70b23b214bfd8bd38a695">More...</a><br /></td></tr>
<tr class="separator:gac058c45840c70b23b214bfd8bd38a695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga475d6d312628d7a5ea7e4a2a39ddb86d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga475d6d312628d7a5ea7e4a2a39ddb86d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga475d6d312628d7a5ea7e4a2a39ddb86d">log</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga475d6d312628d7a5ea7e4a2a39ddb86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga475d6d312628d7a5ea7e4a2a39ddb86d">More...</a><br /></td></tr>
<tr class="separator:ga475d6d312628d7a5ea7e4a2a39ddb86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43e6f1187c4a59b42dfd89415cd70385"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga43e6f1187c4a59b42dfd89415cd70385"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga43e6f1187c4a59b42dfd89415cd70385">log10</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga43e6f1187c4a59b42dfd89415cd70385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the common logarithm for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga43e6f1187c4a59b42dfd89415cd70385">More...</a><br /></td></tr>
<tr class="separator:ga43e6f1187c4a59b42dfd89415cd70385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8641e917d67abd83c347f96190cd9f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac8641e917d67abd83c347f96190cd9f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gac8641e917d67abd83c347f96190cd9f5">log10</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gac8641e917d67abd83c347f96190cd9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the common logarithm for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gac8641e917d67abd83c347f96190cd9f5">More...</a><br /></td></tr>
<tr class="separator:gac8641e917d67abd83c347f96190cd9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad04799e4b933697845c269bf179f494c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad04799e4b933697845c269bf179f494c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gad04799e4b933697845c269bf179f494c">log2</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gad04799e4b933697845c269bf179f494c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary logarithm for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#gad04799e4b933697845c269bf179f494c">More...</a><br /></td></tr>
<tr class="separator:gad04799e4b933697845c269bf179f494c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7fa95868384be38968daaf08011f466"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad7fa95868384be38968daaf08011f466"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gad7fa95868384be38968daaf08011f466">log2</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gad7fa95868384be38968daaf08011f466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary logarithm for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gad7fa95868384be38968daaf08011f466">More...</a><br /></td></tr>
<tr class="separator:gad7fa95868384be38968daaf08011f466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee150930cc8f14933516155430a4faae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaee150930cc8f14933516155430a4faae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaee150930cc8f14933516155430a4faae">operator*</a> (const SIMDi16&lt; T &gt; &amp;a, const SIMDi16&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gaee150930cc8f14933516155430a4faae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of two vectors of 16-bit integral SIMD values of the same type.  <a href="../../dc/d7b/group__simd.html#gaee150930cc8f14933516155430a4faae">More...</a><br /></td></tr>
<tr class="separator:gaee150930cc8f14933516155430a4faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd43ece245268f76c525e93b18a0398"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga8fd43ece245268f76c525e93b18a0398"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d5/d05/classblaze_1_1SIMDuint16.html">SIMDuint16</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga8fd43ece245268f76c525e93b18a0398">operator*</a> (const SIMDi16&lt; T1 &gt; &amp;a, const SIMDi16&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga8fd43ece245268f76c525e93b18a0398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of two vectors of 16-bit integral SIMD values of different type.  <a href="../../dc/d7b/group__simd.html#ga8fd43ece245268f76c525e93b18a0398">More...</a><br /></td></tr>
<tr class="separator:ga8fd43ece245268f76c525e93b18a0398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf7b4157ce0fdd548640993cf59f6240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../db/d30/classblaze_1_1SIMDcint16.html">SIMDcint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gabf7b4157ce0fdd548640993cf59f6240">operator*</a> (const <a class="el" href="../../db/d30/classblaze_1_1SIMDcint16.html">SIMDcint16</a> &amp;a, const <a class="el" href="../../d5/d4c/classblaze_1_1SIMDint16.html">SIMDint16</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gabf7b4157ce0fdd548640993cf59f6240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of 16-bit signed integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#gabf7b4157ce0fdd548640993cf59f6240">More...</a><br /></td></tr>
<tr class="separator:gabf7b4157ce0fdd548640993cf59f6240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1750ae8f66d76b3f9e14b103e5879e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../dc/d8d/classblaze_1_1SIMDcuint16.html">SIMDcuint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga4e1750ae8f66d76b3f9e14b103e5879e">operator*</a> (const <a class="el" href="../../dc/d8d/classblaze_1_1SIMDcuint16.html">SIMDcuint16</a> &amp;a, const <a class="el" href="../../d5/d05/classblaze_1_1SIMDuint16.html">SIMDuint16</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga4e1750ae8f66d76b3f9e14b103e5879e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of 16-bit unsigned integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga4e1750ae8f66d76b3f9e14b103e5879e">More...</a><br /></td></tr>
<tr class="separator:ga4e1750ae8f66d76b3f9e14b103e5879e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga903b396f0201c1401ec46bcf0ac45fb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../db/d30/classblaze_1_1SIMDcint16.html">SIMDcint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga903b396f0201c1401ec46bcf0ac45fb1">operator*</a> (const <a class="el" href="../../d5/d4c/classblaze_1_1SIMDint16.html">SIMDint16</a> &amp;a, const <a class="el" href="../../db/d30/classblaze_1_1SIMDcint16.html">SIMDcint16</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga903b396f0201c1401ec46bcf0ac45fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of 16-bit signed integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga903b396f0201c1401ec46bcf0ac45fb1">More...</a><br /></td></tr>
<tr class="separator:ga903b396f0201c1401ec46bcf0ac45fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a3b63e77701ec8f2b09ecdf53b4ea77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../dc/d8d/classblaze_1_1SIMDcuint16.html">SIMDcuint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga8a3b63e77701ec8f2b09ecdf53b4ea77">operator*</a> (const <a class="el" href="../../d5/d05/classblaze_1_1SIMDuint16.html">SIMDuint16</a> &amp;a, const <a class="el" href="../../dc/d8d/classblaze_1_1SIMDcuint16.html">SIMDcuint16</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga8a3b63e77701ec8f2b09ecdf53b4ea77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of 16-bit unsigned integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga8a3b63e77701ec8f2b09ecdf53b4ea77">More...</a><br /></td></tr>
<tr class="separator:ga8a3b63e77701ec8f2b09ecdf53b4ea77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98036709c5fd4c066f3ae22bfa9cfe5b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga98036709c5fd4c066f3ae22bfa9cfe5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga98036709c5fd4c066f3ae22bfa9cfe5b">operator*</a> (const SIMDci16&lt; T &gt; &amp;a, const SIMDci16&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga98036709c5fd4c066f3ae22bfa9cfe5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of two vectors of 16-bit integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga98036709c5fd4c066f3ae22bfa9cfe5b">More...</a><br /></td></tr>
<tr class="separator:ga98036709c5fd4c066f3ae22bfa9cfe5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b3d099f4e12257f2d16203a81d9e00b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2b3d099f4e12257f2d16203a81d9e00b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga2b3d099f4e12257f2d16203a81d9e00b">operator*</a> (const SIMDi32&lt; T &gt; &amp;a, const SIMDi32&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga2b3d099f4e12257f2d16203a81d9e00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of two vectors of 32-bit integral SIMD values of the same type.  <a href="../../dc/d7b/group__simd.html#ga2b3d099f4e12257f2d16203a81d9e00b">More...</a><br /></td></tr>
<tr class="separator:ga2b3d099f4e12257f2d16203a81d9e00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga124137d202ca59b3a22b06f791f4bc75"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga124137d202ca59b3a22b06f791f4bc75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d8/d06/classblaze_1_1SIMDuint32.html">SIMDuint32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga124137d202ca59b3a22b06f791f4bc75">operator*</a> (const SIMDi32&lt; T1 &gt; &amp;a, const SIMDi32&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga124137d202ca59b3a22b06f791f4bc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of two vectors of 32-bit integral SIMD values of different type.  <a href="../../dc/d7b/group__simd.html#ga124137d202ca59b3a22b06f791f4bc75">More...</a><br /></td></tr>
<tr class="separator:ga124137d202ca59b3a22b06f791f4bc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d7ccb8579a0769188bf6f72f3e0dd48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../dc/d39/classblaze_1_1SIMDcint32.html">SIMDcint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga9d7ccb8579a0769188bf6f72f3e0dd48">operator*</a> (const <a class="el" href="../../dc/d39/classblaze_1_1SIMDcint32.html">SIMDcint32</a> &amp;a, const <a class="el" href="../../db/dca/classblaze_1_1SIMDint32.html">SIMDint32</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga9d7ccb8579a0769188bf6f72f3e0dd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of 32-bit signed integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga9d7ccb8579a0769188bf6f72f3e0dd48">More...</a><br /></td></tr>
<tr class="separator:ga9d7ccb8579a0769188bf6f72f3e0dd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43c1190637f54317d8c9b35078d9213a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../df/d64/classblaze_1_1SIMDcuint32.html">SIMDcuint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga43c1190637f54317d8c9b35078d9213a">operator*</a> (const <a class="el" href="../../df/d64/classblaze_1_1SIMDcuint32.html">SIMDcuint32</a> &amp;a, const <a class="el" href="../../d8/d06/classblaze_1_1SIMDuint32.html">SIMDuint32</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga43c1190637f54317d8c9b35078d9213a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of 32-bit unsigned integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga43c1190637f54317d8c9b35078d9213a">More...</a><br /></td></tr>
<tr class="separator:ga43c1190637f54317d8c9b35078d9213a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga772c5da25d5bf32ca405155ae7ec98fc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga772c5da25d5bf32ca405155ae7ec98fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../dc/d39/classblaze_1_1SIMDcint32.html">SIMDcint32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga772c5da25d5bf32ca405155ae7ec98fc">operator*</a> (const <a class="el" href="../../db/dca/classblaze_1_1SIMDint32.html">SIMDint32</a> &amp;a, const <a class="el" href="../../dc/d39/classblaze_1_1SIMDcint32.html">SIMDcint32</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga772c5da25d5bf32ca405155ae7ec98fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of 32-bit signed integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga772c5da25d5bf32ca405155ae7ec98fc">More...</a><br /></td></tr>
<tr class="separator:ga772c5da25d5bf32ca405155ae7ec98fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9745c116930459902a2b23b6c661d026"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9745c116930459902a2b23b6c661d026"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../df/d64/classblaze_1_1SIMDcuint32.html">SIMDcuint32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga9745c116930459902a2b23b6c661d026">operator*</a> (const <a class="el" href="../../d8/d06/classblaze_1_1SIMDuint32.html">SIMDuint32</a> &amp;a, const <a class="el" href="../../df/d64/classblaze_1_1SIMDcuint32.html">SIMDcuint32</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga9745c116930459902a2b23b6c661d026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of 32-bit unsigned integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga9745c116930459902a2b23b6c661d026">More...</a><br /></td></tr>
<tr class="separator:ga9745c116930459902a2b23b6c661d026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0be665878ee820e853289ccba06ca7c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf0be665878ee820e853289ccba06ca7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaf0be665878ee820e853289ccba06ca7c">operator*</a> (const SIMDci32&lt; T &gt; &amp;a, const SIMDci32&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gaf0be665878ee820e853289ccba06ca7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of two vectors of 32-bit integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#gaf0be665878ee820e853289ccba06ca7c">More...</a><br /></td></tr>
<tr class="separator:gaf0be665878ee820e853289ccba06ca7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14e9e78d82d27081ca74bd661a052c09"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga14e9e78d82d27081ca74bd661a052c09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../df/d1a/structblaze_1_1SIMDf32MultExpr.html">SIMDf32MultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga14e9e78d82d27081ca74bd661a052c09">operator*</a> (const SIMDf32&lt; T1 &gt; &amp;a, const SIMDf32&lt; T2 &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga14e9e78d82d27081ca74bd661a052c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of two vectors of single precision floating point SIMD values.  <a href="../../dc/d7b/group__simd.html#ga14e9e78d82d27081ca74bd661a052c09">More...</a><br /></td></tr>
<tr class="separator:ga14e9e78d82d27081ca74bd661a052c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd2a5eeaac7f194f7b941963f238d804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gadd2a5eeaac7f194f7b941963f238d804">operator*</a> (const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;a, const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gadd2a5eeaac7f194f7b941963f238d804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of single precision complex SIMD values.  <a href="../../dc/d7b/group__simd.html#gadd2a5eeaac7f194f7b941963f238d804">More...</a><br /></td></tr>
<tr class="separator:gadd2a5eeaac7f194f7b941963f238d804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f9494999362e4bc25acb3ea17329377"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga1f9494999362e4bc25acb3ea17329377">operator*</a> (const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a> &amp;a, const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga1f9494999362e4bc25acb3ea17329377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of single precision complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga1f9494999362e4bc25acb3ea17329377">More...</a><br /></td></tr>
<tr class="separator:ga1f9494999362e4bc25acb3ea17329377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1617ae51ecf477a31cec465e089f0795"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga1617ae51ecf477a31cec465e089f0795">operator*</a> (const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;a, const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga1617ae51ecf477a31cec465e089f0795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of two vectors of single precision complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga1617ae51ecf477a31cec465e089f0795">More...</a><br /></td></tr>
<tr class="separator:ga1617ae51ecf477a31cec465e089f0795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga041b75a8c42dae620ebe9ca29eeef8fb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga041b75a8c42dae620ebe9ca29eeef8fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d1/da9/structblaze_1_1SIMDf64MultExpr.html">SIMDf64MultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga041b75a8c42dae620ebe9ca29eeef8fb">operator*</a> (const SIMDf64&lt; T1 &gt; &amp;a, const SIMDf64&lt; T2 &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga041b75a8c42dae620ebe9ca29eeef8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of two vectors of double precision floating point SIMD values.  <a href="../../dc/d7b/group__simd.html#ga041b75a8c42dae620ebe9ca29eeef8fb">More...</a><br /></td></tr>
<tr class="separator:ga041b75a8c42dae620ebe9ca29eeef8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ea591d1a6925e5106aa9b9fcfafc01d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga8ea591d1a6925e5106aa9b9fcfafc01d">operator*</a> (const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;a, const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga8ea591d1a6925e5106aa9b9fcfafc01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of double precision complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga8ea591d1a6925e5106aa9b9fcfafc01d">More...</a><br /></td></tr>
<tr class="separator:ga8ea591d1a6925e5106aa9b9fcfafc01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eac297f5c3d80a1b237adebf4efac51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga9eac297f5c3d80a1b237adebf4efac51">operator*</a> (const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a> &amp;a, const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga9eac297f5c3d80a1b237adebf4efac51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of a vector of double precision complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga9eac297f5c3d80a1b237adebf4efac51">More...</a><br /></td></tr>
<tr class="separator:ga9eac297f5c3d80a1b237adebf4efac51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85f9e7f30ba572fca9a871d290dbd57b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga85f9e7f30ba572fca9a871d290dbd57b">operator*</a> (const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;a, const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga85f9e7f30ba572fca9a871d290dbd57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of two vectors of double precision complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga85f9e7f30ba572fca9a871d290dbd57b">More...</a><br /></td></tr>
<tr class="separator:ga85f9e7f30ba572fca9a871d290dbd57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b1c03ca1b2d7e7fcc0e92bd11424945"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2b1c03ca1b2d7e7fcc0e92bd11424945"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga2b1c03ca1b2d7e7fcc0e92bd11424945">pow</a> (const SIMDf32&lt; T &gt; &amp;a, const SIMDf32&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga2b1c03ca1b2d7e7fcc0e92bd11424945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponential value of a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga2b1c03ca1b2d7e7fcc0e92bd11424945">More...</a><br /></td></tr>
<tr class="separator:ga2b1c03ca1b2d7e7fcc0e92bd11424945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacac74daa739d369972477ff8be3b97e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacac74daa739d369972477ff8be3b97e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gacac74daa739d369972477ff8be3b97e8">pow</a> (const SIMDf64&lt; T &gt; &amp;a, const SIMDf64&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gacac74daa739d369972477ff8be3b97e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponential value of a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gacac74daa739d369972477ff8be3b97e8">More...</a><br /></td></tr>
<tr class="separator:gacac74daa739d369972477ff8be3b97e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f0f052116d519e6a1c0792e138c5838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const complex&lt; <a class="el" href="../../d6/d3b/classblaze_1_1int8__t.html">int8_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga7f0f052116d519e6a1c0792e138c5838">sum</a> (const <a class="el" href="../../d8/db1/classblaze_1_1SIMDcint8.html">SIMDcint8</a> &amp;a) noexcept</td></tr>
<tr class="memdesc:ga7f0f052116d519e6a1c0792e138c5838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the 8-bit integral complex SIMD vector.  <a href="../../dc/d7b/group__simd.html#ga7f0f052116d519e6a1c0792e138c5838">More...</a><br /></td></tr>
<tr class="separator:ga7f0f052116d519e6a1c0792e138c5838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee33d08a7e461881c97fc725a0bba813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/d66/classblaze_1_1int16__t.html">int16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaee33d08a7e461881c97fc725a0bba813">sum</a> (const <a class="el" href="../../d5/d4c/classblaze_1_1SIMDint16.html">SIMDint16</a> &amp;a) noexcept</td></tr>
<tr class="memdesc:gaee33d08a7e461881c97fc725a0bba813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the 16-bit integral SIMD vector.  <a href="../../dc/d7b/group__simd.html#gaee33d08a7e461881c97fc725a0bba813">More...</a><br /></td></tr>
<tr class="separator:gaee33d08a7e461881c97fc725a0bba813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52971b7eca856dc6ba762e469c9c1df1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const complex&lt; <a class="el" href="../../d9/d66/classblaze_1_1int16__t.html">int16_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga52971b7eca856dc6ba762e469c9c1df1">sum</a> (const <a class="el" href="../../db/d30/classblaze_1_1SIMDcint16.html">SIMDcint16</a> &amp;a) noexcept</td></tr>
<tr class="memdesc:ga52971b7eca856dc6ba762e469c9c1df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the 16-bit integral complex SIMD vector.  <a href="../../dc/d7b/group__simd.html#ga52971b7eca856dc6ba762e469c9c1df1">More...</a><br /></td></tr>
<tr class="separator:ga52971b7eca856dc6ba762e469c9c1df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5903060fd96fcb103aaed693f6424ceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d2d/classblaze_1_1int32__t.html">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga5903060fd96fcb103aaed693f6424ceb">sum</a> (const <a class="el" href="../../db/dca/classblaze_1_1SIMDint32.html">SIMDint32</a> &amp;a) noexcept</td></tr>
<tr class="memdesc:ga5903060fd96fcb103aaed693f6424ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the 32-bit integral SIMD vector.  <a href="../../dc/d7b/group__simd.html#ga5903060fd96fcb103aaed693f6424ceb">More...</a><br /></td></tr>
<tr class="separator:ga5903060fd96fcb103aaed693f6424ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fce1394cfa47d8c30d78a0028c34f7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const complex&lt; <a class="el" href="../../de/d2d/classblaze_1_1int32__t.html">int32_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga9fce1394cfa47d8c30d78a0028c34f7f">sum</a> (const <a class="el" href="../../dc/d39/classblaze_1_1SIMDcint32.html">SIMDcint32</a> &amp;a) noexcept</td></tr>
<tr class="memdesc:ga9fce1394cfa47d8c30d78a0028c34f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the 32-bit integral complex SIMD vector.  <a href="../../dc/d7b/group__simd.html#ga9fce1394cfa47d8c30d78a0028c34f7f">More...</a><br /></td></tr>
<tr class="separator:ga9fce1394cfa47d8c30d78a0028c34f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9058105bd8af75f4f3cc4b070b63f9cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d8/dc7/classblaze_1_1int64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga9058105bd8af75f4f3cc4b070b63f9cf">sum</a> (const <a class="el" href="../../d0/d16/classblaze_1_1SIMDint64.html">SIMDint64</a> &amp;a) noexcept</td></tr>
<tr class="memdesc:ga9058105bd8af75f4f3cc4b070b63f9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the 64-bit integral SIMD vector.  <a href="../../dc/d7b/group__simd.html#ga9058105bd8af75f4f3cc4b070b63f9cf">More...</a><br /></td></tr>
<tr class="separator:ga9058105bd8af75f4f3cc4b070b63f9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72447eb38e6c08e24c97fb7fbab9522d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const complex&lt; <a class="el" href="../../d8/dc7/classblaze_1_1int64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga72447eb38e6c08e24c97fb7fbab9522d">sum</a> (const <a class="el" href="../../d7/df7/classblaze_1_1SIMDcint64.html">SIMDcint64</a> &amp;a) noexcept</td></tr>
<tr class="memdesc:ga72447eb38e6c08e24c97fb7fbab9522d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the 64-bit integral complex SIMD vector.  <a href="../../dc/d7b/group__simd.html#ga72447eb38e6c08e24c97fb7fbab9522d">More...</a><br /></td></tr>
<tr class="separator:ga72447eb38e6c08e24c97fb7fbab9522d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267325ca080d086e3e0a8cf4e940e389"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga267325ca080d086e3e0a8cf4e940e389">sum</a> (const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a> &amp;a) noexcept</td></tr>
<tr class="memdesc:ga267325ca080d086e3e0a8cf4e940e389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the single precision floating point SIMD vector.  <a href="../../dc/d7b/group__simd.html#ga267325ca080d086e3e0a8cf4e940e389">More...</a><br /></td></tr>
<tr class="separator:ga267325ca080d086e3e0a8cf4e940e389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c3eb5bd395d7ec98593604517daeef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const complex&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga92c3eb5bd395d7ec98593604517daeef">sum</a> (const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;a) noexcept</td></tr>
<tr class="memdesc:ga92c3eb5bd395d7ec98593604517daeef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the single precision complex SIMD vector.  <a href="../../dc/d7b/group__simd.html#ga92c3eb5bd395d7ec98593604517daeef">More...</a><br /></td></tr>
<tr class="separator:ga92c3eb5bd395d7ec98593604517daeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4e94f661ed5a37186dc15e6ba0de23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaab4e94f661ed5a37186dc15e6ba0de23">sum</a> (const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a> &amp;a) noexcept</td></tr>
<tr class="memdesc:gaab4e94f661ed5a37186dc15e6ba0de23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the double precision floating point SIMD vector.  <a href="../../dc/d7b/group__simd.html#gaab4e94f661ed5a37186dc15e6ba0de23">More...</a><br /></td></tr>
<tr class="separator:gaab4e94f661ed5a37186dc15e6ba0de23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf444d06da6bd2ec13f4a783ffe7ffa73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaf444d06da6bd2ec13f4a783ffe7ffa73">sum</a> (const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;a) noexcept</td></tr>
<tr class="memdesc:gaf444d06da6bd2ec13f4a783ffe7ffa73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the double precision complex SIMD vector.  <a href="../../dc/d7b/group__simd.html#gaf444d06da6bd2ec13f4a783ffe7ffa73">More...</a><br /></td></tr>
<tr class="separator:gaf444d06da6bd2ec13f4a783ffe7ffa73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12b846ea9bbafe90e280c856f67b1ab4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga12b846ea9bbafe90e280c856f67b1ab4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga12b846ea9bbafe90e280c856f67b1ab4">round</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga12b846ea9bbafe90e280c856f67b1ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integers for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga12b846ea9bbafe90e280c856f67b1ab4">More...</a><br /></td></tr>
<tr class="separator:ga12b846ea9bbafe90e280c856f67b1ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae926dfd2193b85ca87639b7f752ebc97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae926dfd2193b85ca87639b7f752ebc97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gae926dfd2193b85ca87639b7f752ebc97">round</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gae926dfd2193b85ca87639b7f752ebc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integers for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gae926dfd2193b85ca87639b7f752ebc97">More...</a><br /></td></tr>
<tr class="separator:gae926dfd2193b85ca87639b7f752ebc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga123bb79d57112645ef44ef5675361a4c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga123bb79d57112645ef44ef5675361a4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 1UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDint8, SIMDuint8 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga123bb79d57112645ef44ef5675361a4c">set</a> (T value) noexcept</td></tr>
<tr class="memdesc:ga123bb79d57112645ef44ef5675361a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given 1-byte integral value.  <a href="../../dc/d7b/group__simd.html#ga123bb79d57112645ef44ef5675361a4c">More...</a><br /></td></tr>
<tr class="separator:ga123bb79d57112645ef44ef5675361a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 1UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDcint8, SIMDcuint8 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga0bd1dc51798d68a2458f7f1164cb59ab">set</a> (complex&lt; T &gt; value) noexcept</td></tr>
<tr class="memdesc:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given 1-byte integral complex value.  <a href="../../dc/d7b/group__simd.html#ga0bd1dc51798d68a2458f7f1164cb59ab">More...</a><br /></td></tr>
<tr class="separator:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga123bb79d57112645ef44ef5675361a4c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga123bb79d57112645ef44ef5675361a4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 2UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDint16, SIMDuint16 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga123bb79d57112645ef44ef5675361a4c">set</a> (T value) noexcept</td></tr>
<tr class="memdesc:ga123bb79d57112645ef44ef5675361a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given 2-byte integral value.  <a href="#ga123bb79d57112645ef44ef5675361a4c">More...</a><br /></td></tr>
<tr class="separator:ga123bb79d57112645ef44ef5675361a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 2UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDcint16, SIMDcuint16 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga0bd1dc51798d68a2458f7f1164cb59ab">set</a> (complex&lt; T &gt; value) noexcept</td></tr>
<tr class="memdesc:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given 2-byte integral complex value.  <a href="#ga0bd1dc51798d68a2458f7f1164cb59ab">More...</a><br /></td></tr>
<tr class="separator:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga123bb79d57112645ef44ef5675361a4c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga123bb79d57112645ef44ef5675361a4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 4UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDint32, SIMDuint32 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga123bb79d57112645ef44ef5675361a4c">set</a> (T value) noexcept</td></tr>
<tr class="memdesc:ga123bb79d57112645ef44ef5675361a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given 4-byte integral value.  <a href="#ga123bb79d57112645ef44ef5675361a4c">More...</a><br /></td></tr>
<tr class="separator:ga123bb79d57112645ef44ef5675361a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 4UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDcint32, SIMDcuint32 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga0bd1dc51798d68a2458f7f1164cb59ab">set</a> (complex&lt; T &gt; value) noexcept</td></tr>
<tr class="memdesc:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given 4-byte integral complex value.  <a href="#ga0bd1dc51798d68a2458f7f1164cb59ab">More...</a><br /></td></tr>
<tr class="separator:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga123bb79d57112645ef44ef5675361a4c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga123bb79d57112645ef44ef5675361a4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 8UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDint64, SIMDuint64 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga123bb79d57112645ef44ef5675361a4c">set</a> (T value) noexcept</td></tr>
<tr class="memdesc:ga123bb79d57112645ef44ef5675361a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given 8-byte integral value.  <a href="#ga123bb79d57112645ef44ef5675361a4c">More...</a><br /></td></tr>
<tr class="separator:ga123bb79d57112645ef44ef5675361a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T, 8UL &gt; &gt;, If_&lt; IsSigned&lt; T &gt;, SIMDcint64, SIMDcuint64 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga0bd1dc51798d68a2458f7f1164cb59ab">set</a> (complex&lt; T &gt; value) noexcept</td></tr>
<tr class="memdesc:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given 8-byte integral complex value.  <a href="#ga0bd1dc51798d68a2458f7f1164cb59ab">More...</a><br /></td></tr>
<tr class="separator:ga0bd1dc51798d68a2458f7f1164cb59ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f16ca380b8c8ca0bd8c83438121fc08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga5f16ca380b8c8ca0bd8c83438121fc08">set</a> (float value) noexcept</td></tr>
<tr class="memdesc:ga5f16ca380b8c8ca0bd8c83438121fc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given 'float' value.  <a href="../../dc/d7b/group__simd.html#ga5f16ca380b8c8ca0bd8c83438121fc08">More...</a><br /></td></tr>
<tr class="separator:ga5f16ca380b8c8ca0bd8c83438121fc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74f9dce4d19e6f00d1a0f4ab45cfe216"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga74f9dce4d19e6f00d1a0f4ab45cfe216">set</a> (const complex&lt; float &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga74f9dce4d19e6f00d1a0f4ab45cfe216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given 'complex&lt;float&gt;' value.  <a href="../../dc/d7b/group__simd.html#ga74f9dce4d19e6f00d1a0f4ab45cfe216">More...</a><br /></td></tr>
<tr class="separator:ga74f9dce4d19e6f00d1a0f4ab45cfe216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7dab0e77e2a224a499444ceafaf31ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gac7dab0e77e2a224a499444ceafaf31ff">set</a> (double value) noexcept</td></tr>
<tr class="memdesc:gac7dab0e77e2a224a499444ceafaf31ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given 'double' value.  <a href="../../dc/d7b/group__simd.html#gac7dab0e77e2a224a499444ceafaf31ff">More...</a><br /></td></tr>
<tr class="separator:gac7dab0e77e2a224a499444ceafaf31ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c6ec9d07f8c08bfb7dc1d2503bdbf57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga7c6ec9d07f8c08bfb7dc1d2503bdbf57">set</a> (const complex&lt; double &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga7c6ec9d07f8c08bfb7dc1d2503bdbf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given 'complex&lt;double&gt;' value.  <a href="../../dc/d7b/group__simd.html#ga7c6ec9d07f8c08bfb7dc1d2503bdbf57">More...</a><br /></td></tr>
<tr class="separator:ga7c6ec9d07f8c08bfb7dc1d2503bdbf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34f0a38ef9a48fec1a0ad3b32ed30171"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga34f0a38ef9a48fec1a0ad3b32ed30171"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga34f0a38ef9a48fec1a0ad3b32ed30171">setzero</a> (SIMDi8&lt; T &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga34f0a38ef9a48fec1a0ad3b32ed30171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an integral SIMD type with 8-bit data values to zero.  <a href="../../dc/d7b/group__simd.html#ga34f0a38ef9a48fec1a0ad3b32ed30171">More...</a><br /></td></tr>
<tr class="separator:ga34f0a38ef9a48fec1a0ad3b32ed30171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf05cfdd14fa97c172a71af1fccebef26"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf05cfdd14fa97c172a71af1fccebef26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaf05cfdd14fa97c172a71af1fccebef26">setzero</a> (SIMDci8&lt; T &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:gaf05cfdd14fa97c172a71af1fccebef26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an integral SIMD type with 8-bit complex values to zero.  <a href="../../dc/d7b/group__simd.html#gaf05cfdd14fa97c172a71af1fccebef26">More...</a><br /></td></tr>
<tr class="separator:gaf05cfdd14fa97c172a71af1fccebef26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga312c81a8568dc553ce8a11dd5bc66812"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga312c81a8568dc553ce8a11dd5bc66812"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga312c81a8568dc553ce8a11dd5bc66812">setzero</a> (SIMDi16&lt; T &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga312c81a8568dc553ce8a11dd5bc66812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an integral SIMD type with 16-bit data values to zero.  <a href="../../dc/d7b/group__simd.html#ga312c81a8568dc553ce8a11dd5bc66812">More...</a><br /></td></tr>
<tr class="separator:ga312c81a8568dc553ce8a11dd5bc66812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d612f95d4f69108a6d500dffd007924"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0d612f95d4f69108a6d500dffd007924"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga0d612f95d4f69108a6d500dffd007924">setzero</a> (SIMDci16&lt; T &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga0d612f95d4f69108a6d500dffd007924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an integral SIMD type with 16-bit complex values to zero.  <a href="../../dc/d7b/group__simd.html#ga0d612f95d4f69108a6d500dffd007924">More...</a><br /></td></tr>
<tr class="separator:ga0d612f95d4f69108a6d500dffd007924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab23f29221f8870e81001dcfe5ee3b911"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab23f29221f8870e81001dcfe5ee3b911"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gab23f29221f8870e81001dcfe5ee3b911">setzero</a> (SIMDi32&lt; T &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:gab23f29221f8870e81001dcfe5ee3b911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an integral SIMD type with 32-bit data values to zero.  <a href="../../dc/d7b/group__simd.html#gab23f29221f8870e81001dcfe5ee3b911">More...</a><br /></td></tr>
<tr class="separator:gab23f29221f8870e81001dcfe5ee3b911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4b119bde99a975362d8f5dddad6d97c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad4b119bde99a975362d8f5dddad6d97c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gad4b119bde99a975362d8f5dddad6d97c">setzero</a> (SIMDci32&lt; T &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:gad4b119bde99a975362d8f5dddad6d97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an integral SIMD type with 32-bit complex values to zero.  <a href="../../dc/d7b/group__simd.html#gad4b119bde99a975362d8f5dddad6d97c">More...</a><br /></td></tr>
<tr class="separator:gad4b119bde99a975362d8f5dddad6d97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab588a7db4562267fcc5943655d21faf6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab588a7db4562267fcc5943655d21faf6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gab588a7db4562267fcc5943655d21faf6">setzero</a> (SIMDi64&lt; T &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:gab588a7db4562267fcc5943655d21faf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an integral SIMD type with 64-bit data values to zero.  <a href="../../dc/d7b/group__simd.html#gab588a7db4562267fcc5943655d21faf6">More...</a><br /></td></tr>
<tr class="separator:gab588a7db4562267fcc5943655d21faf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5376b7e4b6a9c79db564ca586a2cd85b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5376b7e4b6a9c79db564ca586a2cd85b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga5376b7e4b6a9c79db564ca586a2cd85b">setzero</a> (SIMDci64&lt; T &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga5376b7e4b6a9c79db564ca586a2cd85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an integral SIMD type with 64-bit complex values to zero.  <a href="../../dc/d7b/group__simd.html#ga5376b7e4b6a9c79db564ca586a2cd85b">More...</a><br /></td></tr>
<tr class="separator:ga5376b7e4b6a9c79db564ca586a2cd85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76cbd6dd0f4fa028d971a5807b4cc174"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga76cbd6dd0f4fa028d971a5807b4cc174">setzero</a> (<a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ga76cbd6dd0f4fa028d971a5807b4cc174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting a floating point SIMD type with 32-bit single precision data values to zero.  <a href="../../dc/d7b/group__simd.html#ga76cbd6dd0f4fa028d971a5807b4cc174">More...</a><br /></td></tr>
<tr class="separator:ga76cbd6dd0f4fa028d971a5807b4cc174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd5d109c1253b35265a0792b5a6219e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga7fd5d109c1253b35265a0792b5a6219e">setzero</a> (<a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ga7fd5d109c1253b35265a0792b5a6219e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting a floating point SIMD type with 32-bit single precision complex values to zero.  <a href="../../dc/d7b/group__simd.html#ga7fd5d109c1253b35265a0792b5a6219e">More...</a><br /></td></tr>
<tr class="separator:ga7fd5d109c1253b35265a0792b5a6219e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24cc3614d4ef544fe0ac16f91fce5df4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga24cc3614d4ef544fe0ac16f91fce5df4">setzero</a> (<a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ga24cc3614d4ef544fe0ac16f91fce5df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting a floating point SIMD type with 64-bit double precision data values to zero.  <a href="../../dc/d7b/group__simd.html#ga24cc3614d4ef544fe0ac16f91fce5df4">More...</a><br /></td></tr>
<tr class="separator:ga24cc3614d4ef544fe0ac16f91fce5df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762f70acdcb4e735fee9e9e407e8e149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga762f70acdcb4e735fee9e9e407e8e149">setzero</a> (<a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ga762f70acdcb4e735fee9e9e407e8e149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting a floating point SIMD type with 32-bit double precision complex values to zero.  <a href="../../dc/d7b/group__simd.html#ga762f70acdcb4e735fee9e9e407e8e149">More...</a><br /></td></tr>
<tr class="separator:ga762f70acdcb4e735fee9e9e407e8e149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga845d6f40ae9d36f8fac2113da7e9b690"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga845d6f40ae9d36f8fac2113da7e9b690"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga845d6f40ae9d36f8fac2113da7e9b690">sin</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga845d6f40ae9d36f8fac2113da7e9b690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sine of a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga845d6f40ae9d36f8fac2113da7e9b690">More...</a><br /></td></tr>
<tr class="separator:ga845d6f40ae9d36f8fac2113da7e9b690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d96f0f2db1a2be833a6cc3bf210ca4e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3d96f0f2db1a2be833a6cc3bf210ca4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga3d96f0f2db1a2be833a6cc3bf210ca4e">sin</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga3d96f0f2db1a2be833a6cc3bf210ca4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sine of a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga3d96f0f2db1a2be833a6cc3bf210ca4e">More...</a><br /></td></tr>
<tr class="separator:ga3d96f0f2db1a2be833a6cc3bf210ca4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1417b67e6382be5e2b93d0882ecddccb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1417b67e6382be5e2b93d0882ecddccb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga1417b67e6382be5e2b93d0882ecddccb">sinh</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga1417b67e6382be5e2b93d0882ecddccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic sine of a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga1417b67e6382be5e2b93d0882ecddccb">More...</a><br /></td></tr>
<tr class="separator:ga1417b67e6382be5e2b93d0882ecddccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c03527350b1a138ef143fe1be935fe3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4c03527350b1a138ef143fe1be935fe3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga4c03527350b1a138ef143fe1be935fe3">sinh</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga4c03527350b1a138ef143fe1be935fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic sine of a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga4c03527350b1a138ef143fe1be935fe3">More...</a><br /></td></tr>
<tr class="separator:ga4c03527350b1a138ef143fe1be935fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb80a6a5f00c076bbb792c17f8e51715"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadb80a6a5f00c076bbb792c17f8e51715"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gadb80a6a5f00c076bbb792c17f8e51715">sqrt</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gadb80a6a5f00c076bbb792c17f8e51715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#gadb80a6a5f00c076bbb792c17f8e51715">More...</a><br /></td></tr>
<tr class="separator:gadb80a6a5f00c076bbb792c17f8e51715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae4a0a68b08df794503c6b562e321e32"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaae4a0a68b08df794503c6b562e321e32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaae4a0a68b08df794503c6b562e321e32">sqrt</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gaae4a0a68b08df794503c6b562e321e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gaae4a0a68b08df794503c6b562e321e32">More...</a><br /></td></tr>
<tr class="separator:gaae4a0a68b08df794503c6b562e321e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad4138ece60d226b64452beee8c833a4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaad4138ece60d226b64452beee8c833a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 1UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaad4138ece60d226b64452beee8c833a4">storea</a> (T1 *address, const SIMDi8&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:gaad4138ece60d226b64452beee8c833a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of 1-byte integral values.  <a href="../../dc/d7b/group__simd.html#gaad4138ece60d226b64452beee8c833a4">More...</a><br /></td></tr>
<tr class="separator:gaad4138ece60d226b64452beee8c833a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00fb3f8939900405ee46ce63210dd96d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga00fb3f8939900405ee46ce63210dd96d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 1UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga00fb3f8939900405ee46ce63210dd96d">storea</a> (complex&lt; T1 &gt; *address, const SIMDci8&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga00fb3f8939900405ee46ce63210dd96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of 1-byte integral complex values.  <a href="../../dc/d7b/group__simd.html#ga00fb3f8939900405ee46ce63210dd96d">More...</a><br /></td></tr>
<tr class="separator:ga00fb3f8939900405ee46ce63210dd96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e80ccc4575f82073b01f10d23435180"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0e80ccc4575f82073b01f10d23435180"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 2UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga0e80ccc4575f82073b01f10d23435180">storea</a> (T1 *address, const SIMDi16&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga0e80ccc4575f82073b01f10d23435180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of 2-byte integral values.  <a href="../../dc/d7b/group__simd.html#ga0e80ccc4575f82073b01f10d23435180">More...</a><br /></td></tr>
<tr class="separator:ga0e80ccc4575f82073b01f10d23435180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fcac8e6a25f0d620ab6379d33b39e95"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga3fcac8e6a25f0d620ab6379d33b39e95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 2UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga3fcac8e6a25f0d620ab6379d33b39e95">storea</a> (complex&lt; T1 &gt; *address, const SIMDci16&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga3fcac8e6a25f0d620ab6379d33b39e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of 2-byte integral complex values.  <a href="../../dc/d7b/group__simd.html#ga3fcac8e6a25f0d620ab6379d33b39e95">More...</a><br /></td></tr>
<tr class="separator:ga3fcac8e6a25f0d620ab6379d33b39e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54fde30f491679ae74b4abb2f0964760"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga54fde30f491679ae74b4abb2f0964760"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 4UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga54fde30f491679ae74b4abb2f0964760">storea</a> (T1 *address, const SIMDi32&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga54fde30f491679ae74b4abb2f0964760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of 4-byte integral values.  <a href="../../dc/d7b/group__simd.html#ga54fde30f491679ae74b4abb2f0964760">More...</a><br /></td></tr>
<tr class="separator:ga54fde30f491679ae74b4abb2f0964760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71dc54f63be6738610e60e7d82d5cee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gab71dc54f63be6738610e60e7d82d5cee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 4UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gab71dc54f63be6738610e60e7d82d5cee">storea</a> (complex&lt; T1 &gt; *address, const SIMDci32&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:gab71dc54f63be6738610e60e7d82d5cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of 4-byte integral complex values.  <a href="../../dc/d7b/group__simd.html#gab71dc54f63be6738610e60e7d82d5cee">More...</a><br /></td></tr>
<tr class="separator:gab71dc54f63be6738610e60e7d82d5cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86267b3ce97dbc5a74d02cad6d457c50"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga86267b3ce97dbc5a74d02cad6d457c50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 8UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga86267b3ce97dbc5a74d02cad6d457c50">storea</a> (T1 *address, const SIMDi64&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga86267b3ce97dbc5a74d02cad6d457c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of 8-byte integral values.  <a href="../../dc/d7b/group__simd.html#ga86267b3ce97dbc5a74d02cad6d457c50">More...</a><br /></td></tr>
<tr class="separator:ga86267b3ce97dbc5a74d02cad6d457c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae6929f48d8d706e18c8df00af9678f7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaae6929f48d8d706e18c8df00af9678f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 8UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaae6929f48d8d706e18c8df00af9678f7">storea</a> (complex&lt; T1 &gt; *address, const SIMDci64&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:gaae6929f48d8d706e18c8df00af9678f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of 8-byte integral complex values.  <a href="../../dc/d7b/group__simd.html#gaae6929f48d8d706e18c8df00af9678f7">More...</a><br /></td></tr>
<tr class="separator:gaae6929f48d8d706e18c8df00af9678f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa55f5ecf5fd0f9cd266624ac1d3970b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa55f5ecf5fd0f9cd266624ac1d3970b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaa55f5ecf5fd0f9cd266624ac1d3970b9">storea</a> (float *address, const SIMDf32&lt; T &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:gaa55f5ecf5fd0f9cd266624ac1d3970b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of 'float' values.  <a href="../../dc/d7b/group__simd.html#gaa55f5ecf5fd0f9cd266624ac1d3970b9">More...</a><br /></td></tr>
<tr class="separator:gaa55f5ecf5fd0f9cd266624ac1d3970b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc912f76189c204953cf229c88c93312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gacc912f76189c204953cf229c88c93312">storea</a> (complex&lt; float &gt; *address, const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:gacc912f76189c204953cf229c88c93312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of 'complex&lt;float&gt;' values.  <a href="../../dc/d7b/group__simd.html#gacc912f76189c204953cf229c88c93312">More...</a><br /></td></tr>
<tr class="separator:gacc912f76189c204953cf229c88c93312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab143efc731522614195ffbfb449e04ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab143efc731522614195ffbfb449e04ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gab143efc731522614195ffbfb449e04ff">storea</a> (double *address, const SIMDf64&lt; T &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:gab143efc731522614195ffbfb449e04ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of 'double' values.  <a href="../../dc/d7b/group__simd.html#gab143efc731522614195ffbfb449e04ff">More...</a><br /></td></tr>
<tr class="separator:gab143efc731522614195ffbfb449e04ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14c3b90b1e820344168a3347fd62fe64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga14c3b90b1e820344168a3347fd62fe64">storea</a> (complex&lt; double &gt; *address, const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ga14c3b90b1e820344168a3347fd62fe64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of 'complex&lt;double&gt;' values.  <a href="../../dc/d7b/group__simd.html#ga14c3b90b1e820344168a3347fd62fe64">More...</a><br /></td></tr>
<tr class="separator:ga14c3b90b1e820344168a3347fd62fe64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga298259d9a5893fa142037fdb3dbb47cd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga298259d9a5893fa142037fdb3dbb47cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 1UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga298259d9a5893fa142037fdb3dbb47cd">storeu</a> (T1 *address, const SIMDi8&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga298259d9a5893fa142037fdb3dbb47cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a vector of 1-byte integral values.  <a href="../../dc/d7b/group__simd.html#ga298259d9a5893fa142037fdb3dbb47cd">More...</a><br /></td></tr>
<tr class="separator:ga298259d9a5893fa142037fdb3dbb47cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce37a52af1b53bafa55f9a36116162b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga6ce37a52af1b53bafa55f9a36116162b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 1UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga6ce37a52af1b53bafa55f9a36116162b">storeu</a> (complex&lt; T1 &gt; *address, const SIMDci8&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga6ce37a52af1b53bafa55f9a36116162b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a vector of 1-byte integral complex values.  <a href="../../dc/d7b/group__simd.html#ga6ce37a52af1b53bafa55f9a36116162b">More...</a><br /></td></tr>
<tr class="separator:ga6ce37a52af1b53bafa55f9a36116162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga265f34c0e2498d6981fc19ba8af5daed"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga265f34c0e2498d6981fc19ba8af5daed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 2UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga265f34c0e2498d6981fc19ba8af5daed">storeu</a> (T1 *address, const SIMDi16&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga265f34c0e2498d6981fc19ba8af5daed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a vector of 2-byte integral values.  <a href="../../dc/d7b/group__simd.html#ga265f34c0e2498d6981fc19ba8af5daed">More...</a><br /></td></tr>
<tr class="separator:ga265f34c0e2498d6981fc19ba8af5daed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c2a09bf47d383d9d8ba6755f4058fa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga76c2a09bf47d383d9d8ba6755f4058fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 2UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga76c2a09bf47d383d9d8ba6755f4058fa">storeu</a> (complex&lt; T1 &gt; *address, const SIMDci16&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga76c2a09bf47d383d9d8ba6755f4058fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a vector of 2-byte integral complex values.  <a href="../../dc/d7b/group__simd.html#ga76c2a09bf47d383d9d8ba6755f4058fa">More...</a><br /></td></tr>
<tr class="separator:ga76c2a09bf47d383d9d8ba6755f4058fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cce89c555dcccda16e09eaaa47c48a2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga3cce89c555dcccda16e09eaaa47c48a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 4UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga3cce89c555dcccda16e09eaaa47c48a2">storeu</a> (T1 *address, const SIMDi32&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga3cce89c555dcccda16e09eaaa47c48a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a vector of 4-byte integral values.  <a href="../../dc/d7b/group__simd.html#ga3cce89c555dcccda16e09eaaa47c48a2">More...</a><br /></td></tr>
<tr class="separator:ga3cce89c555dcccda16e09eaaa47c48a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d04cf111cf49a279e3ef05684e6fe4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gac9d04cf111cf49a279e3ef05684e6fe4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 4UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gac9d04cf111cf49a279e3ef05684e6fe4">storeu</a> (complex&lt; T1 &gt; *address, const SIMDci32&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:gac9d04cf111cf49a279e3ef05684e6fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a vector of 4-byte integral complex values.  <a href="../../dc/d7b/group__simd.html#gac9d04cf111cf49a279e3ef05684e6fe4">More...</a><br /></td></tr>
<tr class="separator:gac9d04cf111cf49a279e3ef05684e6fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28569bd05e12bb0dac6c2e27a50146e2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga28569bd05e12bb0dac6c2e27a50146e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 8UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga28569bd05e12bb0dac6c2e27a50146e2">storeu</a> (T1 *address, const SIMDi64&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga28569bd05e12bb0dac6c2e27a50146e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a vector of 8-byte integral values.  <a href="../../dc/d7b/group__simd.html#ga28569bd05e12bb0dac6c2e27a50146e2">More...</a><br /></td></tr>
<tr class="separator:ga28569bd05e12bb0dac6c2e27a50146e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe5903f12126f3d1808a78d091a0b3dc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gafe5903f12126f3d1808a78d091a0b3dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 8UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gafe5903f12126f3d1808a78d091a0b3dc">storeu</a> (complex&lt; T1 &gt; *address, const SIMDci64&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:gafe5903f12126f3d1808a78d091a0b3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a vector of 8-byte integral complex values.  <a href="../../dc/d7b/group__simd.html#gafe5903f12126f3d1808a78d091a0b3dc">More...</a><br /></td></tr>
<tr class="separator:gafe5903f12126f3d1808a78d091a0b3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1ea1209a8b56482d055e95c72151de2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf1ea1209a8b56482d055e95c72151de2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaf1ea1209a8b56482d055e95c72151de2">storeu</a> (float *address, const SIMDf32&lt; T &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:gaf1ea1209a8b56482d055e95c72151de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a vector of 'float' values.  <a href="../../dc/d7b/group__simd.html#gaf1ea1209a8b56482d055e95c72151de2">More...</a><br /></td></tr>
<tr class="separator:gaf1ea1209a8b56482d055e95c72151de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd13eef01debbe4d91d8a8d57be0e831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gacd13eef01debbe4d91d8a8d57be0e831">storeu</a> (complex&lt; float &gt; *address, const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:gacd13eef01debbe4d91d8a8d57be0e831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a vector of 'complex&lt;float&gt;' values.  <a href="../../dc/d7b/group__simd.html#gacd13eef01debbe4d91d8a8d57be0e831">More...</a><br /></td></tr>
<tr class="separator:gacd13eef01debbe4d91d8a8d57be0e831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8c3638720be3aebaedef10956fe2d7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa8c3638720be3aebaedef10956fe2d7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaa8c3638720be3aebaedef10956fe2d7d">storeu</a> (double *address, const SIMDf64&lt; T &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:gaa8c3638720be3aebaedef10956fe2d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a vector of 'double' values.  <a href="../../dc/d7b/group__simd.html#gaa8c3638720be3aebaedef10956fe2d7d">More...</a><br /></td></tr>
<tr class="separator:gaa8c3638720be3aebaedef10956fe2d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765b0fa5d1ddf907dec5212085f272f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga765b0fa5d1ddf907dec5212085f272f4">storeu</a> (complex&lt; double &gt; *address, const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ga765b0fa5d1ddf907dec5212085f272f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a vector of 'complex&lt;double&gt;' values.  <a href="../../dc/d7b/group__simd.html#ga765b0fa5d1ddf907dec5212085f272f4">More...</a><br /></td></tr>
<tr class="separator:ga765b0fa5d1ddf907dec5212085f272f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b901558427403fa2b5e9db111bb3037"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1b901558427403fa2b5e9db111bb3037"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 1UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga1b901558427403fa2b5e9db111bb3037">stream</a> (T1 *address, const SIMDi8&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga1b901558427403fa2b5e9db111bb3037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of 1-byte integral values.  <a href="../../dc/d7b/group__simd.html#ga1b901558427403fa2b5e9db111bb3037">More...</a><br /></td></tr>
<tr class="separator:ga1b901558427403fa2b5e9db111bb3037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ea38f0f80e6d6b54233ad051ef9cf67"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1ea38f0f80e6d6b54233ad051ef9cf67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 1UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga1ea38f0f80e6d6b54233ad051ef9cf67">stream</a> (complex&lt; T1 &gt; *address, const SIMDci8&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga1ea38f0f80e6d6b54233ad051ef9cf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of 1-byte integral complex values.  <a href="../../dc/d7b/group__simd.html#ga1ea38f0f80e6d6b54233ad051ef9cf67">More...</a><br /></td></tr>
<tr class="separator:ga1ea38f0f80e6d6b54233ad051ef9cf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2102a18b30512b85bc13c32cf8820dfe"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2102a18b30512b85bc13c32cf8820dfe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 2UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga2102a18b30512b85bc13c32cf8820dfe">stream</a> (T1 *address, const SIMDi16&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga2102a18b30512b85bc13c32cf8820dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of 2-byte integral values.  <a href="../../dc/d7b/group__simd.html#ga2102a18b30512b85bc13c32cf8820dfe">More...</a><br /></td></tr>
<tr class="separator:ga2102a18b30512b85bc13c32cf8820dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5669f15ca701b90ae3720bb04d33e0b2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5669f15ca701b90ae3720bb04d33e0b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 2UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga5669f15ca701b90ae3720bb04d33e0b2">stream</a> (complex&lt; T1 &gt; *address, const SIMDci16&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga5669f15ca701b90ae3720bb04d33e0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of 2-byte integral complex values.  <a href="../../dc/d7b/group__simd.html#ga5669f15ca701b90ae3720bb04d33e0b2">More...</a><br /></td></tr>
<tr class="separator:ga5669f15ca701b90ae3720bb04d33e0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d173eb7c084e37038e519924dd32828"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7d173eb7c084e37038e519924dd32828"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 4UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga7d173eb7c084e37038e519924dd32828">stream</a> (T1 *address, const SIMDi32&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga7d173eb7c084e37038e519924dd32828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of 4-byte integral values.  <a href="../../dc/d7b/group__simd.html#ga7d173eb7c084e37038e519924dd32828">More...</a><br /></td></tr>
<tr class="separator:ga7d173eb7c084e37038e519924dd32828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410f349af32ff5610035eeced6a35315"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga410f349af32ff5610035eeced6a35315"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 4UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga410f349af32ff5610035eeced6a35315">stream</a> (complex&lt; T1 &gt; *address, const SIMDci32&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga410f349af32ff5610035eeced6a35315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of 4-byte integral complex values.  <a href="../../dc/d7b/group__simd.html#ga410f349af32ff5610035eeced6a35315">More...</a><br /></td></tr>
<tr class="separator:ga410f349af32ff5610035eeced6a35315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fd484d1b43fc92aee5a1178af6214b5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5fd484d1b43fc92aee5a1178af6214b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 8UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga5fd484d1b43fc92aee5a1178af6214b5">stream</a> (T1 *address, const SIMDi64&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga5fd484d1b43fc92aee5a1178af6214b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of 8-byte integral values.  <a href="../../dc/d7b/group__simd.html#ga5fd484d1b43fc92aee5a1178af6214b5">More...</a><br /></td></tr>
<tr class="separator:ga5fd484d1b43fc92aee5a1178af6214b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6831ba238be7d07019d14befe6507287"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga6831ba238be7d07019d14befe6507287"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T1 &gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt; T1, 8UL &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga6831ba238be7d07019d14befe6507287">stream</a> (complex&lt; T1 &gt; *address, const SIMDci64&lt; T2 &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga6831ba238be7d07019d14befe6507287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of 8-byte integral complex values.  <a href="../../dc/d7b/group__simd.html#ga6831ba238be7d07019d14befe6507287">More...</a><br /></td></tr>
<tr class="separator:ga6831ba238be7d07019d14befe6507287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6006c7e726eb4cb21af919d97ec6a243"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6006c7e726eb4cb21af919d97ec6a243"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga6006c7e726eb4cb21af919d97ec6a243">stream</a> (float *address, const SIMDf32&lt; T &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga6006c7e726eb4cb21af919d97ec6a243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of 'float' values.  <a href="../../dc/d7b/group__simd.html#ga6006c7e726eb4cb21af919d97ec6a243">More...</a><br /></td></tr>
<tr class="separator:ga6006c7e726eb4cb21af919d97ec6a243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46413be3a58cf92a9d9a2f6bc1e8e264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga46413be3a58cf92a9d9a2f6bc1e8e264">stream</a> (complex&lt; float &gt; *address, const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ga46413be3a58cf92a9d9a2f6bc1e8e264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of 'complex&lt;float&gt;' values.  <a href="../../dc/d7b/group__simd.html#ga46413be3a58cf92a9d9a2f6bc1e8e264">More...</a><br /></td></tr>
<tr class="separator:ga46413be3a58cf92a9d9a2f6bc1e8e264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga884404297754bc33450d00e42f601406"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga884404297754bc33450d00e42f601406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga884404297754bc33450d00e42f601406">stream</a> (double *address, const SIMDf64&lt; T &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga884404297754bc33450d00e42f601406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of 'double' values.  <a href="../../dc/d7b/group__simd.html#ga884404297754bc33450d00e42f601406">More...</a><br /></td></tr>
<tr class="separator:ga884404297754bc33450d00e42f601406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb6483e691902a23043b1488f1f730d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga1eb6483e691902a23043b1488f1f730d">stream</a> (complex&lt; double &gt; *address, const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ga1eb6483e691902a23043b1488f1f730d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of 'complex&lt;double&gt;' values.  <a href="../../dc/d7b/group__simd.html#ga1eb6483e691902a23043b1488f1f730d">More...</a><br /></td></tr>
<tr class="separator:ga1eb6483e691902a23043b1488f1f730d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga188a10b436943a62bdb26ba3c6ca039c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga188a10b436943a62bdb26ba3c6ca039c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga188a10b436943a62bdb26ba3c6ca039c">operator-</a> (const SIMDi8&lt; T &gt; &amp;a, const SIMDi8&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga188a10b436943a62bdb26ba3c6ca039c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of 8-bit integral SIMD values of the same type.  <a href="../../dc/d7b/group__simd.html#ga188a10b436943a62bdb26ba3c6ca039c">More...</a><br /></td></tr>
<tr class="separator:ga188a10b436943a62bdb26ba3c6ca039c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9067b1ef217a138004a05c5df98d2837"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9067b1ef217a138004a05c5df98d2837"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../dd/d00/classblaze_1_1SIMDuint8.html">SIMDuint8</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga9067b1ef217a138004a05c5df98d2837">operator-</a> (const SIMDi8&lt; T1 &gt; &amp;a, const SIMDi8&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga9067b1ef217a138004a05c5df98d2837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of 8-bit integral SIMD values of different type.  <a href="../../dc/d7b/group__simd.html#ga9067b1ef217a138004a05c5df98d2837">More...</a><br /></td></tr>
<tr class="separator:ga9067b1ef217a138004a05c5df98d2837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bfcac43a5150cc2e5cd37803d1d010d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2bfcac43a5150cc2e5cd37803d1d010d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga2bfcac43a5150cc2e5cd37803d1d010d">operator-</a> (const SIMDci8&lt; T &gt; &amp;a, const SIMDci8&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga2bfcac43a5150cc2e5cd37803d1d010d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of 8-bit integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga2bfcac43a5150cc2e5cd37803d1d010d">More...</a><br /></td></tr>
<tr class="separator:ga2bfcac43a5150cc2e5cd37803d1d010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab80fcc3367db38f48ae76938b8bc4b08"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab80fcc3367db38f48ae76938b8bc4b08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gab80fcc3367db38f48ae76938b8bc4b08">operator-</a> (const SIMDi16&lt; T &gt; &amp;a, const SIMDi16&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gab80fcc3367db38f48ae76938b8bc4b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of 16-bit integral SIMD values of the same type.  <a href="../../dc/d7b/group__simd.html#gab80fcc3367db38f48ae76938b8bc4b08">More...</a><br /></td></tr>
<tr class="separator:gab80fcc3367db38f48ae76938b8bc4b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga317e4b3f7855766c4553bdc23e795bbd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga317e4b3f7855766c4553bdc23e795bbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d5/d05/classblaze_1_1SIMDuint16.html">SIMDuint16</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga317e4b3f7855766c4553bdc23e795bbd">operator-</a> (const SIMDi16&lt; T1 &gt; &amp;a, const SIMDi16&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga317e4b3f7855766c4553bdc23e795bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of 16-bit integral SIMD values of different type.  <a href="../../dc/d7b/group__simd.html#ga317e4b3f7855766c4553bdc23e795bbd">More...</a><br /></td></tr>
<tr class="separator:ga317e4b3f7855766c4553bdc23e795bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90680e78642558d1729e143d391e113d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga90680e78642558d1729e143d391e113d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga90680e78642558d1729e143d391e113d">operator-</a> (const SIMDci16&lt; T &gt; &amp;a, const SIMDci16&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga90680e78642558d1729e143d391e113d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of 16-bit integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga90680e78642558d1729e143d391e113d">More...</a><br /></td></tr>
<tr class="separator:ga90680e78642558d1729e143d391e113d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fcd3b5d24aa49c823f62b173d12f0d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2fcd3b5d24aa49c823f62b173d12f0d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga2fcd3b5d24aa49c823f62b173d12f0d0">operator-</a> (const SIMDi32&lt; T &gt; &amp;a, const SIMDi32&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga2fcd3b5d24aa49c823f62b173d12f0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of 32-bit integral SIMD values of the same type.  <a href="../../dc/d7b/group__simd.html#ga2fcd3b5d24aa49c823f62b173d12f0d0">More...</a><br /></td></tr>
<tr class="separator:ga2fcd3b5d24aa49c823f62b173d12f0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78b52ac527998b14255981b5d895db7a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga78b52ac527998b14255981b5d895db7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d8/d06/classblaze_1_1SIMDuint32.html">SIMDuint32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga78b52ac527998b14255981b5d895db7a">operator-</a> (const SIMDi32&lt; T1 &gt; &amp;a, const SIMDi32&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga78b52ac527998b14255981b5d895db7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of 32-bit integral SIMD values of different type.  <a href="../../dc/d7b/group__simd.html#ga78b52ac527998b14255981b5d895db7a">More...</a><br /></td></tr>
<tr class="separator:ga78b52ac527998b14255981b5d895db7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23f0b5abca47467229b1893aca9c8287"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga23f0b5abca47467229b1893aca9c8287"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga23f0b5abca47467229b1893aca9c8287">operator-</a> (const SIMDci32&lt; T &gt; &amp;a, const SIMDci32&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga23f0b5abca47467229b1893aca9c8287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of 32-bit integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga23f0b5abca47467229b1893aca9c8287">More...</a><br /></td></tr>
<tr class="separator:ga23f0b5abca47467229b1893aca9c8287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7530c104fdf00c80bceeae14346b57eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7530c104fdf00c80bceeae14346b57eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga7530c104fdf00c80bceeae14346b57eb">operator-</a> (const SIMDi64&lt; T &gt; &amp;a, const SIMDi64&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga7530c104fdf00c80bceeae14346b57eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of 64-bit integral SIMD values of the same type.  <a href="../../dc/d7b/group__simd.html#ga7530c104fdf00c80bceeae14346b57eb">More...</a><br /></td></tr>
<tr class="separator:ga7530c104fdf00c80bceeae14346b57eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ef0255b9f62da6587ea2ec433440130"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0ef0255b9f62da6587ea2ec433440130"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d1/d32/classblaze_1_1SIMDuint64.html">SIMDuint64</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga0ef0255b9f62da6587ea2ec433440130">operator-</a> (const SIMDi64&lt; T1 &gt; &amp;a, const SIMDi64&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga0ef0255b9f62da6587ea2ec433440130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of 64-bit integral SIMD values of different type.  <a href="../../dc/d7b/group__simd.html#ga0ef0255b9f62da6587ea2ec433440130">More...</a><br /></td></tr>
<tr class="separator:ga0ef0255b9f62da6587ea2ec433440130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2ead9903697fd686623dc6c1daebabf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac2ead9903697fd686623dc6c1daebabf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gac2ead9903697fd686623dc6c1daebabf">operator-</a> (const SIMDci64&lt; T &gt; &amp;a, const SIMDci64&lt; T &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gac2ead9903697fd686623dc6c1daebabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of 64-bit integral complex SIMD values.  <a href="../../dc/d7b/group__simd.html#gac2ead9903697fd686623dc6c1daebabf">More...</a><br /></td></tr>
<tr class="separator:gac2ead9903697fd686623dc6c1daebabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae6209bf097450047fcedf64b54d9a8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2ae6209bf097450047fcedf64b54d9a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga2ae6209bf097450047fcedf64b54d9a8">operator-</a> (const SIMDf32&lt; T1 &gt; &amp;a, const SIMDf32&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga2ae6209bf097450047fcedf64b54d9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of single precision floating point SIMD values.  <a href="../../dc/d7b/group__simd.html#ga2ae6209bf097450047fcedf64b54d9a8">More...</a><br /></td></tr>
<tr class="separator:ga2ae6209bf097450047fcedf64b54d9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf01239b7f5815a6175c10f1c56dc874e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaf01239b7f5815a6175c10f1c56dc874e">operator-</a> (const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;a, const <a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html">SIMDcfloat</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gaf01239b7f5815a6175c10f1c56dc874e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of single precision complex SIMD values.  <a href="../../dc/d7b/group__simd.html#gaf01239b7f5815a6175c10f1c56dc874e">More...</a><br /></td></tr>
<tr class="separator:gaf01239b7f5815a6175c10f1c56dc874e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2fcf2cd2265fde2f0ad941ea142e342"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gad2fcf2cd2265fde2f0ad941ea142e342"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gad2fcf2cd2265fde2f0ad941ea142e342">operator-</a> (const SIMDf64&lt; T1 &gt; &amp;a, const SIMDf64&lt; T2 &gt; &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:gad2fcf2cd2265fde2f0ad941ea142e342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of double precision floating point SIMD values.  <a href="../../dc/d7b/group__simd.html#gad2fcf2cd2265fde2f0ad941ea142e342">More...</a><br /></td></tr>
<tr class="separator:gad2fcf2cd2265fde2f0ad941ea142e342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ca9ad2fe504fb43bc854f8f241dbff7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga2ca9ad2fe504fb43bc854f8f241dbff7">operator-</a> (const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;a, const <a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html">SIMDcdouble</a> &amp;b) noexcept=delete</td></tr>
<tr class="memdesc:ga2ca9ad2fe504fb43bc854f8f241dbff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two vectors of double precision complex SIMD values.  <a href="../../dc/d7b/group__simd.html#ga2ca9ad2fe504fb43bc854f8f241dbff7">More...</a><br /></td></tr>
<tr class="separator:ga2ca9ad2fe504fb43bc854f8f241dbff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d00165b293940a5eb91220eb6d2cdb3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5d00165b293940a5eb91220eb6d2cdb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga5d00165b293940a5eb91220eb6d2cdb3">tan</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga5d00165b293940a5eb91220eb6d2cdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tangent of a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga5d00165b293940a5eb91220eb6d2cdb3">More...</a><br /></td></tr>
<tr class="separator:ga5d00165b293940a5eb91220eb6d2cdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa089d1bd06548e7f567f154992892ed6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa089d1bd06548e7f567f154992892ed6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gaa089d1bd06548e7f567f154992892ed6">tan</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gaa089d1bd06548e7f567f154992892ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tangent of a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gaa089d1bd06548e7f567f154992892ed6">More...</a><br /></td></tr>
<tr class="separator:gaa089d1bd06548e7f567f154992892ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae231bfcb1e09c8d1bcd102b2d051ab12"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae231bfcb1e09c8d1bcd102b2d051ab12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gae231bfcb1e09c8d1bcd102b2d051ab12">tanh</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gae231bfcb1e09c8d1bcd102b2d051ab12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic tangent of a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#gae231bfcb1e09c8d1bcd102b2d051ab12">More...</a><br /></td></tr>
<tr class="separator:gae231bfcb1e09c8d1bcd102b2d051ab12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4fa3cfd45118c95652c72ad5f6de8b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad4fa3cfd45118c95652c72ad5f6de8b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gad4fa3cfd45118c95652c72ad5f6de8b7">tanh</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gad4fa3cfd45118c95652c72ad5f6de8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic tangent of a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gad4fa3cfd45118c95652c72ad5f6de8b7">More...</a><br /></td></tr>
<tr class="separator:gad4fa3cfd45118c95652c72ad5f6de8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07a09d57ce467926f89d9bc17c196257"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga07a09d57ce467926f89d9bc17c196257"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html">SIMDfloat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#ga07a09d57ce467926f89d9bc17c196257">trunc</a> (const SIMDf32&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:ga07a09d57ce467926f89d9bc17c196257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than the given value for a vector of single precision floating point values.  <a href="../../dc/d7b/group__simd.html#ga07a09d57ce467926f89d9bc17c196257">More...</a><br /></td></tr>
<tr class="separator:ga07a09d57ce467926f89d9bc17c196257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab349db60a332f63c1bdc38b63152a248"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab349db60a332f63c1bdc38b63152a248"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html">SIMDdouble</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html#gab349db60a332f63c1bdc38b63152a248">trunc</a> (const SIMDf64&lt; T &gt; &amp;a) noexcept=delete</td></tr>
<tr class="memdesc:gab349db60a332f63c1bdc38b63152a248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than the given value for a vector of double precision floating point values.  <a href="../../dc/d7b/group__simd.html#gab349db60a332f63c1bdc38b63152a248">More...</a><br /></td></tr>
<tr class="separator:gab349db60a332f63c1bdc38b63152a248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga5be271299bf9d21d79adbc98fefc7c73">operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5be271299bf9d21d79adbc98fefc7c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two row-major sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#ga5be271299bf9d21d79adbc98fefc7c73">More...</a><br /></td></tr>
<tr class="separator:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8fe418ba6e1d414a1915677cd42a034"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gad8fe418ba6e1d414a1915677cd42a034"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gad8fe418ba6e1d414a1915677cd42a034">operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad8fe418ba6e1d414a1915677cd42a034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two column-major sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#gad8fe418ba6e1d414a1915677cd42a034">More...</a><br /></td></tr>
<tr class="separator:gad8fe418ba6e1d414a1915677cd42a034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90d2efe628ac27ced94db06b3aa3cf9b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga90d2efe628ac27ced94db06b3aa3cf9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">IsComputation</a>&lt; MT &gt;, <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">IsTransExpr</a>&lt; MT &gt;, <a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html">IsDeclExpr</a>&lt; MT &gt; &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga3507cda05675a7d310b22f91dce0059a">ColumnExprTrait_</a>&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#ga90d2efe628ac27ced94db06b3aa3cf9b">column</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:ga90d2efe628ac27ced94db06b3aa3cf9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific column of the given matrix.  <a href="../../d0/d48/group__views.html#ga90d2efe628ac27ced94db06b3aa3cf9b">More...</a><br /></td></tr>
<tr class="separator:ga90d2efe628ac27ced94db06b3aa3cf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35cb7f604eb701afbe463aedda396913"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga35cb7f604eb701afbe463aedda396913"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">IsComputation</a>&lt; MT &gt;, <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">IsTransExpr</a>&lt; MT &gt;, <a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html">IsDeclExpr</a>&lt; MT &gt; &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga3507cda05675a7d310b22f91dce0059a">ColumnExprTrait_</a>&lt; const MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#ga35cb7f604eb701afbe463aedda396913">column</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:ga35cb7f604eb701afbe463aedda396913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific column of the given constant matrix.  <a href="../../d0/d48/group__views.html#ga35cb7f604eb701afbe463aedda396913">More...</a><br /></td></tr>
<tr class="separator:ga35cb7f604eb701afbe463aedda396913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga251f78730b4d1a6a86415c98df6e92a6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga251f78730b4d1a6a86415c98df6e92a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">IsComputation</a>&lt; MT &gt;, <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">IsTransExpr</a>&lt; MT &gt;, <a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html">IsDeclExpr</a>&lt; MT &gt; &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga3507cda05675a7d310b22f91dce0059a">ColumnExprTrait_</a>&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#ga251f78730b4d1a6a86415c98df6e92a6">column</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;&amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:ga251f78730b4d1a6a86415c98df6e92a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific column of the given temporary matrix.  <a href="../../d0/d48/group__views.html#ga251f78730b4d1a6a86415c98df6e92a6">More...</a><br /></td></tr>
<tr class="separator:ga251f78730b4d1a6a86415c98df6e92a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a6376617370d461c81682f09a4a5772"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga3a6376617370d461c81682f09a4a5772"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">IsComputation</a>&lt; MT &gt;, <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">IsTransExpr</a>&lt; MT &gt;, <a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html">IsDeclExpr</a>&lt; MT &gt; &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga614ee434bf313751eaa652afefd61c46">RowExprTrait_</a>&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#ga3a6376617370d461c81682f09a4a5772">row</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:ga3a6376617370d461c81682f09a4a5772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific row of the given matrix.  <a href="../../d0/d48/group__views.html#ga3a6376617370d461c81682f09a4a5772">More...</a><br /></td></tr>
<tr class="separator:ga3a6376617370d461c81682f09a4a5772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga311edacb322bd791da3ec43a216bca58"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga311edacb322bd791da3ec43a216bca58"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">IsComputation</a>&lt; MT &gt;, <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">IsTransExpr</a>&lt; MT &gt;, <a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html">IsDeclExpr</a>&lt; MT &gt; &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga614ee434bf313751eaa652afefd61c46">RowExprTrait_</a>&lt; const MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#ga311edacb322bd791da3ec43a216bca58">row</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:ga311edacb322bd791da3ec43a216bca58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific row of the given constant matrix.  <a href="../../d0/d48/group__views.html#ga311edacb322bd791da3ec43a216bca58">More...</a><br /></td></tr>
<tr class="separator:ga311edacb322bd791da3ec43a216bca58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1a9e676cba9c5ed0fe726dabdae33b4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae1a9e676cba9c5ed0fe726dabdae33b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">IsComputation</a>&lt; MT &gt;, <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">IsTransExpr</a>&lt; MT &gt;, <a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html">IsDeclExpr</a>&lt; MT &gt; &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga614ee434bf313751eaa652afefd61c46">RowExprTrait_</a>&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#gae1a9e676cba9c5ed0fe726dabdae33b4">row</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;&amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:gae1a9e676cba9c5ed0fe726dabdae33b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific row of the given temporary matrix.  <a href="../../d0/d48/group__views.html#gae1a9e676cba9c5ed0fe726dabdae33b4">More...</a><br /></td></tr>
<tr class="separator:gae1a9e676cba9c5ed0fe726dabdae33b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eee6dfde88632a04c59ed63ecf5732d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga5eee6dfde88632a04c59ed63ecf5732d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d92/group__math__traits.html#ga3fc4a18930642ac1da2025b6b31e0a19">SubmatrixExprTrait_</a>&lt; MT, <a class="el" href="../../de/df1/group__math.html#ga9182d2466faf6f39bfc6a7cd2e5895a5">unaligned</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#ga5eee6dfde88632a04c59ed63ecf5732d">submatrix</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#ga3a6376617370d461c81682f09a4a5772">row</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#ga90d2efe628ac27ced94db06b3aa3cf9b">column</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:ga5eee6dfde88632a04c59ed63ecf5732d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific submatrix of the given matrix.  <a href="../../d0/d48/group__views.html#ga5eee6dfde88632a04c59ed63ecf5732d">More...</a><br /></td></tr>
<tr class="separator:ga5eee6dfde88632a04c59ed63ecf5732d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45c749e3dc545c3e4eae479c3bbf1cf7"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga45c749e3dc545c3e4eae479c3bbf1cf7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga3fc4a18930642ac1da2025b6b31e0a19">SubmatrixExprTrait_</a>&lt; const MT, <a class="el" href="../../de/df1/group__math.html#ga9182d2466faf6f39bfc6a7cd2e5895a5">unaligned</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#ga45c749e3dc545c3e4eae479c3bbf1cf7">submatrix</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#ga3a6376617370d461c81682f09a4a5772">row</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#ga90d2efe628ac27ced94db06b3aa3cf9b">column</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:ga45c749e3dc545c3e4eae479c3bbf1cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific submatrix of the given constant matrix.  <a href="../../d0/d48/group__views.html#ga45c749e3dc545c3e4eae479c3bbf1cf7">More...</a><br /></td></tr>
<tr class="separator:ga45c749e3dc545c3e4eae479c3bbf1cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08594c04a9114bb83b19b57df3266532"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga08594c04a9114bb83b19b57df3266532"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d92/group__math__traits.html#ga3fc4a18930642ac1da2025b6b31e0a19">SubmatrixExprTrait_</a>&lt; MT, <a class="el" href="../../de/df1/group__math.html#ga9182d2466faf6f39bfc6a7cd2e5895a5">unaligned</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#ga08594c04a9114bb83b19b57df3266532">submatrix</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;&amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#ga3a6376617370d461c81682f09a4a5772">row</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#ga90d2efe628ac27ced94db06b3aa3cf9b">column</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:ga08594c04a9114bb83b19b57df3266532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific submatrix of the given temporary matrix.  <a href="../../d0/d48/group__views.html#ga08594c04a9114bb83b19b57df3266532">More...</a><br /></td></tr>
<tr class="separator:ga08594c04a9114bb83b19b57df3266532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c78a794c2eec7d453b17e80a90ef69c"><td class="memTemplParams" colspan="2">template&lt;bool AF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga8c78a794c2eec7d453b17e80a90ef69c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">IsComputation</a>&lt; MT &gt;, <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">IsTransExpr</a>&lt; MT &gt;, <a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html">IsDeclExpr</a>&lt; MT &gt; &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga3fc4a18930642ac1da2025b6b31e0a19">SubmatrixExprTrait_</a>&lt; MT, AF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#ga8c78a794c2eec7d453b17e80a90ef69c">submatrix</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#ga3a6376617370d461c81682f09a4a5772">row</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#ga90d2efe628ac27ced94db06b3aa3cf9b">column</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:ga8c78a794c2eec7d453b17e80a90ef69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific submatrix of the given matrix.  <a href="../../d0/d48/group__views.html#ga8c78a794c2eec7d453b17e80a90ef69c">More...</a><br /></td></tr>
<tr class="separator:ga8c78a794c2eec7d453b17e80a90ef69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fc8de5709e946188fa7f143449f8952"><td class="memTemplParams" colspan="2">template&lt;bool AF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga9fc8de5709e946188fa7f143449f8952"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">IsComputation</a>&lt; MT &gt;, <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">IsTransExpr</a>&lt; MT &gt;, <a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html">IsDeclExpr</a>&lt; MT &gt; &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga3fc4a18930642ac1da2025b6b31e0a19">SubmatrixExprTrait_</a>&lt; const MT, AF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#ga9fc8de5709e946188fa7f143449f8952">submatrix</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#ga3a6376617370d461c81682f09a4a5772">row</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#ga90d2efe628ac27ced94db06b3aa3cf9b">column</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:ga9fc8de5709e946188fa7f143449f8952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific submatrix of the given constant matrix.  <a href="../../d0/d48/group__views.html#ga9fc8de5709e946188fa7f143449f8952">More...</a><br /></td></tr>
<tr class="separator:ga9fc8de5709e946188fa7f143449f8952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa350f596abce7d6563622abad8d76d01"><td class="memTemplParams" colspan="2">template&lt;bool AF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa350f596abce7d6563622abad8d76d01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">IsComputation</a>&lt; MT &gt;, <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">IsTransExpr</a>&lt; MT &gt;, <a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html">IsDeclExpr</a>&lt; MT &gt; &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga3fc4a18930642ac1da2025b6b31e0a19">SubmatrixExprTrait_</a>&lt; MT, AF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#gaa350f596abce7d6563622abad8d76d01">submatrix</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;&amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#ga3a6376617370d461c81682f09a4a5772">row</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#ga90d2efe628ac27ced94db06b3aa3cf9b">column</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:gaa350f596abce7d6563622abad8d76d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific submatrix of the given temporary matrix.  <a href="../../d0/d48/group__views.html#gaa350f596abce7d6563622abad8d76d01">More...</a><br /></td></tr>
<tr class="separator:gaa350f596abce7d6563622abad8d76d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f983a92b56bfed4cbaf3bfbfa64e197"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga8f983a92b56bfed4cbaf3bfbfa64e197"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d92/group__math__traits.html#gafabb36a96e9d948974930ead876b6dfa">SubvectorExprTrait_</a>&lt; VT, <a class="el" href="../../de/df1/group__math.html#ga9182d2466faf6f39bfc6a7cd2e5895a5">unaligned</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#ga8f983a92b56bfed4cbaf3bfbfa64e197">subvector</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vector, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dcf/group__vector.html#gab5a3d85c96e5ec1481fe48cd80e663a0">size</a>)</td></tr>
<tr class="memdesc:ga8f983a92b56bfed4cbaf3bfbfa64e197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific subvector of the given vector.  <a href="../../d0/d48/group__views.html#ga8f983a92b56bfed4cbaf3bfbfa64e197">More...</a><br /></td></tr>
<tr class="separator:ga8f983a92b56bfed4cbaf3bfbfa64e197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8fab4c8b02b5ffefe18326d4b717231"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gac8fab4c8b02b5ffefe18326d4b717231"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#gafabb36a96e9d948974930ead876b6dfa">SubvectorExprTrait_</a>&lt; const VT, <a class="el" href="../../de/df1/group__math.html#ga9182d2466faf6f39bfc6a7cd2e5895a5">unaligned</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#gac8fab4c8b02b5ffefe18326d4b717231">subvector</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vector, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dcf/group__vector.html#gab5a3d85c96e5ec1481fe48cd80e663a0">size</a>)</td></tr>
<tr class="memdesc:gac8fab4c8b02b5ffefe18326d4b717231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific subvector of the given constant vector.  <a href="../../d0/d48/group__views.html#gac8fab4c8b02b5ffefe18326d4b717231">More...</a><br /></td></tr>
<tr class="separator:gac8fab4c8b02b5ffefe18326d4b717231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf874aba1f2de94888f26eb0f51485002"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaf874aba1f2de94888f26eb0f51485002"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d92/group__math__traits.html#gafabb36a96e9d948974930ead876b6dfa">SubvectorExprTrait_</a>&lt; VT, <a class="el" href="../../de/df1/group__math.html#ga9182d2466faf6f39bfc6a7cd2e5895a5">unaligned</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#gaf874aba1f2de94888f26eb0f51485002">subvector</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&amp;vector, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dcf/group__vector.html#gab5a3d85c96e5ec1481fe48cd80e663a0">size</a>)</td></tr>
<tr class="memdesc:gaf874aba1f2de94888f26eb0f51485002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific subvector of the given temporary vector.  <a href="../../d0/d48/group__views.html#gaf874aba1f2de94888f26eb0f51485002">More...</a><br /></td></tr>
<tr class="separator:gaf874aba1f2de94888f26eb0f51485002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ffcb37387700bc9b9909efbf60b8cc0"><td class="memTemplParams" colspan="2">template&lt;bool AF, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0ffcb37387700bc9b9909efbf60b8cc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">IsComputation</a>&lt; VT &gt;, <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">IsTransExpr</a>&lt; VT &gt; &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafabb36a96e9d948974930ead876b6dfa">SubvectorExprTrait_</a>&lt; VT, AF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#ga0ffcb37387700bc9b9909efbf60b8cc0">subvector</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vector, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dcf/group__vector.html#gab5a3d85c96e5ec1481fe48cd80e663a0">size</a>)</td></tr>
<tr class="memdesc:ga0ffcb37387700bc9b9909efbf60b8cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific subvector of the given vector.  <a href="../../d0/d48/group__views.html#ga0ffcb37387700bc9b9909efbf60b8cc0">More...</a><br /></td></tr>
<tr class="separator:ga0ffcb37387700bc9b9909efbf60b8cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2551e8d05c1aef4fb4fc8fcd424de7cf"><td class="memTemplParams" colspan="2">template&lt;bool AF, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga2551e8d05c1aef4fb4fc8fcd424de7cf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">IsComputation</a>&lt; VT &gt;, <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">IsTransExpr</a>&lt; VT &gt; &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafabb36a96e9d948974930ead876b6dfa">SubvectorExprTrait_</a>&lt; const VT, AF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#ga2551e8d05c1aef4fb4fc8fcd424de7cf">subvector</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vector, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dcf/group__vector.html#gab5a3d85c96e5ec1481fe48cd80e663a0">size</a>)</td></tr>
<tr class="memdesc:ga2551e8d05c1aef4fb4fc8fcd424de7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific subvector of the given constant vector.  <a href="../../d0/d48/group__views.html#ga2551e8d05c1aef4fb4fc8fcd424de7cf">More...</a><br /></td></tr>
<tr class="separator:ga2551e8d05c1aef4fb4fc8fcd424de7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c55445945aca9af4d7ee5ecd68085d4"><td class="memTemplParams" colspan="2">template&lt;bool AF, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0c55445945aca9af4d7ee5ecd68085d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d3/d81/structblaze_1_1Or.html">Or</a>&lt; <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">IsComputation</a>&lt; VT &gt;, <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">IsTransExpr</a>&lt; VT &gt; &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafabb36a96e9d948974930ead876b6dfa">SubvectorExprTrait_</a>&lt; VT, AF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html#ga0c55445945aca9af4d7ee5ecd68085d4">subvector</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&amp;vector, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dcf/group__vector.html#gab5a3d85c96e5ec1481fe48cd80e663a0">size</a>)</td></tr>
<tr class="memdesc:ga0c55445945aca9af4d7ee5ecd68085d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a view on a specific subvector of the given temporary vector.  <a href="../../d0/d48/group__views.html#ga0c55445945aca9af4d7ee5ecd68085d4">More...</a><br /></td></tr>
<tr class="separator:ga0c55445945aca9af4d7ee5ecd68085d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a0b6c9115d86e08908397fd2949cef"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:af0a0b6c9115d86e08908397fd2949cef"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#af0a0b6c9115d86e08908397fd2949cef">transfer</a> (InputIterator first, InputIterator last, OutputIterator dest)</td></tr>
<tr class="memdesc:af0a0b6c9115d86e08908397fd2949cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers the elements from the given source range to the destination range.  <a href="#af0a0b6c9115d86e08908397fd2949cef">More...</a><br /></td></tr>
<tr class="separator:af0a0b6c9115d86e08908397fd2949cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300de20d22689dc8157697e1d2026f10"><td class="memTemplParams" colspan="2">template&lt;typename D , typename S &gt; </td></tr>
<tr class="memitem:a300de20d22689dc8157697e1d2026f10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a300de20d22689dc8157697e1d2026f10">polymorphicCount</a> (S *const *first, S *const *last)</td></tr>
<tr class="memdesc:a300de20d22689dc8157697e1d2026f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the pointer to objects with dynamic type <em>D</em>.  <a href="#a300de20d22689dc8157697e1d2026f10">More...</a><br /></td></tr>
<tr class="separator:a300de20d22689dc8157697e1d2026f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526e1bd58f6ea4e93e56d5fd71a0168d"><td class="memTemplParams" colspan="2">template&lt;typename D , typename S &gt; </td></tr>
<tr class="memitem:a526e1bd58f6ea4e93e56d5fd71a0168d"><td class="memTemplItemLeft" align="right" valign="top">S *const  *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a526e1bd58f6ea4e93e56d5fd71a0168d">polymorphicFind</a> (S *const *first, S *const *last)</td></tr>
<tr class="memdesc:a526e1bd58f6ea4e93e56d5fd71a0168d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next pointer to an object with dynamic type <em>D</em>.  <a href="#a526e1bd58f6ea4e93e56d5fd71a0168d">More...</a><br /></td></tr>
<tr class="separator:a526e1bd58f6ea4e93e56d5fd71a0168d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ee49b04d3c3e4b9814e9e0c3c9033d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac4ee49b04d3c3e4b9814e9e0c3c9033d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gac4ee49b04d3c3e4b9814e9e0c3c9033d">checkAlignment</a> (const T *address)</td></tr>
<tr class="memdesc:gac4ee49b04d3c3e4b9814e9e0c3c9033d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the alignment of the given address.  <a href="../../d4/d3a/group__util.html#gac4ee49b04d3c3e4b9814e9e0c3c9033d">More...</a><br /></td></tr>
<tr class="separator:gac4ee49b04d3c3e4b9814e9e0c3c9033d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae15f397e6434f2c811d86a3428c6c089"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d55/group__runtime__assert.html#gae15f397e6434f2c811d86a3428c6c089">ASSERT_MESSAGE</a> (const char *)</td></tr>
<tr class="memdesc:gae15f397e6434f2c811d86a3428c6c089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assertion helper function.The ASSERT_MESSAGE function is a small helper function to assist in printing an informative message in case an assert fires. This function builds on the ideas of Matthew Wilson, who directly combines a C-string error message with the run time expression (Imperfect C++, ISBN: 0321228774):  <a href="../../d5/d55/group__runtime__assert.html#gae15f397e6434f2c811d86a3428c6c089">More...</a><br /></td></tr>
<tr class="separator:gae15f397e6434f2c811d86a3428c6c089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N&gt; </td></tr>
<tr class="memitem:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaceb0ea831c8a56b9212d7a55e10ea5a4">dimensionof</a> (T(&amp;a)[N])</td></tr>
<tr class="memdesc:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static evaluation of array dimensions.  <a href="../../d4/d3a/group__util.html#gaceb0ea831c8a56b9212d7a55e10ea5a4">More...</a><br /></td></tr>
<tr class="separator:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1a0f267ad32bb5a074fa67bba6cb698"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf1a0f267ad32bb5a074fa67bba6cb698"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt; T &gt;, T *&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698">allocate</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dcf/group__vector.html#gab5a3d85c96e5ec1481fe48cd80e663a0">size</a>)</td></tr>
<tr class="memdesc:gaf1a0f267ad32bb5a074fa67bba6cb698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned array allocation for built-in data types.  <a href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698">More...</a><br /></td></tr>
<tr class="separator:gaf1a0f267ad32bb5a074fa67bba6cb698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1a0f267ad32bb5a074fa67bba6cb698"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf1a0f267ad32bb5a074fa67bba6cb698"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt; T &gt;, T *&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gaf1a0f267ad32bb5a074fa67bba6cb698">allocate</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dcf/group__vector.html#gab5a3d85c96e5ec1481fe48cd80e663a0">size</a>)</td></tr>
<tr class="memdesc:gaf1a0f267ad32bb5a074fa67bba6cb698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned array allocation for user-specific class types.  <a href="#gaf1a0f267ad32bb5a074fa67bba6cb698">More...</a><br /></td></tr>
<tr class="separator:gaf1a0f267ad32bb5a074fa67bba6cb698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacba35bf708a4ea62cdca2a4a18a24c4b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacba35bf708a4ea62cdca2a4a18a24c4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gacba35bf708a4ea62cdca2a4a18a24c4b">deallocate</a> (T *address) noexcept</td></tr>
<tr class="memdesc:gacba35bf708a4ea62cdca2a4a18a24c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocation of memory for built-in data types.  <a href="../../d4/d3a/group__util.html#gacba35bf708a4ea62cdca2a4a18a24c4b">More...</a><br /></td></tr>
<tr class="separator:gacba35bf708a4ea62cdca2a4a18a24c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacba35bf708a4ea62cdca2a4a18a24c4b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacba35bf708a4ea62cdca2a4a18a24c4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gacba35bf708a4ea62cdca2a4a18a24c4b">deallocate</a> (T *address)</td></tr>
<tr class="memdesc:gacba35bf708a4ea62cdca2a4a18a24c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocation of memory for user-specific class types.  <a href="#gacba35bf708a4ea62cdca2a4a18a24c4b">More...</a><br /></td></tr>
<tr class="separator:gacba35bf708a4ea62cdca2a4a18a24c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8322a0e31643eb8201816a377b917f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0b8322a0e31643eb8201816a377b917f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga0b8322a0e31643eb8201816a377b917f">misalignment</a> (const T *address)</td></tr>
<tr class="memdesc:ga0b8322a0e31643eb8201816a377b917f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the misalignment of the given address.  <a href="../../d4/d3a/group__util.html#ga0b8322a0e31643eb8201816a377b917f">More...</a><br /></td></tr>
<tr class="separator:ga0b8322a0e31643eb8201816a377b917f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f2de85c3ad5760de5a1c87e56891f6"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga36f2de85c3ad5760de5a1c87e56891f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga36f2de85c3ad5760de5a1c87e56891f6">UNUSED_PARAMETER</a> (const Args &amp;...)</td></tr>
<tr class="memdesc:ga36f2de85c3ad5760de5a1c87e56891f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suppression of unused parameter warnings.  <a href="../../d4/d3a/group__util.html#ga36f2de85c3ad5760de5a1c87e56891f6">More...</a><br /></td></tr>
<tr class="separator:ga36f2de85c3ad5760de5a1c87e56891f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">NegativeAccuracy operators</div></td></tr>
<tr class="memitem:ga4c532eb39351f805537decf26b3d5fcd"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga4c532eb39351f805537decf26b3d5fcd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4c532eb39351f805537decf26b3d5fcd">operator==</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga4c532eb39351f805537decf26b3d5fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga4c532eb39351f805537decf26b3d5fcd">More...</a><br /></td></tr>
<tr class="separator:ga4c532eb39351f805537decf26b3d5fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga236d08a02441df8ea0dbbb4c64749da4"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga236d08a02441df8ea0dbbb4c64749da4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga236d08a02441df8ea0dbbb4c64749da4">operator==</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga236d08a02441df8ea0dbbb4c64749da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="../../de/df1/group__math.html#ga236d08a02441df8ea0dbbb4c64749da4">More...</a><br /></td></tr>
<tr class="separator:ga236d08a02441df8ea0dbbb4c64749da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9163704380fe239f92c9aa2a2d21d2d"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:gac9163704380fe239f92c9aa2a2d21d2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac9163704380fe239f92c9aa2a2d21d2d">operator!=</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gac9163704380fe239f92c9aa2a2d21d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gac9163704380fe239f92c9aa2a2d21d2d">More...</a><br /></td></tr>
<tr class="separator:gac9163704380fe239f92c9aa2a2d21d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e43d75015d84e3173a1353446944a04"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga4e43d75015d84e3173a1353446944a04"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4e43d75015d84e3173a1353446944a04">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga4e43d75015d84e3173a1353446944a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="../../de/df1/group__math.html#ga4e43d75015d84e3173a1353446944a04">More...</a><br /></td></tr>
<tr class="separator:ga4e43d75015d84e3173a1353446944a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9beb59e8da6cadd29439976ad27ef720"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga9beb59e8da6cadd29439976ad27ef720"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9beb59e8da6cadd29439976ad27ef720">operator&lt;</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga9beb59e8da6cadd29439976ad27ef720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga9beb59e8da6cadd29439976ad27ef720">More...</a><br /></td></tr>
<tr class="separator:ga9beb59e8da6cadd29439976ad27ef720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c48a6793a1ffbabed19269784797d09"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga3c48a6793a1ffbabed19269784797d09"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3c48a6793a1ffbabed19269784797d09">operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga3c48a6793a1ffbabed19269784797d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="../../de/df1/group__math.html#ga3c48a6793a1ffbabed19269784797d09">More...</a><br /></td></tr>
<tr class="separator:ga3c48a6793a1ffbabed19269784797d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29c770742f7a66f838d35eff174546c6"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga29c770742f7a66f838d35eff174546c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga29c770742f7a66f838d35eff174546c6">operator&gt;</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga29c770742f7a66f838d35eff174546c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga29c770742f7a66f838d35eff174546c6">More...</a><br /></td></tr>
<tr class="separator:ga29c770742f7a66f838d35eff174546c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c43f45835f32b4189017f2010c9f638"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga0c43f45835f32b4189017f2010c9f638"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0c43f45835f32b4189017f2010c9f638">operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga0c43f45835f32b4189017f2010c9f638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="../../de/df1/group__math.html#ga0c43f45835f32b4189017f2010c9f638">More...</a><br /></td></tr>
<tr class="separator:ga0c43f45835f32b4189017f2010c9f638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accuracy operators</div></td></tr>
<tr class="memitem:ga901136b2bc679e7d3292cce75f539d63"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga901136b2bc679e7d3292cce75f539d63"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga901136b2bc679e7d3292cce75f539d63">operator==</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga901136b2bc679e7d3292cce75f539d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga901136b2bc679e7d3292cce75f539d63">More...</a><br /></td></tr>
<tr class="separator:ga901136b2bc679e7d3292cce75f539d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa7f20ac7fdbf6e0cc1d2a781902a9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4fa7f20ac7fdbf6e0cc1d2a781902a9c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4fa7f20ac7fdbf6e0cc1d2a781902a9c">operator==</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:ga4fa7f20ac7fdbf6e0cc1d2a781902a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#ga4fa7f20ac7fdbf6e0cc1d2a781902a9c">More...</a><br /></td></tr>
<tr class="separator:ga4fa7f20ac7fdbf6e0cc1d2a781902a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18da095de4af19e5b2dd2652d4e99783"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga18da095de4af19e5b2dd2652d4e99783"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga18da095de4af19e5b2dd2652d4e99783">operator!=</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga18da095de4af19e5b2dd2652d4e99783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga18da095de4af19e5b2dd2652d4e99783">More...</a><br /></td></tr>
<tr class="separator:ga18da095de4af19e5b2dd2652d4e99783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d846866633d891a651d1ca34abcd51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf2d846866633d891a651d1ca34abcd51"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf2d846866633d891a651d1ca34abcd51">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:gaf2d846866633d891a651d1ca34abcd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#gaf2d846866633d891a651d1ca34abcd51">More...</a><br /></td></tr>
<tr class="separator:gaf2d846866633d891a651d1ca34abcd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga361e2f13326df36b40c3ac8fbc1ab6e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga361e2f13326df36b40c3ac8fbc1ab6e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga361e2f13326df36b40c3ac8fbc1ab6e5">operator&lt;</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga361e2f13326df36b40c3ac8fbc1ab6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga361e2f13326df36b40c3ac8fbc1ab6e5">More...</a><br /></td></tr>
<tr class="separator:ga361e2f13326df36b40c3ac8fbc1ab6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa803d7476965f7923e5c0c4245d7924a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa803d7476965f7923e5c0c4245d7924a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa803d7476965f7923e5c0c4245d7924a">operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:gaa803d7476965f7923e5c0c4245d7924a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#gaa803d7476965f7923e5c0c4245d7924a">More...</a><br /></td></tr>
<tr class="separator:gaa803d7476965f7923e5c0c4245d7924a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1539c7210c9d84eec0632d388022e57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab1539c7210c9d84eec0632d388022e57"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab1539c7210c9d84eec0632d388022e57">operator&gt;</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gab1539c7210c9d84eec0632d388022e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gab1539c7210c9d84eec0632d388022e57">More...</a><br /></td></tr>
<tr class="separator:gab1539c7210c9d84eec0632d388022e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga892e97c8cb377a8f1f00ae8c451a2681"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga892e97c8cb377a8f1f00ae8c451a2681"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga892e97c8cb377a8f1f00ae8c451a2681">operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:ga892e97c8cb377a8f1f00ae8c451a2681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#ga892e97c8cb377a8f1f00ae8c451a2681">More...</a><br /></td></tr>
<tr class="separator:ga892e97c8cb377a8f1f00ae8c451a2681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cec7da9b31a13bb88d11dcdc7b66acf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3cec7da9b31a13bb88d11dcdc7b66acf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3cec7da9b31a13bb88d11dcdc7b66acf">operator&lt;=</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga3cec7da9b31a13bb88d11dcdc7b66acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga3cec7da9b31a13bb88d11dcdc7b66acf">More...</a><br /></td></tr>
<tr class="separator:ga3cec7da9b31a13bb88d11dcdc7b66acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029ffd5d821432bad2f6145a8a08ab61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga029ffd5d821432bad2f6145a8a08ab61"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga029ffd5d821432bad2f6145a8a08ab61">operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:ga029ffd5d821432bad2f6145a8a08ab61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#ga029ffd5d821432bad2f6145a8a08ab61">More...</a><br /></td></tr>
<tr class="separator:ga029ffd5d821432bad2f6145a8a08ab61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47be5bbb98c25b6050f72022c7a1a353"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga47be5bbb98c25b6050f72022c7a1a353"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga47be5bbb98c25b6050f72022c7a1a353">operator&gt;=</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga47be5bbb98c25b6050f72022c7a1a353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga47be5bbb98c25b6050f72022c7a1a353">More...</a><br /></td></tr>
<tr class="separator:ga47be5bbb98c25b6050f72022c7a1a353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68791a44cbc4c754a1196485fa3a9a37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga68791a44cbc4c754a1196485fa3a9a37"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga68791a44cbc4c754a1196485fa3a9a37">operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:ga68791a44cbc4c754a1196485fa3a9a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#ga68791a44cbc4c754a1196485fa3a9a37">More...</a><br /></td></tr>
<tr class="separator:ga68791a44cbc4c754a1196485fa3a9a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DiagonalProxy global functions</div></td></tr>
<tr class="memitem:gab1218387fdd76e3eead49086d7fdc5e7"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gab1218387fdd76e3eead49086d7fdc5e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d90/group__diagonal__matrix.html#gab1218387fdd76e3eead49086d7fdc5e7">reset</a> (const <a class="el" href="../../dd/dec/classblaze_1_1DiagonalProxy.html">DiagonalProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gab1218387fdd76e3eead49086d7fdc5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../d0/d90/group__diagonal__matrix.html#gab1218387fdd76e3eead49086d7fdc5e7">More...</a><br /></td></tr>
<tr class="separator:gab1218387fdd76e3eead49086d7fdc5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga834f663e7bd7bad48600ec5b036269bb"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga834f663e7bd7bad48600ec5b036269bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d90/group__diagonal__matrix.html#ga834f663e7bd7bad48600ec5b036269bb">clear</a> (const <a class="el" href="../../dd/dec/classblaze_1_1DiagonalProxy.html">DiagonalProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga834f663e7bd7bad48600ec5b036269bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../d0/d90/group__diagonal__matrix.html#ga834f663e7bd7bad48600ec5b036269bb">More...</a><br /></td></tr>
<tr class="separator:ga834f663e7bd7bad48600ec5b036269bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea8a8719fe7a9eea753f71016b8edb57"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaea8a8719fe7a9eea753f71016b8edb57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d90/group__diagonal__matrix.html#gaea8a8719fe7a9eea753f71016b8edb57">isDefault</a> (const <a class="el" href="../../dd/dec/classblaze_1_1DiagonalProxy.html">DiagonalProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaea8a8719fe7a9eea753f71016b8edb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../d0/d90/group__diagonal__matrix.html#gaea8a8719fe7a9eea753f71016b8edb57">More...</a><br /></td></tr>
<tr class="separator:gaea8a8719fe7a9eea753f71016b8edb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50d1edd0cf6aa957d98674df7dadd9f8"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga50d1edd0cf6aa957d98674df7dadd9f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d90/group__diagonal__matrix.html#ga50d1edd0cf6aa957d98674df7dadd9f8">isReal</a> (const <a class="el" href="../../dd/dec/classblaze_1_1DiagonalProxy.html">DiagonalProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga50d1edd0cf6aa957d98674df7dadd9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix element represents a real number.  <a href="../../d0/d90/group__diagonal__matrix.html#ga50d1edd0cf6aa957d98674df7dadd9f8">More...</a><br /></td></tr>
<tr class="separator:ga50d1edd0cf6aa957d98674df7dadd9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga344e3c78c0810d14a7d63361b65ce176"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga344e3c78c0810d14a7d63361b65ce176"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d90/group__diagonal__matrix.html#ga344e3c78c0810d14a7d63361b65ce176">isZero</a> (const <a class="el" href="../../dd/dec/classblaze_1_1DiagonalProxy.html">DiagonalProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga344e3c78c0810d14a7d63361b65ce176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../d0/d90/group__diagonal__matrix.html#ga344e3c78c0810d14a7d63361b65ce176">More...</a><br /></td></tr>
<tr class="separator:ga344e3c78c0810d14a7d63361b65ce176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cfb49b5fb54dd5cc450de21058edb24"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga9cfb49b5fb54dd5cc450de21058edb24"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d90/group__diagonal__matrix.html#ga9cfb49b5fb54dd5cc450de21058edb24">isOne</a> (const <a class="el" href="../../dd/dec/classblaze_1_1DiagonalProxy.html">DiagonalProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga9cfb49b5fb54dd5cc450de21058edb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../d0/d90/group__diagonal__matrix.html#ga9cfb49b5fb54dd5cc450de21058edb24">More...</a><br /></td></tr>
<tr class="separator:ga9cfb49b5fb54dd5cc450de21058edb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d643a61cd9e3b87852233e13973f08"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga88d643a61cd9e3b87852233e13973f08"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d90/group__diagonal__matrix.html#ga88d643a61cd9e3b87852233e13973f08">isnan</a> (const <a class="el" href="../../dd/dec/classblaze_1_1DiagonalProxy.html">DiagonalProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga88d643a61cd9e3b87852233e13973f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../d0/d90/group__diagonal__matrix.html#ga88d643a61cd9e3b87852233e13973f08">More...</a><br /></td></tr>
<tr class="separator:ga88d643a61cd9e3b87852233e13973f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DiagonalMatrix operators</div></td></tr>
<tr class="memitem:gaf5a96bd8f517b67dcc381fe09b4a27ab"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gaf5a96bd8f517b67dcc381fe09b4a27ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d90/group__diagonal__matrix.html#gaf5a96bd8f517b67dcc381fe09b4a27ab">reset</a> (<a class="el" href="../../d9/d3f/classblaze_1_1DiagonalMatrix.html">DiagonalMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:gaf5a96bd8f517b67dcc381fe09b4a27ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given diagonal matrix.  <a href="../../d0/d90/group__diagonal__matrix.html#gaf5a96bd8f517b67dcc381fe09b4a27ab">More...</a><br /></td></tr>
<tr class="separator:gaf5a96bd8f517b67dcc381fe09b4a27ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga642822a3b98e0ca7cafb9918983a8adb"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga642822a3b98e0ca7cafb9918983a8adb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d90/group__diagonal__matrix.html#ga642822a3b98e0ca7cafb9918983a8adb">reset</a> (<a class="el" href="../../d9/d3f/classblaze_1_1DiagonalMatrix.html">DiagonalMatrix</a>&lt; MT, SO, DF &gt; &amp;m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga642822a3b98e0ca7cafb9918983a8adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the specified row/column of the given diagonal matrix.  <a href="../../d0/d90/group__diagonal__matrix.html#ga642822a3b98e0ca7cafb9918983a8adb">More...</a><br /></td></tr>
<tr class="separator:ga642822a3b98e0ca7cafb9918983a8adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28ca57c301f1f0dcf3ed4be62f5a0bbe"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga28ca57c301f1f0dcf3ed4be62f5a0bbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d90/group__diagonal__matrix.html#ga28ca57c301f1f0dcf3ed4be62f5a0bbe">clear</a> (<a class="el" href="../../d9/d3f/classblaze_1_1DiagonalMatrix.html">DiagonalMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga28ca57c301f1f0dcf3ed4be62f5a0bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given diagonal matrix.  <a href="../../d0/d90/group__diagonal__matrix.html#ga28ca57c301f1f0dcf3ed4be62f5a0bbe">More...</a><br /></td></tr>
<tr class="separator:ga28ca57c301f1f0dcf3ed4be62f5a0bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4ab4b6d315ab05e93e539bfbf210b1"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga1f4ab4b6d315ab05e93e539bfbf210b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d90/group__diagonal__matrix.html#ga1f4ab4b6d315ab05e93e539bfbf210b1">isDefault</a> (const <a class="el" href="../../d9/d3f/classblaze_1_1DiagonalMatrix.html">DiagonalMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga1f4ab4b6d315ab05e93e539bfbf210b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given diagonal matrix is in default state.  <a href="../../d0/d90/group__diagonal__matrix.html#ga1f4ab4b6d315ab05e93e539bfbf210b1">More...</a><br /></td></tr>
<tr class="separator:ga1f4ab4b6d315ab05e93e539bfbf210b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a8ab2ae765932abb956d740604ebac"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga03a8ab2ae765932abb956d740604ebac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d90/group__diagonal__matrix.html#ga03a8ab2ae765932abb956d740604ebac">isIntact</a> (const <a class="el" href="../../d9/d3f/classblaze_1_1DiagonalMatrix.html">DiagonalMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga03a8ab2ae765932abb956d740604ebac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given diagonal matrix are intact.  <a href="../../d0/d90/group__diagonal__matrix.html#ga03a8ab2ae765932abb956d740604ebac">More...</a><br /></td></tr>
<tr class="separator:ga03a8ab2ae765932abb956d740604ebac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab43761918ec443f581bbbebb71cd538"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gaab43761918ec443f581bbbebb71cd538"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d90/group__diagonal__matrix.html#gaab43761918ec443f581bbbebb71cd538">swap</a> (<a class="el" href="../../d9/d3f/classblaze_1_1DiagonalMatrix.html">DiagonalMatrix</a>&lt; MT, SO, DF &gt; &amp;a, <a class="el" href="../../d9/d3f/classblaze_1_1DiagonalMatrix.html">DiagonalMatrix</a>&lt; MT, SO, DF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gaab43761918ec443f581bbbebb71cd538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two matrices.  <a href="../../d0/d90/group__diagonal__matrix.html#gaab43761918ec443f581bbbebb71cd538">More...</a><br /></td></tr>
<tr class="separator:gaab43761918ec443f581bbbebb71cd538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">HermitianProxy global functions</div></td></tr>
<tr class="memitem:ga79e22981a06ebae3fb8c3fd0d090f0fa"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga79e22981a06ebae3fb8c3fd0d090f0fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#ga79e22981a06ebae3fb8c3fd0d090f0fa">reset</a> (const <a class="el" href="../../d8/dbd/classblaze_1_1HermitianProxy.html">HermitianProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga79e22981a06ebae3fb8c3fd0d090f0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../dc/dca/group__hermitian__matrix.html#ga79e22981a06ebae3fb8c3fd0d090f0fa">More...</a><br /></td></tr>
<tr class="separator:ga79e22981a06ebae3fb8c3fd0d090f0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9691b5f2160f6cc7b1bb5dbbb2341145"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga9691b5f2160f6cc7b1bb5dbbb2341145"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#ga9691b5f2160f6cc7b1bb5dbbb2341145">clear</a> (const <a class="el" href="../../d8/dbd/classblaze_1_1HermitianProxy.html">HermitianProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga9691b5f2160f6cc7b1bb5dbbb2341145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../dc/dca/group__hermitian__matrix.html#ga9691b5f2160f6cc7b1bb5dbbb2341145">More...</a><br /></td></tr>
<tr class="separator:ga9691b5f2160f6cc7b1bb5dbbb2341145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcadc3a730ea3ba104818694952b8118"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gadcadc3a730ea3ba104818694952b8118"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#gadcadc3a730ea3ba104818694952b8118">invert</a> (const <a class="el" href="../../d8/dbd/classblaze_1_1HermitianProxy.html">HermitianProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gadcadc3a730ea3ba104818694952b8118"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the represented element.  <a href="../../dc/dca/group__hermitian__matrix.html#gadcadc3a730ea3ba104818694952b8118">More...</a><br /></td></tr>
<tr class="separator:gadcadc3a730ea3ba104818694952b8118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07237b80936201bcf724bf95b2c61bc5"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga07237b80936201bcf724bf95b2c61bc5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#ga07237b80936201bcf724bf95b2c61bc5">isDefault</a> (const <a class="el" href="../../d8/dbd/classblaze_1_1HermitianProxy.html">HermitianProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga07237b80936201bcf724bf95b2c61bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../dc/dca/group__hermitian__matrix.html#ga07237b80936201bcf724bf95b2c61bc5">More...</a><br /></td></tr>
<tr class="separator:ga07237b80936201bcf724bf95b2c61bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fa75fb444b7aa85902a5e3a8abf1985"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga9fa75fb444b7aa85902a5e3a8abf1985"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#ga9fa75fb444b7aa85902a5e3a8abf1985">isReal</a> (const <a class="el" href="../../d8/dbd/classblaze_1_1HermitianProxy.html">HermitianProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga9fa75fb444b7aa85902a5e3a8abf1985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix element represents a real number.  <a href="../../dc/dca/group__hermitian__matrix.html#ga9fa75fb444b7aa85902a5e3a8abf1985">More...</a><br /></td></tr>
<tr class="separator:ga9fa75fb444b7aa85902a5e3a8abf1985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ef7b19904c430e8d5d0477a54ee2c3c"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga2ef7b19904c430e8d5d0477a54ee2c3c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#ga2ef7b19904c430e8d5d0477a54ee2c3c">isZero</a> (const <a class="el" href="../../d8/dbd/classblaze_1_1HermitianProxy.html">HermitianProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga2ef7b19904c430e8d5d0477a54ee2c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../dc/dca/group__hermitian__matrix.html#ga2ef7b19904c430e8d5d0477a54ee2c3c">More...</a><br /></td></tr>
<tr class="separator:ga2ef7b19904c430e8d5d0477a54ee2c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20ba33b0d4c4346ba5be47a6773e3e58"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga20ba33b0d4c4346ba5be47a6773e3e58"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#ga20ba33b0d4c4346ba5be47a6773e3e58">isOne</a> (const <a class="el" href="../../d8/dbd/classblaze_1_1HermitianProxy.html">HermitianProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga20ba33b0d4c4346ba5be47a6773e3e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../dc/dca/group__hermitian__matrix.html#ga20ba33b0d4c4346ba5be47a6773e3e58">More...</a><br /></td></tr>
<tr class="separator:ga20ba33b0d4c4346ba5be47a6773e3e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5711233b9758b45d4aac01b896b489ca"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga5711233b9758b45d4aac01b896b489ca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#ga5711233b9758b45d4aac01b896b489ca">isnan</a> (const <a class="el" href="../../d8/dbd/classblaze_1_1HermitianProxy.html">HermitianProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga5711233b9758b45d4aac01b896b489ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../dc/dca/group__hermitian__matrix.html#ga5711233b9758b45d4aac01b896b489ca">More...</a><br /></td></tr>
<tr class="separator:ga5711233b9758b45d4aac01b896b489ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">HermitianValue global functions</div></td></tr>
<tr class="memitem:ga2e432ce5f4c4236f94917a3f4be598fb"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga2e432ce5f4c4236f94917a3f4be598fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#ga2e432ce5f4c4236f94917a3f4be598fb">reset</a> (const <a class="el" href="../../d2/d3c/classblaze_1_1HermitianValue.html">HermitianValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga2e432ce5f4c4236f94917a3f4be598fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the Hermitian value to the default initial values.  <a href="../../dc/dca/group__hermitian__matrix.html#ga2e432ce5f4c4236f94917a3f4be598fb">More...</a><br /></td></tr>
<tr class="separator:ga2e432ce5f4c4236f94917a3f4be598fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae090733e48e0f506088d0c3e40952412"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gae090733e48e0f506088d0c3e40952412"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#gae090733e48e0f506088d0c3e40952412">clear</a> (const <a class="el" href="../../d2/d3c/classblaze_1_1HermitianValue.html">HermitianValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gae090733e48e0f506088d0c3e40952412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the Hermitian value.  <a href="../../dc/dca/group__hermitian__matrix.html#gae090733e48e0f506088d0c3e40952412">More...</a><br /></td></tr>
<tr class="separator:gae090733e48e0f506088d0c3e40952412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb661ead03fe55d409be661e4d4df1f"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaeeb661ead03fe55d409be661e4d4df1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#gaeeb661ead03fe55d409be661e4d4df1f">invert</a> (const <a class="el" href="../../d2/d3c/classblaze_1_1HermitianValue.html">HermitianValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gaeeb661ead03fe55d409be661e4d4df1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the Hermitian value.  <a href="../../dc/dca/group__hermitian__matrix.html#gaeeb661ead03fe55d409be661e4d4df1f">More...</a><br /></td></tr>
<tr class="separator:gaeeb661ead03fe55d409be661e4d4df1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd629d264d0ad7c00d523be4715378a0"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gadd629d264d0ad7c00d523be4715378a0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#gadd629d264d0ad7c00d523be4715378a0">isDefault</a> (const <a class="el" href="../../d2/d3c/classblaze_1_1HermitianValue.html">HermitianValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gadd629d264d0ad7c00d523be4715378a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the Hermitian value is in default state.  <a href="../../dc/dca/group__hermitian__matrix.html#gadd629d264d0ad7c00d523be4715378a0">More...</a><br /></td></tr>
<tr class="separator:gadd629d264d0ad7c00d523be4715378a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2bcd2d6d895e1f7c975c7b592b90050"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gad2bcd2d6d895e1f7c975c7b592b90050"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#gad2bcd2d6d895e1f7c975c7b592b90050">isReal</a> (const <a class="el" href="../../d2/d3c/classblaze_1_1HermitianValue.html">HermitianValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gad2bcd2d6d895e1f7c975c7b592b90050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the Hermitian value represents a real number.  <a href="../../dc/dca/group__hermitian__matrix.html#gad2bcd2d6d895e1f7c975c7b592b90050">More...</a><br /></td></tr>
<tr class="separator:gad2bcd2d6d895e1f7c975c7b592b90050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d0b106182d95a1e80dea57f161c4f59"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga8d0b106182d95a1e80dea57f161c4f59"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#ga8d0b106182d95a1e80dea57f161c4f59">isZero</a> (const <a class="el" href="../../d2/d3c/classblaze_1_1HermitianValue.html">HermitianValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga8d0b106182d95a1e80dea57f161c4f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the Hermitian value is 0.  <a href="../../dc/dca/group__hermitian__matrix.html#ga8d0b106182d95a1e80dea57f161c4f59">More...</a><br /></td></tr>
<tr class="separator:ga8d0b106182d95a1e80dea57f161c4f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3500148d75f5b2826b44992fc8d62ffd"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga3500148d75f5b2826b44992fc8d62ffd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#ga3500148d75f5b2826b44992fc8d62ffd">isOne</a> (const <a class="el" href="../../d2/d3c/classblaze_1_1HermitianValue.html">HermitianValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga3500148d75f5b2826b44992fc8d62ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the Hermitian value is 1.  <a href="../../dc/dca/group__hermitian__matrix.html#ga3500148d75f5b2826b44992fc8d62ffd">More...</a><br /></td></tr>
<tr class="separator:ga3500148d75f5b2826b44992fc8d62ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1bbefa936166f851b0928c86700e372"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaf1bbefa936166f851b0928c86700e372"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#gaf1bbefa936166f851b0928c86700e372">isnan</a> (const <a class="el" href="../../d2/d3c/classblaze_1_1HermitianValue.html">HermitianValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gaf1bbefa936166f851b0928c86700e372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the Hermitian value is not a number.  <a href="../../dc/dca/group__hermitian__matrix.html#gaf1bbefa936166f851b0928c86700e372">More...</a><br /></td></tr>
<tr class="separator:gaf1bbefa936166f851b0928c86700e372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">HermitianMatrix operators</div></td></tr>
<tr class="memitem:ga1e1e0ac4db7a66027a12a17dd99c70d3"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga1e1e0ac4db7a66027a12a17dd99c70d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#ga1e1e0ac4db7a66027a12a17dd99c70d3">reset</a> (<a class="el" href="../../dd/df4/classblaze_1_1HermitianMatrix.html">HermitianMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga1e1e0ac4db7a66027a12a17dd99c70d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given Hermitian matrix.  <a href="../../dc/dca/group__hermitian__matrix.html#ga1e1e0ac4db7a66027a12a17dd99c70d3">More...</a><br /></td></tr>
<tr class="separator:ga1e1e0ac4db7a66027a12a17dd99c70d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga781307df85a9a874d14d91f6f9fb9c74"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga781307df85a9a874d14d91f6f9fb9c74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#ga781307df85a9a874d14d91f6f9fb9c74">reset</a> (<a class="el" href="../../dd/df4/classblaze_1_1HermitianMatrix.html">HermitianMatrix</a>&lt; MT, SO, DF &gt; &amp;m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga781307df85a9a874d14d91f6f9fb9c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the specified row/column of the given Hermitian matrix.  <a href="../../dc/dca/group__hermitian__matrix.html#ga781307df85a9a874d14d91f6f9fb9c74">More...</a><br /></td></tr>
<tr class="separator:ga781307df85a9a874d14d91f6f9fb9c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae10d22049c01235a0258057a03a30c8f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gae10d22049c01235a0258057a03a30c8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#gae10d22049c01235a0258057a03a30c8f">clear</a> (<a class="el" href="../../dd/df4/classblaze_1_1HermitianMatrix.html">HermitianMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:gae10d22049c01235a0258057a03a30c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given Hermitian matrix.  <a href="../../dc/dca/group__hermitian__matrix.html#gae10d22049c01235a0258057a03a30c8f">More...</a><br /></td></tr>
<tr class="separator:gae10d22049c01235a0258057a03a30c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e24c3b682862f8c3d645238c2e83c9"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga54e24c3b682862f8c3d645238c2e83c9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#ga54e24c3b682862f8c3d645238c2e83c9">isDefault</a> (const <a class="el" href="../../dd/df4/classblaze_1_1HermitianMatrix.html">HermitianMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga54e24c3b682862f8c3d645238c2e83c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given Hermitian matrix is in default state.  <a href="../../dc/dca/group__hermitian__matrix.html#ga54e24c3b682862f8c3d645238c2e83c9">More...</a><br /></td></tr>
<tr class="separator:ga54e24c3b682862f8c3d645238c2e83c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga044a12ee6711aa6cf506e1b4c3c7d160"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga044a12ee6711aa6cf506e1b4c3c7d160"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#ga044a12ee6711aa6cf506e1b4c3c7d160">isIntact</a> (const <a class="el" href="../../dd/df4/classblaze_1_1HermitianMatrix.html">HermitianMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga044a12ee6711aa6cf506e1b4c3c7d160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given Hermitian matrix are intact.  <a href="../../dc/dca/group__hermitian__matrix.html#ga044a12ee6711aa6cf506e1b4c3c7d160">More...</a><br /></td></tr>
<tr class="separator:ga044a12ee6711aa6cf506e1b4c3c7d160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc55e95630255bf4e25ae621d2e39171"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gacc55e95630255bf4e25ae621d2e39171"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dca/group__hermitian__matrix.html#gacc55e95630255bf4e25ae621d2e39171">swap</a> (<a class="el" href="../../dd/df4/classblaze_1_1HermitianMatrix.html">HermitianMatrix</a>&lt; MT, SO, DF &gt; &amp;a, <a class="el" href="../../dd/df4/classblaze_1_1HermitianMatrix.html">HermitianMatrix</a>&lt; MT, SO, DF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gacc55e95630255bf4e25ae621d2e39171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two matrices.  <a href="../../dc/dca/group__hermitian__matrix.html#gacc55e95630255bf4e25ae621d2e39171">More...</a><br /></td></tr>
<tr class="separator:gacc55e95630255bf4e25ae621d2e39171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LowerProxy global functions</div></td></tr>
<tr class="memitem:ga9454d1aa19d47ad199da3ba2242bb9bd"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga9454d1aa19d47ad199da3ba2242bb9bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d02/group__lower__matrix.html#ga9454d1aa19d47ad199da3ba2242bb9bd">reset</a> (const <a class="el" href="../../d5/de5/classblaze_1_1LowerProxy.html">LowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga9454d1aa19d47ad199da3ba2242bb9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../db/d02/group__lower__matrix.html#ga9454d1aa19d47ad199da3ba2242bb9bd">More...</a><br /></td></tr>
<tr class="separator:ga9454d1aa19d47ad199da3ba2242bb9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d3f139df9d97c454929fd046548787e"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga3d3f139df9d97c454929fd046548787e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d02/group__lower__matrix.html#ga3d3f139df9d97c454929fd046548787e">clear</a> (const <a class="el" href="../../d5/de5/classblaze_1_1LowerProxy.html">LowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga3d3f139df9d97c454929fd046548787e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../db/d02/group__lower__matrix.html#ga3d3f139df9d97c454929fd046548787e">More...</a><br /></td></tr>
<tr class="separator:ga3d3f139df9d97c454929fd046548787e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92dcdea016fcd354e14edf4c5056a1a3"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga92dcdea016fcd354e14edf4c5056a1a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d02/group__lower__matrix.html#ga92dcdea016fcd354e14edf4c5056a1a3">isDefault</a> (const <a class="el" href="../../d5/de5/classblaze_1_1LowerProxy.html">LowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga92dcdea016fcd354e14edf4c5056a1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../db/d02/group__lower__matrix.html#ga92dcdea016fcd354e14edf4c5056a1a3">More...</a><br /></td></tr>
<tr class="separator:ga92dcdea016fcd354e14edf4c5056a1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4581f7dd4e3e7d6b293bbd0c679b67ab"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga4581f7dd4e3e7d6b293bbd0c679b67ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d02/group__lower__matrix.html#ga4581f7dd4e3e7d6b293bbd0c679b67ab">isReal</a> (const <a class="el" href="../../d5/de5/classblaze_1_1LowerProxy.html">LowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga4581f7dd4e3e7d6b293bbd0c679b67ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix element represents a real number.  <a href="../../db/d02/group__lower__matrix.html#ga4581f7dd4e3e7d6b293bbd0c679b67ab">More...</a><br /></td></tr>
<tr class="separator:ga4581f7dd4e3e7d6b293bbd0c679b67ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767cc982b197a119bc704714e0ae6738"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga767cc982b197a119bc704714e0ae6738"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d02/group__lower__matrix.html#ga767cc982b197a119bc704714e0ae6738">isZero</a> (const <a class="el" href="../../d5/de5/classblaze_1_1LowerProxy.html">LowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga767cc982b197a119bc704714e0ae6738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../db/d02/group__lower__matrix.html#ga767cc982b197a119bc704714e0ae6738">More...</a><br /></td></tr>
<tr class="separator:ga767cc982b197a119bc704714e0ae6738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c152a60f483c97babf81d9b069e75b"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gad6c152a60f483c97babf81d9b069e75b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d02/group__lower__matrix.html#gad6c152a60f483c97babf81d9b069e75b">isOne</a> (const <a class="el" href="../../d5/de5/classblaze_1_1LowerProxy.html">LowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad6c152a60f483c97babf81d9b069e75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../db/d02/group__lower__matrix.html#gad6c152a60f483c97babf81d9b069e75b">More...</a><br /></td></tr>
<tr class="separator:gad6c152a60f483c97babf81d9b069e75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad881a439656395e6974dc4ad5e476b61"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gad881a439656395e6974dc4ad5e476b61"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d02/group__lower__matrix.html#gad881a439656395e6974dc4ad5e476b61">isnan</a> (const <a class="el" href="../../d5/de5/classblaze_1_1LowerProxy.html">LowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad881a439656395e6974dc4ad5e476b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../db/d02/group__lower__matrix.html#gad881a439656395e6974dc4ad5e476b61">More...</a><br /></td></tr>
<tr class="separator:gad881a439656395e6974dc4ad5e476b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LowerMatrix operators</div></td></tr>
<tr class="memitem:ga5c57ef37519cb300eb6b55d59cc91a4f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga5c57ef37519cb300eb6b55d59cc91a4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d02/group__lower__matrix.html#ga5c57ef37519cb300eb6b55d59cc91a4f">reset</a> (<a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html">LowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga5c57ef37519cb300eb6b55d59cc91a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given lower matrix.  <a href="../../db/d02/group__lower__matrix.html#ga5c57ef37519cb300eb6b55d59cc91a4f">More...</a><br /></td></tr>
<tr class="separator:ga5c57ef37519cb300eb6b55d59cc91a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a5af558b3bd91f799a275d23d75fc02"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga9a5af558b3bd91f799a275d23d75fc02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d02/group__lower__matrix.html#ga9a5af558b3bd91f799a275d23d75fc02">reset</a> (<a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html">LowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga9a5af558b3bd91f799a275d23d75fc02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the specified row/column of the given lower matrix.  <a href="../../db/d02/group__lower__matrix.html#ga9a5af558b3bd91f799a275d23d75fc02">More...</a><br /></td></tr>
<tr class="separator:ga9a5af558b3bd91f799a275d23d75fc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f31a429e0503f00756f6cb6fa425e35"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga0f31a429e0503f00756f6cb6fa425e35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d02/group__lower__matrix.html#ga0f31a429e0503f00756f6cb6fa425e35">clear</a> (<a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html">LowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga0f31a429e0503f00756f6cb6fa425e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given lower matrix.  <a href="../../db/d02/group__lower__matrix.html#ga0f31a429e0503f00756f6cb6fa425e35">More...</a><br /></td></tr>
<tr class="separator:ga0f31a429e0503f00756f6cb6fa425e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2935f79631c669d8fd73ee2d014c1fb9"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga2935f79631c669d8fd73ee2d014c1fb9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d02/group__lower__matrix.html#ga2935f79631c669d8fd73ee2d014c1fb9">isDefault</a> (const <a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html">LowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga2935f79631c669d8fd73ee2d014c1fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given lower matrix is in default state.  <a href="../../db/d02/group__lower__matrix.html#ga2935f79631c669d8fd73ee2d014c1fb9">More...</a><br /></td></tr>
<tr class="separator:ga2935f79631c669d8fd73ee2d014c1fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0450fd32ef5a8e4f8103a2ec15a2144d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga0450fd32ef5a8e4f8103a2ec15a2144d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d02/group__lower__matrix.html#ga0450fd32ef5a8e4f8103a2ec15a2144d">isIntact</a> (const <a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html">LowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga0450fd32ef5a8e4f8103a2ec15a2144d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given lower matrix are intact.  <a href="../../db/d02/group__lower__matrix.html#ga0450fd32ef5a8e4f8103a2ec15a2144d">More...</a><br /></td></tr>
<tr class="separator:ga0450fd32ef5a8e4f8103a2ec15a2144d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9cf26e58e86322578c8ce897a1f56f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gacf9cf26e58e86322578c8ce897a1f56f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d02/group__lower__matrix.html#gacf9cf26e58e86322578c8ce897a1f56f">swap</a> (<a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html">LowerMatrix</a>&lt; MT, SO, DF &gt; &amp;a, <a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html">LowerMatrix</a>&lt; MT, SO, DF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gacf9cf26e58e86322578c8ce897a1f56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two matrices.  <a href="../../db/d02/group__lower__matrix.html#gacf9cf26e58e86322578c8ce897a1f56f">More...</a><br /></td></tr>
<tr class="separator:gacf9cf26e58e86322578c8ce897a1f56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">StrictlyLowerProxy global functions</div></td></tr>
<tr class="memitem:ga4df8cfaf5db325a55fb9becc5d2939c6"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga4df8cfaf5db325a55fb9becc5d2939c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d23/group__strictly__lower__matrix.html#ga4df8cfaf5db325a55fb9becc5d2939c6">reset</a> (const <a class="el" href="../../de/d0d/classblaze_1_1StrictlyLowerProxy.html">StrictlyLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga4df8cfaf5db325a55fb9becc5d2939c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../de/d23/group__strictly__lower__matrix.html#ga4df8cfaf5db325a55fb9becc5d2939c6">More...</a><br /></td></tr>
<tr class="separator:ga4df8cfaf5db325a55fb9becc5d2939c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb550c7641b3855ec174bc13df220118"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gabb550c7641b3855ec174bc13df220118"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d23/group__strictly__lower__matrix.html#gabb550c7641b3855ec174bc13df220118">clear</a> (const <a class="el" href="../../de/d0d/classblaze_1_1StrictlyLowerProxy.html">StrictlyLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gabb550c7641b3855ec174bc13df220118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../de/d23/group__strictly__lower__matrix.html#gabb550c7641b3855ec174bc13df220118">More...</a><br /></td></tr>
<tr class="separator:gabb550c7641b3855ec174bc13df220118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3df38d02169d5d154859d54b5ed6baee"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga3df38d02169d5d154859d54b5ed6baee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d23/group__strictly__lower__matrix.html#ga3df38d02169d5d154859d54b5ed6baee">isDefault</a> (const <a class="el" href="../../de/d0d/classblaze_1_1StrictlyLowerProxy.html">StrictlyLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga3df38d02169d5d154859d54b5ed6baee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../de/d23/group__strictly__lower__matrix.html#ga3df38d02169d5d154859d54b5ed6baee">More...</a><br /></td></tr>
<tr class="separator:ga3df38d02169d5d154859d54b5ed6baee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e9b0a90c59bd240b2d20fe1dc6631fd"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga4e9b0a90c59bd240b2d20fe1dc6631fd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d23/group__strictly__lower__matrix.html#ga4e9b0a90c59bd240b2d20fe1dc6631fd">isReal</a> (const <a class="el" href="../../de/d0d/classblaze_1_1StrictlyLowerProxy.html">StrictlyLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga4e9b0a90c59bd240b2d20fe1dc6631fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix element represents a real number.  <a href="../../de/d23/group__strictly__lower__matrix.html#ga4e9b0a90c59bd240b2d20fe1dc6631fd">More...</a><br /></td></tr>
<tr class="separator:ga4e9b0a90c59bd240b2d20fe1dc6631fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b2778477f42821b8db0164cfb73020"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gad5b2778477f42821b8db0164cfb73020"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d23/group__strictly__lower__matrix.html#gad5b2778477f42821b8db0164cfb73020">isZero</a> (const <a class="el" href="../../de/d0d/classblaze_1_1StrictlyLowerProxy.html">StrictlyLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad5b2778477f42821b8db0164cfb73020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../de/d23/group__strictly__lower__matrix.html#gad5b2778477f42821b8db0164cfb73020">More...</a><br /></td></tr>
<tr class="separator:gad5b2778477f42821b8db0164cfb73020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca53d6b0ed79a6067aa0e5cf078a7e10"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaca53d6b0ed79a6067aa0e5cf078a7e10"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d23/group__strictly__lower__matrix.html#gaca53d6b0ed79a6067aa0e5cf078a7e10">isOne</a> (const <a class="el" href="../../de/d0d/classblaze_1_1StrictlyLowerProxy.html">StrictlyLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaca53d6b0ed79a6067aa0e5cf078a7e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../de/d23/group__strictly__lower__matrix.html#gaca53d6b0ed79a6067aa0e5cf078a7e10">More...</a><br /></td></tr>
<tr class="separator:gaca53d6b0ed79a6067aa0e5cf078a7e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2b4872cb332e0edcccc4ef59fe8aa47"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaf2b4872cb332e0edcccc4ef59fe8aa47"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d23/group__strictly__lower__matrix.html#gaf2b4872cb332e0edcccc4ef59fe8aa47">isnan</a> (const <a class="el" href="../../de/d0d/classblaze_1_1StrictlyLowerProxy.html">StrictlyLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaf2b4872cb332e0edcccc4ef59fe8aa47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../de/d23/group__strictly__lower__matrix.html#gaf2b4872cb332e0edcccc4ef59fe8aa47">More...</a><br /></td></tr>
<tr class="separator:gaf2b4872cb332e0edcccc4ef59fe8aa47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">StrictlyLowerMatrix operators</div></td></tr>
<tr class="memitem:ga83812cf230dd93bae9116ea09331d17e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga83812cf230dd93bae9116ea09331d17e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d23/group__strictly__lower__matrix.html#ga83812cf230dd93bae9116ea09331d17e">reset</a> (<a class="el" href="../../db/d08/classblaze_1_1StrictlyLowerMatrix.html">StrictlyLowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga83812cf230dd93bae9116ea09331d17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given strictly lower matrix.  <a href="../../de/d23/group__strictly__lower__matrix.html#ga83812cf230dd93bae9116ea09331d17e">More...</a><br /></td></tr>
<tr class="separator:ga83812cf230dd93bae9116ea09331d17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ced376b326887cb59bdc96bd88df09c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga3ced376b326887cb59bdc96bd88df09c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d23/group__strictly__lower__matrix.html#ga3ced376b326887cb59bdc96bd88df09c">reset</a> (<a class="el" href="../../db/d08/classblaze_1_1StrictlyLowerMatrix.html">StrictlyLowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga3ced376b326887cb59bdc96bd88df09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the specified row/column of the given strictly lower matrix.  <a href="../../de/d23/group__strictly__lower__matrix.html#ga3ced376b326887cb59bdc96bd88df09c">More...</a><br /></td></tr>
<tr class="separator:ga3ced376b326887cb59bdc96bd88df09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0f5e4a2013c88bdd41cd7c49744b1ac"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gac0f5e4a2013c88bdd41cd7c49744b1ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d23/group__strictly__lower__matrix.html#gac0f5e4a2013c88bdd41cd7c49744b1ac">clear</a> (<a class="el" href="../../db/d08/classblaze_1_1StrictlyLowerMatrix.html">StrictlyLowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:gac0f5e4a2013c88bdd41cd7c49744b1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given strictly lower matrix.  <a href="../../de/d23/group__strictly__lower__matrix.html#gac0f5e4a2013c88bdd41cd7c49744b1ac">More...</a><br /></td></tr>
<tr class="separator:gac0f5e4a2013c88bdd41cd7c49744b1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga921b09c0def08767da0e648caaf75889"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga921b09c0def08767da0e648caaf75889"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d23/group__strictly__lower__matrix.html#ga921b09c0def08767da0e648caaf75889">isDefault</a> (const <a class="el" href="../../db/d08/classblaze_1_1StrictlyLowerMatrix.html">StrictlyLowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga921b09c0def08767da0e648caaf75889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given strictly lower matrix is in default state.  <a href="../../de/d23/group__strictly__lower__matrix.html#ga921b09c0def08767da0e648caaf75889">More...</a><br /></td></tr>
<tr class="separator:ga921b09c0def08767da0e648caaf75889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a70e4074b9f7c854affea6c03cde11d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga8a70e4074b9f7c854affea6c03cde11d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d23/group__strictly__lower__matrix.html#ga8a70e4074b9f7c854affea6c03cde11d">isIntact</a> (const <a class="el" href="../../db/d08/classblaze_1_1StrictlyLowerMatrix.html">StrictlyLowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga8a70e4074b9f7c854affea6c03cde11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given strictly lower matrix are intact.  <a href="../../de/d23/group__strictly__lower__matrix.html#ga8a70e4074b9f7c854affea6c03cde11d">More...</a><br /></td></tr>
<tr class="separator:ga8a70e4074b9f7c854affea6c03cde11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16b9e160bd86be57b0272ba7a7e4726f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga16b9e160bd86be57b0272ba7a7e4726f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d23/group__strictly__lower__matrix.html#ga16b9e160bd86be57b0272ba7a7e4726f">swap</a> (<a class="el" href="../../db/d08/classblaze_1_1StrictlyLowerMatrix.html">StrictlyLowerMatrix</a>&lt; MT, SO, DF &gt; &amp;a, <a class="el" href="../../db/d08/classblaze_1_1StrictlyLowerMatrix.html">StrictlyLowerMatrix</a>&lt; MT, SO, DF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga16b9e160bd86be57b0272ba7a7e4726f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two matrices.  <a href="../../de/d23/group__strictly__lower__matrix.html#ga16b9e160bd86be57b0272ba7a7e4726f">More...</a><br /></td></tr>
<tr class="separator:ga16b9e160bd86be57b0272ba7a7e4726f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">StrictlyUpperProxy global functions</div></td></tr>
<tr class="memitem:gaa867e2b54e23959a51a86080b945264d"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaa867e2b54e23959a51a86080b945264d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d9d/group__strictly__upper__matrix.html#gaa867e2b54e23959a51a86080b945264d">reset</a> (const <a class="el" href="../../d3/d4b/classblaze_1_1StrictlyUpperProxy.html">StrictlyUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa867e2b54e23959a51a86080b945264d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../d6/d9d/group__strictly__upper__matrix.html#gaa867e2b54e23959a51a86080b945264d">More...</a><br /></td></tr>
<tr class="separator:gaa867e2b54e23959a51a86080b945264d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c827cbfb016530728c6424399fb6ed9"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga7c827cbfb016530728c6424399fb6ed9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d9d/group__strictly__upper__matrix.html#ga7c827cbfb016530728c6424399fb6ed9">clear</a> (const <a class="el" href="../../d3/d4b/classblaze_1_1StrictlyUpperProxy.html">StrictlyUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga7c827cbfb016530728c6424399fb6ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../d6/d9d/group__strictly__upper__matrix.html#ga7c827cbfb016530728c6424399fb6ed9">More...</a><br /></td></tr>
<tr class="separator:ga7c827cbfb016530728c6424399fb6ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a6ead820025f9efcd8f220e9670d34f"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga2a6ead820025f9efcd8f220e9670d34f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d9d/group__strictly__upper__matrix.html#ga2a6ead820025f9efcd8f220e9670d34f">isDefault</a> (const <a class="el" href="../../d3/d4b/classblaze_1_1StrictlyUpperProxy.html">StrictlyUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga2a6ead820025f9efcd8f220e9670d34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../d6/d9d/group__strictly__upper__matrix.html#ga2a6ead820025f9efcd8f220e9670d34f">More...</a><br /></td></tr>
<tr class="separator:ga2a6ead820025f9efcd8f220e9670d34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b23782ff9534cc4600ceb83ee93700b"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga0b23782ff9534cc4600ceb83ee93700b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d9d/group__strictly__upper__matrix.html#ga0b23782ff9534cc4600ceb83ee93700b">isReal</a> (const <a class="el" href="../../d3/d4b/classblaze_1_1StrictlyUpperProxy.html">StrictlyUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga0b23782ff9534cc4600ceb83ee93700b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix element represents a real number.  <a href="../../d6/d9d/group__strictly__upper__matrix.html#ga0b23782ff9534cc4600ceb83ee93700b">More...</a><br /></td></tr>
<tr class="separator:ga0b23782ff9534cc4600ceb83ee93700b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ea0b66366bd849cea605c06e4382aab"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga0ea0b66366bd849cea605c06e4382aab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d9d/group__strictly__upper__matrix.html#ga0ea0b66366bd849cea605c06e4382aab">isZero</a> (const <a class="el" href="../../d3/d4b/classblaze_1_1StrictlyUpperProxy.html">StrictlyUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga0ea0b66366bd849cea605c06e4382aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../d6/d9d/group__strictly__upper__matrix.html#ga0ea0b66366bd849cea605c06e4382aab">More...</a><br /></td></tr>
<tr class="separator:ga0ea0b66366bd849cea605c06e4382aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6923fc2e7984bd1d68cc5e7efdde598"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gae6923fc2e7984bd1d68cc5e7efdde598"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d9d/group__strictly__upper__matrix.html#gae6923fc2e7984bd1d68cc5e7efdde598">isOne</a> (const <a class="el" href="../../d3/d4b/classblaze_1_1StrictlyUpperProxy.html">StrictlyUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gae6923fc2e7984bd1d68cc5e7efdde598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../d6/d9d/group__strictly__upper__matrix.html#gae6923fc2e7984bd1d68cc5e7efdde598">More...</a><br /></td></tr>
<tr class="separator:gae6923fc2e7984bd1d68cc5e7efdde598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2b831f38a98a2b85759d0f176956e1"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaef2b831f38a98a2b85759d0f176956e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d9d/group__strictly__upper__matrix.html#gaef2b831f38a98a2b85759d0f176956e1">isnan</a> (const <a class="el" href="../../d3/d4b/classblaze_1_1StrictlyUpperProxy.html">StrictlyUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaef2b831f38a98a2b85759d0f176956e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../d6/d9d/group__strictly__upper__matrix.html#gaef2b831f38a98a2b85759d0f176956e1">More...</a><br /></td></tr>
<tr class="separator:gaef2b831f38a98a2b85759d0f176956e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">StrictlyUpperMatrix operators</div></td></tr>
<tr class="memitem:ga2b2f024599b6cf9c9b60d1ac4604720b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga2b2f024599b6cf9c9b60d1ac4604720b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d9d/group__strictly__upper__matrix.html#ga2b2f024599b6cf9c9b60d1ac4604720b">reset</a> (<a class="el" href="../../de/d41/classblaze_1_1StrictlyUpperMatrix.html">StrictlyUpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga2b2f024599b6cf9c9b60d1ac4604720b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given strictly upper matrix.  <a href="../../d6/d9d/group__strictly__upper__matrix.html#ga2b2f024599b6cf9c9b60d1ac4604720b">More...</a><br /></td></tr>
<tr class="separator:ga2b2f024599b6cf9c9b60d1ac4604720b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0865e5dbcfa95939f6708359c34e319"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gac0865e5dbcfa95939f6708359c34e319"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d9d/group__strictly__upper__matrix.html#gac0865e5dbcfa95939f6708359c34e319">reset</a> (<a class="el" href="../../de/d41/classblaze_1_1StrictlyUpperMatrix.html">StrictlyUpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gac0865e5dbcfa95939f6708359c34e319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the specified row/column of the given strictly upper matrix.  <a href="../../d6/d9d/group__strictly__upper__matrix.html#gac0865e5dbcfa95939f6708359c34e319">More...</a><br /></td></tr>
<tr class="separator:gac0865e5dbcfa95939f6708359c34e319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33311e968c84d4463f8bee5892102cb3"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga33311e968c84d4463f8bee5892102cb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d9d/group__strictly__upper__matrix.html#ga33311e968c84d4463f8bee5892102cb3">clear</a> (<a class="el" href="../../de/d41/classblaze_1_1StrictlyUpperMatrix.html">StrictlyUpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga33311e968c84d4463f8bee5892102cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given strictly upper matrix.  <a href="../../d6/d9d/group__strictly__upper__matrix.html#ga33311e968c84d4463f8bee5892102cb3">More...</a><br /></td></tr>
<tr class="separator:ga33311e968c84d4463f8bee5892102cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga857593c759bac11f4ee2f18fb336f356"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga857593c759bac11f4ee2f18fb336f356"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d9d/group__strictly__upper__matrix.html#ga857593c759bac11f4ee2f18fb336f356">isDefault</a> (const <a class="el" href="../../de/d41/classblaze_1_1StrictlyUpperMatrix.html">StrictlyUpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga857593c759bac11f4ee2f18fb336f356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given strictly upper matrix is in default state.  <a href="../../d6/d9d/group__strictly__upper__matrix.html#ga857593c759bac11f4ee2f18fb336f356">More...</a><br /></td></tr>
<tr class="separator:ga857593c759bac11f4ee2f18fb336f356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga686421a124dd7d4d47ef7c8030913583"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga686421a124dd7d4d47ef7c8030913583"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d9d/group__strictly__upper__matrix.html#ga686421a124dd7d4d47ef7c8030913583">isIntact</a> (const <a class="el" href="../../de/d41/classblaze_1_1StrictlyUpperMatrix.html">StrictlyUpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga686421a124dd7d4d47ef7c8030913583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given strictly upper matrix are intact.  <a href="../../d6/d9d/group__strictly__upper__matrix.html#ga686421a124dd7d4d47ef7c8030913583">More...</a><br /></td></tr>
<tr class="separator:ga686421a124dd7d4d47ef7c8030913583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dd26d257e25f43cf1691f7f95eeb70b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga6dd26d257e25f43cf1691f7f95eeb70b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d9d/group__strictly__upper__matrix.html#ga6dd26d257e25f43cf1691f7f95eeb70b">swap</a> (<a class="el" href="../../de/d41/classblaze_1_1StrictlyUpperMatrix.html">StrictlyUpperMatrix</a>&lt; MT, SO, DF &gt; &amp;a, <a class="el" href="../../de/d41/classblaze_1_1StrictlyUpperMatrix.html">StrictlyUpperMatrix</a>&lt; MT, SO, DF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga6dd26d257e25f43cf1691f7f95eeb70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two matrices.  <a href="../../d6/d9d/group__strictly__upper__matrix.html#ga6dd26d257e25f43cf1691f7f95eeb70b">More...</a><br /></td></tr>
<tr class="separator:ga6dd26d257e25f43cf1691f7f95eeb70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">NonNumericProxy global functions</div></td></tr>
<tr class="memitem:ga8903880dd0fba7887660fba4fea44626"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga8903880dd0fba7887660fba4fea44626"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga8903880dd0fba7887660fba4fea44626">reset</a> (const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga8903880dd0fba7887660fba4fea44626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../dc/d25/group__symmetric__matrix.html#ga8903880dd0fba7887660fba4fea44626">More...</a><br /></td></tr>
<tr class="separator:ga8903880dd0fba7887660fba4fea44626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5527efd4ad06fbce216db37ab7d8619a"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga5527efd4ad06fbce216db37ab7d8619a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga5527efd4ad06fbce216db37ab7d8619a">clear</a> (const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga5527efd4ad06fbce216db37ab7d8619a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../dc/d25/group__symmetric__matrix.html#ga5527efd4ad06fbce216db37ab7d8619a">More...</a><br /></td></tr>
<tr class="separator:ga5527efd4ad06fbce216db37ab7d8619a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd2a366ec8e9edb7f8909d27a855ce87"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gacd2a366ec8e9edb7f8909d27a855ce87"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#gacd2a366ec8e9edb7f8909d27a855ce87">isDefault</a> (const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gacd2a366ec8e9edb7f8909d27a855ce87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../dc/d25/group__symmetric__matrix.html#gacd2a366ec8e9edb7f8909d27a855ce87">More...</a><br /></td></tr>
<tr class="separator:gacd2a366ec8e9edb7f8909d27a855ce87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fdcca227ffc9a1fc51ec2f6a639276c"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga2fdcca227ffc9a1fc51ec2f6a639276c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga2fdcca227ffc9a1fc51ec2f6a639276c">isReal</a> (const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga2fdcca227ffc9a1fc51ec2f6a639276c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix element represents a real number.  <a href="../../dc/d25/group__symmetric__matrix.html#ga2fdcca227ffc9a1fc51ec2f6a639276c">More...</a><br /></td></tr>
<tr class="separator:ga2fdcca227ffc9a1fc51ec2f6a639276c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b4062341a06ab28a835c9f6a8910bcf"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga8b4062341a06ab28a835c9f6a8910bcf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga8b4062341a06ab28a835c9f6a8910bcf">isZero</a> (const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga8b4062341a06ab28a835c9f6a8910bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../dc/d25/group__symmetric__matrix.html#ga8b4062341a06ab28a835c9f6a8910bcf">More...</a><br /></td></tr>
<tr class="separator:ga8b4062341a06ab28a835c9f6a8910bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad18955a3b687d69cf44113cb11746f8b"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gad18955a3b687d69cf44113cb11746f8b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#gad18955a3b687d69cf44113cb11746f8b">isOne</a> (const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad18955a3b687d69cf44113cb11746f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../dc/d25/group__symmetric__matrix.html#gad18955a3b687d69cf44113cb11746f8b">More...</a><br /></td></tr>
<tr class="separator:gad18955a3b687d69cf44113cb11746f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1a47cb21c08201cb4fb1b74515e7158"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaf1a47cb21c08201cb4fb1b74515e7158"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#gaf1a47cb21c08201cb4fb1b74515e7158">isnan</a> (const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaf1a47cb21c08201cb4fb1b74515e7158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../dc/d25/group__symmetric__matrix.html#gaf1a47cb21c08201cb4fb1b74515e7158">More...</a><br /></td></tr>
<tr class="separator:gaf1a47cb21c08201cb4fb1b74515e7158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">NumericProxy global functions</div></td></tr>
<tr class="memitem:ga3ae34b2ec24cae5b2396805c09df4719"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga3ae34b2ec24cae5b2396805c09df4719"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga3ae34b2ec24cae5b2396805c09df4719">reset</a> (const <a class="el" href="../../d2/d85/classblaze_1_1NumericProxy.html">NumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga3ae34b2ec24cae5b2396805c09df4719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../dc/d25/group__symmetric__matrix.html#ga3ae34b2ec24cae5b2396805c09df4719">More...</a><br /></td></tr>
<tr class="separator:ga3ae34b2ec24cae5b2396805c09df4719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ff4b294d18e2de354467f54d715d9a"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gab0ff4b294d18e2de354467f54d715d9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#gab0ff4b294d18e2de354467f54d715d9a">clear</a> (const <a class="el" href="../../d2/d85/classblaze_1_1NumericProxy.html">NumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gab0ff4b294d18e2de354467f54d715d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../dc/d25/group__symmetric__matrix.html#gab0ff4b294d18e2de354467f54d715d9a">More...</a><br /></td></tr>
<tr class="separator:gab0ff4b294d18e2de354467f54d715d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea2333a964d0d502779cb6f1091e19a3"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaea2333a964d0d502779cb6f1091e19a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#gaea2333a964d0d502779cb6f1091e19a3">invert</a> (const <a class="el" href="../../d2/d85/classblaze_1_1NumericProxy.html">NumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaea2333a964d0d502779cb6f1091e19a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the represented element.  <a href="../../dc/d25/group__symmetric__matrix.html#gaea2333a964d0d502779cb6f1091e19a3">More...</a><br /></td></tr>
<tr class="separator:gaea2333a964d0d502779cb6f1091e19a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga078340bfb860d9a9b1bf7952c9355dc9"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga078340bfb860d9a9b1bf7952c9355dc9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga078340bfb860d9a9b1bf7952c9355dc9">isDefault</a> (const <a class="el" href="../../d2/d85/classblaze_1_1NumericProxy.html">NumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga078340bfb860d9a9b1bf7952c9355dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../dc/d25/group__symmetric__matrix.html#ga078340bfb860d9a9b1bf7952c9355dc9">More...</a><br /></td></tr>
<tr class="separator:ga078340bfb860d9a9b1bf7952c9355dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86931a41170e8791580a86af5f99e882"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga86931a41170e8791580a86af5f99e882"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga86931a41170e8791580a86af5f99e882">isReal</a> (const <a class="el" href="../../d2/d85/classblaze_1_1NumericProxy.html">NumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga86931a41170e8791580a86af5f99e882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix element represents a real number.  <a href="../../dc/d25/group__symmetric__matrix.html#ga86931a41170e8791580a86af5f99e882">More...</a><br /></td></tr>
<tr class="separator:ga86931a41170e8791580a86af5f99e882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa577e8aadccf7b45b37466e7e8ba562"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaaa577e8aadccf7b45b37466e7e8ba562"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#gaaa577e8aadccf7b45b37466e7e8ba562">isZero</a> (const <a class="el" href="../../d2/d85/classblaze_1_1NumericProxy.html">NumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaaa577e8aadccf7b45b37466e7e8ba562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../dc/d25/group__symmetric__matrix.html#gaaa577e8aadccf7b45b37466e7e8ba562">More...</a><br /></td></tr>
<tr class="separator:gaaa577e8aadccf7b45b37466e7e8ba562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefc063f238459c950a4d10b48ec891ab"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaefc063f238459c950a4d10b48ec891ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#gaefc063f238459c950a4d10b48ec891ab">isOne</a> (const <a class="el" href="../../d2/d85/classblaze_1_1NumericProxy.html">NumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaefc063f238459c950a4d10b48ec891ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../dc/d25/group__symmetric__matrix.html#gaefc063f238459c950a4d10b48ec891ab">More...</a><br /></td></tr>
<tr class="separator:gaefc063f238459c950a4d10b48ec891ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fffb56887773011a905d98cb666b9e"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga30fffb56887773011a905d98cb666b9e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga30fffb56887773011a905d98cb666b9e">isnan</a> (const <a class="el" href="../../d2/d85/classblaze_1_1NumericProxy.html">NumericProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga30fffb56887773011a905d98cb666b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../dc/d25/group__symmetric__matrix.html#ga30fffb56887773011a905d98cb666b9e">More...</a><br /></td></tr>
<tr class="separator:ga30fffb56887773011a905d98cb666b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SharedValue operators</div></td></tr>
<tr class="memitem:gaad3899ccbf8f4aec2cdb5e4351d1908e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaad3899ccbf8f4aec2cdb5e4351d1908e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#gaad3899ccbf8f4aec2cdb5e4351d1908e">operator==</a> (const <a class="el" href="../../d2/d20/classblaze_1_1SharedValue.html">SharedValue</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../d2/d20/classblaze_1_1SharedValue.html">SharedValue</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaad3899ccbf8f4aec2cdb5e4351d1908e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../d2/d20/classblaze_1_1SharedValue.html" title="Value shared among several positions within a symmetric matrix.The SharedValue class template represe...">SharedValue</a> objects.  <a href="../../dc/d25/group__symmetric__matrix.html#gaad3899ccbf8f4aec2cdb5e4351d1908e">More...</a><br /></td></tr>
<tr class="separator:gaad3899ccbf8f4aec2cdb5e4351d1908e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3bdae288fd56d886b8d055699f02657"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa3bdae288fd56d886b8d055699f02657"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#gaa3bdae288fd56d886b8d055699f02657">operator!=</a> (const <a class="el" href="../../d2/d20/classblaze_1_1SharedValue.html">SharedValue</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../d2/d20/classblaze_1_1SharedValue.html">SharedValue</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa3bdae288fd56d886b8d055699f02657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../d2/d20/classblaze_1_1SharedValue.html" title="Value shared among several positions within a symmetric matrix.The SharedValue class template represe...">SharedValue</a> objects.  <a href="../../dc/d25/group__symmetric__matrix.html#gaa3bdae288fd56d886b8d055699f02657">More...</a><br /></td></tr>
<tr class="separator:gaa3bdae288fd56d886b8d055699f02657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SharedValue global functions</div></td></tr>
<tr class="memitem:ga584a5df4f24081f51c6073fb54b85f26"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga584a5df4f24081f51c6073fb54b85f26"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga584a5df4f24081f51c6073fb54b85f26">isDefault</a> (const <a class="el" href="../../d2/d20/classblaze_1_1SharedValue.html">SharedValue</a>&lt; Type &gt; &amp;value)</td></tr>
<tr class="memdesc:ga584a5df4f24081f51c6073fb54b85f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the shared value is in default state.  <a href="../../dc/d25/group__symmetric__matrix.html#ga584a5df4f24081f51c6073fb54b85f26">More...</a><br /></td></tr>
<tr class="separator:ga584a5df4f24081f51c6073fb54b85f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SymmetricValue global functions</div></td></tr>
<tr class="memitem:ga95c0b3a1f5d5215719b376a375243ee2"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga95c0b3a1f5d5215719b376a375243ee2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga95c0b3a1f5d5215719b376a375243ee2">reset</a> (const <a class="el" href="../../d5/d85/classblaze_1_1SymmetricValue.html">SymmetricValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga95c0b3a1f5d5215719b376a375243ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the symmetric value to the default initial values.  <a href="../../dc/d25/group__symmetric__matrix.html#ga95c0b3a1f5d5215719b376a375243ee2">More...</a><br /></td></tr>
<tr class="separator:ga95c0b3a1f5d5215719b376a375243ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363c9c0a0806b9345816fe1b5fbe5b71"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga363c9c0a0806b9345816fe1b5fbe5b71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga363c9c0a0806b9345816fe1b5fbe5b71">clear</a> (const <a class="el" href="../../d5/d85/classblaze_1_1SymmetricValue.html">SymmetricValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga363c9c0a0806b9345816fe1b5fbe5b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the symmetric value.  <a href="../../dc/d25/group__symmetric__matrix.html#ga363c9c0a0806b9345816fe1b5fbe5b71">More...</a><br /></td></tr>
<tr class="separator:ga363c9c0a0806b9345816fe1b5fbe5b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdfe5537fc0d75dfcddc054af784fdc6"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gafdfe5537fc0d75dfcddc054af784fdc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#gafdfe5537fc0d75dfcddc054af784fdc6">invert</a> (const <a class="el" href="../../d5/d85/classblaze_1_1SymmetricValue.html">SymmetricValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gafdfe5537fc0d75dfcddc054af784fdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the symmetric value.  <a href="../../dc/d25/group__symmetric__matrix.html#gafdfe5537fc0d75dfcddc054af784fdc6">More...</a><br /></td></tr>
<tr class="separator:gafdfe5537fc0d75dfcddc054af784fdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00f4c67459b4e03be6f6fc2c38c4d10e"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga00f4c67459b4e03be6f6fc2c38c4d10e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga00f4c67459b4e03be6f6fc2c38c4d10e">isDefault</a> (const <a class="el" href="../../d5/d85/classblaze_1_1SymmetricValue.html">SymmetricValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga00f4c67459b4e03be6f6fc2c38c4d10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the symmetric value is in default state.  <a href="../../dc/d25/group__symmetric__matrix.html#ga00f4c67459b4e03be6f6fc2c38c4d10e">More...</a><br /></td></tr>
<tr class="separator:ga00f4c67459b4e03be6f6fc2c38c4d10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94babcd74b8a1099fb880a03f78f2d99"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga94babcd74b8a1099fb880a03f78f2d99"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga94babcd74b8a1099fb880a03f78f2d99">isReal</a> (const <a class="el" href="../../d5/d85/classblaze_1_1SymmetricValue.html">SymmetricValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga94babcd74b8a1099fb880a03f78f2d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the symmetric value represents a real number.  <a href="../../dc/d25/group__symmetric__matrix.html#ga94babcd74b8a1099fb880a03f78f2d99">More...</a><br /></td></tr>
<tr class="separator:ga94babcd74b8a1099fb880a03f78f2d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80ebd490deffdf0177f96dd5236f2e58"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga80ebd490deffdf0177f96dd5236f2e58"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga80ebd490deffdf0177f96dd5236f2e58">isZero</a> (const <a class="el" href="../../d5/d85/classblaze_1_1SymmetricValue.html">SymmetricValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga80ebd490deffdf0177f96dd5236f2e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the symmetric value is 0.  <a href="../../dc/d25/group__symmetric__matrix.html#ga80ebd490deffdf0177f96dd5236f2e58">More...</a><br /></td></tr>
<tr class="separator:ga80ebd490deffdf0177f96dd5236f2e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3707c3725d304bd35c4dbf0cda7311ed"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga3707c3725d304bd35c4dbf0cda7311ed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga3707c3725d304bd35c4dbf0cda7311ed">isOne</a> (const <a class="el" href="../../d5/d85/classblaze_1_1SymmetricValue.html">SymmetricValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga3707c3725d304bd35c4dbf0cda7311ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the symmetric value is 1.  <a href="../../dc/d25/group__symmetric__matrix.html#ga3707c3725d304bd35c4dbf0cda7311ed">More...</a><br /></td></tr>
<tr class="separator:ga3707c3725d304bd35c4dbf0cda7311ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbbbb0a84d9c2fe4baad9fe3731e3d37"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gafbbbb0a84d9c2fe4baad9fe3731e3d37"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#gafbbbb0a84d9c2fe4baad9fe3731e3d37">isnan</a> (const <a class="el" href="../../d5/d85/classblaze_1_1SymmetricValue.html">SymmetricValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gafbbbb0a84d9c2fe4baad9fe3731e3d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the symmetric value is not a number.  <a href="../../dc/d25/group__symmetric__matrix.html#gafbbbb0a84d9c2fe4baad9fe3731e3d37">More...</a><br /></td></tr>
<tr class="separator:gafbbbb0a84d9c2fe4baad9fe3731e3d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SymmetricMatrix operators</div></td></tr>
<tr class="memitem:ga3546cfedb99697c89317ffe0d3fba3b0"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool NF&gt; </td></tr>
<tr class="memitem:ga3546cfedb99697c89317ffe0d3fba3b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga3546cfedb99697c89317ffe0d3fba3b0">reset</a> (<a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">SymmetricMatrix</a>&lt; MT, SO, DF, NF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga3546cfedb99697c89317ffe0d3fba3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given symmetric matrix.  <a href="../../dc/d25/group__symmetric__matrix.html#ga3546cfedb99697c89317ffe0d3fba3b0">More...</a><br /></td></tr>
<tr class="separator:ga3546cfedb99697c89317ffe0d3fba3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e4405bafe2b0fb09a89f243ea0cbdc"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool NF&gt; </td></tr>
<tr class="memitem:gad1e4405bafe2b0fb09a89f243ea0cbdc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#gad1e4405bafe2b0fb09a89f243ea0cbdc">reset</a> (<a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">SymmetricMatrix</a>&lt; MT, SO, DF, NF &gt; &amp;m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gad1e4405bafe2b0fb09a89f243ea0cbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the specified row/column of the given symmetric matrix.  <a href="../../dc/d25/group__symmetric__matrix.html#gad1e4405bafe2b0fb09a89f243ea0cbdc">More...</a><br /></td></tr>
<tr class="separator:gad1e4405bafe2b0fb09a89f243ea0cbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bbb6ae30e72a41abe7b5858837336b6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool NF&gt; </td></tr>
<tr class="memitem:ga8bbb6ae30e72a41abe7b5858837336b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga8bbb6ae30e72a41abe7b5858837336b6">clear</a> (<a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">SymmetricMatrix</a>&lt; MT, SO, DF, NF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga8bbb6ae30e72a41abe7b5858837336b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given symmetric matrix.  <a href="../../dc/d25/group__symmetric__matrix.html#ga8bbb6ae30e72a41abe7b5858837336b6">More...</a><br /></td></tr>
<tr class="separator:ga8bbb6ae30e72a41abe7b5858837336b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5431a54612a2042db461476a59dd4584"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool NF&gt; </td></tr>
<tr class="memitem:ga5431a54612a2042db461476a59dd4584"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga5431a54612a2042db461476a59dd4584">isDefault</a> (const <a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">SymmetricMatrix</a>&lt; MT, SO, DF, NF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga5431a54612a2042db461476a59dd4584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given symmetric matrix is in default state.  <a href="../../dc/d25/group__symmetric__matrix.html#ga5431a54612a2042db461476a59dd4584">More...</a><br /></td></tr>
<tr class="separator:ga5431a54612a2042db461476a59dd4584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92a8c169a0d8453f90cf8df3cd25a027"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool NF&gt; </td></tr>
<tr class="memitem:ga92a8c169a0d8453f90cf8df3cd25a027"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#ga92a8c169a0d8453f90cf8df3cd25a027">isIntact</a> (const <a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">SymmetricMatrix</a>&lt; MT, SO, DF, NF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga92a8c169a0d8453f90cf8df3cd25a027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given symmetric matrix are intact.  <a href="../../dc/d25/group__symmetric__matrix.html#ga92a8c169a0d8453f90cf8df3cd25a027">More...</a><br /></td></tr>
<tr class="separator:ga92a8c169a0d8453f90cf8df3cd25a027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab69bc56fa33198fc912f2c8d98a4c863"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool NF&gt; </td></tr>
<tr class="memitem:gab69bc56fa33198fc912f2c8d98a4c863"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d25/group__symmetric__matrix.html#gab69bc56fa33198fc912f2c8d98a4c863">swap</a> (<a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">SymmetricMatrix</a>&lt; MT, SO, DF, NF &gt; &amp;a, <a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">SymmetricMatrix</a>&lt; MT, SO, DF, NF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gab69bc56fa33198fc912f2c8d98a4c863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two matrices.  <a href="../../dc/d25/group__symmetric__matrix.html#gab69bc56fa33198fc912f2c8d98a4c863">More...</a><br /></td></tr>
<tr class="separator:gab69bc56fa33198fc912f2c8d98a4c863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">UniLowerProxy global functions</div></td></tr>
<tr class="memitem:gad144e2c2327fd60ac0e662939589fc17"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gad144e2c2327fd60ac0e662939589fc17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#gad144e2c2327fd60ac0e662939589fc17">reset</a> (const <a class="el" href="../../da/d0e/classblaze_1_1UniLowerProxy.html">UniLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad144e2c2327fd60ac0e662939589fc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../d5/d9b/group__unilower__matrix.html#gad144e2c2327fd60ac0e662939589fc17">More...</a><br /></td></tr>
<tr class="separator:gad144e2c2327fd60ac0e662939589fc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d2dd793167b0c05d29208e5cf4ab5d"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga31d2dd793167b0c05d29208e5cf4ab5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#ga31d2dd793167b0c05d29208e5cf4ab5d">clear</a> (const <a class="el" href="../../da/d0e/classblaze_1_1UniLowerProxy.html">UniLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga31d2dd793167b0c05d29208e5cf4ab5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../d5/d9b/group__unilower__matrix.html#ga31d2dd793167b0c05d29208e5cf4ab5d">More...</a><br /></td></tr>
<tr class="separator:ga31d2dd793167b0c05d29208e5cf4ab5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17c30c1a5a74977345368b2fdb2904fe"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga17c30c1a5a74977345368b2fdb2904fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#ga17c30c1a5a74977345368b2fdb2904fe">invert</a> (const <a class="el" href="../../da/d0e/classblaze_1_1UniLowerProxy.html">UniLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga17c30c1a5a74977345368b2fdb2904fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the represented element.  <a href="../../d5/d9b/group__unilower__matrix.html#ga17c30c1a5a74977345368b2fdb2904fe">More...</a><br /></td></tr>
<tr class="separator:ga17c30c1a5a74977345368b2fdb2904fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e46d91dccceb888030347179d2db16"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga16e46d91dccceb888030347179d2db16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#ga16e46d91dccceb888030347179d2db16">isDefault</a> (const <a class="el" href="../../da/d0e/classblaze_1_1UniLowerProxy.html">UniLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga16e46d91dccceb888030347179d2db16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../d5/d9b/group__unilower__matrix.html#ga16e46d91dccceb888030347179d2db16">More...</a><br /></td></tr>
<tr class="separator:ga16e46d91dccceb888030347179d2db16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac719afb798e9abf46f140e278a8c424b"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gac719afb798e9abf46f140e278a8c424b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#gac719afb798e9abf46f140e278a8c424b">isReal</a> (const <a class="el" href="../../da/d0e/classblaze_1_1UniLowerProxy.html">UniLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gac719afb798e9abf46f140e278a8c424b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix element represents a real number.  <a href="../../d5/d9b/group__unilower__matrix.html#gac719afb798e9abf46f140e278a8c424b">More...</a><br /></td></tr>
<tr class="separator:gac719afb798e9abf46f140e278a8c424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c41bb11649e60fbbc5c4209a65e80a1"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga7c41bb11649e60fbbc5c4209a65e80a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#ga7c41bb11649e60fbbc5c4209a65e80a1">isZero</a> (const <a class="el" href="../../da/d0e/classblaze_1_1UniLowerProxy.html">UniLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga7c41bb11649e60fbbc5c4209a65e80a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../d5/d9b/group__unilower__matrix.html#ga7c41bb11649e60fbbc5c4209a65e80a1">More...</a><br /></td></tr>
<tr class="separator:ga7c41bb11649e60fbbc5c4209a65e80a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f8a5e68b1fda81110291b2da2d5843a"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga2f8a5e68b1fda81110291b2da2d5843a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#ga2f8a5e68b1fda81110291b2da2d5843a">isOne</a> (const <a class="el" href="../../da/d0e/classblaze_1_1UniLowerProxy.html">UniLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga2f8a5e68b1fda81110291b2da2d5843a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../d5/d9b/group__unilower__matrix.html#ga2f8a5e68b1fda81110291b2da2d5843a">More...</a><br /></td></tr>
<tr class="separator:ga2f8a5e68b1fda81110291b2da2d5843a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4460af68a2298b85c012bfa96cf62438"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga4460af68a2298b85c012bfa96cf62438"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#ga4460af68a2298b85c012bfa96cf62438">isnan</a> (const <a class="el" href="../../da/d0e/classblaze_1_1UniLowerProxy.html">UniLowerProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga4460af68a2298b85c012bfa96cf62438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../d5/d9b/group__unilower__matrix.html#ga4460af68a2298b85c012bfa96cf62438">More...</a><br /></td></tr>
<tr class="separator:ga4460af68a2298b85c012bfa96cf62438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">UniLowerValue global functions</div></td></tr>
<tr class="memitem:gada96a34ddb673b8d5b517f64e6b96f3a"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gada96a34ddb673b8d5b517f64e6b96f3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#gada96a34ddb673b8d5b517f64e6b96f3a">reset</a> (const <a class="el" href="../../d0/dc7/classblaze_1_1UniLowerValue.html">UniLowerValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gada96a34ddb673b8d5b517f64e6b96f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the unilower value to the default initial values.  <a href="../../d5/d9b/group__unilower__matrix.html#gada96a34ddb673b8d5b517f64e6b96f3a">More...</a><br /></td></tr>
<tr class="separator:gada96a34ddb673b8d5b517f64e6b96f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece14db0f8937e450ce1c74125040b12"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaece14db0f8937e450ce1c74125040b12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#gaece14db0f8937e450ce1c74125040b12">clear</a> (const <a class="el" href="../../d0/dc7/classblaze_1_1UniLowerValue.html">UniLowerValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gaece14db0f8937e450ce1c74125040b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the unilower value.  <a href="../../d5/d9b/group__unilower__matrix.html#gaece14db0f8937e450ce1c74125040b12">More...</a><br /></td></tr>
<tr class="separator:gaece14db0f8937e450ce1c74125040b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebc976ad0e94f6d208a4d603bc11adba"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaebc976ad0e94f6d208a4d603bc11adba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#gaebc976ad0e94f6d208a4d603bc11adba">invert</a> (const <a class="el" href="../../d0/dc7/classblaze_1_1UniLowerValue.html">UniLowerValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gaebc976ad0e94f6d208a4d603bc11adba"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the unilower value.  <a href="../../d5/d9b/group__unilower__matrix.html#gaebc976ad0e94f6d208a4d603bc11adba">More...</a><br /></td></tr>
<tr class="separator:gaebc976ad0e94f6d208a4d603bc11adba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8b9187d1f7e17fd9aa384187fdcbb3"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga2c8b9187d1f7e17fd9aa384187fdcbb3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#ga2c8b9187d1f7e17fd9aa384187fdcbb3">isDefault</a> (const <a class="el" href="../../d0/dc7/classblaze_1_1UniLowerValue.html">UniLowerValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga2c8b9187d1f7e17fd9aa384187fdcbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the unilower value is in default state.  <a href="../../d5/d9b/group__unilower__matrix.html#ga2c8b9187d1f7e17fd9aa384187fdcbb3">More...</a><br /></td></tr>
<tr class="separator:ga2c8b9187d1f7e17fd9aa384187fdcbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad209b1e180e559e024387ad8209a71ee"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gad209b1e180e559e024387ad8209a71ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#gad209b1e180e559e024387ad8209a71ee">isReal</a> (const <a class="el" href="../../d0/dc7/classblaze_1_1UniLowerValue.html">UniLowerValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gad209b1e180e559e024387ad8209a71ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the unilower value represents a real number.  <a href="../../d5/d9b/group__unilower__matrix.html#gad209b1e180e559e024387ad8209a71ee">More...</a><br /></td></tr>
<tr class="separator:gad209b1e180e559e024387ad8209a71ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0bcc49ac3fe15e896ff123a810a70d"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gafd0bcc49ac3fe15e896ff123a810a70d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#gafd0bcc49ac3fe15e896ff123a810a70d">isZero</a> (const <a class="el" href="../../d0/dc7/classblaze_1_1UniLowerValue.html">UniLowerValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gafd0bcc49ac3fe15e896ff123a810a70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the unilower value is 0.  <a href="../../d5/d9b/group__unilower__matrix.html#gafd0bcc49ac3fe15e896ff123a810a70d">More...</a><br /></td></tr>
<tr class="separator:gafd0bcc49ac3fe15e896ff123a810a70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2022dff7f8bb94622c462ffba12f358"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gab2022dff7f8bb94622c462ffba12f358"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#gab2022dff7f8bb94622c462ffba12f358">isOne</a> (const <a class="el" href="../../d0/dc7/classblaze_1_1UniLowerValue.html">UniLowerValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gab2022dff7f8bb94622c462ffba12f358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the unilower value is 1.  <a href="../../d5/d9b/group__unilower__matrix.html#gab2022dff7f8bb94622c462ffba12f358">More...</a><br /></td></tr>
<tr class="separator:gab2022dff7f8bb94622c462ffba12f358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c574d26a095945f344071515702883f"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga4c574d26a095945f344071515702883f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#ga4c574d26a095945f344071515702883f">isnan</a> (const <a class="el" href="../../d0/dc7/classblaze_1_1UniLowerValue.html">UniLowerValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga4c574d26a095945f344071515702883f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the unilower value is not a number.  <a href="../../d5/d9b/group__unilower__matrix.html#ga4c574d26a095945f344071515702883f">More...</a><br /></td></tr>
<tr class="separator:ga4c574d26a095945f344071515702883f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">UniLowerMatrix operators</div></td></tr>
<tr class="memitem:ga9f311062f16b3940cf1a8632076a93c7"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga9f311062f16b3940cf1a8632076a93c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#ga9f311062f16b3940cf1a8632076a93c7">reset</a> (<a class="el" href="../../d2/d62/classblaze_1_1UniLowerMatrix.html">UniLowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga9f311062f16b3940cf1a8632076a93c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given unilower matrix.  <a href="../../d5/d9b/group__unilower__matrix.html#ga9f311062f16b3940cf1a8632076a93c7">More...</a><br /></td></tr>
<tr class="separator:ga9f311062f16b3940cf1a8632076a93c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11ad5bc68dc9b60fdfd058ef9f4d8ae1"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga11ad5bc68dc9b60fdfd058ef9f4d8ae1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#ga11ad5bc68dc9b60fdfd058ef9f4d8ae1">reset</a> (<a class="el" href="../../d2/d62/classblaze_1_1UniLowerMatrix.html">UniLowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga11ad5bc68dc9b60fdfd058ef9f4d8ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the specified row/column of the given unilower matrix.  <a href="../../d5/d9b/group__unilower__matrix.html#ga11ad5bc68dc9b60fdfd058ef9f4d8ae1">More...</a><br /></td></tr>
<tr class="separator:ga11ad5bc68dc9b60fdfd058ef9f4d8ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga699eda0b6ae9c01492a9f5146e7f15db"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga699eda0b6ae9c01492a9f5146e7f15db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#ga699eda0b6ae9c01492a9f5146e7f15db">clear</a> (<a class="el" href="../../d2/d62/classblaze_1_1UniLowerMatrix.html">UniLowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga699eda0b6ae9c01492a9f5146e7f15db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given unilower matrix.  <a href="../../d5/d9b/group__unilower__matrix.html#ga699eda0b6ae9c01492a9f5146e7f15db">More...</a><br /></td></tr>
<tr class="separator:ga699eda0b6ae9c01492a9f5146e7f15db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1ff3675cc5c8054d0271a0b205ccab6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gab1ff3675cc5c8054d0271a0b205ccab6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#gab1ff3675cc5c8054d0271a0b205ccab6">isDefault</a> (const <a class="el" href="../../d2/d62/classblaze_1_1UniLowerMatrix.html">UniLowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:gab1ff3675cc5c8054d0271a0b205ccab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given unilower matrix is in default state.  <a href="../../d5/d9b/group__unilower__matrix.html#gab1ff3675cc5c8054d0271a0b205ccab6">More...</a><br /></td></tr>
<tr class="separator:gab1ff3675cc5c8054d0271a0b205ccab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad83e21dd8f9857cdb0bc7bd01333be07"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gad83e21dd8f9857cdb0bc7bd01333be07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#gad83e21dd8f9857cdb0bc7bd01333be07">isIntact</a> (const <a class="el" href="../../d2/d62/classblaze_1_1UniLowerMatrix.html">UniLowerMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:gad83e21dd8f9857cdb0bc7bd01333be07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given unilower matrix are intact.  <a href="../../d5/d9b/group__unilower__matrix.html#gad83e21dd8f9857cdb0bc7bd01333be07">More...</a><br /></td></tr>
<tr class="separator:gad83e21dd8f9857cdb0bc7bd01333be07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga816344f3f978d1e9f8c590837d40065b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga816344f3f978d1e9f8c590837d40065b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9b/group__unilower__matrix.html#ga816344f3f978d1e9f8c590837d40065b">swap</a> (<a class="el" href="../../d2/d62/classblaze_1_1UniLowerMatrix.html">UniLowerMatrix</a>&lt; MT, SO, DF &gt; &amp;a, <a class="el" href="../../d2/d62/classblaze_1_1UniLowerMatrix.html">UniLowerMatrix</a>&lt; MT, SO, DF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga816344f3f978d1e9f8c590837d40065b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two matrices.  <a href="../../d5/d9b/group__unilower__matrix.html#ga816344f3f978d1e9f8c590837d40065b">More...</a><br /></td></tr>
<tr class="separator:ga816344f3f978d1e9f8c590837d40065b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">UniUpperProxy global functions</div></td></tr>
<tr class="memitem:ga31af69b79713e7285314b9f66f5d3533"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga31af69b79713e7285314b9f66f5d3533"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga31af69b79713e7285314b9f66f5d3533">reset</a> (const <a class="el" href="../../d8/d98/classblaze_1_1UniUpperProxy.html">UniUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga31af69b79713e7285314b9f66f5d3533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../d3/d41/group__uniupper__matrix.html#ga31af69b79713e7285314b9f66f5d3533">More...</a><br /></td></tr>
<tr class="separator:ga31af69b79713e7285314b9f66f5d3533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f3e65fffcf8ddca9a930ee609dd5469"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga8f3e65fffcf8ddca9a930ee609dd5469"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga8f3e65fffcf8ddca9a930ee609dd5469">clear</a> (const <a class="el" href="../../d8/d98/classblaze_1_1UniUpperProxy.html">UniUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga8f3e65fffcf8ddca9a930ee609dd5469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../d3/d41/group__uniupper__matrix.html#ga8f3e65fffcf8ddca9a930ee609dd5469">More...</a><br /></td></tr>
<tr class="separator:ga8f3e65fffcf8ddca9a930ee609dd5469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga892ba6f353fd68534bbd63ce89430d4c"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga892ba6f353fd68534bbd63ce89430d4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga892ba6f353fd68534bbd63ce89430d4c">invert</a> (const <a class="el" href="../../d8/d98/classblaze_1_1UniUpperProxy.html">UniUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga892ba6f353fd68534bbd63ce89430d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the represented element.  <a href="../../d3/d41/group__uniupper__matrix.html#ga892ba6f353fd68534bbd63ce89430d4c">More...</a><br /></td></tr>
<tr class="separator:ga892ba6f353fd68534bbd63ce89430d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b110d1dfd4d8a7a7728020a1124aa69"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga6b110d1dfd4d8a7a7728020a1124aa69"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga6b110d1dfd4d8a7a7728020a1124aa69">isDefault</a> (const <a class="el" href="../../d8/d98/classblaze_1_1UniUpperProxy.html">UniUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga6b110d1dfd4d8a7a7728020a1124aa69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../d3/d41/group__uniupper__matrix.html#ga6b110d1dfd4d8a7a7728020a1124aa69">More...</a><br /></td></tr>
<tr class="separator:ga6b110d1dfd4d8a7a7728020a1124aa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22bafc5e884ba35b80f0bc311326fa70"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga22bafc5e884ba35b80f0bc311326fa70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga22bafc5e884ba35b80f0bc311326fa70">isReal</a> (const <a class="el" href="../../d8/d98/classblaze_1_1UniUpperProxy.html">UniUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga22bafc5e884ba35b80f0bc311326fa70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix element represents a real number.  <a href="../../d3/d41/group__uniupper__matrix.html#ga22bafc5e884ba35b80f0bc311326fa70">More...</a><br /></td></tr>
<tr class="separator:ga22bafc5e884ba35b80f0bc311326fa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17dacabe8bc9ef714f8306d1a5f034cc"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga17dacabe8bc9ef714f8306d1a5f034cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga17dacabe8bc9ef714f8306d1a5f034cc">isZero</a> (const <a class="el" href="../../d8/d98/classblaze_1_1UniUpperProxy.html">UniUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga17dacabe8bc9ef714f8306d1a5f034cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../d3/d41/group__uniupper__matrix.html#ga17dacabe8bc9ef714f8306d1a5f034cc">More...</a><br /></td></tr>
<tr class="separator:ga17dacabe8bc9ef714f8306d1a5f034cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38a489d720d42ed60b12f4c4c8f20f11"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga38a489d720d42ed60b12f4c4c8f20f11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga38a489d720d42ed60b12f4c4c8f20f11">isOne</a> (const <a class="el" href="../../d8/d98/classblaze_1_1UniUpperProxy.html">UniUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga38a489d720d42ed60b12f4c4c8f20f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../d3/d41/group__uniupper__matrix.html#ga38a489d720d42ed60b12f4c4c8f20f11">More...</a><br /></td></tr>
<tr class="separator:ga38a489d720d42ed60b12f4c4c8f20f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c2adc623b1bb0e9495b8c3eafda542"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gae3c2adc623b1bb0e9495b8c3eafda542"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#gae3c2adc623b1bb0e9495b8c3eafda542">isnan</a> (const <a class="el" href="../../d8/d98/classblaze_1_1UniUpperProxy.html">UniUpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gae3c2adc623b1bb0e9495b8c3eafda542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../d3/d41/group__uniupper__matrix.html#gae3c2adc623b1bb0e9495b8c3eafda542">More...</a><br /></td></tr>
<tr class="separator:gae3c2adc623b1bb0e9495b8c3eafda542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">UniUpperValue global functions</div></td></tr>
<tr class="memitem:gad0d90123bd33094aff51c3af049a25d4"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gad0d90123bd33094aff51c3af049a25d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#gad0d90123bd33094aff51c3af049a25d4">reset</a> (const <a class="el" href="../../dc/d7c/classblaze_1_1UniUpperValue.html">UniUpperValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gad0d90123bd33094aff51c3af049a25d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the uniupper value to the default initial values.  <a href="../../d3/d41/group__uniupper__matrix.html#gad0d90123bd33094aff51c3af049a25d4">More...</a><br /></td></tr>
<tr class="separator:gad0d90123bd33094aff51c3af049a25d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa2fdd8e856cd07c5955545fcc0c2001"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaaa2fdd8e856cd07c5955545fcc0c2001"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#gaaa2fdd8e856cd07c5955545fcc0c2001">clear</a> (const <a class="el" href="../../dc/d7c/classblaze_1_1UniUpperValue.html">UniUpperValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gaaa2fdd8e856cd07c5955545fcc0c2001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the uniupper value.  <a href="../../d3/d41/group__uniupper__matrix.html#gaaa2fdd8e856cd07c5955545fcc0c2001">More...</a><br /></td></tr>
<tr class="separator:gaaa2fdd8e856cd07c5955545fcc0c2001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7720f1b379a3578eed616ee3d1b1cb8"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gac7720f1b379a3578eed616ee3d1b1cb8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#gac7720f1b379a3578eed616ee3d1b1cb8">invert</a> (const <a class="el" href="../../dc/d7c/classblaze_1_1UniUpperValue.html">UniUpperValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gac7720f1b379a3578eed616ee3d1b1cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the uniupper value.  <a href="../../d3/d41/group__uniupper__matrix.html#gac7720f1b379a3578eed616ee3d1b1cb8">More...</a><br /></td></tr>
<tr class="separator:gac7720f1b379a3578eed616ee3d1b1cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93ec6d04a330595f79bc26cb9ccda6bb"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga93ec6d04a330595f79bc26cb9ccda6bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga93ec6d04a330595f79bc26cb9ccda6bb">isDefault</a> (const <a class="el" href="../../dc/d7c/classblaze_1_1UniUpperValue.html">UniUpperValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga93ec6d04a330595f79bc26cb9ccda6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the uniupper value is in default state.  <a href="../../d3/d41/group__uniupper__matrix.html#ga93ec6d04a330595f79bc26cb9ccda6bb">More...</a><br /></td></tr>
<tr class="separator:ga93ec6d04a330595f79bc26cb9ccda6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecea4fb528be1680d9434a3654c6ff11"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaecea4fb528be1680d9434a3654c6ff11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#gaecea4fb528be1680d9434a3654c6ff11">isReal</a> (const <a class="el" href="../../dc/d7c/classblaze_1_1UniUpperValue.html">UniUpperValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:gaecea4fb528be1680d9434a3654c6ff11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the uniupper value represents a real number.  <a href="../../d3/d41/group__uniupper__matrix.html#gaecea4fb528be1680d9434a3654c6ff11">More...</a><br /></td></tr>
<tr class="separator:gaecea4fb528be1680d9434a3654c6ff11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga383572443add892d8b203a61df8416ba"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga383572443add892d8b203a61df8416ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga383572443add892d8b203a61df8416ba">isZero</a> (const <a class="el" href="../../dc/d7c/classblaze_1_1UniUpperValue.html">UniUpperValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga383572443add892d8b203a61df8416ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the uniupper value is 0.  <a href="../../d3/d41/group__uniupper__matrix.html#ga383572443add892d8b203a61df8416ba">More...</a><br /></td></tr>
<tr class="separator:ga383572443add892d8b203a61df8416ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0faf15fbca64cbb2712aeeec00e3bc"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga4c0faf15fbca64cbb2712aeeec00e3bc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga4c0faf15fbca64cbb2712aeeec00e3bc">isOne</a> (const <a class="el" href="../../dc/d7c/classblaze_1_1UniUpperValue.html">UniUpperValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga4c0faf15fbca64cbb2712aeeec00e3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the uniupper value is 1.  <a href="../../d3/d41/group__uniupper__matrix.html#ga4c0faf15fbca64cbb2712aeeec00e3bc">More...</a><br /></td></tr>
<tr class="separator:ga4c0faf15fbca64cbb2712aeeec00e3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481d5d0ff7fe9654b48a4ba9724f9a2c"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga481d5d0ff7fe9654b48a4ba9724f9a2c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga481d5d0ff7fe9654b48a4ba9724f9a2c">isnan</a> (const <a class="el" href="../../dc/d7c/classblaze_1_1UniUpperValue.html">UniUpperValue</a>&lt; MT &gt; &amp;value)</td></tr>
<tr class="memdesc:ga481d5d0ff7fe9654b48a4ba9724f9a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the uniupper value is not a number.  <a href="../../d3/d41/group__uniupper__matrix.html#ga481d5d0ff7fe9654b48a4ba9724f9a2c">More...</a><br /></td></tr>
<tr class="separator:ga481d5d0ff7fe9654b48a4ba9724f9a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">UniUpperMatrix operators</div></td></tr>
<tr class="memitem:ga740a03dc3f965c0b2ad4df3ea90897ec"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga740a03dc3f965c0b2ad4df3ea90897ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga740a03dc3f965c0b2ad4df3ea90897ec">reset</a> (<a class="el" href="../../db/d0d/classblaze_1_1UniUpperMatrix.html">UniUpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga740a03dc3f965c0b2ad4df3ea90897ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given uniupper matrix.  <a href="../../d3/d41/group__uniupper__matrix.html#ga740a03dc3f965c0b2ad4df3ea90897ec">More...</a><br /></td></tr>
<tr class="separator:ga740a03dc3f965c0b2ad4df3ea90897ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78ba8f5120e6da9c1aa4ed8513964fa5"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga78ba8f5120e6da9c1aa4ed8513964fa5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga78ba8f5120e6da9c1aa4ed8513964fa5">reset</a> (<a class="el" href="../../db/d0d/classblaze_1_1UniUpperMatrix.html">UniUpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga78ba8f5120e6da9c1aa4ed8513964fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the specified row/column of the given uniupper matrix.  <a href="../../d3/d41/group__uniupper__matrix.html#ga78ba8f5120e6da9c1aa4ed8513964fa5">More...</a><br /></td></tr>
<tr class="separator:ga78ba8f5120e6da9c1aa4ed8513964fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9440318c79b0a66c776e86de05b321b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gae9440318c79b0a66c776e86de05b321b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#gae9440318c79b0a66c776e86de05b321b">clear</a> (<a class="el" href="../../db/d0d/classblaze_1_1UniUpperMatrix.html">UniUpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:gae9440318c79b0a66c776e86de05b321b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given uniupper matrix.  <a href="../../d3/d41/group__uniupper__matrix.html#gae9440318c79b0a66c776e86de05b321b">More...</a><br /></td></tr>
<tr class="separator:gae9440318c79b0a66c776e86de05b321b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c6fb526a9a0a574f7cd099c99934d8c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga8c6fb526a9a0a574f7cd099c99934d8c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga8c6fb526a9a0a574f7cd099c99934d8c">isDefault</a> (const <a class="el" href="../../db/d0d/classblaze_1_1UniUpperMatrix.html">UniUpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga8c6fb526a9a0a574f7cd099c99934d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given uniupper matrix is in default state.  <a href="../../d3/d41/group__uniupper__matrix.html#ga8c6fb526a9a0a574f7cd099c99934d8c">More...</a><br /></td></tr>
<tr class="separator:ga8c6fb526a9a0a574f7cd099c99934d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a283cf58b47caa3556a3b3aae471989"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga8a283cf58b47caa3556a3b3aae471989"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#ga8a283cf58b47caa3556a3b3aae471989">isIntact</a> (const <a class="el" href="../../db/d0d/classblaze_1_1UniUpperMatrix.html">UniUpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga8a283cf58b47caa3556a3b3aae471989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given uniupper matrix are intact.  <a href="../../d3/d41/group__uniupper__matrix.html#ga8a283cf58b47caa3556a3b3aae471989">More...</a><br /></td></tr>
<tr class="separator:ga8a283cf58b47caa3556a3b3aae471989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab70934c5c686b0b0d96ba3c29d49c6c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gaab70934c5c686b0b0d96ba3c29d49c6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d41/group__uniupper__matrix.html#gaab70934c5c686b0b0d96ba3c29d49c6c">swap</a> (<a class="el" href="../../db/d0d/classblaze_1_1UniUpperMatrix.html">UniUpperMatrix</a>&lt; MT, SO, DF &gt; &amp;a, <a class="el" href="../../db/d0d/classblaze_1_1UniUpperMatrix.html">UniUpperMatrix</a>&lt; MT, SO, DF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gaab70934c5c686b0b0d96ba3c29d49c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two matrices.  <a href="../../d3/d41/group__uniupper__matrix.html#gaab70934c5c686b0b0d96ba3c29d49c6c">More...</a><br /></td></tr>
<tr class="separator:gaab70934c5c686b0b0d96ba3c29d49c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">UpperProxy global functions</div></td></tr>
<tr class="memitem:ga11d178d1f4e73012b434b34585a5f57f"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga11d178d1f4e73012b434b34585a5f57f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d2e/group__upper__matrix.html#ga11d178d1f4e73012b434b34585a5f57f">reset</a> (const <a class="el" href="../../d7/dee/classblaze_1_1UpperProxy.html">UpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga11d178d1f4e73012b434b34585a5f57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../d3/d2e/group__upper__matrix.html#ga11d178d1f4e73012b434b34585a5f57f">More...</a><br /></td></tr>
<tr class="separator:ga11d178d1f4e73012b434b34585a5f57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4540390f7f610c61212fa631e1b182fb"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga4540390f7f610c61212fa631e1b182fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d2e/group__upper__matrix.html#ga4540390f7f610c61212fa631e1b182fb">clear</a> (const <a class="el" href="../../d7/dee/classblaze_1_1UpperProxy.html">UpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga4540390f7f610c61212fa631e1b182fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../d3/d2e/group__upper__matrix.html#ga4540390f7f610c61212fa631e1b182fb">More...</a><br /></td></tr>
<tr class="separator:ga4540390f7f610c61212fa631e1b182fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bc4d3cebecad72f54313359e8098199"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga7bc4d3cebecad72f54313359e8098199"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d2e/group__upper__matrix.html#ga7bc4d3cebecad72f54313359e8098199">isDefault</a> (const <a class="el" href="../../d7/dee/classblaze_1_1UpperProxy.html">UpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga7bc4d3cebecad72f54313359e8098199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../d3/d2e/group__upper__matrix.html#ga7bc4d3cebecad72f54313359e8098199">More...</a><br /></td></tr>
<tr class="separator:ga7bc4d3cebecad72f54313359e8098199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5af47a7c914b6c046503401f236c4c39"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga5af47a7c914b6c046503401f236c4c39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d2e/group__upper__matrix.html#ga5af47a7c914b6c046503401f236c4c39">isReal</a> (const <a class="el" href="../../d7/dee/classblaze_1_1UpperProxy.html">UpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga5af47a7c914b6c046503401f236c4c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix element represents a real number.  <a href="../../d3/d2e/group__upper__matrix.html#ga5af47a7c914b6c046503401f236c4c39">More...</a><br /></td></tr>
<tr class="separator:ga5af47a7c914b6c046503401f236c4c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40254a39b320cf56dc1c839e241e51fd"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga40254a39b320cf56dc1c839e241e51fd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d2e/group__upper__matrix.html#ga40254a39b320cf56dc1c839e241e51fd">isZero</a> (const <a class="el" href="../../d7/dee/classblaze_1_1UpperProxy.html">UpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga40254a39b320cf56dc1c839e241e51fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../d3/d2e/group__upper__matrix.html#ga40254a39b320cf56dc1c839e241e51fd">More...</a><br /></td></tr>
<tr class="separator:ga40254a39b320cf56dc1c839e241e51fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7090d9946a3d85fb59bfdd079b1e5e9b"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga7090d9946a3d85fb59bfdd079b1e5e9b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d2e/group__upper__matrix.html#ga7090d9946a3d85fb59bfdd079b1e5e9b">isOne</a> (const <a class="el" href="../../d7/dee/classblaze_1_1UpperProxy.html">UpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga7090d9946a3d85fb59bfdd079b1e5e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../d3/d2e/group__upper__matrix.html#ga7090d9946a3d85fb59bfdd079b1e5e9b">More...</a><br /></td></tr>
<tr class="separator:ga7090d9946a3d85fb59bfdd079b1e5e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21baf16a4eda67b9dbc38be022915890"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga21baf16a4eda67b9dbc38be022915890"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d2e/group__upper__matrix.html#ga21baf16a4eda67b9dbc38be022915890">isnan</a> (const <a class="el" href="../../d7/dee/classblaze_1_1UpperProxy.html">UpperProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga21baf16a4eda67b9dbc38be022915890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../d3/d2e/group__upper__matrix.html#ga21baf16a4eda67b9dbc38be022915890">More...</a><br /></td></tr>
<tr class="separator:ga21baf16a4eda67b9dbc38be022915890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">UpperMatrix operators</div></td></tr>
<tr class="memitem:gabc8ddf3771e2eb5b44a3c67f498b450e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gabc8ddf3771e2eb5b44a3c67f498b450e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d2e/group__upper__matrix.html#gabc8ddf3771e2eb5b44a3c67f498b450e">reset</a> (<a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html">UpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:gabc8ddf3771e2eb5b44a3c67f498b450e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given upper matrix.  <a href="../../d3/d2e/group__upper__matrix.html#gabc8ddf3771e2eb5b44a3c67f498b450e">More...</a><br /></td></tr>
<tr class="separator:gabc8ddf3771e2eb5b44a3c67f498b450e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae84acd50b9ff853baa16df04af86b68b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gae84acd50b9ff853baa16df04af86b68b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d2e/group__upper__matrix.html#gae84acd50b9ff853baa16df04af86b68b">reset</a> (<a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html">UpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gae84acd50b9ff853baa16df04af86b68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the specified row/column of the given upper matrix.  <a href="../../d3/d2e/group__upper__matrix.html#gae84acd50b9ff853baa16df04af86b68b">More...</a><br /></td></tr>
<tr class="separator:gae84acd50b9ff853baa16df04af86b68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e81bb2b66b3d0a7c45a7f7b5a2ddf6f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga6e81bb2b66b3d0a7c45a7f7b5a2ddf6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d2e/group__upper__matrix.html#ga6e81bb2b66b3d0a7c45a7f7b5a2ddf6f">clear</a> (<a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html">UpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga6e81bb2b66b3d0a7c45a7f7b5a2ddf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given upper matrix.  <a href="../../d3/d2e/group__upper__matrix.html#ga6e81bb2b66b3d0a7c45a7f7b5a2ddf6f">More...</a><br /></td></tr>
<tr class="separator:ga6e81bb2b66b3d0a7c45a7f7b5a2ddf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac149d92c0ce45ea9d7823627ab743d6f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gac149d92c0ce45ea9d7823627ab743d6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d2e/group__upper__matrix.html#gac149d92c0ce45ea9d7823627ab743d6f">isDefault</a> (const <a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html">UpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:gac149d92c0ce45ea9d7823627ab743d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given upper matrix is in default state.  <a href="../../d3/d2e/group__upper__matrix.html#gac149d92c0ce45ea9d7823627ab743d6f">More...</a><br /></td></tr>
<tr class="separator:gac149d92c0ce45ea9d7823627ab743d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b1747e8e6dde15606f912ed0bd2485a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga5b1747e8e6dde15606f912ed0bd2485a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d2e/group__upper__matrix.html#ga5b1747e8e6dde15606f912ed0bd2485a">isIntact</a> (const <a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html">UpperMatrix</a>&lt; MT, SO, DF &gt; &amp;m)</td></tr>
<tr class="memdesc:ga5b1747e8e6dde15606f912ed0bd2485a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given lower matrix are intact.  <a href="../../d3/d2e/group__upper__matrix.html#ga5b1747e8e6dde15606f912ed0bd2485a">More...</a><br /></td></tr>
<tr class="separator:ga5b1747e8e6dde15606f912ed0bd2485a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc0adae6a7fe49e4c97b1b9cae6a51f7"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gadc0adae6a7fe49e4c97b1b9cae6a51f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d2e/group__upper__matrix.html#gadc0adae6a7fe49e4c97b1b9cae6a51f7">swap</a> (<a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html">UpperMatrix</a>&lt; MT, SO, DF &gt; &amp;a, <a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html">UpperMatrix</a>&lt; MT, SO, DF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gadc0adae6a7fe49e4c97b1b9cae6a51f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two matrices.  <a href="../../d3/d2e/group__upper__matrix.html#gadc0adae6a7fe49e4c97b1b9cae6a51f7">More...</a><br /></td></tr>
<tr class="separator:gadc0adae6a7fe49e4c97b1b9cae6a51f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">CustomMatrix operators</div></td></tr>
<tr class="memitem:gaa00a05b183940d3aaebdcfe934aacad9"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF, bool PF, bool SO&gt; </td></tr>
<tr class="memitem:gaa00a05b183940d3aaebdcfe934aacad9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d77/group__custom__matrix.html#gaa00a05b183940d3aaebdcfe934aacad9">reset</a> (<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:gaa00a05b183940d3aaebdcfe934aacad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given custom matrix.  <a href="../../d2/d77/group__custom__matrix.html#gaa00a05b183940d3aaebdcfe934aacad9">More...</a><br /></td></tr>
<tr class="separator:gaa00a05b183940d3aaebdcfe934aacad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b2bcc69ff606f1a0a826b164db3648d"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF, bool PF, bool SO&gt; </td></tr>
<tr class="memitem:ga1b2bcc69ff606f1a0a826b164db3648d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d77/group__custom__matrix.html#ga1b2bcc69ff606f1a0a826b164db3648d">reset</a> (<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga1b2bcc69ff606f1a0a826b164db3648d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column of the given custom matrix.  <a href="../../d2/d77/group__custom__matrix.html#ga1b2bcc69ff606f1a0a826b164db3648d">More...</a><br /></td></tr>
<tr class="separator:ga1b2bcc69ff606f1a0a826b164db3648d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e451a1d504b1f732cd79d4dfe0a819b"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF, bool PF, bool SO&gt; </td></tr>
<tr class="memitem:ga8e451a1d504b1f732cd79d4dfe0a819b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d77/group__custom__matrix.html#ga8e451a1d504b1f732cd79d4dfe0a819b">clear</a> (<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga8e451a1d504b1f732cd79d4dfe0a819b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given custom matrix.  <a href="../../d2/d77/group__custom__matrix.html#ga8e451a1d504b1f732cd79d4dfe0a819b">More...</a><br /></td></tr>
<tr class="separator:ga8e451a1d504b1f732cd79d4dfe0a819b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8960c9ded3e0422f10fd474f84b294d9"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF, bool PF, bool SO&gt; </td></tr>
<tr class="memitem:ga8960c9ded3e0422f10fd474f84b294d9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d77/group__custom__matrix.html#ga8960c9ded3e0422f10fd474f84b294d9">isDefault</a> (const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga8960c9ded3e0422f10fd474f84b294d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given custom matrix is in default state.  <a href="../../d2/d77/group__custom__matrix.html#ga8960c9ded3e0422f10fd474f84b294d9">More...</a><br /></td></tr>
<tr class="separator:ga8960c9ded3e0422f10fd474f84b294d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e651e916d76004077daf3de294953ec"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF, bool PF, bool SO&gt; </td></tr>
<tr class="memitem:ga2e651e916d76004077daf3de294953ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d77/group__custom__matrix.html#ga2e651e916d76004077daf3de294953ec">isIntact</a> (const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga2e651e916d76004077daf3de294953ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given custom matrix are intact.  <a href="../../d2/d77/group__custom__matrix.html#ga2e651e916d76004077daf3de294953ec">More...</a><br /></td></tr>
<tr class="separator:ga2e651e916d76004077daf3de294953ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace862112869da879edc94489636ebb77"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF, bool PF, bool SO&gt; </td></tr>
<tr class="memitem:gace862112869da879edc94489636ebb77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d77/group__custom__matrix.html#gace862112869da879edc94489636ebb77">swap</a> (<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;a, <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gace862112869da879edc94489636ebb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two custom matrices.  <a href="../../d2/d77/group__custom__matrix.html#gace862112869da879edc94489636ebb77">More...</a><br /></td></tr>
<tr class="separator:gace862112869da879edc94489636ebb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">CustomVector operators</div></td></tr>
<tr class="memitem:gab8ca0c607c5f666dbe01b549b254e903"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF, bool PF, bool TF&gt; </td></tr>
<tr class="memitem:gab8ca0c607c5f666dbe01b549b254e903"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d32/group__custom__vector.html#gab8ca0c607c5f666dbe01b549b254e903">reset</a> (<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:gab8ca0c607c5f666dbe01b549b254e903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given custom vector.  <a href="../../d5/d32/group__custom__vector.html#gab8ca0c607c5f666dbe01b549b254e903">More...</a><br /></td></tr>
<tr class="separator:gab8ca0c607c5f666dbe01b549b254e903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0716be2df3a9598149678e85df735d5f"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF, bool PF, bool TF&gt; </td></tr>
<tr class="memitem:ga0716be2df3a9598149678e85df735d5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d32/group__custom__vector.html#ga0716be2df3a9598149678e85df735d5f">clear</a> (<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga0716be2df3a9598149678e85df735d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given custom vector.  <a href="../../d5/d32/group__custom__vector.html#ga0716be2df3a9598149678e85df735d5f">More...</a><br /></td></tr>
<tr class="separator:ga0716be2df3a9598149678e85df735d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga473b60f41c004a1a64a55f9dba956c97"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF, bool PF, bool TF&gt; </td></tr>
<tr class="memitem:ga473b60f41c004a1a64a55f9dba956c97"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d32/group__custom__vector.html#ga473b60f41c004a1a64a55f9dba956c97">isDefault</a> (const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga473b60f41c004a1a64a55f9dba956c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given custom vector is in default state.  <a href="../../d5/d32/group__custom__vector.html#ga473b60f41c004a1a64a55f9dba956c97">More...</a><br /></td></tr>
<tr class="separator:ga473b60f41c004a1a64a55f9dba956c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27d0551bdb00097d0b42673613847bc0"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF, bool PF, bool TF&gt; </td></tr>
<tr class="memitem:ga27d0551bdb00097d0b42673613847bc0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d32/group__custom__vector.html#ga27d0551bdb00097d0b42673613847bc0">isIntact</a> (const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga27d0551bdb00097d0b42673613847bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given custom vector are intact.  <a href="../../d5/d32/group__custom__vector.html#ga27d0551bdb00097d0b42673613847bc0">More...</a><br /></td></tr>
<tr class="separator:ga27d0551bdb00097d0b42673613847bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga111021a9302951fd40aed4e1d36deec7"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF, bool PF, bool TF&gt; </td></tr>
<tr class="memitem:ga111021a9302951fd40aed4e1d36deec7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d32/group__custom__vector.html#ga111021a9302951fd40aed4e1d36deec7">swap</a> (<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;a, <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga111021a9302951fd40aed4e1d36deec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two vectors.  <a href="../../d5/d32/group__custom__vector.html#ga111021a9302951fd40aed4e1d36deec7">More...</a><br /></td></tr>
<tr class="separator:ga111021a9302951fd40aed4e1d36deec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DenseIterator operators</div></td></tr>
<tr class="memitem:ae1c6af9cbb860721101fd603adb7c90b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool AF1, typename T2 , bool AF2&gt; </td></tr>
<tr class="memitem:ae1c6af9cbb860721101fd603adb7c90b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ae1c6af9cbb860721101fd603adb7c90b">operator==</a> (const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T1, AF1 &gt; &amp;lhs, const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T2, AF2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae1c6af9cbb860721101fd603adb7c90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> objects.  <a href="#ae1c6af9cbb860721101fd603adb7c90b">More...</a><br /></td></tr>
<tr class="separator:ae1c6af9cbb860721101fd603adb7c90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a3af293c57b38ce351c31dd3d34b6c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool AF1, typename T2 , bool AF2&gt; </td></tr>
<tr class="memitem:ab8a3af293c57b38ce351c31dd3d34b6c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ab8a3af293c57b38ce351c31dd3d34b6c">operator!=</a> (const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T1, AF1 &gt; &amp;lhs, const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T2, AF2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab8a3af293c57b38ce351c31dd3d34b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> objects.  <a href="#ab8a3af293c57b38ce351c31dd3d34b6c">More...</a><br /></td></tr>
<tr class="separator:ab8a3af293c57b38ce351c31dd3d34b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e054b943082e9dc5e339b0254f9800e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool AF1, typename T2 , bool AF2&gt; </td></tr>
<tr class="memitem:a8e054b943082e9dc5e339b0254f9800e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a8e054b943082e9dc5e339b0254f9800e">operator&lt;</a> (const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T1, AF1 &gt; &amp;lhs, const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T2, AF2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8e054b943082e9dc5e339b0254f9800e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between two <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> objects.  <a href="#a8e054b943082e9dc5e339b0254f9800e">More...</a><br /></td></tr>
<tr class="separator:a8e054b943082e9dc5e339b0254f9800e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d38aa4cd7b79617b957c33b7f50cdb4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool AF1, typename T2 , bool AF2&gt; </td></tr>
<tr class="memitem:a5d38aa4cd7b79617b957c33b7f50cdb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a5d38aa4cd7b79617b957c33b7f50cdb4">operator&gt;</a> (const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T1, AF1 &gt; &amp;lhs, const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T2, AF2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a5d38aa4cd7b79617b957c33b7f50cdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between two <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> objects.  <a href="#a5d38aa4cd7b79617b957c33b7f50cdb4">More...</a><br /></td></tr>
<tr class="separator:a5d38aa4cd7b79617b957c33b7f50cdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dc9a29df3b365fb40f34963519d791"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool AF1, typename T2 , bool AF2&gt; </td></tr>
<tr class="memitem:a32dc9a29df3b365fb40f34963519d791"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a32dc9a29df3b365fb40f34963519d791">operator&lt;=</a> (const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T1, AF1 &gt; &amp;lhs, const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T2, AF2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a32dc9a29df3b365fb40f34963519d791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between two <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> objects.  <a href="#a32dc9a29df3b365fb40f34963519d791">More...</a><br /></td></tr>
<tr class="separator:a32dc9a29df3b365fb40f34963519d791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2acacc78f03cb0ec8e8e7218b96f93b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool AF1, typename T2 , bool AF2&gt; </td></tr>
<tr class="memitem:ad2acacc78f03cb0ec8e8e7218b96f93b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ad2acacc78f03cb0ec8e8e7218b96f93b">operator&gt;=</a> (const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T1, AF1 &gt; &amp;lhs, const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T2, AF2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ad2acacc78f03cb0ec8e8e7218b96f93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between two <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> objects.  <a href="#ad2acacc78f03cb0ec8e8e7218b96f93b">More...</a><br /></td></tr>
<tr class="separator:ad2acacc78f03cb0ec8e8e7218b96f93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4bc8412b1132b17be23b06833cadc2"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF&gt; </td></tr>
<tr class="memitem:acc4bc8412b1132b17be23b06833cadc2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#acc4bc8412b1132b17be23b06833cadc2">operator+</a> (const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt; &amp;it, <a class="el" href="../../d2/d8c/classblaze_1_1ptrdiff__t.html">ptrdiff_t</a> inc) noexcept</td></tr>
<tr class="memdesc:acc4bc8412b1132b17be23b06833cadc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between a <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> and an integral value.  <a href="#acc4bc8412b1132b17be23b06833cadc2">More...</a><br /></td></tr>
<tr class="separator:acc4bc8412b1132b17be23b06833cadc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea90488b629d69d4511711e24f23ba7"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF&gt; </td></tr>
<tr class="memitem:a3ea90488b629d69d4511711e24f23ba7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a3ea90488b629d69d4511711e24f23ba7">operator+</a> (<a class="el" href="../../d2/d8c/classblaze_1_1ptrdiff__t.html">ptrdiff_t</a> inc, const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt; &amp;it) noexcept</td></tr>
<tr class="memdesc:a3ea90488b629d69d4511711e24f23ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between an integral value and a <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a>.  <a href="#a3ea90488b629d69d4511711e24f23ba7">More...</a><br /></td></tr>
<tr class="separator:a3ea90488b629d69d4511711e24f23ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8032b6bc6514096c8edb2f3a731cea0"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF&gt; </td></tr>
<tr class="memitem:ad8032b6bc6514096c8edb2f3a731cea0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ad8032b6bc6514096c8edb2f3a731cea0">operator-</a> (const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt; &amp;it, <a class="el" href="../../d2/d8c/classblaze_1_1ptrdiff__t.html">ptrdiff_t</a> dec) noexcept</td></tr>
<tr class="memdesc:ad8032b6bc6514096c8edb2f3a731cea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between a <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> and an integral value.  <a href="#ad8032b6bc6514096c8edb2f3a731cea0">More...</a><br /></td></tr>
<tr class="separator:ad8032b6bc6514096c8edb2f3a731cea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b2c6f50fef6e812d34a712843d2a43"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool AF&gt; </td></tr>
<tr class="memitem:a46b2c6f50fef6e812d34a712843d2a43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/d8c/classblaze_1_1ptrdiff__t.html">ptrdiff_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a46b2c6f50fef6e812d34a712843d2a43">operator-</a> (const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt; &amp;lhs, const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a46b2c6f50fef6e812d34a712843d2a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculating the number of elements between two <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> objects.  <a href="#a46b2c6f50fef6e812d34a712843d2a43">More...</a><br /></td></tr>
<tr class="separator:a46b2c6f50fef6e812d34a712843d2a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DenseMatrix operators</div></td></tr>
<tr class="memitem:ga7120542028164e84f57b2bd0daf1ed07"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7120542028164e84f57b2bd0daf1ed07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7120542028164e84f57b2bd0daf1ed07">operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7120542028164e84f57b2bd0daf1ed07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two rwo-major dense matrices.  <a href="../../db/df0/group__dense__matrix.html#ga7120542028164e84f57b2bd0daf1ed07">More...</a><br /></td></tr>
<tr class="separator:ga7120542028164e84f57b2bd0daf1ed07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e85fa1492d985e034b7ca152d69dac2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga3e85fa1492d985e034b7ca152d69dac2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga3e85fa1492d985e034b7ca152d69dac2">operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3e85fa1492d985e034b7ca152d69dac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two column-major dense matrices.  <a href="../../db/df0/group__dense__matrix.html#ga3e85fa1492d985e034b7ca152d69dac2">More...</a><br /></td></tr>
<tr class="separator:ga3e85fa1492d985e034b7ca152d69dac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gacff1ea4c8128a09b47db0c324da5c2f0">operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two dense matrices with different storage order.  <a href="../../db/df0/group__dense__matrix.html#gacff1ea4c8128a09b47db0c324da5c2f0">More...</a><br /></td></tr>
<tr class="separator:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga192685ae7dfdfa74ee94a9d6c51d1809">operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense matrix and a row-major sparse matrix.  <a href="../../db/df0/group__dense__matrix.html#ga192685ae7dfdfa74ee94a9d6c51d1809">More...</a><br /></td></tr>
<tr class="separator:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8212c8f46b5a2e31e355922f8fc2e3fc">operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense matrix and a column-major sparse matrix.  <a href="../../db/df0/group__dense__matrix.html#ga8212c8f46b5a2e31e355922f8fc2e3fc">More...</a><br /></td></tr>
<tr class="separator:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242470c706af7ba3a96eb35a1816b4cf"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga242470c706af7ba3a96eb35a1816b4cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga242470c706af7ba3a96eb35a1816b4cf">operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga242470c706af7ba3a96eb35a1816b4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a sparse matrix and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga242470c706af7ba3a96eb35a1816b4cf">More...</a><br /></td></tr>
<tr class="separator:ga242470c706af7ba3a96eb35a1816b4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11775fe4d60690cbdc76e71ccb71c545"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga11775fe4d60690cbdc76e71ccb71c545"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga11775fe4d60690cbdc76e71ccb71c545">operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga11775fe4d60690cbdc76e71ccb71c545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a row-major dense matrix and a scalar value.  <a href="../../db/df0/group__dense__matrix.html#ga11775fe4d60690cbdc76e71ccb71c545">More...</a><br /></td></tr>
<tr class="separator:ga11775fe4d60690cbdc76e71ccb71c545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3947c9d43314d45fb4e000ff4a08859"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gab3947c9d43314d45fb4e000ff4a08859"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab3947c9d43314d45fb4e000ff4a08859">operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:gab3947c9d43314d45fb4e000ff4a08859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a column-major dense matrix and a scalar value.  <a href="../../db/df0/group__dense__matrix.html#gab3947c9d43314d45fb4e000ff4a08859">More...</a><br /></td></tr>
<tr class="separator:gab3947c9d43314d45fb4e000ff4a08859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga25855a1d3c48eb1cb6f3f5a66842a85e">operator==</a> (T1 scalar, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a scalar value and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga25855a1d3c48eb1cb6f3f5a66842a85e">More...</a><br /></td></tr>
<tr class="separator:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga52848b40fa0e5a7f72bdcdd92d68f032">operator!=</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two dense matrices.  <a href="../../db/df0/group__dense__matrix.html#ga52848b40fa0e5a7f72bdcdd92d68f032">More...</a><br /></td></tr>
<tr class="separator:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174d0a369968b438ed23725b3361283c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga174d0a369968b438ed23725b3361283c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga174d0a369968b438ed23725b3361283c">operator!=</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga174d0a369968b438ed23725b3361283c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense matrix and a sparse matrix.  <a href="../../db/df0/group__dense__matrix.html#ga174d0a369968b438ed23725b3361283c">More...</a><br /></td></tr>
<tr class="separator:ga174d0a369968b438ed23725b3361283c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa83dce66f3d82b99bb0dd83aa3efb7a4">operator!=</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a sparse matrix and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#gaa83dce66f3d82b99bb0dd83aa3efb7a4">More...</a><br /></td></tr>
<tr class="separator:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bb8b9fb92ead32a2907a21c4bd81a91"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga5bb8b9fb92ead32a2907a21c4bd81a91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga5bb8b9fb92ead32a2907a21c4bd81a91">operator!=</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga5bb8b9fb92ead32a2907a21c4bd81a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense matrix and a scalar value.  <a href="../../db/df0/group__dense__matrix.html#ga5bb8b9fb92ead32a2907a21c4bd81a91">More...</a><br /></td></tr>
<tr class="separator:ga5bb8b9fb92ead32a2907a21c4bd81a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8ab1683cf0ef1f675329a4d27d45751c">operator!=</a> (T1 scalar, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a scalar value and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga8ab1683cf0ef1f675329a4d27d45751c">More...</a><br /></td></tr>
<tr class="separator:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DenseMatrix functions</div></td></tr>
<tr class="memitem:ga99ba6a5b32152077ba7d013be1add4dc"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga99ba6a5b32152077ba7d013be1add4dc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga99ba6a5b32152077ba7d013be1add4dc">isnan</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga99ba6a5b32152077ba7d013be1add4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given dense matrix for not-a-number elements.  <a href="../../db/df0/group__dense__matrix.html#ga99ba6a5b32152077ba7d013be1add4dc">More...</a><br /></td></tr>
<tr class="separator:ga99ba6a5b32152077ba7d013be1add4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c4333a5647750c5cd126ef9ca5d25b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga54c4333a5647750c5cd126ef9ca5d25b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga54c4333a5647750c5cd126ef9ca5d25b">isSymmetric</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga54c4333a5647750c5cd126ef9ca5d25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is symmetric.  <a href="../../db/df0/group__dense__matrix.html#ga54c4333a5647750c5cd126ef9ca5d25b">More...</a><br /></td></tr>
<tr class="separator:ga54c4333a5647750c5cd126ef9ca5d25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c4d4b151827b6e300cd949fc33a707a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga2c4d4b151827b6e300cd949fc33a707a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga2c4d4b151827b6e300cd949fc33a707a">isHermitian</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga2c4d4b151827b6e300cd949fc33a707a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is Hermitian.  <a href="../../db/df0/group__dense__matrix.html#ga2c4d4b151827b6e300cd949fc33a707a">More...</a><br /></td></tr>
<tr class="separator:ga2c4d4b151827b6e300cd949fc33a707a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aafd1dd369f715e523850f4adb36696"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7aafd1dd369f715e523850f4adb36696"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7aafd1dd369f715e523850f4adb36696">isUniform</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga7aafd1dd369f715e523850f4adb36696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a uniform matrix.  <a href="../../db/df0/group__dense__matrix.html#ga7aafd1dd369f715e523850f4adb36696">More...</a><br /></td></tr>
<tr class="separator:ga7aafd1dd369f715e523850f4adb36696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78ee9a691c9a59c3883f458866f9b76f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga78ee9a691c9a59c3883f458866f9b76f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga78ee9a691c9a59c3883f458866f9b76f">isLower</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga78ee9a691c9a59c3883f458866f9b76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a lower triangular matrix.  <a href="../../db/df0/group__dense__matrix.html#ga78ee9a691c9a59c3883f458866f9b76f">More...</a><br /></td></tr>
<tr class="separator:ga78ee9a691c9a59c3883f458866f9b76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72556b3671610da96aea635f41d166a1"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga72556b3671610da96aea635f41d166a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga72556b3671610da96aea635f41d166a1">isUniLower</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga72556b3671610da96aea635f41d166a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a lower unitriangular matrix.  <a href="../../db/df0/group__dense__matrix.html#ga72556b3671610da96aea635f41d166a1">More...</a><br /></td></tr>
<tr class="separator:ga72556b3671610da96aea635f41d166a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a77d7fdc4319a6e74bd6eae4d1c71c1"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7a77d7fdc4319a6e74bd6eae4d1c71c1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7a77d7fdc4319a6e74bd6eae4d1c71c1">isStrictlyLower</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga7a77d7fdc4319a6e74bd6eae4d1c71c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a strictly lower triangular matrix.  <a href="../../db/df0/group__dense__matrix.html#ga7a77d7fdc4319a6e74bd6eae4d1c71c1">More...</a><br /></td></tr>
<tr class="separator:ga7a77d7fdc4319a6e74bd6eae4d1c71c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e03c886fd6538a6f10dbdbbd4faacd"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac2e03c886fd6538a6f10dbdbbd4faacd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gac2e03c886fd6538a6f10dbdbbd4faacd">isUpper</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gac2e03c886fd6538a6f10dbdbbd4faacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is an upper triangular matrix.  <a href="../../db/df0/group__dense__matrix.html#gac2e03c886fd6538a6f10dbdbbd4faacd">More...</a><br /></td></tr>
<tr class="separator:gac2e03c886fd6538a6f10dbdbbd4faacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d3d32d95705421514aa1de3da0ef48d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga0d3d32d95705421514aa1de3da0ef48d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga0d3d32d95705421514aa1de3da0ef48d">isUniUpper</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga0d3d32d95705421514aa1de3da0ef48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is an upper unitriangular matrix.  <a href="../../db/df0/group__dense__matrix.html#ga0d3d32d95705421514aa1de3da0ef48d">More...</a><br /></td></tr>
<tr class="separator:ga0d3d32d95705421514aa1de3da0ef48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1b4b55a81a85ee76379ab19a1a75d64"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa1b4b55a81a85ee76379ab19a1a75d64"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa1b4b55a81a85ee76379ab19a1a75d64">isStrictlyUpper</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaa1b4b55a81a85ee76379ab19a1a75d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a strictly upper triangular matrix.  <a href="../../db/df0/group__dense__matrix.html#gaa1b4b55a81a85ee76379ab19a1a75d64">More...</a><br /></td></tr>
<tr class="separator:gaa1b4b55a81a85ee76379ab19a1a75d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga144e15e7b1f40485ed2dac1f51ba5083"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga144e15e7b1f40485ed2dac1f51ba5083"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga144e15e7b1f40485ed2dac1f51ba5083">isDiagonal</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga144e15e7b1f40485ed2dac1f51ba5083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the give dense matrix is diagonal.  <a href="../../db/df0/group__dense__matrix.html#ga144e15e7b1f40485ed2dac1f51ba5083">More...</a><br /></td></tr>
<tr class="separator:ga144e15e7b1f40485ed2dac1f51ba5083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3674413b281f83fcc81e3a6b2dea188"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa3674413b281f83fcc81e3a6b2dea188"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa3674413b281f83fcc81e3a6b2dea188">isIdentity</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaa3674413b281f83fcc81e3a6b2dea188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the give dense matrix is an identity matrix.  <a href="../../db/df0/group__dense__matrix.html#gaa3674413b281f83fcc81e3a6b2dea188">More...</a><br /></td></tr>
<tr class="separator:gaa3674413b281f83fcc81e3a6b2dea188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1147d0f93d7cc6fad33935048f2b058e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga1147d0f93d7cc6fad33935048f2b058e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga1147d0f93d7cc6fad33935048f2b058e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">More...</a><br /></td></tr>
<tr class="separator:ga1147d0f93d7cc6fad33935048f2b058e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ae2749f3a298c7927a4f7f85407e2c4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga6ae2749f3a298c7927a4f7f85407e2c4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga6ae2749f3a298c7927a4f7f85407e2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">More...</a><br /></td></tr>
<tr class="separator:ga6ae2749f3a298c7927a4f7f85407e2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DenseVector operators</div></td></tr>
<tr class="memitem:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7718438f21d78c1c5cd61e11b620f3ac">operator==</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two dense vectors.  <a href="../../de/d90/group__dense__vector.html#ga7718438f21d78c1c5cd61e11b620f3ac">More...</a><br /></td></tr>
<tr class="separator:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga521be975d8edae170b5f159468392be7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga521be975d8edae170b5f159468392be7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga521be975d8edae170b5f159468392be7">operator==</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga521be975d8edae170b5f159468392be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense vector and a sparse vector.  <a href="../../de/d90/group__dense__vector.html#ga521be975d8edae170b5f159468392be7">More...</a><br /></td></tr>
<tr class="separator:ga521be975d8edae170b5f159468392be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga90afa4cbe670f292f01e0a8c0989bcb4">operator==</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a sparse vector and a dense vector.  <a href="../../de/d90/group__dense__vector.html#ga90afa4cbe670f292f01e0a8c0989bcb4">More...</a><br /></td></tr>
<tr class="separator:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97dd82d4debad3d8fc7a11d39e345127"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga97dd82d4debad3d8fc7a11d39e345127"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga97dd82d4debad3d8fc7a11d39e345127">operator==</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga97dd82d4debad3d8fc7a11d39e345127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense vector and a scalar value.  <a href="../../de/d90/group__dense__vector.html#ga97dd82d4debad3d8fc7a11d39e345127">More...</a><br /></td></tr>
<tr class="separator:ga97dd82d4debad3d8fc7a11d39e345127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45da3a514747e0dd835d01393e1eb985"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga45da3a514747e0dd835d01393e1eb985"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga45da3a514747e0dd835d01393e1eb985">operator==</a> (T1 scalar, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga45da3a514747e0dd835d01393e1eb985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a scalar value and a dense vector.  <a href="../../de/d90/group__dense__vector.html#ga45da3a514747e0dd835d01393e1eb985">More...</a><br /></td></tr>
<tr class="separator:ga45da3a514747e0dd835d01393e1eb985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga1d006cc08bc800f749d0cffb9ddbb9a7">operator!=</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two dense vectors.  <a href="../../de/d90/group__dense__vector.html#ga1d006cc08bc800f749d0cffb9ddbb9a7">More...</a><br /></td></tr>
<tr class="separator:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga8c4f3ccbb0ab4cdb1d85ce597cba43bb">operator!=</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense vector and a sparse vector.  <a href="../../de/d90/group__dense__vector.html#ga8c4f3ccbb0ab4cdb1d85ce597cba43bb">More...</a><br /></td></tr>
<tr class="separator:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gabde27bb0ee7f998bef03dceca10cdce3">operator!=</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabde27bb0ee7f998bef03dceca10cdce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a sparse vector and a dense vector.  <a href="../../de/d90/group__dense__vector.html#gabde27bb0ee7f998bef03dceca10cdce3">More...</a><br /></td></tr>
<tr class="separator:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa769a4a7de2e4ba9b853c401e75fdc8d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaa769a4a7de2e4ba9b853c401e75fdc8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa769a4a7de2e4ba9b853c401e75fdc8d">operator!=</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:gaa769a4a7de2e4ba9b853c401e75fdc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense vector and a scalar value.  <a href="../../de/d90/group__dense__vector.html#gaa769a4a7de2e4ba9b853c401e75fdc8d">More...</a><br /></td></tr>
<tr class="separator:gaa769a4a7de2e4ba9b853c401e75fdc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga017746aadc85298a8c84e4e7f5e24bef"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga017746aadc85298a8c84e4e7f5e24bef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga017746aadc85298a8c84e4e7f5e24bef">operator!=</a> (T1 scalar, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga017746aadc85298a8c84e4e7f5e24bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a scalar value and a dense vector.  <a href="../../de/d90/group__dense__vector.html#ga017746aadc85298a8c84e4e7f5e24bef">More...</a><br /></td></tr>
<tr class="separator:ga017746aadc85298a8c84e4e7f5e24bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DenseVector functions</div></td></tr>
<tr class="memitem:gaee69fc388ff36a0cd55c36b24e6556f6"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaee69fc388ff36a0cd55c36b24e6556f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaee69fc388ff36a0cd55c36b24e6556f6">isnan</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gaee69fc388ff36a0cd55c36b24e6556f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given dense vector for not-a-number elements.  <a href="../../de/d90/group__dense__vector.html#gaee69fc388ff36a0cd55c36b24e6556f6">More...</a><br /></td></tr>
<tr class="separator:gaee69fc388ff36a0cd55c36b24e6556f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e50fe25442dd50eb27aea89797d65a"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga65e50fe25442dd50eb27aea89797d65a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga65e50fe25442dd50eb27aea89797d65a">isDivisor</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga65e50fe25442dd50eb27aea89797d65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given dense vector is a valid divisor.  <a href="../../de/d90/group__dense__vector.html#ga65e50fe25442dd50eb27aea89797d65a">More...</a><br /></td></tr>
<tr class="separator:ga65e50fe25442dd50eb27aea89797d65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga527e3c01fa1ccc42fae90bb95cc50082"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga527e3c01fa1ccc42fae90bb95cc50082"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga527e3c01fa1ccc42fae90bb95cc50082">isUniform</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga527e3c01fa1ccc42fae90bb95cc50082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense vector is a uniform vector.  <a href="../../de/d90/group__dense__vector.html#ga527e3c01fa1ccc42fae90bb95cc50082">More...</a><br /></td></tr>
<tr class="separator:ga527e3c01fa1ccc42fae90bb95cc50082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51d40e92bb2867d6d6b04ebbafd86b32"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga51d40e92bb2867d6d6b04ebbafd86b32"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32">sqrLength</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga51d40e92bb2867d6d6b04ebbafd86b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the dense vector square length <img class="formulaInl" alt="$|\vec{a}|^2$" src="../../form_63.png"/>.  <a href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32">More...</a><br /></td></tr>
<tr class="separator:ga51d40e92bb2867d6d6b04ebbafd86b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3585e479887969c9f815c0223fe5284f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga3585e479887969c9f815c0223fe5284f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga3585e479887969c9f815c0223fe5284f">length</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv) -&gt; decltype(<a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">sqrt</a>(<a class="el" href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32">sqrLength</a>(~dv)))</td></tr>
<tr class="memdesc:ga3585e479887969c9f815c0223fe5284f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the dense vector length <img class="formulaInl" alt="$|\vec{a}|$" src="../../form_64.png"/>.  <a href="../../de/d90/group__dense__vector.html#ga3585e479887969c9f815c0223fe5284f">More...</a><br /></td></tr>
<tr class="separator:ga3585e479887969c9f815c0223fe5284f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1525e1c59a3fd1e94e1777746600374"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gad1525e1c59a3fd1e94e1777746600374"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gad1525e1c59a3fd1e94e1777746600374">min</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gad1525e1c59a3fd1e94e1777746600374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the dense vector.  <a href="../../de/d90/group__dense__vector.html#gad1525e1c59a3fd1e94e1777746600374">More...</a><br /></td></tr>
<tr class="separator:gad1525e1c59a3fd1e94e1777746600374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd8640cf6c00926b89f0ae974e20da2"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7cd8640cf6c00926b89f0ae974e20da2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7cd8640cf6c00926b89f0ae974e20da2">max</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga7cd8640cf6c00926b89f0ae974e20da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the dense vector.  <a href="../../de/d90/group__dense__vector.html#ga7cd8640cf6c00926b89f0ae974e20da2">More...</a><br /></td></tr>
<tr class="separator:ga7cd8640cf6c00926b89f0ae974e20da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DynamicMatrix operators</div></td></tr>
<tr class="memitem:gaab0b6bd39504d1c632cb5a77658f3c66"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:gaab0b6bd39504d1c632cb5a77658f3c66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#gaab0b6bd39504d1c632cb5a77658f3c66">reset</a> (<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:gaab0b6bd39504d1c632cb5a77658f3c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given dynamic matrix.  <a href="../../dd/dfc/group__dynamic__matrix.html#gaab0b6bd39504d1c632cb5a77658f3c66">More...</a><br /></td></tr>
<tr class="separator:gaab0b6bd39504d1c632cb5a77658f3c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0f3c595b8bf2a5b8cac9a9f2340835d"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:gad0f3c595b8bf2a5b8cac9a9f2340835d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#gad0f3c595b8bf2a5b8cac9a9f2340835d">reset</a> (<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gad0f3c595b8bf2a5b8cac9a9f2340835d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column of the given dynamic matrix.  <a href="../../dd/dfc/group__dynamic__matrix.html#gad0f3c595b8bf2a5b8cac9a9f2340835d">More...</a><br /></td></tr>
<tr class="separator:gad0f3c595b8bf2a5b8cac9a9f2340835d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27bd64e4886d3ea017d6624d634a5145"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:ga27bd64e4886d3ea017d6624d634a5145"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#ga27bd64e4886d3ea017d6624d634a5145">clear</a> (<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga27bd64e4886d3ea017d6624d634a5145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given dynamic matrix.  <a href="../../dd/dfc/group__dynamic__matrix.html#ga27bd64e4886d3ea017d6624d634a5145">More...</a><br /></td></tr>
<tr class="separator:ga27bd64e4886d3ea017d6624d634a5145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad21449e9057f62feff3d74ef13064366"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:gad21449e9057f62feff3d74ef13064366"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#gad21449e9057f62feff3d74ef13064366">isDefault</a> (const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:gad21449e9057f62feff3d74ef13064366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given dynamic matrix is in default state.  <a href="../../dd/dfc/group__dynamic__matrix.html#gad21449e9057f62feff3d74ef13064366">More...</a><br /></td></tr>
<tr class="separator:gad21449e9057f62feff3d74ef13064366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a241daf3ed87f7635d055650e1d457"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:ga51a241daf3ed87f7635d055650e1d457"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#ga51a241daf3ed87f7635d055650e1d457">isIntact</a> (const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga51a241daf3ed87f7635d055650e1d457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given dynamic matrix are intact.  <a href="../../dd/dfc/group__dynamic__matrix.html#ga51a241daf3ed87f7635d055650e1d457">More...</a><br /></td></tr>
<tr class="separator:ga51a241daf3ed87f7635d055650e1d457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098009da1e9b773a7071e769feb07945"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:ga098009da1e9b773a7071e769feb07945"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#ga098009da1e9b773a7071e769feb07945">swap</a> (<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;a, <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga098009da1e9b773a7071e769feb07945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two dynamic matrices.  <a href="../../dd/dfc/group__dynamic__matrix.html#ga098009da1e9b773a7071e769feb07945">More...</a><br /></td></tr>
<tr class="separator:ga098009da1e9b773a7071e769feb07945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DynamicVector operators</div></td></tr>
<tr class="memitem:ga2fec0c1b60eb0357323c125b538a4192"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:ga2fec0c1b60eb0357323c125b538a4192"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da3/group__dynamic__vector.html#ga2fec0c1b60eb0357323c125b538a4192">reset</a> (<a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; Type, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga2fec0c1b60eb0357323c125b538a4192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given dynamic vector.  <a href="../../dd/da3/group__dynamic__vector.html#ga2fec0c1b60eb0357323c125b538a4192">More...</a><br /></td></tr>
<tr class="separator:ga2fec0c1b60eb0357323c125b538a4192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb5f8ac862261819dde5428784642893"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:gabb5f8ac862261819dde5428784642893"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da3/group__dynamic__vector.html#gabb5f8ac862261819dde5428784642893">clear</a> (<a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; Type, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:gabb5f8ac862261819dde5428784642893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given dynamic vector.  <a href="../../dd/da3/group__dynamic__vector.html#gabb5f8ac862261819dde5428784642893">More...</a><br /></td></tr>
<tr class="separator:gabb5f8ac862261819dde5428784642893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef79474bdecfb65923e504b5fe40843"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:gaeef79474bdecfb65923e504b5fe40843"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da3/group__dynamic__vector.html#gaeef79474bdecfb65923e504b5fe40843">isDefault</a> (const <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; Type, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:gaeef79474bdecfb65923e504b5fe40843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given dynamic vector is in default state.  <a href="../../dd/da3/group__dynamic__vector.html#gaeef79474bdecfb65923e504b5fe40843">More...</a><br /></td></tr>
<tr class="separator:gaeef79474bdecfb65923e504b5fe40843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60041ed54b7cb58f434a6d489efd28e2"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:ga60041ed54b7cb58f434a6d489efd28e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da3/group__dynamic__vector.html#ga60041ed54b7cb58f434a6d489efd28e2">isIntact</a> (const <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; Type, TF &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga60041ed54b7cb58f434a6d489efd28e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given dynamic vector are intact.  <a href="../../dd/da3/group__dynamic__vector.html#ga60041ed54b7cb58f434a6d489efd28e2">More...</a><br /></td></tr>
<tr class="separator:ga60041ed54b7cb58f434a6d489efd28e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga436a5005455854927fe446bdb84417a8"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:ga436a5005455854927fe446bdb84417a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da3/group__dynamic__vector.html#ga436a5005455854927fe446bdb84417a8">swap</a> (<a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; Type, TF &gt; &amp;a, <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; Type, TF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga436a5005455854927fe446bdb84417a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two vectors.  <a href="../../dd/da3/group__dynamic__vector.html#ga436a5005455854927fe446bdb84417a8">More...</a><br /></td></tr>
<tr class="separator:ga436a5005455854927fe446bdb84417a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">HybridMatrix operators</div></td></tr>
<tr class="memitem:ga3d7a93a65892c4d9a79dc3e7e3f286a5"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:ga3d7a93a65892c4d9a79dc3e7e3f286a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d0f/group__hybrid__matrix.html#ga3d7a93a65892c4d9a79dc3e7e3f286a5">reset</a> (<a class="el" href="../../d6/d60/classblaze_1_1HybridMatrix.html">HybridMatrix</a>&lt; Type, M, N, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga3d7a93a65892c4d9a79dc3e7e3f286a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given hybrid matrix.  <a href="../../dc/d0f/group__hybrid__matrix.html#ga3d7a93a65892c4d9a79dc3e7e3f286a5">More...</a><br /></td></tr>
<tr class="separator:ga3d7a93a65892c4d9a79dc3e7e3f286a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab95880a71d0e4549cc9e844d94c1507"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:gaab95880a71d0e4549cc9e844d94c1507"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d0f/group__hybrid__matrix.html#gaab95880a71d0e4549cc9e844d94c1507">reset</a> (<a class="el" href="../../d6/d60/classblaze_1_1HybridMatrix.html">HybridMatrix</a>&lt; Type, M, N, SO &gt; &amp;m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gaab95880a71d0e4549cc9e844d94c1507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column of the given hybrid matrix.  <a href="../../dc/d0f/group__hybrid__matrix.html#gaab95880a71d0e4549cc9e844d94c1507">More...</a><br /></td></tr>
<tr class="separator:gaab95880a71d0e4549cc9e844d94c1507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga421aff6a41e9b0d6749bd97155d1232a"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:ga421aff6a41e9b0d6749bd97155d1232a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d0f/group__hybrid__matrix.html#ga421aff6a41e9b0d6749bd97155d1232a">clear</a> (<a class="el" href="../../d6/d60/classblaze_1_1HybridMatrix.html">HybridMatrix</a>&lt; Type, M, N, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga421aff6a41e9b0d6749bd97155d1232a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given hybrid matrix.  <a href="../../dc/d0f/group__hybrid__matrix.html#ga421aff6a41e9b0d6749bd97155d1232a">More...</a><br /></td></tr>
<tr class="separator:ga421aff6a41e9b0d6749bd97155d1232a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07ca98f63c4c65f229452ba43b068c72"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:ga07ca98f63c4c65f229452ba43b068c72"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d0f/group__hybrid__matrix.html#ga07ca98f63c4c65f229452ba43b068c72">isDefault</a> (const <a class="el" href="../../d6/d60/classblaze_1_1HybridMatrix.html">HybridMatrix</a>&lt; Type, M, N, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga07ca98f63c4c65f229452ba43b068c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given hybrid matrix is in default state.  <a href="../../dc/d0f/group__hybrid__matrix.html#ga07ca98f63c4c65f229452ba43b068c72">More...</a><br /></td></tr>
<tr class="separator:ga07ca98f63c4c65f229452ba43b068c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5be117f86baf40ab65a7493ccafe093"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:gae5be117f86baf40ab65a7493ccafe093"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d0f/group__hybrid__matrix.html#gae5be117f86baf40ab65a7493ccafe093">isIntact</a> (const <a class="el" href="../../d6/d60/classblaze_1_1HybridMatrix.html">HybridMatrix</a>&lt; Type, M, N, SO &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:gae5be117f86baf40ab65a7493ccafe093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given hybrid matrix are intact.  <a href="../../dc/d0f/group__hybrid__matrix.html#gae5be117f86baf40ab65a7493ccafe093">More...</a><br /></td></tr>
<tr class="separator:gae5be117f86baf40ab65a7493ccafe093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14fca234d4c9f47993539c80bc3e26a7"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:ga14fca234d4c9f47993539c80bc3e26a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d0f/group__hybrid__matrix.html#ga14fca234d4c9f47993539c80bc3e26a7">swap</a> (<a class="el" href="../../d6/d60/classblaze_1_1HybridMatrix.html">HybridMatrix</a>&lt; Type, M, N, SO &gt; &amp;a, <a class="el" href="../../d6/d60/classblaze_1_1HybridMatrix.html">HybridMatrix</a>&lt; Type, M, N, SO &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga14fca234d4c9f47993539c80bc3e26a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two hybrid matrices.  <a href="../../dc/d0f/group__hybrid__matrix.html#ga14fca234d4c9f47993539c80bc3e26a7">More...</a><br /></td></tr>
<tr class="separator:ga14fca234d4c9f47993539c80bc3e26a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">HybridVector operators</div></td></tr>
<tr class="memitem:ga88c3dd871895ee17d5795dcb7e74c86a"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:ga88c3dd871895ee17d5795dcb7e74c86a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group__hybrid__vector.html#ga88c3dd871895ee17d5795dcb7e74c86a">reset</a> (<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga88c3dd871895ee17d5795dcb7e74c86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given hybrid vector.  <a href="../../d1/dc9/group__hybrid__vector.html#ga88c3dd871895ee17d5795dcb7e74c86a">More...</a><br /></td></tr>
<tr class="separator:ga88c3dd871895ee17d5795dcb7e74c86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga504b5be508084fd79f2c4557db10b0b0"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:ga504b5be508084fd79f2c4557db10b0b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group__hybrid__vector.html#ga504b5be508084fd79f2c4557db10b0b0">clear</a> (<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga504b5be508084fd79f2c4557db10b0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given hybrid vector.  <a href="../../d1/dc9/group__hybrid__vector.html#ga504b5be508084fd79f2c4557db10b0b0">More...</a><br /></td></tr>
<tr class="separator:ga504b5be508084fd79f2c4557db10b0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58da13ce7c3c83dc87e02a9e8936c147"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:ga58da13ce7c3c83dc87e02a9e8936c147"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group__hybrid__vector.html#ga58da13ce7c3c83dc87e02a9e8936c147">isDefault</a> (const <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga58da13ce7c3c83dc87e02a9e8936c147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given hybrid vector is in default state.  <a href="../../d1/dc9/group__hybrid__vector.html#ga58da13ce7c3c83dc87e02a9e8936c147">More...</a><br /></td></tr>
<tr class="separator:ga58da13ce7c3c83dc87e02a9e8936c147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe9e71136120cc48a756aad0884f592"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:ga6fe9e71136120cc48a756aad0884f592"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group__hybrid__vector.html#ga6fe9e71136120cc48a756aad0884f592">isIntact</a> (const <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga6fe9e71136120cc48a756aad0884f592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given hybrid vector are intact.  <a href="../../d1/dc9/group__hybrid__vector.html#ga6fe9e71136120cc48a756aad0884f592">More...</a><br /></td></tr>
<tr class="separator:ga6fe9e71136120cc48a756aad0884f592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga463ccbfaa4ec2f46dd91a4d8ae7b8f94"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:ga463ccbfaa4ec2f46dd91a4d8ae7b8f94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group__hybrid__vector.html#ga463ccbfaa4ec2f46dd91a4d8ae7b8f94">swap</a> (<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;a, <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga463ccbfaa4ec2f46dd91a4d8ae7b8f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two hybrid vectors.  <a href="../../d1/dc9/group__hybrid__vector.html#ga463ccbfaa4ec2f46dd91a4d8ae7b8f94">More...</a><br /></td></tr>
<tr class="separator:ga463ccbfaa4ec2f46dd91a4d8ae7b8f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Inversion functions</div></td></tr>
<tr class="memitem:ga1703390e63b9cb5b805ab5b4718ddda3"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga1703390e63b9cb5b805ab5b4718ddda3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1703390e63b9cb5b805ab5b4718ddda3">invert</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga1703390e63b9cb5b805ab5b4718ddda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga1703390e63b9cb5b805ab5b4718ddda3">More...</a><br /></td></tr>
<tr class="separator:ga1703390e63b9cb5b805ab5b4718ddda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0fd934e9c1b84cc2588cfe142c55a4"><td class="memTemplParams" colspan="2">template&lt;InversionFlag IF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4c0fd934e9c1b84cc2588cfe142c55a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4c0fd934e9c1b84cc2588cfe142c55a4">invert</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga4c0fd934e9c1b84cc2588cfe142c55a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga4c0fd934e9c1b84cc2588cfe142c55a4">More...</a><br /></td></tr>
<tr class="separator:ga4c0fd934e9c1b84cc2588cfe142c55a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LLH decomposition functions</div></td></tr>
<tr class="memitem:ga63e7f6efe504ec8f7416decef5446662"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga63e7f6efe504ec8f7416decef5446662"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga63e7f6efe504ec8f7416decef5446662">llh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;L)</td></tr>
<tr class="memdesc:ga63e7f6efe504ec8f7416decef5446662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cholesky (LLH) decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga63e7f6efe504ec8f7416decef5446662">More...</a><br /></td></tr>
<tr class="separator:ga63e7f6efe504ec8f7416decef5446662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LQ decomposition functions</div></td></tr>
<tr class="memitem:ga797f2c71d569b9abf5784ff118a308f2"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:ga797f2c71d569b9abf5784ff118a308f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga797f2c71d569b9abf5784ff118a308f2">lq</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;L, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;Q)</td></tr>
<tr class="memdesc:ga797f2c71d569b9abf5784ff118a308f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">LQ decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga797f2c71d569b9abf5784ff118a308f2">More...</a><br /></td></tr>
<tr class="separator:ga797f2c71d569b9abf5784ff118a308f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LU decomposition functions</div></td></tr>
<tr class="memitem:ga10d699031e948b83afcc0ffc68853d65"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , typename MT3 , typename MT4 , bool SO2&gt; </td></tr>
<tr class="memitem:ga10d699031e948b83afcc0ffc68853d65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65">lu</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO1 &gt; &amp;L, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO1 &gt; &amp;U, <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT4, SO2 &gt; &amp;P)</td></tr>
<tr class="memdesc:ga10d699031e948b83afcc0ffc68853d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">LU decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65">More...</a><br /></td></tr>
<tr class="separator:ga10d699031e948b83afcc0ffc68853d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">QL decomposition functions</div></td></tr>
<tr class="memitem:gab7c1c25d32e228f167f4544cc950bf1f"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:gab7c1c25d32e228f167f4544cc950bf1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab7c1c25d32e228f167f4544cc950bf1f">ql</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;Q, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;L)</td></tr>
<tr class="memdesc:gab7c1c25d32e228f167f4544cc950bf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">QL decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#gab7c1c25d32e228f167f4544cc950bf1f">More...</a><br /></td></tr>
<tr class="separator:gab7c1c25d32e228f167f4544cc950bf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">QR decomposition functions</div></td></tr>
<tr class="memitem:ga92d7e3366b2e5020229aba1e123235d6"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:ga92d7e3366b2e5020229aba1e123235d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga92d7e3366b2e5020229aba1e123235d6">qr</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;Q, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;R)</td></tr>
<tr class="memdesc:ga92d7e3366b2e5020229aba1e123235d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">QR decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga92d7e3366b2e5020229aba1e123235d6">More...</a><br /></td></tr>
<tr class="separator:ga92d7e3366b2e5020229aba1e123235d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">RQ decomposition functions</div></td></tr>
<tr class="memitem:ga28d8769f4cf3189184544ab620949dba"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:ga28d8769f4cf3189184544ab620949dba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga28d8769f4cf3189184544ab620949dba">rq</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;R, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;Q)</td></tr>
<tr class="memdesc:ga28d8769f4cf3189184544ab620949dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">RQ decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga28d8769f4cf3189184544ab620949dba">More...</a><br /></td></tr>
<tr class="separator:ga28d8769f4cf3189184544ab620949dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">StaticMatrix operators</div></td></tr>
<tr class="memitem:gac31655524a82392af7af7aba42acc9b6"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:gac31655524a82392af7af7aba42acc9b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/def/group__static__matrix.html#gac31655524a82392af7af7aba42acc9b6">reset</a> (<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:gac31655524a82392af7af7aba42acc9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given static matrix.  <a href="../../d5/def/group__static__matrix.html#gac31655524a82392af7af7aba42acc9b6">More...</a><br /></td></tr>
<tr class="separator:gac31655524a82392af7af7aba42acc9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab138c4ab47afa6ab81a62f9ac020de19"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:gab138c4ab47afa6ab81a62f9ac020de19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/def/group__static__matrix.html#gab138c4ab47afa6ab81a62f9ac020de19">reset</a> (<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gab138c4ab47afa6ab81a62f9ac020de19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column of the given static matrix.  <a href="../../d5/def/group__static__matrix.html#gab138c4ab47afa6ab81a62f9ac020de19">More...</a><br /></td></tr>
<tr class="separator:gab138c4ab47afa6ab81a62f9ac020de19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4baae3cffff62571955e3d90a182fe8"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:gaf4baae3cffff62571955e3d90a182fe8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/def/group__static__matrix.html#gaf4baae3cffff62571955e3d90a182fe8">clear</a> (<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:gaf4baae3cffff62571955e3d90a182fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given static matrix.  <a href="../../d5/def/group__static__matrix.html#gaf4baae3cffff62571955e3d90a182fe8">More...</a><br /></td></tr>
<tr class="separator:gaf4baae3cffff62571955e3d90a182fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8abc10190d774951de58b6a4efde8f27"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:ga8abc10190d774951de58b6a4efde8f27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/def/group__static__matrix.html#ga8abc10190d774951de58b6a4efde8f27">isDefault</a> (const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga8abc10190d774951de58b6a4efde8f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given dynamic matrix is in default state.  <a href="../../d5/def/group__static__matrix.html#ga8abc10190d774951de58b6a4efde8f27">More...</a><br /></td></tr>
<tr class="separator:ga8abc10190d774951de58b6a4efde8f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2dae513ad30404770723383f19e3422"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:gaa2dae513ad30404770723383f19e3422"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/def/group__static__matrix.html#gaa2dae513ad30404770723383f19e3422">isIntact</a> (const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:gaa2dae513ad30404770723383f19e3422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given static matrix are intact.  <a href="../../d5/def/group__static__matrix.html#gaa2dae513ad30404770723383f19e3422">More...</a><br /></td></tr>
<tr class="separator:gaa2dae513ad30404770723383f19e3422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0636caef871b02521d5e3517da824791"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:ga0636caef871b02521d5e3517da824791"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/def/group__static__matrix.html#ga0636caef871b02521d5e3517da824791">swap</a> (<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;a, <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga0636caef871b02521d5e3517da824791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two static matrices.  <a href="../../d5/def/group__static__matrix.html#ga0636caef871b02521d5e3517da824791">More...</a><br /></td></tr>
<tr class="separator:ga0636caef871b02521d5e3517da824791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">StaticVector operators</div></td></tr>
<tr class="memitem:gae163f13f07c819a1893b6f808eaa5413"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:gae163f13f07c819a1893b6f808eaa5413"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html#gae163f13f07c819a1893b6f808eaa5413">reset</a> (<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:gae163f13f07c819a1893b6f808eaa5413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given static vector.  <a href="../../d4/d95/group__static__vector.html#gae163f13f07c819a1893b6f808eaa5413">More...</a><br /></td></tr>
<tr class="separator:gae163f13f07c819a1893b6f808eaa5413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f74183430418c81f47e4546da92212"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:ga25f74183430418c81f47e4546da92212"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html#ga25f74183430418c81f47e4546da92212">clear</a> (<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga25f74183430418c81f47e4546da92212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given static vector.  <a href="../../d4/d95/group__static__vector.html#ga25f74183430418c81f47e4546da92212">More...</a><br /></td></tr>
<tr class="separator:ga25f74183430418c81f47e4546da92212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0cf22f8633faf616d031d64a08cb9ee"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:gae0cf22f8633faf616d031d64a08cb9ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html#gae0cf22f8633faf616d031d64a08cb9ee">isDefault</a> (const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:gae0cf22f8633faf616d031d64a08cb9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given static vector is in default state.  <a href="../../d4/d95/group__static__vector.html#gae0cf22f8633faf616d031d64a08cb9ee">More...</a><br /></td></tr>
<tr class="separator:gae0cf22f8633faf616d031d64a08cb9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ed49d41bac9f468cfa5ae3598b43656"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:ga0ed49d41bac9f468cfa5ae3598b43656"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html#ga0ed49d41bac9f468cfa5ae3598b43656">isIntact</a> (const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga0ed49d41bac9f468cfa5ae3598b43656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given static vector are intact.  <a href="../../d4/d95/group__static__vector.html#ga0ed49d41bac9f468cfa5ae3598b43656">More...</a><br /></td></tr>
<tr class="separator:ga0ed49d41bac9f468cfa5ae3598b43656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057a8e52f5bc1681c44e4830b1102a7b"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:ga057a8e52f5bc1681c44e4830b1102a7b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, 2UL, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html#ga057a8e52f5bc1681c44e4830b1102a7b">perp</a> (const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, 2UL, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga057a8e52f5bc1681c44e4830b1102a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary perp dot product operator for the calculation of a perpendicular vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}^\perp $" src="../../form_80.png"/>).  <a href="../../d4/d95/group__static__vector.html#ga057a8e52f5bc1681c44e4830b1102a7b">More...</a><br /></td></tr>
<tr class="separator:ga057a8e52f5bc1681c44e4830b1102a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a4bc9026cfbb388c00c39328f627430"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:ga6a4bc9026cfbb388c00c39328f627430"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, 3UL, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html#ga6a4bc9026cfbb388c00c39328f627430">perp</a> (const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, 3UL, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga6a4bc9026cfbb388c00c39328f627430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a perpendicular vector b which satisfies <img class="formulaInl" alt="$ \vec{a} \cdot \vec{b} = 0 $" src="../../form_84.png"/>.  <a href="../../d4/d95/group__static__vector.html#ga6a4bc9026cfbb388c00c39328f627430">More...</a><br /></td></tr>
<tr class="separator:ga6a4bc9026cfbb388c00c39328f627430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae441e84c49270d3495379e58a90cded3"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:gae441e84c49270d3495379e58a90cded3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html#gae441e84c49270d3495379e58a90cded3">swap</a> (<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;a, <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gae441e84c49270d3495379e58a90cded3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two static vectors.  <a href="../../d4/d95/group__static__vector.html#gae441e84c49270d3495379e58a90cded3">More...</a><br /></td></tr>
<tr class="separator:gae441e84c49270d3495379e58a90cded3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">NegativeEpsilon operators</div></td></tr>
<tr class="memitem:gaf07f5f4affa2e7b19de28dca9c35db6b"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:gaf07f5f4affa2e7b19de28dca9c35db6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf07f5f4affa2e7b19de28dca9c35db6b">operator==</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaf07f5f4affa2e7b19de28dca9c35db6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gaf07f5f4affa2e7b19de28dca9c35db6b">More...</a><br /></td></tr>
<tr class="separator:gaf07f5f4affa2e7b19de28dca9c35db6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a179498d07d4ec942a451ae92ec143"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga51a179498d07d4ec942a451ae92ec143"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga51a179498d07d4ec942a451ae92ec143">operator==</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga51a179498d07d4ec942a451ae92ec143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="../../de/df1/group__math.html#ga51a179498d07d4ec942a451ae92ec143">More...</a><br /></td></tr>
<tr class="separator:ga51a179498d07d4ec942a451ae92ec143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54487f79ea60723216b11c6fb0320286"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga54487f79ea60723216b11c6fb0320286"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga54487f79ea60723216b11c6fb0320286">operator!=</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga54487f79ea60723216b11c6fb0320286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga54487f79ea60723216b11c6fb0320286">More...</a><br /></td></tr>
<tr class="separator:ga54487f79ea60723216b11c6fb0320286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b91516b2c4be4334a58cb054b1a0680"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga6b91516b2c4be4334a58cb054b1a0680"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6b91516b2c4be4334a58cb054b1a0680">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga6b91516b2c4be4334a58cb054b1a0680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="../../de/df1/group__math.html#ga6b91516b2c4be4334a58cb054b1a0680">More...</a><br /></td></tr>
<tr class="separator:ga6b91516b2c4be4334a58cb054b1a0680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a3dd16604cf5215b58366eacb4ffdf5"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga3a3dd16604cf5215b58366eacb4ffdf5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3a3dd16604cf5215b58366eacb4ffdf5">operator&lt;</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga3a3dd16604cf5215b58366eacb4ffdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga3a3dd16604cf5215b58366eacb4ffdf5">More...</a><br /></td></tr>
<tr class="separator:ga3a3dd16604cf5215b58366eacb4ffdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e085f85d723050dd3472d1542642cab"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga3e085f85d723050dd3472d1542642cab"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3e085f85d723050dd3472d1542642cab">operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga3e085f85d723050dd3472d1542642cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="../../de/df1/group__math.html#ga3e085f85d723050dd3472d1542642cab">More...</a><br /></td></tr>
<tr class="separator:ga3e085f85d723050dd3472d1542642cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf9819fb4a78b96dc642b032680a4497"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:gaaf9819fb4a78b96dc642b032680a4497"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaaf9819fb4a78b96dc642b032680a4497">operator&gt;</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaaf9819fb4a78b96dc642b032680a4497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gaaf9819fb4a78b96dc642b032680a4497">More...</a><br /></td></tr>
<tr class="separator:gaaf9819fb4a78b96dc642b032680a4497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4567aade84dfbb24e1587dcfc8751cf2"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga4567aade84dfbb24e1587dcfc8751cf2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4567aade84dfbb24e1587dcfc8751cf2">operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga4567aade84dfbb24e1587dcfc8751cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="../../de/df1/group__math.html#ga4567aade84dfbb24e1587dcfc8751cf2">More...</a><br /></td></tr>
<tr class="separator:ga4567aade84dfbb24e1587dcfc8751cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Epsilon operators</div></td></tr>
<tr class="memitem:gaf77696e0b4298236b50e604cf58fcaf3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf77696e0b4298236b50e604cf58fcaf3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf77696e0b4298236b50e604cf58fcaf3">operator==</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaf77696e0b4298236b50e604cf58fcaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gaf77696e0b4298236b50e604cf58fcaf3">More...</a><br /></td></tr>
<tr class="separator:gaf77696e0b4298236b50e604cf58fcaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a51f607694128250e09404f52b4b276"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0a51f607694128250e09404f52b4b276"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0a51f607694128250e09404f52b4b276">operator==</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:ga0a51f607694128250e09404f52b4b276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#ga0a51f607694128250e09404f52b4b276">More...</a><br /></td></tr>
<tr class="separator:ga0a51f607694128250e09404f52b4b276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b125c455dda69ab246b146ca505bf09"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1b125c455dda69ab246b146ca505bf09"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1b125c455dda69ab246b146ca505bf09">operator!=</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga1b125c455dda69ab246b146ca505bf09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga1b125c455dda69ab246b146ca505bf09">More...</a><br /></td></tr>
<tr class="separator:ga1b125c455dda69ab246b146ca505bf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed7f8cdce1a915934c959eb91f80cf50"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaed7f8cdce1a915934c959eb91f80cf50"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaed7f8cdce1a915934c959eb91f80cf50">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:gaed7f8cdce1a915934c959eb91f80cf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#gaed7f8cdce1a915934c959eb91f80cf50">More...</a><br /></td></tr>
<tr class="separator:gaed7f8cdce1a915934c959eb91f80cf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40820137079464541dfb2e509116cea9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga40820137079464541dfb2e509116cea9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga40820137079464541dfb2e509116cea9">operator&lt;</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga40820137079464541dfb2e509116cea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga40820137079464541dfb2e509116cea9">More...</a><br /></td></tr>
<tr class="separator:ga40820137079464541dfb2e509116cea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c8df923cf79e378abe78f578c2fd3a4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0c8df923cf79e378abe78f578c2fd3a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0c8df923cf79e378abe78f578c2fd3a4">operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:ga0c8df923cf79e378abe78f578c2fd3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#ga0c8df923cf79e378abe78f578c2fd3a4">More...</a><br /></td></tr>
<tr class="separator:ga0c8df923cf79e378abe78f578c2fd3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03d0a5fa15d8e3467e9e74403a4af36d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga03d0a5fa15d8e3467e9e74403a4af36d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga03d0a5fa15d8e3467e9e74403a4af36d">operator&gt;</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga03d0a5fa15d8e3467e9e74403a4af36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga03d0a5fa15d8e3467e9e74403a4af36d">More...</a><br /></td></tr>
<tr class="separator:ga03d0a5fa15d8e3467e9e74403a4af36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d2a20484cd688e10c1f783a62ccdf57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7d2a20484cd688e10c1f783a62ccdf57"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7d2a20484cd688e10c1f783a62ccdf57">operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:ga7d2a20484cd688e10c1f783a62ccdf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#ga7d2a20484cd688e10c1f783a62ccdf57">More...</a><br /></td></tr>
<tr class="separator:ga7d2a20484cd688e10c1f783a62ccdf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e1bdb7c2e83533ec5900290f3db2926"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5e1bdb7c2e83533ec5900290f3db2926"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5e1bdb7c2e83533ec5900290f3db2926">operator&lt;=</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga5e1bdb7c2e83533ec5900290f3db2926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga5e1bdb7c2e83533ec5900290f3db2926">More...</a><br /></td></tr>
<tr class="separator:ga5e1bdb7c2e83533ec5900290f3db2926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75793d83615e27381df0bae5d84f89ee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga75793d83615e27381df0bae5d84f89ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga75793d83615e27381df0bae5d84f89ee">operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:ga75793d83615e27381df0bae5d84f89ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#ga75793d83615e27381df0bae5d84f89ee">More...</a><br /></td></tr>
<tr class="separator:ga75793d83615e27381df0bae5d84f89ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53f3ade227fca2dac380d0451ae70bb1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga53f3ade227fca2dac380d0451ae70bb1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga53f3ade227fca2dac380d0451ae70bb1">operator&gt;=</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga53f3ade227fca2dac380d0451ae70bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga53f3ade227fca2dac380d0451ae70bb1">More...</a><br /></td></tr>
<tr class="separator:ga53f3ade227fca2dac380d0451ae70bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae821d3d1c431b8ec5705eb979dd2238e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae821d3d1c431b8ec5705eb979dd2238e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae821d3d1c431b8ec5705eb979dd2238e">operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:gae821d3d1c431b8ec5705eb979dd2238e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#gae821d3d1c431b8ec5705eb979dd2238e">More...</a><br /></td></tr>
<tr class="separator:gae821d3d1c431b8ec5705eb979dd2238e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Determinant functions</div></td></tr>
<tr class="memitem:ga152576fa391bcb9a2892063bdf3953f7"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga152576fa391bcb9a2892063bdf3953f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga152576fa391bcb9a2892063bdf3953f7">det</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga152576fa391bcb9a2892063bdf3953f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> of the determinant of the given dense square matrix.  <a href="../../db/df0/group__dense__matrix.html#ga152576fa391bcb9a2892063bdf3953f7">More...</a><br /></td></tr>
<tr class="separator:ga152576fa391bcb9a2892063bdf3953f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix global functions</div></td></tr>
<tr class="memitem:ga8f0c048c86b644d1b9be16edc43d1b99"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga8f0c048c86b644d1b9be16edc43d1b99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> MT::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga8f0c048c86b644d1b9be16edc43d1b99">begin</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga8f0c048c86b644d1b9be16edc43d1b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em>.  <a href="../../dd/d7a/group__matrix.html#ga8f0c048c86b644d1b9be16edc43d1b99">More...</a><br /></td></tr>
<tr class="separator:ga8f0c048c86b644d1b9be16edc43d1b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d96a586bf2747b37279709950b4c1a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga67d96a586bf2747b37279709950b4c1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> MT::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga67d96a586bf2747b37279709950b4c1a">begin</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga67d96a586bf2747b37279709950b4c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em>.  <a href="../../dd/d7a/group__matrix.html#ga67d96a586bf2747b37279709950b4c1a">More...</a><br /></td></tr>
<tr class="separator:ga67d96a586bf2747b37279709950b4c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga369515ccbfb1641af7b6fc3b9e510174"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga369515ccbfb1641af7b6fc3b9e510174"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> MT::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga369515ccbfb1641af7b6fc3b9e510174">cbegin</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga369515ccbfb1641af7b6fc3b9e510174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em>.  <a href="../../dd/d7a/group__matrix.html#ga369515ccbfb1641af7b6fc3b9e510174">More...</a><br /></td></tr>
<tr class="separator:ga369515ccbfb1641af7b6fc3b9e510174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdc81bb7ed1970229a4f29afebfd7a6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7fdc81bb7ed1970229a4f29afebfd7a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> MT::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga7fdc81bb7ed1970229a4f29afebfd7a6">end</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga7fdc81bb7ed1970229a4f29afebfd7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em>.  <a href="../../dd/d7a/group__matrix.html#ga7fdc81bb7ed1970229a4f29afebfd7a6">More...</a><br /></td></tr>
<tr class="separator:ga7fdc81bb7ed1970229a4f29afebfd7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6769b1b62bcd0ddf05e9c5237f04cb4b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga6769b1b62bcd0ddf05e9c5237f04cb4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> MT::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga6769b1b62bcd0ddf05e9c5237f04cb4b">end</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga6769b1b62bcd0ddf05e9c5237f04cb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em>.  <a href="../../dd/d7a/group__matrix.html#ga6769b1b62bcd0ddf05e9c5237f04cb4b">More...</a><br /></td></tr>
<tr class="separator:ga6769b1b62bcd0ddf05e9c5237f04cb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga096461344e174dd70d10ef1166d59023"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga096461344e174dd70d10ef1166d59023"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> MT::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga096461344e174dd70d10ef1166d59023">cend</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga096461344e174dd70d10ef1166d59023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em>.  <a href="../../dd/d7a/group__matrix.html#ga096461344e174dd70d10ef1166d59023">More...</a><br /></td></tr>
<tr class="separator:ga096461344e174dd70d10ef1166d59023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b0c6e30994ba97cc2817a848355daf4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7b0c6e30994ba97cc2817a848355daf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga7b0c6e30994ba97cc2817a848355daf4">rows</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix) noexcept</td></tr>
<tr class="memdesc:ga7b0c6e30994ba97cc2817a848355daf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of rows of the matrix.  <a href="../../dd/d7a/group__matrix.html#ga7b0c6e30994ba97cc2817a848355daf4">More...</a><br /></td></tr>
<tr class="separator:ga7b0c6e30994ba97cc2817a848355daf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43caf6f27a219eb68a76ebdf2550b62d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga43caf6f27a219eb68a76ebdf2550b62d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga43caf6f27a219eb68a76ebdf2550b62d">columns</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix) noexcept</td></tr>
<tr class="memdesc:ga43caf6f27a219eb68a76ebdf2550b62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of columns of the matrix.  <a href="../../dd/d7a/group__matrix.html#ga43caf6f27a219eb68a76ebdf2550b62d">More...</a><br /></td></tr>
<tr class="separator:ga43caf6f27a219eb68a76ebdf2550b62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e8f2c5d0de752c667be20765570e56"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga41e8f2c5d0de752c667be20765570e56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga41e8f2c5d0de752c667be20765570e56">capacity</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix) noexcept</td></tr>
<tr class="memdesc:ga41e8f2c5d0de752c667be20765570e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the matrix.  <a href="../../dd/d7a/group__matrix.html#ga41e8f2c5d0de752c667be20765570e56">More...</a><br /></td></tr>
<tr class="separator:ga41e8f2c5d0de752c667be20765570e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21b0a7c980de5600705e343b7b65215e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga21b0a7c980de5600705e343b7b65215e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga21b0a7c980de5600705e343b7b65215e">capacity</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) noexcept</td></tr>
<tr class="memdesc:ga21b0a7c980de5600705e343b7b65215e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the specified row/column.  <a href="../../dd/d7a/group__matrix.html#ga21b0a7c980de5600705e343b7b65215e">More...</a><br /></td></tr>
<tr class="separator:ga21b0a7c980de5600705e343b7b65215e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f34f7e65e4d2be9617f824285073923"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga2f34f7e65e4d2be9617f824285073923"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga2f34f7e65e4d2be9617f824285073923">nonZeros</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix)</td></tr>
<tr class="memdesc:ga2f34f7e65e4d2be9617f824285073923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of non-zero elements in the matrix.  <a href="../../dd/d7a/group__matrix.html#ga2f34f7e65e4d2be9617f824285073923">More...</a><br /></td></tr>
<tr class="separator:ga2f34f7e65e4d2be9617f824285073923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2551362b764f05d740db6d269e7dddac"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga2551362b764f05d740db6d269e7dddac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga2551362b764f05d740db6d269e7dddac">nonZeros</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga2551362b764f05d740db6d269e7dddac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the specified row/column.  <a href="../../dd/d7a/group__matrix.html#ga2551362b764f05d740db6d269e7dddac">More...</a><br /></td></tr>
<tr class="separator:ga2551362b764f05d740db6d269e7dddac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga651c6be92e3a13425c42f3d92cf309fc"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga651c6be92e3a13425c42f3d92cf309fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga651c6be92e3a13425c42f3d92cf309fc">resize</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve)</td></tr>
<tr class="memdesc:ga651c6be92e3a13425c42f3d92cf309fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the size of the matrix.  <a href="../../dd/d7a/group__matrix.html#ga651c6be92e3a13425c42f3d92cf309fc">More...</a><br /></td></tr>
<tr class="separator:ga651c6be92e3a13425c42f3d92cf309fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6ec40dcae1598b663c10eda754381cb"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa6ec40dcae1598b663c10eda754381cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#gaa6ec40dcae1598b663c10eda754381cb">transpose</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix)</td></tr>
<tr class="memdesc:gaa6ec40dcae1598b663c10eda754381cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place transpose of the given matrix.  <a href="../../dd/d7a/group__matrix.html#gaa6ec40dcae1598b663c10eda754381cb">More...</a><br /></td></tr>
<tr class="separator:gaa6ec40dcae1598b663c10eda754381cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5f9d43032028526b8b155eb736b87f2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf5f9d43032028526b8b155eb736b87f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#gaf5f9d43032028526b8b155eb736b87f2">isSquare</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;matrix) noexcept</td></tr>
<tr class="memdesc:gaf5f9d43032028526b8b155eb736b87f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given matrix is a square matrix.  <a href="../../dd/d7a/group__matrix.html#gaf5f9d43032028526b8b155eb736b87f2">More...</a><br /></td></tr>
<tr class="separator:gaf5f9d43032028526b8b155eb736b87f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga532c1fb51e06afaf7e871074922a6b7a"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga532c1fb51e06afaf7e871074922a6b7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga532c1fb51e06afaf7e871074922a6b7a">isSame</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT1, SO1 &gt; &amp;a, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga532c1fb51e06afaf7e871074922a6b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two given matrices represent the same observable state.  <a href="../../dd/d7a/group__matrix.html#ga532c1fb51e06afaf7e871074922a6b7a">More...</a><br /></td></tr>
<tr class="separator:ga532c1fb51e06afaf7e871074922a6b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vector global functions</div></td></tr>
<tr class="memitem:gae0b944a5ec90948c0ab1d4996c972bb6"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gae0b944a5ec90948c0ab1d4996c972bb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> VT::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#gae0b944a5ec90948c0ab1d4996c972bb6">begin</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vector)</td></tr>
<tr class="memdesc:gae0b944a5ec90948c0ab1d4996c972bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the given vector.  <a href="../../dc/dcf/group__vector.html#gae0b944a5ec90948c0ab1d4996c972bb6">More...</a><br /></td></tr>
<tr class="separator:gae0b944a5ec90948c0ab1d4996c972bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c85278a26270d710a22f7ad7c8badf4"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga2c85278a26270d710a22f7ad7c8badf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> VT::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga2c85278a26270d710a22f7ad7c8badf4">begin</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vector)</td></tr>
<tr class="memdesc:ga2c85278a26270d710a22f7ad7c8badf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the given vector.  <a href="../../dc/dcf/group__vector.html#ga2c85278a26270d710a22f7ad7c8badf4">More...</a><br /></td></tr>
<tr class="separator:ga2c85278a26270d710a22f7ad7c8badf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2691e8f108cb245295c193af4fda6622"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga2691e8f108cb245295c193af4fda6622"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> VT::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga2691e8f108cb245295c193af4fda6622">cbegin</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vector)</td></tr>
<tr class="memdesc:ga2691e8f108cb245295c193af4fda6622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the given vector.  <a href="../../dc/dcf/group__vector.html#ga2691e8f108cb245295c193af4fda6622">More...</a><br /></td></tr>
<tr class="separator:ga2691e8f108cb245295c193af4fda6622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94fe63316f7573549db6481f534da5c8"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga94fe63316f7573549db6481f534da5c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> VT::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga94fe63316f7573549db6481f534da5c8">end</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vector)</td></tr>
<tr class="memdesc:ga94fe63316f7573549db6481f534da5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the given vector.  <a href="../../dc/dcf/group__vector.html#ga94fe63316f7573549db6481f534da5c8">More...</a><br /></td></tr>
<tr class="separator:ga94fe63316f7573549db6481f534da5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0e3c59edeee16da171512db785b1c5a"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gac0e3c59edeee16da171512db785b1c5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> VT::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#gac0e3c59edeee16da171512db785b1c5a">end</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vector)</td></tr>
<tr class="memdesc:gac0e3c59edeee16da171512db785b1c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the given vector.  <a href="../../dc/dcf/group__vector.html#gac0e3c59edeee16da171512db785b1c5a">More...</a><br /></td></tr>
<tr class="separator:gac0e3c59edeee16da171512db785b1c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac11e0150355c8d77ad91ef3d5f29bba1"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gac11e0150355c8d77ad91ef3d5f29bba1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> VT::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#gac11e0150355c8d77ad91ef3d5f29bba1">cend</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vector)</td></tr>
<tr class="memdesc:gac11e0150355c8d77ad91ef3d5f29bba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the given vector.  <a href="../../dc/dcf/group__vector.html#gac11e0150355c8d77ad91ef3d5f29bba1">More...</a><br /></td></tr>
<tr class="separator:gac11e0150355c8d77ad91ef3d5f29bba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5a3d85c96e5ec1481fe48cd80e663a0"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gab5a3d85c96e5ec1481fe48cd80e663a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#gab5a3d85c96e5ec1481fe48cd80e663a0">size</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vector) noexcept</td></tr>
<tr class="memdesc:gab5a3d85c96e5ec1481fe48cd80e663a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the vector.  <a href="../../dc/dcf/group__vector.html#gab5a3d85c96e5ec1481fe48cd80e663a0">More...</a><br /></td></tr>
<tr class="separator:gab5a3d85c96e5ec1481fe48cd80e663a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga000981b18db0a27837c21d40d6f46ce6"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga000981b18db0a27837c21d40d6f46ce6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga000981b18db0a27837c21d40d6f46ce6">capacity</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vector) noexcept</td></tr>
<tr class="memdesc:ga000981b18db0a27837c21d40d6f46ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the vector.  <a href="../../dc/dcf/group__vector.html#ga000981b18db0a27837c21d40d6f46ce6">More...</a><br /></td></tr>
<tr class="separator:ga000981b18db0a27837c21d40d6f46ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3885536741858efed5349a09113144f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gac3885536741858efed5349a09113144f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#gac3885536741858efed5349a09113144f">nonZeros</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vector)</td></tr>
<tr class="memdesc:gac3885536741858efed5349a09113144f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the vector.  <a href="../../dc/dcf/group__vector.html#gac3885536741858efed5349a09113144f">More...</a><br /></td></tr>
<tr class="separator:gac3885536741858efed5349a09113144f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga681cede0954239de992f6ade062fc3d2"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga681cede0954239de992f6ade062fc3d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga681cede0954239de992f6ade062fc3d2">resize</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;vector, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve)</td></tr>
<tr class="memdesc:ga681cede0954239de992f6ade062fc3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the size of the vector.  <a href="../../dc/dcf/group__vector.html#ga681cede0954239de992f6ade062fc3d2">More...</a><br /></td></tr>
<tr class="separator:ga681cede0954239de992f6ade062fc3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga717e045fa693f3c1f835f985e4214741"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga717e045fa693f3c1f835f985e4214741"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga717e045fa693f3c1f835f985e4214741">isSame</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;a, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga717e045fa693f3c1f835f985e4214741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two given vectors represent the same observable state.  <a href="../../dc/dcf/group__vector.html#ga717e045fa693f3c1f835f985e4214741">More...</a><br /></td></tr>
<tr class="separator:ga717e045fa693f3c1f835f985e4214741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical utility functions</div></td></tr>
<tr class="memitem:gaffebe2fae5612534433dbd26a999fefe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaffebe2fae5612534433dbd26a999fefe"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaffebe2fae5612534433dbd26a999fefe">sign</a> (T a) noexcept</td></tr>
<tr class="memdesc:gaffebe2fae5612534433dbd26a999fefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign function.  <a href="../../de/df1/group__math.html#gaffebe2fae5612534433dbd26a999fefe">More...</a><br /></td></tr>
<tr class="separator:gaffebe2fae5612534433dbd26a999fefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85346c256b6e74c93733704c6683314e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga85346c256b6e74c93733704c6683314e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga85346c256b6e74c93733704c6683314e">digits</a> (T a) noexcept</td></tr>
<tr class="memdesc:ga85346c256b6e74c93733704c6683314e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of valid digits of an integral value.  <a href="../../de/df1/group__math.html#ga85346c256b6e74c93733704c6683314e">More...</a><br /></td></tr>
<tr class="separator:ga85346c256b6e74c93733704c6683314e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga742a520758a3d3e2f106c7f074cbe839"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga742a520758a3d3e2f106c7f074cbe839"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr <a class="el" href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">CommonType_</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga742a520758a3d3e2f106c7f074cbe839">min</a> (const T1 &amp;a, const T2 &amp;b) noexcept(<a class="el" href="../../d9/de6/structblaze_1_1All.html">All</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>, T1, T2 &gt;::value)</td></tr>
<tr class="memdesc:ga742a520758a3d3e2f106c7f074cbe839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum function for two data values.  <a href="../../de/df1/group__math.html#ga742a520758a3d3e2f106c7f074cbe839">More...</a><br /></td></tr>
<tr class="separator:ga742a520758a3d3e2f106c7f074cbe839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd6ea515b37423d7580e3234e5120625"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Ts&gt; </td></tr>
<tr class="memitem:gacd6ea515b37423d7580e3234e5120625"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr <a class="el" href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">CommonType_</a>&lt; T1, T2, Ts... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gacd6ea515b37423d7580e3234e5120625">min</a> (const T1 &amp;a, const T2 &amp;b, const Ts &amp;... args) noexcept(<a class="el" href="../../d9/de6/structblaze_1_1All.html">All</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>, T1, T2, Ts... &gt;::value)</td></tr>
<tr class="memdesc:gacd6ea515b37423d7580e3234e5120625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum function for at least three data values.  <a href="../../de/df1/group__math.html#gacd6ea515b37423d7580e3234e5120625">More...</a><br /></td></tr>
<tr class="separator:gacd6ea515b37423d7580e3234e5120625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34ce710449801d337f239ae5ebda05cf"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga34ce710449801d337f239ae5ebda05cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr <a class="el" href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">CommonType_</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga34ce710449801d337f239ae5ebda05cf">max</a> (const T1 &amp;a, const T2 &amp;b) noexcept(<a class="el" href="../../d9/de6/structblaze_1_1All.html">All</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>, T1, T2 &gt;::value)</td></tr>
<tr class="memdesc:ga34ce710449801d337f239ae5ebda05cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum function for two data values.  <a href="../../de/df1/group__math.html#ga34ce710449801d337f239ae5ebda05cf">More...</a><br /></td></tr>
<tr class="separator:ga34ce710449801d337f239ae5ebda05cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b206ca0d7d334cfd018d24c0f64d8e5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Ts&gt; </td></tr>
<tr class="memitem:ga2b206ca0d7d334cfd018d24c0f64d8e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr <a class="el" href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">CommonType_</a>&lt; T1, T2, Ts... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2b206ca0d7d334cfd018d24c0f64d8e5">max</a> (const T1 &amp;a, const T2 &amp;b, const Ts &amp;... args) noexcept(<a class="el" href="../../d9/de6/structblaze_1_1All.html">All</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>, T1, T2, Ts... &gt;::value)</td></tr>
<tr class="memdesc:ga2b206ca0d7d334cfd018d24c0f64d8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum function for at least three data values.  <a href="../../de/df1/group__math.html#ga2b206ca0d7d334cfd018d24c0f64d8e5">More...</a><br /></td></tr>
<tr class="separator:ga2b206ca0d7d334cfd018d24c0f64d8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga744c2cdcc27fba2af1d7f24043353bd9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga744c2cdcc27fba2af1d7f24043353bd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga744c2cdcc27fba2af1d7f24043353bd9">nextMultiple</a> (T1 value, T2 factor) noexcept</td></tr>
<tr class="memdesc:ga744c2cdcc27fba2af1d7f24043353bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up an integral value to the next multiple of a given factor.  <a href="../../de/df1/group__math.html#ga744c2cdcc27fba2af1d7f24043353bd9">More...</a><br /></td></tr>
<tr class="separator:ga744c2cdcc27fba2af1d7f24043353bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d897a05236023eb2572750966bb1847"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1d897a05236023eb2572750966bb1847"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1d897a05236023eb2572750966bb1847">less</a> (const T1 &amp;a, const T2 &amp;b) noexcept(<a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt; <a class="el" href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">CommonType_</a>&lt; T1, T2 &gt; &gt;::value)</td></tr>
<tr class="memdesc:ga1d897a05236023eb2572750966bb1847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic less-than comparison.  <a href="../../de/df1/group__math.html#ga1d897a05236023eb2572750966bb1847">More...</a><br /></td></tr>
<tr class="separator:ga1d897a05236023eb2572750966bb1847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga860b2a005ccfc06780298500cf874a79"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga860b2a005ccfc06780298500cf874a79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga860b2a005ccfc06780298500cf874a79">greater</a> (const T1 &amp;a, const T2 &amp;b) noexcept(<a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt; <a class="el" href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">CommonType_</a>&lt; T1, T2 &gt; &gt;::value)</td></tr>
<tr class="memdesc:ga860b2a005ccfc06780298500cf874a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic greater-than comparison.  <a href="../../de/df1/group__math.html#ga860b2a005ccfc06780298500cf874a79">More...</a><br /></td></tr>
<tr class="separator:ga860b2a005ccfc06780298500cf874a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">NegativeInfinity operators</div></td></tr>
<tr class="memitem:gaf72e3519f6f3e1222bb492165c1ff473"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:gaf72e3519f6f3e1222bb492165c1ff473"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf72e3519f6f3e1222bb492165c1ff473">operator==</a> (const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I1 &gt; &amp;, const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I2 &gt; &amp;)</td></tr>
<tr class="memdesc:gaf72e3519f6f3e1222bb492165c1ff473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> objects.  <a href="../../de/df1/group__math.html#gaf72e3519f6f3e1222bb492165c1ff473">More...</a><br /></td></tr>
<tr class="separator:gaf72e3519f6f3e1222bb492165c1ff473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac724ba633053ce342cb0e6a3045c6a09"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:gac724ba633053ce342cb0e6a3045c6a09"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac724ba633053ce342cb0e6a3045c6a09">operator==</a> (const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gac724ba633053ce342cb0e6a3045c6a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type.  <a href="../../de/df1/group__math.html#gac724ba633053ce342cb0e6a3045c6a09">More...</a><br /></td></tr>
<tr class="separator:gac724ba633053ce342cb0e6a3045c6a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8690c52b43be431f700b2424340eab78"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:ga8690c52b43be431f700b2424340eab78"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga8690c52b43be431f700b2424340eab78">operator==</a> (const T &amp;lhs, const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8690c52b43be431f700b2424340eab78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="../../de/df1/group__math.html#ga8690c52b43be431f700b2424340eab78">More...</a><br /></td></tr>
<tr class="separator:ga8690c52b43be431f700b2424340eab78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e9f9352cad83e055316189fc57cb384"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:ga5e9f9352cad83e055316189fc57cb384"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5e9f9352cad83e055316189fc57cb384">operator!=</a> (const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I1 &gt; &amp;, const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I2 &gt; &amp;)</td></tr>
<tr class="memdesc:ga5e9f9352cad83e055316189fc57cb384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> objects.  <a href="../../de/df1/group__math.html#ga5e9f9352cad83e055316189fc57cb384">More...</a><br /></td></tr>
<tr class="separator:ga5e9f9352cad83e055316189fc57cb384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4c05a37e71a0c3d7c4cdc3902a9aed0"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:gad4c05a37e71a0c3d7c4cdc3902a9aed0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad4c05a37e71a0c3d7c4cdc3902a9aed0">operator!=</a> (const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gad4c05a37e71a0c3d7c4cdc3902a9aed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type.  <a href="../../de/df1/group__math.html#gad4c05a37e71a0c3d7c4cdc3902a9aed0">More...</a><br /></td></tr>
<tr class="separator:gad4c05a37e71a0c3d7c4cdc3902a9aed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276208f7821e9194172f1485258d385c"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:ga276208f7821e9194172f1485258d385c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga276208f7821e9194172f1485258d385c">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga276208f7821e9194172f1485258d385c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="../../de/df1/group__math.html#ga276208f7821e9194172f1485258d385c">More...</a><br /></td></tr>
<tr class="separator:ga276208f7821e9194172f1485258d385c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Infinity operators</div></td></tr>
<tr class="memitem:ga1cade862a899080b7219bb9468051f14"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1cade862a899080b7219bb9468051f14">operator==</a> (const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;, const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;)</td></tr>
<tr class="memdesc:ga1cade862a899080b7219bb9468051f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> objects.  <a href="../../de/df1/group__math.html#ga1cade862a899080b7219bb9468051f14">More...</a><br /></td></tr>
<tr class="separator:ga1cade862a899080b7219bb9468051f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae113fce8b3a8df1350075c2c4868983c"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:gae113fce8b3a8df1350075c2c4868983c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae113fce8b3a8df1350075c2c4868983c">operator==</a> (const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;, const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;)</td></tr>
<tr class="memdesc:gae113fce8b3a8df1350075c2c4868983c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="../../de/df1/group__math.html#gae113fce8b3a8df1350075c2c4868983c">More...</a><br /></td></tr>
<tr class="separator:gae113fce8b3a8df1350075c2c4868983c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae914b7ce7e8fcfcf0bf4fa8767fcb15d"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:gae914b7ce7e8fcfcf0bf4fa8767fcb15d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae914b7ce7e8fcfcf0bf4fa8767fcb15d">operator==</a> (const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;, const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;)</td></tr>
<tr class="memdesc:gae914b7ce7e8fcfcf0bf4fa8767fcb15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="../../de/df1/group__math.html#gae914b7ce7e8fcfcf0bf4fa8767fcb15d">More...</a><br /></td></tr>
<tr class="separator:gae914b7ce7e8fcfcf0bf4fa8767fcb15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf89122a0bb9a848015b65506874909"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabdf89122a0bb9a848015b65506874909"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabdf89122a0bb9a848015b65506874909">operator==</a> (const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gabdf89122a0bb9a848015b65506874909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type.  <a href="../../de/df1/group__math.html#gabdf89122a0bb9a848015b65506874909">More...</a><br /></td></tr>
<tr class="separator:gabdf89122a0bb9a848015b65506874909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef34c0250b3f5dbfe8d24ed181650659"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaef34c0250b3f5dbfe8d24ed181650659"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaef34c0250b3f5dbfe8d24ed181650659">operator==</a> (const T &amp;lhs, const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaef34c0250b3f5dbfe8d24ed181650659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="../../de/df1/group__math.html#gaef34c0250b3f5dbfe8d24ed181650659">More...</a><br /></td></tr>
<tr class="separator:gaef34c0250b3f5dbfe8d24ed181650659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35624fa5c81fa4f70a5d03dc944c5411"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga35624fa5c81fa4f70a5d03dc944c5411">operator!=</a> (const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;, const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;)</td></tr>
<tr class="memdesc:ga35624fa5c81fa4f70a5d03dc944c5411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> objects.  <a href="../../de/df1/group__math.html#ga35624fa5c81fa4f70a5d03dc944c5411">More...</a><br /></td></tr>
<tr class="separator:ga35624fa5c81fa4f70a5d03dc944c5411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8505375a66afb5af9edd75b85ba5204"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:gae8505375a66afb5af9edd75b85ba5204"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae8505375a66afb5af9edd75b85ba5204">operator!=</a> (const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;, const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;)</td></tr>
<tr class="memdesc:gae8505375a66afb5af9edd75b85ba5204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="../../de/df1/group__math.html#gae8505375a66afb5af9edd75b85ba5204">More...</a><br /></td></tr>
<tr class="separator:gae8505375a66afb5af9edd75b85ba5204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf708a331a30e78fda59df5b66de17b63"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:gaf708a331a30e78fda59df5b66de17b63"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf708a331a30e78fda59df5b66de17b63">operator!=</a> (const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;, const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;)</td></tr>
<tr class="memdesc:gaf708a331a30e78fda59df5b66de17b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="../../de/df1/group__math.html#gaf708a331a30e78fda59df5b66de17b63">More...</a><br /></td></tr>
<tr class="separator:gaf708a331a30e78fda59df5b66de17b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7856e8e97381138ec49530fdbe0ec412"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7856e8e97381138ec49530fdbe0ec412"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7856e8e97381138ec49530fdbe0ec412">operator!=</a> (const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga7856e8e97381138ec49530fdbe0ec412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type.  <a href="../../de/df1/group__math.html#ga7856e8e97381138ec49530fdbe0ec412">More...</a><br /></td></tr>
<tr class="separator:ga7856e8e97381138ec49530fdbe0ec412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d73646abcac7bfd4727f62ae1c7df2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga36d73646abcac7bfd4727f62ae1c7df2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga36d73646abcac7bfd4727f62ae1c7df2">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga36d73646abcac7bfd4727f62ae1c7df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="../../de/df1/group__math.html#ga36d73646abcac7bfd4727f62ae1c7df2">More...</a><br /></td></tr>
<tr class="separator:ga36d73646abcac7bfd4727f62ae1c7df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK LQ decomposition functions (gelqf)</div></td></tr>
<tr class="memitem:ga87b6eb233ee7c0c4834d46d0c465b694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga87b6eb233ee7c0c4834d46d0c465b694">gelqf</a> (int m, int n, float *A, int lda, float *tau, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga87b6eb233ee7c0c4834d46d0c465b694"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the LQ decomposition of the given dense single precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga87b6eb233ee7c0c4834d46d0c465b694">More...</a><br /></td></tr>
<tr class="separator:ga87b6eb233ee7c0c4834d46d0c465b694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47f6d5da630784fb89dff8aab0301b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga47f6d5da630784fb89dff8aab0301b43">gelqf</a> (int m, int n, double *A, int lda, double *tau, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga47f6d5da630784fb89dff8aab0301b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the LQ decomposition of the given dense double precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga47f6d5da630784fb89dff8aab0301b43">More...</a><br /></td></tr>
<tr class="separator:ga47f6d5da630784fb89dff8aab0301b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d0d9237aa4fcbb1ee5106c2d5814e37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga2d0d9237aa4fcbb1ee5106c2d5814e37">gelqf</a> (int m, int n, complex&lt; float &gt; *A, int lda, complex&lt; float &gt; *tau, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga2d0d9237aa4fcbb1ee5106c2d5814e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the LQ decomposition of the given dense single precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga2d0d9237aa4fcbb1ee5106c2d5814e37">More...</a><br /></td></tr>
<tr class="separator:ga2d0d9237aa4fcbb1ee5106c2d5814e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9394824f5969b9003831bccd9c23e183"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga9394824f5969b9003831bccd9c23e183">gelqf</a> (int m, int n, complex&lt; double &gt; *A, int lda, complex&lt; double &gt; *tau, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga9394824f5969b9003831bccd9c23e183"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the LQ decomposition of the given dense double precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga9394824f5969b9003831bccd9c23e183">More...</a><br /></td></tr>
<tr class="separator:ga9394824f5969b9003831bccd9c23e183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab365bca181eadeac74070947e484ff32"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gab365bca181eadeac74070947e484ff32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gab365bca181eadeac74070947e484ff32">gelqf</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; *tau)</td></tr>
<tr class="memdesc:gab365bca181eadeac74070947e484ff32"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the LQ decomposition of the given dense matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gab365bca181eadeac74070947e484ff32">More...</a><br /></td></tr>
<tr class="separator:gab365bca181eadeac74070947e484ff32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK QL decomposition functions (geqlf)</div></td></tr>
<tr class="memitem:ga0fe775f8013ab8a4d9b6e5a1c89e30ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga0fe775f8013ab8a4d9b6e5a1c89e30ed">geqlf</a> (int m, int n, float *A, int lda, float *tau, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga0fe775f8013ab8a4d9b6e5a1c89e30ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the QL decomposition of the given dense single precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga0fe775f8013ab8a4d9b6e5a1c89e30ed">More...</a><br /></td></tr>
<tr class="separator:ga0fe775f8013ab8a4d9b6e5a1c89e30ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd5e03d3a4177d96d69fd197200f05a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gabd5e03d3a4177d96d69fd197200f05a5">geqlf</a> (int m, int n, double *A, int lda, double *tau, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gabd5e03d3a4177d96d69fd197200f05a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the QL decomposition of the given dense double precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gabd5e03d3a4177d96d69fd197200f05a5">More...</a><br /></td></tr>
<tr class="separator:gabd5e03d3a4177d96d69fd197200f05a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf990a0dfa4d8544c8c299556c96ad28d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaf990a0dfa4d8544c8c299556c96ad28d">geqlf</a> (int m, int n, complex&lt; float &gt; *A, int lda, complex&lt; float &gt; *tau, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gaf990a0dfa4d8544c8c299556c96ad28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the QL decomposition of the given dense single precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gaf990a0dfa4d8544c8c299556c96ad28d">More...</a><br /></td></tr>
<tr class="separator:gaf990a0dfa4d8544c8c299556c96ad28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe6c0ff9ae0eeb2968f487d2fc84d29c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gafe6c0ff9ae0eeb2968f487d2fc84d29c">geqlf</a> (int m, int n, complex&lt; double &gt; *A, int lda, complex&lt; double &gt; *tau, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gafe6c0ff9ae0eeb2968f487d2fc84d29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the QL decomposition of the given dense double precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gafe6c0ff9ae0eeb2968f487d2fc84d29c">More...</a><br /></td></tr>
<tr class="separator:gafe6c0ff9ae0eeb2968f487d2fc84d29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga093cd8bb4b9031f27f12728b14442b6d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga093cd8bb4b9031f27f12728b14442b6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga093cd8bb4b9031f27f12728b14442b6d">geqlf</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; *tau)</td></tr>
<tr class="memdesc:ga093cd8bb4b9031f27f12728b14442b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the QL decomposition of the given dense matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga093cd8bb4b9031f27f12728b14442b6d">More...</a><br /></td></tr>
<tr class="separator:ga093cd8bb4b9031f27f12728b14442b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK QR decomposition functions (geqp3)</div></td></tr>
<tr class="memitem:gaee597a0aff62791dde106faa3a22994e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaee597a0aff62791dde106faa3a22994e">geqp3</a> (int m, int n, float *A, int lda, int *jpvt, float *tau, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gaee597a0aff62791dde106faa3a22994e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the QR decomposition of the given dense single precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gaee597a0aff62791dde106faa3a22994e">More...</a><br /></td></tr>
<tr class="separator:gaee597a0aff62791dde106faa3a22994e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a360ef65f7648e17de5fcbfa0514134"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga5a360ef65f7648e17de5fcbfa0514134">geqp3</a> (int m, int n, double *A, int lda, int *jpvt, double *tau, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga5a360ef65f7648e17de5fcbfa0514134"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the QR decomposition of the given dense double precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga5a360ef65f7648e17de5fcbfa0514134">More...</a><br /></td></tr>
<tr class="separator:ga5a360ef65f7648e17de5fcbfa0514134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK QR decomposition functions (geqrf)</div></td></tr>
<tr class="memitem:ga9eac6b01393d7cdc78daf9662f13ab73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga9eac6b01393d7cdc78daf9662f13ab73">geqrf</a> (int m, int n, float *A, int lda, float *tau, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga9eac6b01393d7cdc78daf9662f13ab73"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the QR decomposition of the given dense single precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga9eac6b01393d7cdc78daf9662f13ab73">More...</a><br /></td></tr>
<tr class="separator:ga9eac6b01393d7cdc78daf9662f13ab73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c7f2b7a691b9902598cd33f8189cece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga1c7f2b7a691b9902598cd33f8189cece">geqrf</a> (int m, int n, double *A, int lda, double *tau, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga1c7f2b7a691b9902598cd33f8189cece"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the QR decomposition of the given dense double precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga1c7f2b7a691b9902598cd33f8189cece">More...</a><br /></td></tr>
<tr class="separator:ga1c7f2b7a691b9902598cd33f8189cece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2efb17c47884a3eb59010ea40196e051"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga2efb17c47884a3eb59010ea40196e051">geqrf</a> (int m, int n, complex&lt; float &gt; *A, int lda, complex&lt; float &gt; *tau, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga2efb17c47884a3eb59010ea40196e051"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the QR decomposition of the given dense single precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga2efb17c47884a3eb59010ea40196e051">More...</a><br /></td></tr>
<tr class="separator:ga2efb17c47884a3eb59010ea40196e051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb2cf1733173e57108cce5f0a8885f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gabb2cf1733173e57108cce5f0a8885f71">geqrf</a> (int m, int n, complex&lt; double &gt; *A, int lda, complex&lt; double &gt; *tau, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gabb2cf1733173e57108cce5f0a8885f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the QR decomposition of the given dense double precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gabb2cf1733173e57108cce5f0a8885f71">More...</a><br /></td></tr>
<tr class="separator:gabb2cf1733173e57108cce5f0a8885f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2263b475357ae2cbc0e82ad4bc25486"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae2263b475357ae2cbc0e82ad4bc25486"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gae2263b475357ae2cbc0e82ad4bc25486">geqrf</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; *tau)</td></tr>
<tr class="memdesc:gae2263b475357ae2cbc0e82ad4bc25486"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the QR decomposition of the given dense matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gae2263b475357ae2cbc0e82ad4bc25486">More...</a><br /></td></tr>
<tr class="separator:gae2263b475357ae2cbc0e82ad4bc25486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK RQ decomposition functions (gerqf)</div></td></tr>
<tr class="memitem:gad174dd48c2477c7c045bd4fd69587446"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gad174dd48c2477c7c045bd4fd69587446">gerqf</a> (int m, int n, float *A, int lda, float *tau, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gad174dd48c2477c7c045bd4fd69587446"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the RQ decomposition of the given dense single precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gad174dd48c2477c7c045bd4fd69587446">More...</a><br /></td></tr>
<tr class="separator:gad174dd48c2477c7c045bd4fd69587446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa15e19f8b2c1fa2e890244b1a4d2b12a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaa15e19f8b2c1fa2e890244b1a4d2b12a">gerqf</a> (int m, int n, double *A, int lda, double *tau, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gaa15e19f8b2c1fa2e890244b1a4d2b12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the RQ decomposition of the given dense single precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gaa15e19f8b2c1fa2e890244b1a4d2b12a">More...</a><br /></td></tr>
<tr class="separator:gaa15e19f8b2c1fa2e890244b1a4d2b12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c36242c62cbdb4810ae88fc12139652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga6c36242c62cbdb4810ae88fc12139652">gerqf</a> (int m, int n, complex&lt; float &gt; *A, int lda, complex&lt; float &gt; *tau, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga6c36242c62cbdb4810ae88fc12139652"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the RQ decomposition of the given dense single precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga6c36242c62cbdb4810ae88fc12139652">More...</a><br /></td></tr>
<tr class="separator:ga6c36242c62cbdb4810ae88fc12139652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36dbaff871f964510f65a1b1484341c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga36dbaff871f964510f65a1b1484341c0">gerqf</a> (int m, int n, complex&lt; double &gt; *A, int lda, complex&lt; double &gt; *tau, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga36dbaff871f964510f65a1b1484341c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the RQ decomposition of the given dense double precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga36dbaff871f964510f65a1b1484341c0">More...</a><br /></td></tr>
<tr class="separator:ga36dbaff871f964510f65a1b1484341c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300ca556052021d16339e27210762e11"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga300ca556052021d16339e27210762e11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga300ca556052021d16339e27210762e11">gerqf</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; *tau)</td></tr>
<tr class="memdesc:ga300ca556052021d16339e27210762e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the RQ decomposition of the given dense matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga300ca556052021d16339e27210762e11">More...</a><br /></td></tr>
<tr class="separator:ga300ca556052021d16339e27210762e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK general linear system functions (gesv)</div></td></tr>
<tr class="memitem:ga1cc371300e831ba108603703f5316ac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#ga1cc371300e831ba108603703f5316ac2">gesv</a> (int n, int nrhs, float *A, int lda, int *ipiv, float *B, int ldb, int *info)</td></tr>
<tr class="memdesc:ga1cc371300e831ba108603703f5316ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a general single precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#ga1cc371300e831ba108603703f5316ac2">More...</a><br /></td></tr>
<tr class="separator:ga1cc371300e831ba108603703f5316ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5bd38d6f5cdf9b0a4498ac87d5517dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gac5bd38d6f5cdf9b0a4498ac87d5517dc">gesv</a> (int n, int nrhs, double *A, int lda, int *ipiv, double *B, int ldb, int *info)</td></tr>
<tr class="memdesc:gac5bd38d6f5cdf9b0a4498ac87d5517dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a general double precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gac5bd38d6f5cdf9b0a4498ac87d5517dc">More...</a><br /></td></tr>
<tr class="separator:gac5bd38d6f5cdf9b0a4498ac87d5517dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa39fbaed40a423d486ad28444165922d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gaa39fbaed40a423d486ad28444165922d">gesv</a> (int n, int nrhs, complex&lt; float &gt; *A, int lda, int *ipiv, complex&lt; float &gt; *B, int ldb, int *info)</td></tr>
<tr class="memdesc:gaa39fbaed40a423d486ad28444165922d"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a general single precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gaa39fbaed40a423d486ad28444165922d">More...</a><br /></td></tr>
<tr class="separator:gaa39fbaed40a423d486ad28444165922d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga967811ec8f8a6c6f189fed364e135a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#ga967811ec8f8a6c6f189fed364e135a19">gesv</a> (int n, int nrhs, complex&lt; double &gt; *A, int lda, int *ipiv, complex&lt; double &gt; *B, int ldb, int *info)</td></tr>
<tr class="memdesc:ga967811ec8f8a6c6f189fed364e135a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a general double precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#ga967811ec8f8a6c6f189fed364e135a19">More...</a><br /></td></tr>
<tr class="separator:ga967811ec8f8a6c6f189fed364e135a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118f28497637e89c562a03614cdb56ea"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga118f28497637e89c562a03614cdb56ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#ga118f28497637e89c562a03614cdb56ea">gesv</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;b, int *ipiv)</td></tr>
<tr class="memdesc:ga118f28497637e89c562a03614cdb56ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a general linear system of equations ( <img class="formulaInl" alt="$ A*x=b $" src="../../form_149.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#ga118f28497637e89c562a03614cdb56ea">More...</a><br /></td></tr>
<tr class="separator:ga118f28497637e89c562a03614cdb56ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59bf325689f24295062dccf490e75da"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:gad59bf325689f24295062dccf490e75da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gad59bf325689f24295062dccf490e75da">gesv</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;B, int *ipiv)</td></tr>
<tr class="memdesc:gad59bf325689f24295062dccf490e75da"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a general linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gad59bf325689f24295062dccf490e75da">More...</a><br /></td></tr>
<tr class="separator:gad59bf325689f24295062dccf490e75da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK LU decomposition functions (getrf)</div></td></tr>
<tr class="memitem:ga3bc9d7a4dec71cd357b761fe74abb205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga3bc9d7a4dec71cd357b761fe74abb205">getrf</a> (int m, int n, float *A, int lda, int *ipiv, int *info)</td></tr>
<tr class="memdesc:ga3bc9d7a4dec71cd357b761fe74abb205"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the LU decomposition of the given dense general single precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga3bc9d7a4dec71cd357b761fe74abb205">More...</a><br /></td></tr>
<tr class="separator:ga3bc9d7a4dec71cd357b761fe74abb205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba4c5d26ffa4e24599f5b9f140ffe8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga5ba4c5d26ffa4e24599f5b9f140ffe8e">getrf</a> (int m, int n, double *A, int lda, int *ipiv, int *info)</td></tr>
<tr class="memdesc:ga5ba4c5d26ffa4e24599f5b9f140ffe8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the LU decomposition of the given dense general double precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga5ba4c5d26ffa4e24599f5b9f140ffe8e">More...</a><br /></td></tr>
<tr class="separator:ga5ba4c5d26ffa4e24599f5b9f140ffe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e977459ac9dc6b17c997bc6aad5a788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga2e977459ac9dc6b17c997bc6aad5a788">getrf</a> (int m, int n, complex&lt; float &gt; *A, int lda, int *ipiv, int *info)</td></tr>
<tr class="memdesc:ga2e977459ac9dc6b17c997bc6aad5a788"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the LU decomposition of the given dense general single precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga2e977459ac9dc6b17c997bc6aad5a788">More...</a><br /></td></tr>
<tr class="separator:ga2e977459ac9dc6b17c997bc6aad5a788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27caa3d27718ab34c50aba70b416baac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga27caa3d27718ab34c50aba70b416baac">getrf</a> (int m, int n, complex&lt; double &gt; *A, int lda, int *ipiv, int *info)</td></tr>
<tr class="memdesc:ga27caa3d27718ab34c50aba70b416baac"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the LU decomposition of the given dense general double precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga27caa3d27718ab34c50aba70b416baac">More...</a><br /></td></tr>
<tr class="separator:ga27caa3d27718ab34c50aba70b416baac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47facb533f7cc62f3f01eeee0728e883"><td class="memTemplParams" colspan="2">
template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga47facb533f7cc62f3f01eeee0728e883"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getrf</b> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, int *ipiv)</td></tr>
<tr class="separator:ga47facb533f7cc62f3f01eeee0728e883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK LU-based inversion functions (getri)</div></td></tr>
<tr class="memitem:ga5c37f8906313ab4e00e19c3b5928f5bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga5c37f8906313ab4e00e19c3b5928f5bf">getri</a> (int n, float *A, int lda, const int *ipiv, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga5c37f8906313ab4e00e19c3b5928f5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense general single precision column-major square matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga5c37f8906313ab4e00e19c3b5928f5bf">More...</a><br /></td></tr>
<tr class="separator:ga5c37f8906313ab4e00e19c3b5928f5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b3d85865dccbbc135b19912115b52f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga4b3d85865dccbbc135b19912115b52f2">getri</a> (int n, double *A, int lda, const int *ipiv, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga4b3d85865dccbbc135b19912115b52f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense general double precision column-major square matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga4b3d85865dccbbc135b19912115b52f2">More...</a><br /></td></tr>
<tr class="separator:ga4b3d85865dccbbc135b19912115b52f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c380d6d2ddc79aa35d2510d21e87019"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga8c380d6d2ddc79aa35d2510d21e87019">getri</a> (int n, complex&lt; float &gt; *A, int lda, const int *ipiv, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga8c380d6d2ddc79aa35d2510d21e87019"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense general single precision complex column-major square matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga8c380d6d2ddc79aa35d2510d21e87019">More...</a><br /></td></tr>
<tr class="separator:ga8c380d6d2ddc79aa35d2510d21e87019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a9d0d71713c1298bc106d6aeeea1db9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga4a9d0d71713c1298bc106d6aeeea1db9">getri</a> (int n, complex&lt; double &gt; *A, int lda, const int *ipiv, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga4a9d0d71713c1298bc106d6aeeea1db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense general double precision complex column-major square matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga4a9d0d71713c1298bc106d6aeeea1db9">More...</a><br /></td></tr>
<tr class="separator:ga4a9d0d71713c1298bc106d6aeeea1db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a219343cb3d7574626daf02291e8fa7"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga9a219343cb3d7574626daf02291e8fa7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga9a219343cb3d7574626daf02291e8fa7">getri</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, const int *ipiv)</td></tr>
<tr class="memdesc:ga9a219343cb3d7574626daf02291e8fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense general matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga9a219343cb3d7574626daf02291e8fa7">More...</a><br /></td></tr>
<tr class="separator:ga9a219343cb3d7574626daf02291e8fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK LU-based substitution functions (getrs)</div></td></tr>
<tr class="memitem:gaf3830acfeb2859fb964ea188b09d0c8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#gaf3830acfeb2859fb964ea188b09d0c8e">getrs</a> (char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int n, int nrhs, const float *A, int lda, const int *ipiv, float *B, int ldb, int *info)</td></tr>
<tr class="memdesc:gaf3830acfeb2859fb964ea188b09d0c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a general single precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#gaf3830acfeb2859fb964ea188b09d0c8e">More...</a><br /></td></tr>
<tr class="separator:gaf3830acfeb2859fb964ea188b09d0c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ef562fa9e337679254703816f2c38f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga10ef562fa9e337679254703816f2c38f">getrs</a> (char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int n, int nrhs, const double *A, int lda, const int *ipiv, double *B, int ldb, int *info)</td></tr>
<tr class="memdesc:ga10ef562fa9e337679254703816f2c38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a general double precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga10ef562fa9e337679254703816f2c38f">More...</a><br /></td></tr>
<tr class="separator:ga10ef562fa9e337679254703816f2c38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a0f04f434bb3aab328f2b5d7ae18515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga6a0f04f434bb3aab328f2b5d7ae18515">getrs</a> (char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int n, int nrhs, const complex&lt; float &gt; *A, int lda, const int *ipiv, complex&lt; float &gt; *B, int ldb, int *info)</td></tr>
<tr class="memdesc:ga6a0f04f434bb3aab328f2b5d7ae18515"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a general single precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga6a0f04f434bb3aab328f2b5d7ae18515">More...</a><br /></td></tr>
<tr class="separator:ga6a0f04f434bb3aab328f2b5d7ae18515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga875018da363cbb082b51331d373662da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga875018da363cbb082b51331d373662da">getrs</a> (char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int n, int nrhs, const complex&lt; double &gt; *A, int lda, const int *ipiv, complex&lt; double &gt; *B, int ldb, int *info)</td></tr>
<tr class="memdesc:ga875018da363cbb082b51331d373662da"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a general double precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga875018da363cbb082b51331d373662da">More...</a><br /></td></tr>
<tr class="separator:ga875018da363cbb082b51331d373662da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606bdafc640aa4206b3bc5f8ce461f2c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga606bdafc640aa4206b3bc5f8ce461f2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga606bdafc640aa4206b3bc5f8ce461f2c">getrs</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;b, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, const int *ipiv)</td></tr>
<tr class="memdesc:ga606bdafc640aa4206b3bc5f8ce461f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a general linear system of equations ( <img class="formulaInl" alt="$ A*x=b $" src="../../form_149.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga606bdafc640aa4206b3bc5f8ce461f2c">More...</a><br /></td></tr>
<tr class="separator:ga606bdafc640aa4206b3bc5f8ce461f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga845ca4bec2884b8f451a5f5b404d2b3d"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga845ca4bec2884b8f451a5f5b404d2b3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga845ca4bec2884b8f451a5f5b404d2b3d">getrs</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;B, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, const int *ipiv)</td></tr>
<tr class="memdesc:ga845ca4bec2884b8f451a5f5b404d2b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a general linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga845ca4bec2884b8f451a5f5b404d2b3d">More...</a><br /></td></tr>
<tr class="separator:ga845ca4bec2884b8f451a5f5b404d2b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK Hermitian indefinite linear system functions (hesv)</div></td></tr>
<tr class="memitem:gaa25a22664b3d75b5f6e6bc8eefc211a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gaa25a22664b3d75b5f6e6bc8eefc211a2">hesv</a> (char uplo, int n, int nrhs, complex&lt; float &gt; *A, int lda, int *ipiv, complex&lt; float &gt; *B, int ldb, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gaa25a22664b3d75b5f6e6bc8eefc211a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a Hermitian indefinite single precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gaa25a22664b3d75b5f6e6bc8eefc211a2">More...</a><br /></td></tr>
<tr class="separator:gaa25a22664b3d75b5f6e6bc8eefc211a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749131fb195018629ba9af348699e74f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#ga749131fb195018629ba9af348699e74f">hesv</a> (char uplo, int n, int nrhs, complex&lt; double &gt; *A, int lda, int *ipiv, complex&lt; double &gt; *B, int ldb, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga749131fb195018629ba9af348699e74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a Hermitian indefinite double precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#ga749131fb195018629ba9af348699e74f">More...</a><br /></td></tr>
<tr class="separator:ga749131fb195018629ba9af348699e74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d8358bbff03abdd020eaaa27c075a1d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga3d8358bbff03abdd020eaaa27c075a1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#ga3d8358bbff03abdd020eaaa27c075a1d">hesv</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;b, char uplo, int *ipiv)</td></tr>
<tr class="memdesc:ga3d8358bbff03abdd020eaaa27c075a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a Hermitian indefinite linear system of equations ( <img class="formulaInl" alt="$ A*x=b $" src="../../form_149.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#ga3d8358bbff03abdd020eaaa27c075a1d">More...</a><br /></td></tr>
<tr class="separator:ga3d8358bbff03abdd020eaaa27c075a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d7288dafd26fa61fcc86edf6d1b2b22"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga9d7288dafd26fa61fcc86edf6d1b2b22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#ga9d7288dafd26fa61fcc86edf6d1b2b22">hesv</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;B, char uplo, int *ipiv)</td></tr>
<tr class="memdesc:ga9d7288dafd26fa61fcc86edf6d1b2b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a Hermitian indefinite linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#ga9d7288dafd26fa61fcc86edf6d1b2b22">More...</a><br /></td></tr>
<tr class="separator:ga9d7288dafd26fa61fcc86edf6d1b2b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK LDLH decomposition functions (hetrf)</div></td></tr>
<tr class="memitem:ga97e4983d060a22050c9048ac9970a95a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga97e4983d060a22050c9048ac9970a95a">hetrf</a> (char uplo, int n, complex&lt; float &gt; *A, int lda, int *ipiv, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga97e4983d060a22050c9048ac9970a95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the decomposition of the given dense Hermitian indefinite single precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga97e4983d060a22050c9048ac9970a95a">More...</a><br /></td></tr>
<tr class="separator:ga97e4983d060a22050c9048ac9970a95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec37d39a35816eb025623e71132d173f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaec37d39a35816eb025623e71132d173f">hetrf</a> (char uplo, int n, complex&lt; double &gt; *A, int lda, int *ipiv, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gaec37d39a35816eb025623e71132d173f"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the decomposition of the given dense Hermitian indefinite double precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gaec37d39a35816eb025623e71132d173f">More...</a><br /></td></tr>
<tr class="separator:gaec37d39a35816eb025623e71132d173f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca36b2e978ce74349d02c7ec899947c4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaca36b2e978ce74349d02c7ec899947c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaca36b2e978ce74349d02c7ec899947c4">hetrf</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, char uplo, int *ipiv)</td></tr>
<tr class="memdesc:gaca36b2e978ce74349d02c7ec899947c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the decomposition of the given dense Hermitian indefinite matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gaca36b2e978ce74349d02c7ec899947c4">More...</a><br /></td></tr>
<tr class="separator:gaca36b2e978ce74349d02c7ec899947c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK LDLH-based inversion functions (hetri)</div></td></tr>
<tr class="memitem:ga7b29a2ef47ef81d174e28c390cfa08e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga7b29a2ef47ef81d174e28c390cfa08e9">hetri</a> (char uplo, int n, complex&lt; float &gt; *A, int lda, const int *ipiv, complex&lt; float &gt; *work, int *info)</td></tr>
<tr class="memdesc:ga7b29a2ef47ef81d174e28c390cfa08e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense Hermitian indefinite single precision complex column-major square matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga7b29a2ef47ef81d174e28c390cfa08e9">More...</a><br /></td></tr>
<tr class="separator:ga7b29a2ef47ef81d174e28c390cfa08e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d439a9a0a741bf6f039d775aa8a21e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga58d439a9a0a741bf6f039d775aa8a21e">hetri</a> (char uplo, int n, complex&lt; double &gt; *A, int lda, const int *ipiv, complex&lt; double &gt; *work, int *info)</td></tr>
<tr class="memdesc:ga58d439a9a0a741bf6f039d775aa8a21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense Hermitian indefinite double precision complex column-major square matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga58d439a9a0a741bf6f039d775aa8a21e">More...</a><br /></td></tr>
<tr class="separator:ga58d439a9a0a741bf6f039d775aa8a21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad19e541ebac52da62cd6c162be64a4c9"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad19e541ebac52da62cd6c162be64a4c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#gad19e541ebac52da62cd6c162be64a4c9">hetri</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, char uplo, const int *ipiv)</td></tr>
<tr class="memdesc:gad19e541ebac52da62cd6c162be64a4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense Hermitian indefinite matrix.  <a href="../../d7/d92/group__lapack__inversion.html#gad19e541ebac52da62cd6c162be64a4c9">More...</a><br /></td></tr>
<tr class="separator:gad19e541ebac52da62cd6c162be64a4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK LDLH-based substitution functions (hetrs)</div></td></tr>
<tr class="memitem:gaa5fa49b1967a6fdd70050bbf74bcd8a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#gaa5fa49b1967a6fdd70050bbf74bcd8a7">hetrs</a> (char uplo, int n, int nrhs, const complex&lt; float &gt; *A, int lda, const int *ipiv, complex&lt; float &gt; *B, int ldb, int *info)</td></tr>
<tr class="memdesc:gaa5fa49b1967a6fdd70050bbf74bcd8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a symmetric indefinite single precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#gaa5fa49b1967a6fdd70050bbf74bcd8a7">More...</a><br /></td></tr>
<tr class="separator:gaa5fa49b1967a6fdd70050bbf74bcd8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d2f56224bc61d9e55912b4531287ec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga4d2f56224bc61d9e55912b4531287ec3">hetrs</a> (char uplo, int n, int nrhs, const complex&lt; double &gt; *A, int lda, const int *ipiv, complex&lt; double &gt; *B, int ldb, int *info)</td></tr>
<tr class="memdesc:ga4d2f56224bc61d9e55912b4531287ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a symmetric indefinite double precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga4d2f56224bc61d9e55912b4531287ec3">More...</a><br /></td></tr>
<tr class="separator:ga4d2f56224bc61d9e55912b4531287ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9032e9aaff18501df6dbdeb742fac389"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga9032e9aaff18501df6dbdeb742fac389"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga9032e9aaff18501df6dbdeb742fac389">hetrs</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;b, char uplo, const int *ipiv)</td></tr>
<tr class="memdesc:ga9032e9aaff18501df6dbdeb742fac389"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a symmetric indefinite linear system of equations ( <img class="formulaInl" alt="$ A*x=b $" src="../../form_149.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga9032e9aaff18501df6dbdeb742fac389">More...</a><br /></td></tr>
<tr class="separator:ga9032e9aaff18501df6dbdeb742fac389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef892e50ae0d5d05f7d2916ba4ac0e2c"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:gaef892e50ae0d5d05f7d2916ba4ac0e2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#gaef892e50ae0d5d05f7d2916ba4ac0e2c">hetrs</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;B, char uplo, const int *ipiv)</td></tr>
<tr class="memdesc:gaef892e50ae0d5d05f7d2916ba4ac0e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a symmetric indefinite linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#gaef892e50ae0d5d05f7d2916ba4ac0e2c">More...</a><br /></td></tr>
<tr class="separator:gaef892e50ae0d5d05f7d2916ba4ac0e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to reconstruct Q from a LQ decomposition (orglq)</div></td></tr>
<tr class="memitem:ga14bbcfbc52995f02337783ced0d80885"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga14bbcfbc52995f02337783ced0d80885">orglq</a> (int m, int n, int k, float *A, int lda, const float *tau, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga14bbcfbc52995f02337783ced0d80885"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a LQ decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga14bbcfbc52995f02337783ced0d80885">More...</a><br /></td></tr>
<tr class="separator:ga14bbcfbc52995f02337783ced0d80885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a4a2005d7f0a27f407acde1ef23a79f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga8a4a2005d7f0a27f407acde1ef23a79f">orglq</a> (int m, int n, int k, double *A, int lda, const double *tau, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga8a4a2005d7f0a27f407acde1ef23a79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a LQ decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga8a4a2005d7f0a27f407acde1ef23a79f">More...</a><br /></td></tr>
<tr class="separator:ga8a4a2005d7f0a27f407acde1ef23a79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea2ab9314c24a1874d3b817571585e44"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaea2ab9314c24a1874d3b817571585e44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaea2ab9314c24a1874d3b817571585e44">orglq</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; *tau)</td></tr>
<tr class="memdesc:gaea2ab9314c24a1874d3b817571585e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a LQ decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#gaea2ab9314c24a1874d3b817571585e44">More...</a><br /></td></tr>
<tr class="separator:gaea2ab9314c24a1874d3b817571585e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to reconstruct Q from a QL decomposition (orgql)</div></td></tr>
<tr class="memitem:ga68fa055ccc673fe05f7693310fd486ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga68fa055ccc673fe05f7693310fd486ec">orgql</a> (int m, int n, int k, float *A, int lda, const float *tau, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga68fa055ccc673fe05f7693310fd486ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a QL decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga68fa055ccc673fe05f7693310fd486ec">More...</a><br /></td></tr>
<tr class="separator:ga68fa055ccc673fe05f7693310fd486ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadcfd82511cf0db939db00b9fe228bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaadcfd82511cf0db939db00b9fe228bec">orgql</a> (int m, int n, int k, double *A, int lda, const double *tau, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gaadcfd82511cf0db939db00b9fe228bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a QL decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#gaadcfd82511cf0db939db00b9fe228bec">More...</a><br /></td></tr>
<tr class="separator:gaadcfd82511cf0db939db00b9fe228bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5750e7d7cad2b0fb4e7b61811e9168d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae5750e7d7cad2b0fb4e7b61811e9168d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gae5750e7d7cad2b0fb4e7b61811e9168d">orgql</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; *tau)</td></tr>
<tr class="memdesc:gae5750e7d7cad2b0fb4e7b61811e9168d"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a QL decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#gae5750e7d7cad2b0fb4e7b61811e9168d">More...</a><br /></td></tr>
<tr class="separator:gae5750e7d7cad2b0fb4e7b61811e9168d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to reconstruct Q from a QR decomposition (orgqr)</div></td></tr>
<tr class="memitem:ga00aac925f978b68ae6ab2b8294712719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga00aac925f978b68ae6ab2b8294712719">orgqr</a> (int m, int n, int k, float *A, int lda, const float *tau, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga00aac925f978b68ae6ab2b8294712719"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a QR decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga00aac925f978b68ae6ab2b8294712719">More...</a><br /></td></tr>
<tr class="separator:ga00aac925f978b68ae6ab2b8294712719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga221f8ab8df43bcb1481b30930aac0d81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga221f8ab8df43bcb1481b30930aac0d81">orgqr</a> (int m, int n, int k, double *A, int lda, const double *tau, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga221f8ab8df43bcb1481b30930aac0d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a QR decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga221f8ab8df43bcb1481b30930aac0d81">More...</a><br /></td></tr>
<tr class="separator:ga221f8ab8df43bcb1481b30930aac0d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac409d9feaa24e62be18e65a24bf9703f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac409d9feaa24e62be18e65a24bf9703f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gac409d9feaa24e62be18e65a24bf9703f">orgqr</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; *tau)</td></tr>
<tr class="memdesc:gac409d9feaa24e62be18e65a24bf9703f"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a QR decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#gac409d9feaa24e62be18e65a24bf9703f">More...</a><br /></td></tr>
<tr class="separator:gac409d9feaa24e62be18e65a24bf9703f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to reconstruct Q from a RQ decomposition (orgrq)</div></td></tr>
<tr class="memitem:ga6c4353b7fe2445a12fd84b74ffd52646"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga6c4353b7fe2445a12fd84b74ffd52646">orgrq</a> (int m, int n, int k, float *A, int lda, const float *tau, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga6c4353b7fe2445a12fd84b74ffd52646"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a RQ decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga6c4353b7fe2445a12fd84b74ffd52646">More...</a><br /></td></tr>
<tr class="separator:ga6c4353b7fe2445a12fd84b74ffd52646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a457bda5fc522cd13429276536f8884"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga7a457bda5fc522cd13429276536f8884">orgrq</a> (int m, int n, int k, double *A, int lda, const double *tau, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga7a457bda5fc522cd13429276536f8884"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a RQ decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga7a457bda5fc522cd13429276536f8884">More...</a><br /></td></tr>
<tr class="separator:ga7a457bda5fc522cd13429276536f8884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed3240907485ef2fc95dd4077ac84c70"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaed3240907485ef2fc95dd4077ac84c70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaed3240907485ef2fc95dd4077ac84c70">orgrq</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; *tau)</td></tr>
<tr class="memdesc:gaed3240907485ef2fc95dd4077ac84c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a RQ decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#gaed3240907485ef2fc95dd4077ac84c70">More...</a><br /></td></tr>
<tr class="separator:gaed3240907485ef2fc95dd4077ac84c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to multiply Q from a LQ decomposition with a matrix (ormlq)</div></td></tr>
<tr class="memitem:ga45a251e035e5df64ad3a463d5491264c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga45a251e035e5df64ad3a463d5491264c">ormlq</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const float *A, int lda, const float *tau, float *C, int ldc, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga45a251e035e5df64ad3a463d5491264c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the single precision Q from a LQ decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga45a251e035e5df64ad3a463d5491264c">More...</a><br /></td></tr>
<tr class="separator:ga45a251e035e5df64ad3a463d5491264c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ccc1625d125f8f19fd763e2fd2f8fa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga4ccc1625d125f8f19fd763e2fd2f8fa7">ormlq</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const double *A, int lda, const double *tau, double *C, int ldc, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga4ccc1625d125f8f19fd763e2fd2f8fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a LQ decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga4ccc1625d125f8f19fd763e2fd2f8fa7">More...</a><br /></td></tr>
<tr class="separator:ga4ccc1625d125f8f19fd763e2fd2f8fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d76a2a2fba0e4a97955371bfb9ed4ca"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga6d76a2a2fba0e4a97955371bfb9ed4ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga6d76a2a2fba0e4a97955371bfb9ed4ca">ormlq</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;C, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;A, char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT2 &gt; *tau)</td></tr>
<tr class="memdesc:ga6d76a2a2fba0e4a97955371bfb9ed4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a LQ decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga6d76a2a2fba0e4a97955371bfb9ed4ca">More...</a><br /></td></tr>
<tr class="separator:ga6d76a2a2fba0e4a97955371bfb9ed4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to multiply Q from a QL decomposition with a matrix (ormql)</div></td></tr>
<tr class="memitem:ga39d055f07fb5e17108bed3da0a27a3da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga39d055f07fb5e17108bed3da0a27a3da">ormql</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const float *A, int lda, const float *tau, float *C, int ldc, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga39d055f07fb5e17108bed3da0a27a3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the single precision Q from a QL decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga39d055f07fb5e17108bed3da0a27a3da">More...</a><br /></td></tr>
<tr class="separator:ga39d055f07fb5e17108bed3da0a27a3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga991ff678c8cb6a9173f4b20067c928be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga991ff678c8cb6a9173f4b20067c928be">ormql</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const double *A, int lda, const double *tau, double *C, int ldc, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga991ff678c8cb6a9173f4b20067c928be"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a QL decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga991ff678c8cb6a9173f4b20067c928be">More...</a><br /></td></tr>
<tr class="separator:ga991ff678c8cb6a9173f4b20067c928be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6191e96f11a8cdc3e524d9ae4fa7989"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:gaf6191e96f11a8cdc3e524d9ae4fa7989"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaf6191e96f11a8cdc3e524d9ae4fa7989">ormql</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;C, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;A, char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT2 &gt; *tau)</td></tr>
<tr class="memdesc:gaf6191e96f11a8cdc3e524d9ae4fa7989"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a QL decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gaf6191e96f11a8cdc3e524d9ae4fa7989">More...</a><br /></td></tr>
<tr class="separator:gaf6191e96f11a8cdc3e524d9ae4fa7989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to multiply Q from a QR decomposition with a matrix (ormqr)</div></td></tr>
<tr class="memitem:gaa0dd76b822f560195f758f49ed79428f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaa0dd76b822f560195f758f49ed79428f">ormqr</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const float *A, int lda, const float *tau, float *C, int ldc, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gaa0dd76b822f560195f758f49ed79428f"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the single precision Q from a QR decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gaa0dd76b822f560195f758f49ed79428f">More...</a><br /></td></tr>
<tr class="separator:gaa0dd76b822f560195f758f49ed79428f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga794297c3b943713cee77368ce8192eca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga794297c3b943713cee77368ce8192eca">ormqr</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const double *A, int lda, const double *tau, double *C, int ldc, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga794297c3b943713cee77368ce8192eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a QR decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga794297c3b943713cee77368ce8192eca">More...</a><br /></td></tr>
<tr class="separator:ga794297c3b943713cee77368ce8192eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d08a30d8d6dd560b39c1b8c186c5cfc"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga4d08a30d8d6dd560b39c1b8c186c5cfc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga4d08a30d8d6dd560b39c1b8c186c5cfc">ormqr</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;C, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;A, char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT2 &gt; *tau)</td></tr>
<tr class="memdesc:ga4d08a30d8d6dd560b39c1b8c186c5cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a QR decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga4d08a30d8d6dd560b39c1b8c186c5cfc">More...</a><br /></td></tr>
<tr class="separator:ga4d08a30d8d6dd560b39c1b8c186c5cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to multiply Q from a RQ decomposition with a matrix (ormrq)</div></td></tr>
<tr class="memitem:ga5e2389e0d4a91184f453d635f7c0a06d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga5e2389e0d4a91184f453d635f7c0a06d">ormrq</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const float *A, int lda, const float *tau, float *C, int ldc, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga5e2389e0d4a91184f453d635f7c0a06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the single precision Q from a RQ decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga5e2389e0d4a91184f453d635f7c0a06d">More...</a><br /></td></tr>
<tr class="separator:ga5e2389e0d4a91184f453d635f7c0a06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85fb0698cdfe5e3d9f49c5f9a495f082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga85fb0698cdfe5e3d9f49c5f9a495f082">ormrq</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const double *A, int lda, const double *tau, double *C, int ldc, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga85fb0698cdfe5e3d9f49c5f9a495f082"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a RQ decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga85fb0698cdfe5e3d9f49c5f9a495f082">More...</a><br /></td></tr>
<tr class="separator:ga85fb0698cdfe5e3d9f49c5f9a495f082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cf91cec11785eb05226de6a91c4d3a"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga98cf91cec11785eb05226de6a91c4d3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga98cf91cec11785eb05226de6a91c4d3a">ormrq</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;C, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;A, char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT2 &gt; *tau)</td></tr>
<tr class="memdesc:ga98cf91cec11785eb05226de6a91c4d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a RQ decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga98cf91cec11785eb05226de6a91c4d3a">More...</a><br /></td></tr>
<tr class="separator:ga98cf91cec11785eb05226de6a91c4d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK positive definite linear system functions (posv)</div></td></tr>
<tr class="memitem:gaf4d5bc0ab7862dee29926f6b20f607c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gaf4d5bc0ab7862dee29926f6b20f607c8">posv</a> (char uplo, int n, int nrhs, float *A, int lda, float *B, int ldb, int *info)</td></tr>
<tr class="memdesc:gaf4d5bc0ab7862dee29926f6b20f607c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a positive definite single precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gaf4d5bc0ab7862dee29926f6b20f607c8">More...</a><br /></td></tr>
<tr class="separator:gaf4d5bc0ab7862dee29926f6b20f607c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacee77c39f299090b50f8151bcba59edf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gacee77c39f299090b50f8151bcba59edf">posv</a> (char uplo, int n, int nrhs, double *A, int lda, double *B, int ldb, int *info)</td></tr>
<tr class="memdesc:gacee77c39f299090b50f8151bcba59edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a positive definite double precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gacee77c39f299090b50f8151bcba59edf">More...</a><br /></td></tr>
<tr class="separator:gacee77c39f299090b50f8151bcba59edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4eb25dc80bca268586b2c55a42cbfd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gae4eb25dc80bca268586b2c55a42cbfd8">posv</a> (char uplo, int n, int nrhs, complex&lt; float &gt; *A, int lda, complex&lt; float &gt; *B, int ldb, int *info)</td></tr>
<tr class="memdesc:gae4eb25dc80bca268586b2c55a42cbfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a positive definite single precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gae4eb25dc80bca268586b2c55a42cbfd8">More...</a><br /></td></tr>
<tr class="separator:gae4eb25dc80bca268586b2c55a42cbfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa408e8fc7ddcbb16863e0e9a599f8b24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gaa408e8fc7ddcbb16863e0e9a599f8b24">posv</a> (char uplo, int n, int nrhs, complex&lt; double &gt; *A, int lda, complex&lt; double &gt; *B, int ldb, int *info)</td></tr>
<tr class="memdesc:gaa408e8fc7ddcbb16863e0e9a599f8b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a positive definite double precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gaa408e8fc7ddcbb16863e0e9a599f8b24">More...</a><br /></td></tr>
<tr class="separator:gaa408e8fc7ddcbb16863e0e9a599f8b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2622f883130d608a6e57b9ddce5dd73"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaf2622f883130d608a6e57b9ddce5dd73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gaf2622f883130d608a6e57b9ddce5dd73">posv</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;b, char uplo)</td></tr>
<tr class="memdesc:gaf2622f883130d608a6e57b9ddce5dd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a positive definite linear system of equations ( <img class="formulaInl" alt="$ A*x=b $" src="../../form_149.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gaf2622f883130d608a6e57b9ddce5dd73">More...</a><br /></td></tr>
<tr class="separator:gaf2622f883130d608a6e57b9ddce5dd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga504865aac68cc4b68d390e638c798a57"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga504865aac68cc4b68d390e638c798a57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#ga504865aac68cc4b68d390e638c798a57">posv</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;B, char uplo)</td></tr>
<tr class="memdesc:ga504865aac68cc4b68d390e638c798a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a positive definite linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#ga504865aac68cc4b68d390e638c798a57">More...</a><br /></td></tr>
<tr class="separator:ga504865aac68cc4b68d390e638c798a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK LLH (Cholesky) decomposition functions (potrf)</div></td></tr>
<tr class="memitem:ga5d7ef4ba1ebe56b25c757a49366b881c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga5d7ef4ba1ebe56b25c757a49366b881c">potrf</a> (char uplo, int n, float *A, int lda, int *info)</td></tr>
<tr class="memdesc:ga5d7ef4ba1ebe56b25c757a49366b881c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the Cholesky decomposition of the given dense positive definite single precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga5d7ef4ba1ebe56b25c757a49366b881c">More...</a><br /></td></tr>
<tr class="separator:ga5d7ef4ba1ebe56b25c757a49366b881c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89cf82a4ffc9b8b07a39e0c9b4bf809"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gad89cf82a4ffc9b8b07a39e0c9b4bf809">potrf</a> (char uplo, int n, double *A, int lda, int *info)</td></tr>
<tr class="memdesc:gad89cf82a4ffc9b8b07a39e0c9b4bf809"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the Cholesky decomposition of the given dense positive definite double precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gad89cf82a4ffc9b8b07a39e0c9b4bf809">More...</a><br /></td></tr>
<tr class="separator:gad89cf82a4ffc9b8b07a39e0c9b4bf809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf674837b926d1f3fe97d5c27778cb0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gacf674837b926d1f3fe97d5c27778cb0e">potrf</a> (char uplo, int n, complex&lt; float &gt; *A, int lda, int *info)</td></tr>
<tr class="memdesc:gacf674837b926d1f3fe97d5c27778cb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the Cholesky decomposition of the given dense positive definite single precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gacf674837b926d1f3fe97d5c27778cb0e">More...</a><br /></td></tr>
<tr class="separator:gacf674837b926d1f3fe97d5c27778cb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ec78cd86940a43bc5ad8fbf6509f3f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga2ec78cd86940a43bc5ad8fbf6509f3f8">potrf</a> (char uplo, int n, complex&lt; double &gt; *A, int lda, int *info)</td></tr>
<tr class="memdesc:ga2ec78cd86940a43bc5ad8fbf6509f3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the Cholesky decomposition of the given dense positive definite double precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga2ec78cd86940a43bc5ad8fbf6509f3f8">More...</a><br /></td></tr>
<tr class="separator:ga2ec78cd86940a43bc5ad8fbf6509f3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4de1b17567f64c37e4c03730e1df01a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad4de1b17567f64c37e4c03730e1df01a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gad4de1b17567f64c37e4c03730e1df01a">potrf</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, char uplo)</td></tr>
<tr class="memdesc:gad4de1b17567f64c37e4c03730e1df01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the Cholesky decomposition of the given dense positive definite matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gad4de1b17567f64c37e4c03730e1df01a">More...</a><br /></td></tr>
<tr class="separator:gad4de1b17567f64c37e4c03730e1df01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK LLH-based inversion functions (potri)</div></td></tr>
<tr class="memitem:ga5ce1fa9527f3260e1b35c69f5aa292ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga5ce1fa9527f3260e1b35c69f5aa292ee">potri</a> (char uplo, int n, float *A, int lda, int *info)</td></tr>
<tr class="memdesc:ga5ce1fa9527f3260e1b35c69f5aa292ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense positive definite single precision column-major square matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga5ce1fa9527f3260e1b35c69f5aa292ee">More...</a><br /></td></tr>
<tr class="separator:ga5ce1fa9527f3260e1b35c69f5aa292ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab607a6775378ee87bda3a10b782774e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#gab607a6775378ee87bda3a10b782774e8">potri</a> (char uplo, int n, double *A, int lda, int *info)</td></tr>
<tr class="memdesc:gab607a6775378ee87bda3a10b782774e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense positive definite double precision column-major square matrix.  <a href="../../d7/d92/group__lapack__inversion.html#gab607a6775378ee87bda3a10b782774e8">More...</a><br /></td></tr>
<tr class="separator:gab607a6775378ee87bda3a10b782774e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2dab30879edbe7d06033f653cf53135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#gaa2dab30879edbe7d06033f653cf53135">potri</a> (char uplo, int n, complex&lt; float &gt; *A, int lda, int *info)</td></tr>
<tr class="memdesc:gaa2dab30879edbe7d06033f653cf53135"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense positive definite single precision complex column-major square matrix.  <a href="../../d7/d92/group__lapack__inversion.html#gaa2dab30879edbe7d06033f653cf53135">More...</a><br /></td></tr>
<tr class="separator:gaa2dab30879edbe7d06033f653cf53135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0bc9455ab68f76a3ea6884f73b79de1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#gab0bc9455ab68f76a3ea6884f73b79de1">potri</a> (char uplo, int n, complex&lt; double &gt; *A, int lda, int *info)</td></tr>
<tr class="memdesc:gab0bc9455ab68f76a3ea6884f73b79de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense positive definite double precision complex column-major square matrix.  <a href="../../d7/d92/group__lapack__inversion.html#gab0bc9455ab68f76a3ea6884f73b79de1">More...</a><br /></td></tr>
<tr class="separator:gab0bc9455ab68f76a3ea6884f73b79de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9141730536701f5c7d735aa1dc445f8b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga9141730536701f5c7d735aa1dc445f8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga9141730536701f5c7d735aa1dc445f8b">potri</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, char uplo)</td></tr>
<tr class="memdesc:ga9141730536701f5c7d735aa1dc445f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense positive definite matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga9141730536701f5c7d735aa1dc445f8b">More...</a><br /></td></tr>
<tr class="separator:ga9141730536701f5c7d735aa1dc445f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK LLH-based substitution functions (potrs)</div></td></tr>
<tr class="memitem:ga64ae466db22825ed9214d3895d0d9823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga64ae466db22825ed9214d3895d0d9823">potrs</a> (char uplo, int n, int nrhs, const float *A, int lda, float *B, int ldb, int *info)</td></tr>
<tr class="memdesc:ga64ae466db22825ed9214d3895d0d9823"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a positive definite single precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga64ae466db22825ed9214d3895d0d9823">More...</a><br /></td></tr>
<tr class="separator:ga64ae466db22825ed9214d3895d0d9823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9994d63d33048e8f369c81319c5c3f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#gae9994d63d33048e8f369c81319c5c3f1">potrs</a> (char uplo, int n, int nrhs, const double *A, int lda, double *B, int ldb, int *info)</td></tr>
<tr class="memdesc:gae9994d63d33048e8f369c81319c5c3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a positive definite double precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#gae9994d63d33048e8f369c81319c5c3f1">More...</a><br /></td></tr>
<tr class="separator:gae9994d63d33048e8f369c81319c5c3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e6d1e5b7938ef57d6b7bccd46f8d3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#gac7e6d1e5b7938ef57d6b7bccd46f8d3a">potrs</a> (char uplo, int n, int nrhs, const complex&lt; float &gt; *A, int lda, complex&lt; float &gt; *B, int ldb, int *info)</td></tr>
<tr class="memdesc:gac7e6d1e5b7938ef57d6b7bccd46f8d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a positive definite single precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#gac7e6d1e5b7938ef57d6b7bccd46f8d3a">More...</a><br /></td></tr>
<tr class="separator:gac7e6d1e5b7938ef57d6b7bccd46f8d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga438f3f0507cf493379b7fc0458e85c96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga438f3f0507cf493379b7fc0458e85c96">potrs</a> (char uplo, int n, int nrhs, const complex&lt; double &gt; *A, int lda, complex&lt; double &gt; *B, int ldb, int *info)</td></tr>
<tr class="memdesc:ga438f3f0507cf493379b7fc0458e85c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a positive definite double precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga438f3f0507cf493379b7fc0458e85c96">More...</a><br /></td></tr>
<tr class="separator:ga438f3f0507cf493379b7fc0458e85c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf03fd41565f253f372d88242e1d6f39c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaf03fd41565f253f372d88242e1d6f39c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#gaf03fd41565f253f372d88242e1d6f39c">potrs</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;b, char uplo)</td></tr>
<tr class="memdesc:gaf03fd41565f253f372d88242e1d6f39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a positive definite linear system of equations ( <img class="formulaInl" alt="$ A*x=b $" src="../../form_149.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#gaf03fd41565f253f372d88242e1d6f39c">More...</a><br /></td></tr>
<tr class="separator:gaf03fd41565f253f372d88242e1d6f39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf03a288ec92e36ae83aa3d5c9da2f6bd"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:gaf03a288ec92e36ae83aa3d5c9da2f6bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#gaf03a288ec92e36ae83aa3d5c9da2f6bd">potrs</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;B, char uplo)</td></tr>
<tr class="memdesc:gaf03a288ec92e36ae83aa3d5c9da2f6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a positive definite linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#gaf03a288ec92e36ae83aa3d5c9da2f6bd">More...</a><br /></td></tr>
<tr class="separator:gaf03a288ec92e36ae83aa3d5c9da2f6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK symmetric indefinite linear system functions (sysv)</div></td></tr>
<tr class="memitem:gaa31da1502320f7cf58a289825f5036a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gaa31da1502320f7cf58a289825f5036a1">sysv</a> (char uplo, int n, int nrhs, float *A, int lda, int *ipiv, float *B, int ldb, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gaa31da1502320f7cf58a289825f5036a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a symmetric indefinite single precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gaa31da1502320f7cf58a289825f5036a1">More...</a><br /></td></tr>
<tr class="separator:gaa31da1502320f7cf58a289825f5036a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad347cbbe69a6c3e4dcc32d93f4b2d06c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gad347cbbe69a6c3e4dcc32d93f4b2d06c">sysv</a> (char uplo, int n, int nrhs, double *A, int lda, int *ipiv, double *B, int ldb, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gad347cbbe69a6c3e4dcc32d93f4b2d06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a symmetric indefinite double precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gad347cbbe69a6c3e4dcc32d93f4b2d06c">More...</a><br /></td></tr>
<tr class="separator:gad347cbbe69a6c3e4dcc32d93f4b2d06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2058f2e04ff95d15548727dfa16b292c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#ga2058f2e04ff95d15548727dfa16b292c">sysv</a> (char uplo, int n, int nrhs, complex&lt; float &gt; *A, int lda, int *ipiv, complex&lt; float &gt; *B, int ldb, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga2058f2e04ff95d15548727dfa16b292c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a symmetric indefinite single precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#ga2058f2e04ff95d15548727dfa16b292c">More...</a><br /></td></tr>
<tr class="separator:ga2058f2e04ff95d15548727dfa16b292c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadad49b809aec26face223fd52f6d8678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gadad49b809aec26face223fd52f6d8678">sysv</a> (char uplo, int n, int nrhs, complex&lt; double &gt; *A, int lda, int *ipiv, complex&lt; double &gt; *B, int ldb, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gadad49b809aec26face223fd52f6d8678"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a symmetric indefinite double precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gadad49b809aec26face223fd52f6d8678">More...</a><br /></td></tr>
<tr class="separator:gadad49b809aec26face223fd52f6d8678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff44898ef086f0afba6b248e80dce30"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gabff44898ef086f0afba6b248e80dce30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gabff44898ef086f0afba6b248e80dce30">sysv</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;b, char uplo, int *ipiv)</td></tr>
<tr class="memdesc:gabff44898ef086f0afba6b248e80dce30"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a symmetric indefinite linear system of equations ( <img class="formulaInl" alt="$ A*x=b $" src="../../form_149.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gabff44898ef086f0afba6b248e80dce30">More...</a><br /></td></tr>
<tr class="separator:gabff44898ef086f0afba6b248e80dce30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3addebbbf6ea1d12003aa42e48d617e"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:gab3addebbbf6ea1d12003aa42e48d617e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gab3addebbbf6ea1d12003aa42e48d617e">sysv</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;B, char uplo, int *ipiv)</td></tr>
<tr class="memdesc:gab3addebbbf6ea1d12003aa42e48d617e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a symmetric indefinite linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gab3addebbbf6ea1d12003aa42e48d617e">More...</a><br /></td></tr>
<tr class="separator:gab3addebbbf6ea1d12003aa42e48d617e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK LDLT decomposition functions (sytrf)</div></td></tr>
<tr class="memitem:ga2d56eb2fb40e764952ac50d86eaeba6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga2d56eb2fb40e764952ac50d86eaeba6e">sytrf</a> (char uplo, int n, float *A, int lda, int *ipiv, float *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga2d56eb2fb40e764952ac50d86eaeba6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the decomposition of the given dense symmetric indefinite single precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga2d56eb2fb40e764952ac50d86eaeba6e">More...</a><br /></td></tr>
<tr class="separator:ga2d56eb2fb40e764952ac50d86eaeba6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e1129636034675480cab0eb35b707da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga3e1129636034675480cab0eb35b707da">sytrf</a> (char uplo, int n, double *A, int lda, int *ipiv, double *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga3e1129636034675480cab0eb35b707da"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the decomposition of the given dense symmetric indefinite double precision column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga3e1129636034675480cab0eb35b707da">More...</a><br /></td></tr>
<tr class="separator:ga3e1129636034675480cab0eb35b707da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96724dc8778475a2c5edfa853bcfd041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga96724dc8778475a2c5edfa853bcfd041">sytrf</a> (char uplo, int n, complex&lt; float &gt; *A, int lda, int *ipiv, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga96724dc8778475a2c5edfa853bcfd041"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the decomposition of the given dense symmetric indefinite single precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga96724dc8778475a2c5edfa853bcfd041">More...</a><br /></td></tr>
<tr class="separator:ga96724dc8778475a2c5edfa853bcfd041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce888f6162102e69d48b317f6f9efe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga2ce888f6162102e69d48b317f6f9efe7">sytrf</a> (char uplo, int n, complex&lt; double &gt; *A, int lda, int *ipiv, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga2ce888f6162102e69d48b317f6f9efe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the decomposition of the given dense symmetric indefinite double precision complex column-major matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga2ce888f6162102e69d48b317f6f9efe7">More...</a><br /></td></tr>
<tr class="separator:ga2ce888f6162102e69d48b317f6f9efe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2147909cb50231729ce5a4233cee1f59"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga2147909cb50231729ce5a4233cee1f59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga2147909cb50231729ce5a4233cee1f59">sytrf</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, char uplo, int *ipiv)</td></tr>
<tr class="memdesc:ga2147909cb50231729ce5a4233cee1f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the decomposition of the given dense symmetric indefinite matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga2147909cb50231729ce5a4233cee1f59">More...</a><br /></td></tr>
<tr class="separator:ga2147909cb50231729ce5a4233cee1f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK LDLT-based inversion functions (sytri)</div></td></tr>
<tr class="memitem:ga1eaf77e1ea74fa8e607cb639c80ec181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga1eaf77e1ea74fa8e607cb639c80ec181">sytri</a> (char uplo, int n, float *A, int lda, const int *ipiv, float *work, int *info)</td></tr>
<tr class="memdesc:ga1eaf77e1ea74fa8e607cb639c80ec181"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense symmetric indefinite single precision column-major square matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga1eaf77e1ea74fa8e607cb639c80ec181">More...</a><br /></td></tr>
<tr class="separator:ga1eaf77e1ea74fa8e607cb639c80ec181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ee3608a97e8f7f803708880cf0f4411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga2ee3608a97e8f7f803708880cf0f4411">sytri</a> (char uplo, int n, double *A, int lda, const int *ipiv, double *work, int *info)</td></tr>
<tr class="memdesc:ga2ee3608a97e8f7f803708880cf0f4411"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense symmetric indefinite double precision column-major square matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga2ee3608a97e8f7f803708880cf0f4411">More...</a><br /></td></tr>
<tr class="separator:ga2ee3608a97e8f7f803708880cf0f4411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2827c8b73d6e079f4c53f719dff0b23a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga2827c8b73d6e079f4c53f719dff0b23a">sytri</a> (char uplo, int n, complex&lt; float &gt; *A, int lda, const int *ipiv, complex&lt; float &gt; *work, int *info)</td></tr>
<tr class="memdesc:ga2827c8b73d6e079f4c53f719dff0b23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense symmetric indefinite single precision complex column-major square matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga2827c8b73d6e079f4c53f719dff0b23a">More...</a><br /></td></tr>
<tr class="separator:ga2827c8b73d6e079f4c53f719dff0b23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ce8195254a23f155f9a06051a6d14ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga4ce8195254a23f155f9a06051a6d14ef">sytri</a> (char uplo, int n, complex&lt; double &gt; *A, int lda, const int *ipiv, complex&lt; double &gt; *work, int *info)</td></tr>
<tr class="memdesc:ga4ce8195254a23f155f9a06051a6d14ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense symmetric indefinite double precision complex column-major square matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga4ce8195254a23f155f9a06051a6d14ef">More...</a><br /></td></tr>
<tr class="separator:ga4ce8195254a23f155f9a06051a6d14ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcecc39b5cf2d7a6159ef44f54205260"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gadcecc39b5cf2d7a6159ef44f54205260"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#gadcecc39b5cf2d7a6159ef44f54205260">sytri</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, char uplo, const int *ipiv)</td></tr>
<tr class="memdesc:gadcecc39b5cf2d7a6159ef44f54205260"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense symmetric indefinite matrix.  <a href="../../d7/d92/group__lapack__inversion.html#gadcecc39b5cf2d7a6159ef44f54205260">More...</a><br /></td></tr>
<tr class="separator:gadcecc39b5cf2d7a6159ef44f54205260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK LDLT-based substitution functions (sytrs)</div></td></tr>
<tr class="memitem:ga282053077b7b3c21445a32afd672dd51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga282053077b7b3c21445a32afd672dd51">sytrs</a> (char uplo, int n, int nrhs, const float *A, int lda, const int *ipiv, float *B, int ldb, int *info)</td></tr>
<tr class="memdesc:ga282053077b7b3c21445a32afd672dd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a symmetric indefinite single precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga282053077b7b3c21445a32afd672dd51">More...</a><br /></td></tr>
<tr class="separator:ga282053077b7b3c21445a32afd672dd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac449a5cb1c7be68140f3ec25076c8be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#gaac449a5cb1c7be68140f3ec25076c8be">sytrs</a> (char uplo, int n, int nrhs, const double *A, int lda, const int *ipiv, double *B, int ldb, int *info)</td></tr>
<tr class="memdesc:gaac449a5cb1c7be68140f3ec25076c8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a symmetric indefinite double precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#gaac449a5cb1c7be68140f3ec25076c8be">More...</a><br /></td></tr>
<tr class="separator:gaac449a5cb1c7be68140f3ec25076c8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ff5324506a7f1bd4d56c3dbf720407c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga3ff5324506a7f1bd4d56c3dbf720407c">sytrs</a> (char uplo, int n, int nrhs, const complex&lt; float &gt; *A, int lda, const int *ipiv, complex&lt; float &gt; *B, int ldb, int *info)</td></tr>
<tr class="memdesc:ga3ff5324506a7f1bd4d56c3dbf720407c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a symmetric indefinite single precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga3ff5324506a7f1bd4d56c3dbf720407c">More...</a><br /></td></tr>
<tr class="separator:ga3ff5324506a7f1bd4d56c3dbf720407c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd3eb77fc5584c8066d0f00927b6dbba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#gabd3eb77fc5584c8066d0f00927b6dbba">sytrs</a> (char uplo, int n, int nrhs, const complex&lt; double &gt; *A, int lda, const int *ipiv, complex&lt; double &gt; *B, int ldb, int *info)</td></tr>
<tr class="memdesc:gabd3eb77fc5584c8066d0f00927b6dbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a symmetric indefinite double precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#gabd3eb77fc5584c8066d0f00927b6dbba">More...</a><br /></td></tr>
<tr class="separator:gabd3eb77fc5584c8066d0f00927b6dbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ca140a4cc6bd9cd29e1c990aba2d49"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga24ca140a4cc6bd9cd29e1c990aba2d49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga24ca140a4cc6bd9cd29e1c990aba2d49">sytrs</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;b, char uplo, const int *ipiv)</td></tr>
<tr class="memdesc:ga24ca140a4cc6bd9cd29e1c990aba2d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a symmetric indefinite linear system of equations ( <img class="formulaInl" alt="$ A*x=b $" src="../../form_149.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga24ca140a4cc6bd9cd29e1c990aba2d49">More...</a><br /></td></tr>
<tr class="separator:ga24ca140a4cc6bd9cd29e1c990aba2d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2741a0de8ebd9939f9262afcf4ac372"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:gae2741a0de8ebd9939f9262afcf4ac372"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#gae2741a0de8ebd9939f9262afcf4ac372">sytrs</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;B, char uplo, const int *ipiv)</td></tr>
<tr class="memdesc:gae2741a0de8ebd9939f9262afcf4ac372"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a symmetric indefinite linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#gae2741a0de8ebd9939f9262afcf4ac372">More...</a><br /></td></tr>
<tr class="separator:gae2741a0de8ebd9939f9262afcf4ac372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK triangular linear system functions (trsv)</div></td></tr>
<tr class="memitem:gab4345dcee3f3e33c55d558e54012d9ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#gab4345dcee3f3e33c55d558e54012d9ac">trsv</a> (char uplo, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, char diag, int n, const float *A, int lda, float *x, int incX)</td></tr>
<tr class="memdesc:gab4345dcee3f3e33c55d558e54012d9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a triangular single precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#gab4345dcee3f3e33c55d558e54012d9ac">More...</a><br /></td></tr>
<tr class="separator:gab4345dcee3f3e33c55d558e54012d9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82f09f718104a0c20a130a2829683b7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#ga82f09f718104a0c20a130a2829683b7f">trsv</a> (char uplo, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, char diag, int n, const double *A, int lda, double *x, int incX)</td></tr>
<tr class="memdesc:ga82f09f718104a0c20a130a2829683b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a triangular double precision linear system of equations ( <img class="formulaInl" alt="$ A*x=b $" src="../../form_149.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#ga82f09f718104a0c20a130a2829683b7f">More...</a><br /></td></tr>
<tr class="separator:ga82f09f718104a0c20a130a2829683b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ececa9224b380da7a89a0715f2cfab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#ga7ececa9224b380da7a89a0715f2cfab0">trsv</a> (char uplo, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, char diag, int n, const complex&lt; float &gt; *A, int lda, complex&lt; float &gt; *x, int incX)</td></tr>
<tr class="memdesc:ga7ececa9224b380da7a89a0715f2cfab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a triangular single precision complex linear system of equations ( <img class="formulaInl" alt="$ A*x=b $" src="../../form_149.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#ga7ececa9224b380da7a89a0715f2cfab0">More...</a><br /></td></tr>
<tr class="separator:ga7ececa9224b380da7a89a0715f2cfab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa171adc536ab073f955cdc27682ed2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#ga2aa171adc536ab073f955cdc27682ed2">trsv</a> (char uplo, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, char diag, int n, const complex&lt; double &gt; *A, int lda, complex&lt; double &gt; *x, int incX)</td></tr>
<tr class="memdesc:ga2aa171adc536ab073f955cdc27682ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a triangular double precision complex linear system of equations ( <img class="formulaInl" alt="$ A*x=b $" src="../../form_149.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#ga2aa171adc536ab073f955cdc27682ed2">More...</a><br /></td></tr>
<tr class="separator:ga2aa171adc536ab073f955cdc27682ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3ad850a574330272951332e9868587"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0f3ad850a574330272951332e9868587"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d5c/group__lapack__solver.html#ga0f3ad850a574330272951332e9868587">trsv</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;b, char uplo, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, char diag)</td></tr>
<tr class="memdesc:ga0f3ad850a574330272951332e9868587"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for solving a triangular linear system of equations ( <img class="formulaInl" alt="$ A*x=b $" src="../../form_149.png"/>). ( <img class="formulaInl" alt="$ A*x=b $" src="../../form_149.png"/>).  <a href="../../dd/d5c/group__lapack__solver.html#ga0f3ad850a574330272951332e9868587">More...</a><br /></td></tr>
<tr class="separator:ga0f3ad850a574330272951332e9868587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK triangular matrix inversion functions (trtri)</div></td></tr>
<tr class="memitem:ga16645bf5093a471939f51d4da8aed52f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga16645bf5093a471939f51d4da8aed52f">trtri</a> (char uplo, char diag, int n, float *A, int lda, int *info)</td></tr>
<tr class="memdesc:ga16645bf5093a471939f51d4da8aed52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense triangular single precision column-major matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga16645bf5093a471939f51d4da8aed52f">More...</a><br /></td></tr>
<tr class="separator:ga16645bf5093a471939f51d4da8aed52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b875590bd34960d9d7e32f2a331f5b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga4b875590bd34960d9d7e32f2a331f5b6">trtri</a> (char uplo, char diag, int n, double *A, int lda, int *info)</td></tr>
<tr class="memdesc:ga4b875590bd34960d9d7e32f2a331f5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense triangular double precision column-major matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga4b875590bd34960d9d7e32f2a331f5b6">More...</a><br /></td></tr>
<tr class="separator:ga4b875590bd34960d9d7e32f2a331f5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga581f8f8437c566f268b75c6787ff8719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga581f8f8437c566f268b75c6787ff8719">trtri</a> (char uplo, char diag, int n, complex&lt; float &gt; *A, int lda, int *info)</td></tr>
<tr class="memdesc:ga581f8f8437c566f268b75c6787ff8719"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense triangular single precision complex column-major matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga581f8f8437c566f268b75c6787ff8719">More...</a><br /></td></tr>
<tr class="separator:ga581f8f8437c566f268b75c6787ff8719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b736607030e7b738da7cfb9fc75cc0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga9b736607030e7b738da7cfb9fc75cc0c">trtri</a> (char uplo, char diag, int n, complex&lt; double &gt; *A, int lda, int *info)</td></tr>
<tr class="memdesc:ga9b736607030e7b738da7cfb9fc75cc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense triangular double precision complex column-major matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga9b736607030e7b738da7cfb9fc75cc0c">More...</a><br /></td></tr>
<tr class="separator:ga9b736607030e7b738da7cfb9fc75cc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b98c08e9466ab411603e8a4570947a9"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4b98c08e9466ab411603e8a4570947a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d92/group__lapack__inversion.html#ga4b98c08e9466ab411603e8a4570947a9">trtri</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, char uplo, char diag)</td></tr>
<tr class="memdesc:ga4b98c08e9466ab411603e8a4570947a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the inversion of the given dense triangular matrix.  <a href="../../d7/d92/group__lapack__inversion.html#ga4b98c08e9466ab411603e8a4570947a9">More...</a><br /></td></tr>
<tr class="separator:ga4b98c08e9466ab411603e8a4570947a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK triangular substitution functions (trtrs)</div></td></tr>
<tr class="memitem:ga3aec924250873f92da56589d76de61d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga3aec924250873f92da56589d76de61d5">trtrs</a> (char uplo, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, char diag, int n, int nrhs, const float *A, int lda, float *B, int ldb, int *info)</td></tr>
<tr class="memdesc:ga3aec924250873f92da56589d76de61d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a triangular single precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga3aec924250873f92da56589d76de61d5">More...</a><br /></td></tr>
<tr class="separator:ga3aec924250873f92da56589d76de61d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf3e308c4fdd9a382edd0da35f36404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#gafaf3e308c4fdd9a382edd0da35f36404">trtrs</a> (char uplo, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, char diag, int n, int nrhs, const double *A, int lda, double *B, int ldb, int *info)</td></tr>
<tr class="memdesc:gafaf3e308c4fdd9a382edd0da35f36404"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a triangular double precision linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#gafaf3e308c4fdd9a382edd0da35f36404">More...</a><br /></td></tr>
<tr class="separator:gafaf3e308c4fdd9a382edd0da35f36404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacd61bb476ce0433140127d173f442f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#gaacd61bb476ce0433140127d173f442f6">trtrs</a> (char uplo, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, char diag, int n, int nrhs, const complex&lt; float &gt; *A, int lda, complex&lt; float &gt; *B, int ldb, int *info)</td></tr>
<tr class="memdesc:gaacd61bb476ce0433140127d173f442f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a triangular single precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#gaacd61bb476ce0433140127d173f442f6">More...</a><br /></td></tr>
<tr class="separator:gaacd61bb476ce0433140127d173f442f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c34a2836c6a72cb6d867f0fe1129168"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga4c34a2836c6a72cb6d867f0fe1129168">trtrs</a> (char uplo, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, char diag, int n, int nrhs, const complex&lt; double &gt; *A, int lda, complex&lt; double &gt; *B, int ldb, int *info)</td></tr>
<tr class="memdesc:ga4c34a2836c6a72cb6d867f0fe1129168"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a triangular double precision complex linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga4c34a2836c6a72cb6d867f0fe1129168">More...</a><br /></td></tr>
<tr class="separator:ga4c34a2836c6a72cb6d867f0fe1129168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98f3936fcd5eacbf9e49cf2d2eeec5d2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga98f3936fcd5eacbf9e49cf2d2eeec5d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#ga98f3936fcd5eacbf9e49cf2d2eeec5d2">trtrs</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;b, char uplo, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, char diag)</td></tr>
<tr class="memdesc:ga98f3936fcd5eacbf9e49cf2d2eeec5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a triangular linear system of equations ( <img class="formulaInl" alt="$ A*x=b $" src="../../form_149.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#ga98f3936fcd5eacbf9e49cf2d2eeec5d2">More...</a><br /></td></tr>
<tr class="separator:ga98f3936fcd5eacbf9e49cf2d2eeec5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad37bf5859a23564e33151e92514ceb3a"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:gad37bf5859a23564e33151e92514ceb3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d49/group__lapack__substitution.html#gad37bf5859a23564e33151e92514ceb3a">trtrs</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;B, char uplo, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, char diag)</td></tr>
<tr class="memdesc:gad37bf5859a23564e33151e92514ceb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the substitution step of solving a triangular linear system of equations ( <img class="formulaInl" alt="$ A*X=B $" src="../../form_136.png"/>).  <a href="../../db/d49/group__lapack__substitution.html#gad37bf5859a23564e33151e92514ceb3a">More...</a><br /></td></tr>
<tr class="separator:gad37bf5859a23564e33151e92514ceb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to reconstruct Q from a LQ decomposition (unglq)</div></td></tr>
<tr class="memitem:gac6d66b82d553d9831e8ad77c99a0edd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gac6d66b82d553d9831e8ad77c99a0edd0">unglq</a> (int m, int n, int k, complex&lt; float &gt; *A, int lda, const complex&lt; float &gt; *tau, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gac6d66b82d553d9831e8ad77c99a0edd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a LQ decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#gac6d66b82d553d9831e8ad77c99a0edd0">More...</a><br /></td></tr>
<tr class="separator:gac6d66b82d553d9831e8ad77c99a0edd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd6491a00dd2324f1d5c19f007bde4d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gabd6491a00dd2324f1d5c19f007bde4d2">unglq</a> (int m, int n, int k, complex&lt; double &gt; *A, int lda, const complex&lt; double &gt; *tau, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gabd6491a00dd2324f1d5c19f007bde4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a LQ decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#gabd6491a00dd2324f1d5c19f007bde4d2">More...</a><br /></td></tr>
<tr class="separator:gabd6491a00dd2324f1d5c19f007bde4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28a478303e6233fb0daefb6c9226fd05"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga28a478303e6233fb0daefb6c9226fd05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga28a478303e6233fb0daefb6c9226fd05">unglq</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; *tau)</td></tr>
<tr class="memdesc:ga28a478303e6233fb0daefb6c9226fd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a LQ decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga28a478303e6233fb0daefb6c9226fd05">More...</a><br /></td></tr>
<tr class="separator:ga28a478303e6233fb0daefb6c9226fd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to reconstruct Q from a QL decomposition (ungql)</div></td></tr>
<tr class="memitem:ga1d26d96f1e86d2511b4c9c486f57fd74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga1d26d96f1e86d2511b4c9c486f57fd74">ungql</a> (int m, int n, int k, complex&lt; float &gt; *A, int lda, const complex&lt; float &gt; *tau, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga1d26d96f1e86d2511b4c9c486f57fd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a QL decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga1d26d96f1e86d2511b4c9c486f57fd74">More...</a><br /></td></tr>
<tr class="separator:ga1d26d96f1e86d2511b4c9c486f57fd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e7aaf0b496a7f67e69a7040cbc7c82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gac7e7aaf0b496a7f67e69a7040cbc7c82">ungql</a> (int m, int n, int k, complex&lt; double &gt; *A, int lda, const complex&lt; double &gt; *tau, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gac7e7aaf0b496a7f67e69a7040cbc7c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a QL decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#gac7e7aaf0b496a7f67e69a7040cbc7c82">More...</a><br /></td></tr>
<tr class="separator:gac7e7aaf0b496a7f67e69a7040cbc7c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bde74abf11478732d4233fdc98a1a88"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4bde74abf11478732d4233fdc98a1a88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga4bde74abf11478732d4233fdc98a1a88">ungql</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; *tau)</td></tr>
<tr class="memdesc:ga4bde74abf11478732d4233fdc98a1a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a QL decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga4bde74abf11478732d4233fdc98a1a88">More...</a><br /></td></tr>
<tr class="separator:ga4bde74abf11478732d4233fdc98a1a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to reconstruct Q from a QR decomposition (ungqr)</div></td></tr>
<tr class="memitem:gaeaba2b479c42924c6f15e71f48e3419f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaeaba2b479c42924c6f15e71f48e3419f">ungqr</a> (int m, int n, int k, complex&lt; float &gt; *A, int lda, const complex&lt; float &gt; *tau, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gaeaba2b479c42924c6f15e71f48e3419f"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a QR decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#gaeaba2b479c42924c6f15e71f48e3419f">More...</a><br /></td></tr>
<tr class="separator:gaeaba2b479c42924c6f15e71f48e3419f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31cefe6a965b4977a7c9764ce7e657b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga31cefe6a965b4977a7c9764ce7e657b5">ungqr</a> (int m, int n, int k, complex&lt; double &gt; *A, int lda, const complex&lt; double &gt; *tau, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga31cefe6a965b4977a7c9764ce7e657b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a QR decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga31cefe6a965b4977a7c9764ce7e657b5">More...</a><br /></td></tr>
<tr class="separator:ga31cefe6a965b4977a7c9764ce7e657b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga596437fde4f8199d858cfbb65ff15708"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga596437fde4f8199d858cfbb65ff15708"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga596437fde4f8199d858cfbb65ff15708">ungqr</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; *tau)</td></tr>
<tr class="memdesc:ga596437fde4f8199d858cfbb65ff15708"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a QR decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga596437fde4f8199d858cfbb65ff15708">More...</a><br /></td></tr>
<tr class="separator:ga596437fde4f8199d858cfbb65ff15708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to reconstruct Q from a RQ decomposition (ungrq)</div></td></tr>
<tr class="memitem:ga4a4193ce8cc56f35443ffca01fbc21d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga4a4193ce8cc56f35443ffca01fbc21d2">ungrq</a> (int m, int n, int k, complex&lt; float &gt; *A, int lda, const complex&lt; float &gt; *tau, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga4a4193ce8cc56f35443ffca01fbc21d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a RQ decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga4a4193ce8cc56f35443ffca01fbc21d2">More...</a><br /></td></tr>
<tr class="separator:ga4a4193ce8cc56f35443ffca01fbc21d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e9d1d45ea082359bc794e79bd7e09c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga4e9d1d45ea082359bc794e79bd7e09c5">ungrq</a> (int m, int n, int k, complex&lt; double &gt; *A, int lda, const complex&lt; double &gt; *tau, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga4e9d1d45ea082359bc794e79bd7e09c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a RQ decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga4e9d1d45ea082359bc794e79bd7e09c5">More...</a><br /></td></tr>
<tr class="separator:ga4e9d1d45ea082359bc794e79bd7e09c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2435c2a417d92e368554722ea34e5dd2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga2435c2a417d92e368554722ea34e5dd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga2435c2a417d92e368554722ea34e5dd2">ungrq</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; *tau)</td></tr>
<tr class="memdesc:ga2435c2a417d92e368554722ea34e5dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the reconstruction of the orthogonal matrix Q from a RQ decomposition.  <a href="../../da/dea/group__lapack__decomposition.html#ga2435c2a417d92e368554722ea34e5dd2">More...</a><br /></td></tr>
<tr class="separator:ga2435c2a417d92e368554722ea34e5dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to multiply Q from a LQ decomposition with a matrix (unmlq)</div></td></tr>
<tr class="memitem:ga8933e3a46211bc9096f855f16ed999e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga8933e3a46211bc9096f855f16ed999e4">unmlq</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const complex&lt; float &gt; *A, int lda, const complex&lt; float &gt; *tau, complex&lt; float &gt; *C, int ldc, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga8933e3a46211bc9096f855f16ed999e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the single precision complex Q from a LQ decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga8933e3a46211bc9096f855f16ed999e4">More...</a><br /></td></tr>
<tr class="separator:ga8933e3a46211bc9096f855f16ed999e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3785fb6b5a9f52c068f7ee66e9523f06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga3785fb6b5a9f52c068f7ee66e9523f06">unmlq</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const complex&lt; double &gt; *A, int lda, const complex&lt; double &gt; *tau, complex&lt; double &gt; *C, int ldc, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga3785fb6b5a9f52c068f7ee66e9523f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision complex Q from a LQ decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga3785fb6b5a9f52c068f7ee66e9523f06">More...</a><br /></td></tr>
<tr class="separator:ga3785fb6b5a9f52c068f7ee66e9523f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga198fc97f1b3703ddc7e16222b48f703e"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO, typename MT2 &gt; </td></tr>
<tr class="memitem:ga198fc97f1b3703ddc7e16222b48f703e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga198fc97f1b3703ddc7e16222b48f703e">unmlq</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;C, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;A, char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT2 &gt; *tau)</td></tr>
<tr class="memdesc:ga198fc97f1b3703ddc7e16222b48f703e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a LQ decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga198fc97f1b3703ddc7e16222b48f703e">More...</a><br /></td></tr>
<tr class="separator:ga198fc97f1b3703ddc7e16222b48f703e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to multiply Q from a QL decomposition with a matrix (unmql)</div></td></tr>
<tr class="memitem:gaebbc748a641c7cb3bdd79aaa3c7e9098"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaebbc748a641c7cb3bdd79aaa3c7e9098">unmql</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const complex&lt; float &gt; *A, int lda, const complex&lt; float &gt; *tau, complex&lt; float &gt; *C, int ldc, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gaebbc748a641c7cb3bdd79aaa3c7e9098"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the single precision Q from a QL decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gaebbc748a641c7cb3bdd79aaa3c7e9098">More...</a><br /></td></tr>
<tr class="separator:gaebbc748a641c7cb3bdd79aaa3c7e9098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b4a755e25dae11233d9ced170edd226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga2b4a755e25dae11233d9ced170edd226">unmql</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const complex&lt; double &gt; *A, int lda, const complex&lt; double &gt; *tau, complex&lt; double &gt; *C, int ldc, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga2b4a755e25dae11233d9ced170edd226"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a QL decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga2b4a755e25dae11233d9ced170edd226">More...</a><br /></td></tr>
<tr class="separator:ga2b4a755e25dae11233d9ced170edd226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec3fa5e4fc74700d328c626979268af4"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO, typename MT2 &gt; </td></tr>
<tr class="memitem:gaec3fa5e4fc74700d328c626979268af4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaec3fa5e4fc74700d328c626979268af4">unmql</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;C, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;A, char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT2 &gt; *tau)</td></tr>
<tr class="memdesc:gaec3fa5e4fc74700d328c626979268af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a QL decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gaec3fa5e4fc74700d328c626979268af4">More...</a><br /></td></tr>
<tr class="separator:gaec3fa5e4fc74700d328c626979268af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to multiply Q from a QR decomposition with a matrix (unmqr)</div></td></tr>
<tr class="memitem:ga1b2ffef69168e0e5a5b0958c29802629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#ga1b2ffef69168e0e5a5b0958c29802629">unmqr</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const complex&lt; float &gt; *A, int lda, const complex&lt; float &gt; *tau, complex&lt; float &gt; *C, int ldc, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:ga1b2ffef69168e0e5a5b0958c29802629"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the single precision Q from a QR decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#ga1b2ffef69168e0e5a5b0958c29802629">More...</a><br /></td></tr>
<tr class="separator:ga1b2ffef69168e0e5a5b0958c29802629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5cd529bcb85e81171e06813ddf2ac23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gab5cd529bcb85e81171e06813ddf2ac23">unmqr</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const complex&lt; double &gt; *A, int lda, const complex&lt; double &gt; *tau, complex&lt; double &gt; *C, int ldc, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gab5cd529bcb85e81171e06813ddf2ac23"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a QR decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gab5cd529bcb85e81171e06813ddf2ac23">More...</a><br /></td></tr>
<tr class="separator:gab5cd529bcb85e81171e06813ddf2ac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc63fa5b1ca2c8b78a466fa7ef93cc12"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO, typename MT2 &gt; </td></tr>
<tr class="memitem:gabc63fa5b1ca2c8b78a466fa7ef93cc12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gabc63fa5b1ca2c8b78a466fa7ef93cc12">unmqr</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;C, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;A, char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT2 &gt; *tau)</td></tr>
<tr class="memdesc:gabc63fa5b1ca2c8b78a466fa7ef93cc12"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a QR decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gabc63fa5b1ca2c8b78a466fa7ef93cc12">More...</a><br /></td></tr>
<tr class="separator:gabc63fa5b1ca2c8b78a466fa7ef93cc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LAPACK functions to multiply Q from a RQ decomposition with a matrix (unmrq)</div></td></tr>
<tr class="memitem:gaa5d1f27b70ad90bf02fa667acd69a493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaa5d1f27b70ad90bf02fa667acd69a493">unmrq</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const complex&lt; float &gt; *A, int lda, const complex&lt; float &gt; *tau, complex&lt; float &gt; *C, int ldc, complex&lt; float &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gaa5d1f27b70ad90bf02fa667acd69a493"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the single precision Q from a RQ decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gaa5d1f27b70ad90bf02fa667acd69a493">More...</a><br /></td></tr>
<tr class="separator:gaa5d1f27b70ad90bf02fa667acd69a493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffb5fabae4eee65dfd81b81ef1535bac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dea/group__lapack__decomposition.html#gaffb5fabae4eee65dfd81b81ef1535bac">unmrq</a> (char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, int m, int n, int k, const complex&lt; double &gt; *A, int lda, const complex&lt; double &gt; *tau, complex&lt; double &gt; *C, int ldc, complex&lt; double &gt; *work, int lwork, int *info)</td></tr>
<tr class="memdesc:gaffb5fabae4eee65dfd81b81ef1535bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK kernel for the multiplication of the double precision Q from a RQ decomposition with another matrix.  <a href="../../da/dea/group__lapack__decomposition.html#gaffb5fabae4eee65dfd81b81ef1535bac">More...</a><br /></td></tr>
<tr class="separator:gaffb5fabae4eee65dfd81b81ef1535bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67ca6806e6b69459177f7333c5511368"><td class="memTemplParams" colspan="2">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga67ca6806e6b69459177f7333c5511368"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unmrq</b> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;C, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;A, char side, char <a class="el" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>, const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT2 &gt; *tau)</td></tr>
<tr class="separator:ga67ca6806e6b69459177f7333c5511368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix functions</div></td></tr>
<tr class="memitem:gac49c56871f0559df0b80283bb2ff8377"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac49c56871f0559df0b80283bb2ff8377"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#gac49c56871f0559df0b80283bb2ff8377">trace</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:gac49c56871f0559df0b80283bb2ff8377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the trace of the given square matrix.  <a href="../../dd/d7a/group__matrix.html#gac49c56871f0559df0b80283bb2ff8377">More...</a><br /></td></tr>
<tr class="separator:gac49c56871f0559df0b80283bb2ff8377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix operators</div></td></tr>
<tr class="memitem:ga5f051fa9685c313199d2f2e38067b8ff"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga5f051fa9685c313199d2f2e38067b8ff"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga5f051fa9685c313199d2f2e38067b8ff">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga5f051fa9685c313199d2f2e38067b8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for dense and sparse matrices.  <a href="../../dd/d7a/group__matrix.html#ga5f051fa9685c313199d2f2e38067b8ff">More...</a><br /></td></tr>
<tr class="separator:ga5f051fa9685c313199d2f2e38067b8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DenseMatrixProxy global functions</div></td></tr>
<tr class="memitem:ga473e41444b6324cdd14e5a675b829f4a"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga473e41444b6324cdd14e5a675b829f4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga473e41444b6324cdd14e5a675b829f4a">begin</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga473e41444b6324cdd14e5a675b829f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#ga473e41444b6324cdd14e5a675b829f4a">More...</a><br /></td></tr>
<tr class="separator:ga473e41444b6324cdd14e5a675b829f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e4b8a71e6e426f52371c0d5b9846fd"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gab5e4b8a71e6e426f52371c0d5b9846fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab5e4b8a71e6e426f52371c0d5b9846fd">cbegin</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gab5e4b8a71e6e426f52371c0d5b9846fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#gab5e4b8a71e6e426f52371c0d5b9846fd">More...</a><br /></td></tr>
<tr class="separator:gab5e4b8a71e6e426f52371c0d5b9846fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd12cbf050e7ee64aff69936d37d6b97"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gabd12cbf050e7ee64aff69936d37d6b97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabd12cbf050e7ee64aff69936d37d6b97">end</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gabd12cbf050e7ee64aff69936d37d6b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#gabd12cbf050e7ee64aff69936d37d6b97">More...</a><br /></td></tr>
<tr class="separator:gabd12cbf050e7ee64aff69936d37d6b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb1b473d7716b9abe090c3db5c8df431"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gacb1b473d7716b9abe090c3db5c8df431"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gacb1b473d7716b9abe090c3db5c8df431">cend</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gacb1b473d7716b9abe090c3db5c8df431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#gacb1b473d7716b9abe090c3db5c8df431">More...</a><br /></td></tr>
<tr class="separator:gacb1b473d7716b9abe090c3db5c8df431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b7cec0953f0e0be2c5220bd61e6e2e3"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga9b7cec0953f0e0be2c5220bd61e6e2e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9b7cec0953f0e0be2c5220bd61e6e2e3">rows</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga9b7cec0953f0e0be2c5220bd61e6e2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of rows of the represented matrix.  <a href="../../de/df1/group__math.html#ga9b7cec0953f0e0be2c5220bd61e6e2e3">More...</a><br /></td></tr>
<tr class="separator:ga9b7cec0953f0e0be2c5220bd61e6e2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf184ec513c031b63bb72c7161f7f9f5c"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaf184ec513c031b63bb72c7161f7f9f5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf184ec513c031b63bb72c7161f7f9f5c">columns</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaf184ec513c031b63bb72c7161f7f9f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of columns of the represented matrix.  <a href="../../de/df1/group__math.html#gaf184ec513c031b63bb72c7161f7f9f5c">More...</a><br /></td></tr>
<tr class="separator:gaf184ec513c031b63bb72c7161f7f9f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdce650ad06eb019f79bb6b7e92bf15d"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gabdce650ad06eb019f79bb6b7e92bf15d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabdce650ad06eb019f79bb6b7e92bf15d">capacity</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gabdce650ad06eb019f79bb6b7e92bf15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the represented matrix.  <a href="../../de/df1/group__math.html#gabdce650ad06eb019f79bb6b7e92bf15d">More...</a><br /></td></tr>
<tr class="separator:gabdce650ad06eb019f79bb6b7e92bf15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad086b7d12b02acd9fadbba5c105350c0"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gad086b7d12b02acd9fadbba5c105350c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad086b7d12b02acd9fadbba5c105350c0">capacity</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gad086b7d12b02acd9fadbba5c105350c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the specified row/column of the represented matrix.  <a href="../../de/df1/group__math.html#gad086b7d12b02acd9fadbba5c105350c0">More...</a><br /></td></tr>
<tr class="separator:gad086b7d12b02acd9fadbba5c105350c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf98d55b3997a5e0666e9467aac2f383e"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaf98d55b3997a5e0666e9467aac2f383e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf98d55b3997a5e0666e9467aac2f383e">nonZeros</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaf98d55b3997a5e0666e9467aac2f383e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the represented matrix.  <a href="../../de/df1/group__math.html#gaf98d55b3997a5e0666e9467aac2f383e">More...</a><br /></td></tr>
<tr class="separator:gaf98d55b3997a5e0666e9467aac2f383e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade25555a94e648076982a8c68fb38b70"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gade25555a94e648076982a8c68fb38b70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gade25555a94e648076982a8c68fb38b70">nonZeros</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gade25555a94e648076982a8c68fb38b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the specified row/column of the represented matrix.  <a href="../../de/df1/group__math.html#gade25555a94e648076982a8c68fb38b70">More...</a><br /></td></tr>
<tr class="separator:gade25555a94e648076982a8c68fb38b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc381719659d4900cba8b887b072351"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga2bc381719659d4900cba8b887b072351"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2bc381719659d4900cba8b887b072351">resize</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve)</td></tr>
<tr class="memdesc:ga2bc381719659d4900cba8b887b072351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the size of the represented matrix.  <a href="../../de/df1/group__math.html#ga2bc381719659d4900cba8b887b072351">More...</a><br /></td></tr>
<tr class="separator:ga2bc381719659d4900cba8b887b072351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b361008599fbe7c5ad3262ed1cf8bf9"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga6b361008599fbe7c5ad3262ed1cf8bf9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6b361008599fbe7c5ad3262ed1cf8bf9">reset</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga6b361008599fbe7c5ad3262ed1cf8bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../de/df1/group__math.html#ga6b361008599fbe7c5ad3262ed1cf8bf9">More...</a><br /></td></tr>
<tr class="separator:ga6b361008599fbe7c5ad3262ed1cf8bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga218b5d7e25e582cf759a0ffb94d8f88b"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga218b5d7e25e582cf759a0ffb94d8f88b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga218b5d7e25e582cf759a0ffb94d8f88b">reset</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga218b5d7e25e582cf759a0ffb94d8f88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column of the represented matrix.  <a href="../../de/df1/group__math.html#ga218b5d7e25e582cf759a0ffb94d8f88b">More...</a><br /></td></tr>
<tr class="separator:ga218b5d7e25e582cf759a0ffb94d8f88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d821c7a793e0c694258e2917bb44edc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga1d821c7a793e0c694258e2917bb44edc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1d821c7a793e0c694258e2917bb44edc">clear</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga1d821c7a793e0c694258e2917bb44edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented matrix.  <a href="../../de/df1/group__math.html#ga1d821c7a793e0c694258e2917bb44edc">More...</a><br /></td></tr>
<tr class="separator:ga1d821c7a793e0c694258e2917bb44edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DenseVectorProxy global functions</div></td></tr>
<tr class="memitem:ga33cd8a737acd2b68cf33d84baad75bf8"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga33cd8a737acd2b68cf33d84baad75bf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga33cd8a737acd2b68cf33d84baad75bf8">begin</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga33cd8a737acd2b68cf33d84baad75bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the represented vector.  <a href="../../de/df1/group__math.html#ga33cd8a737acd2b68cf33d84baad75bf8">More...</a><br /></td></tr>
<tr class="separator:ga33cd8a737acd2b68cf33d84baad75bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1552651c7e7b05385a91c477f198b92c"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga1552651c7e7b05385a91c477f198b92c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1552651c7e7b05385a91c477f198b92c">cbegin</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga1552651c7e7b05385a91c477f198b92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the represented vector.  <a href="../../de/df1/group__math.html#ga1552651c7e7b05385a91c477f198b92c">More...</a><br /></td></tr>
<tr class="separator:ga1552651c7e7b05385a91c477f198b92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad47f01490e02fe97e3e71003d70006b1"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gad47f01490e02fe97e3e71003d70006b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad47f01490e02fe97e3e71003d70006b1">end</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad47f01490e02fe97e3e71003d70006b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the represented vector.  <a href="../../de/df1/group__math.html#gad47f01490e02fe97e3e71003d70006b1">More...</a><br /></td></tr>
<tr class="separator:gad47f01490e02fe97e3e71003d70006b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga485df6bb7b74d08f29bcc446517f33bc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga485df6bb7b74d08f29bcc446517f33bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga485df6bb7b74d08f29bcc446517f33bc">cend</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga485df6bb7b74d08f29bcc446517f33bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the represented vector.  <a href="../../de/df1/group__math.html#ga485df6bb7b74d08f29bcc446517f33bc">More...</a><br /></td></tr>
<tr class="separator:ga485df6bb7b74d08f29bcc446517f33bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga815b73881a05f1de2c4ed92521758c22"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga815b73881a05f1de2c4ed92521758c22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga815b73881a05f1de2c4ed92521758c22">size</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga815b73881a05f1de2c4ed92521758c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the represented vector.  <a href="../../de/df1/group__math.html#ga815b73881a05f1de2c4ed92521758c22">More...</a><br /></td></tr>
<tr class="separator:ga815b73881a05f1de2c4ed92521758c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ad8f51a4e5551c83c078c2729c2bece"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga9ad8f51a4e5551c83c078c2729c2bece"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9ad8f51a4e5551c83c078c2729c2bece">capacity</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga9ad8f51a4e5551c83c078c2729c2bece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the represented vector.  <a href="../../de/df1/group__math.html#ga9ad8f51a4e5551c83c078c2729c2bece">More...</a><br /></td></tr>
<tr class="separator:ga9ad8f51a4e5551c83c078c2729c2bece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb886f8afac581ea219e7fd9dfdf6c74"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gacb886f8afac581ea219e7fd9dfdf6c74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gacb886f8afac581ea219e7fd9dfdf6c74">nonZeros</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gacb886f8afac581ea219e7fd9dfdf6c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the represented vector.  <a href="../../de/df1/group__math.html#gacb886f8afac581ea219e7fd9dfdf6c74">More...</a><br /></td></tr>
<tr class="separator:gacb886f8afac581ea219e7fd9dfdf6c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga413b7144866fb308fe121cf5b3695d0e"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga413b7144866fb308fe121cf5b3695d0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga413b7144866fb308fe121cf5b3695d0e">resize</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve)</td></tr>
<tr class="memdesc:ga413b7144866fb308fe121cf5b3695d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the size of the represented vector.  <a href="../../de/df1/group__math.html#ga413b7144866fb308fe121cf5b3695d0e">More...</a><br /></td></tr>
<tr class="separator:ga413b7144866fb308fe121cf5b3695d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5277ea1f337ba3a87d2dad48b609cec7"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga5277ea1f337ba3a87d2dad48b609cec7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5277ea1f337ba3a87d2dad48b609cec7">reset</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga5277ea1f337ba3a87d2dad48b609cec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented vector to the default initial values.  <a href="../../de/df1/group__math.html#ga5277ea1f337ba3a87d2dad48b609cec7">More...</a><br /></td></tr>
<tr class="separator:ga5277ea1f337ba3a87d2dad48b609cec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae42eef9a424004a86df6fc9c4115c2bc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gae42eef9a424004a86df6fc9c4115c2bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae42eef9a424004a86df6fc9c4115c2bc">clear</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gae42eef9a424004a86df6fc9c4115c2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented vector.  <a href="../../de/df1/group__math.html#gae42eef9a424004a86df6fc9c4115c2bc">More...</a><br /></td></tr>
<tr class="separator:gae42eef9a424004a86df6fc9c4115c2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Proxy operators</div></td></tr>
<tr class="memitem:ga252cf4ce9c985fa60ca6fa6c043e49d6"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:ga252cf4ce9c985fa60ca6fa6c043e49d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d92/group__math__traits.html#gaa8e44a329b04c220d865a66e33ebd605">AddExprTrait_</a>&lt; RT1, RT2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga252cf4ce9c985fa60ca6fa6c043e49d6">operator+</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga252cf4ce9c985fa60ca6fa6c043e49d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#ga252cf4ce9c985fa60ca6fa6c043e49d6">More...</a><br /></td></tr>
<tr class="separator:ga252cf4ce9c985fa60ca6fa6c043e49d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab77836657b23b8e2672dee471447d75b"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T &gt; </td></tr>
<tr class="memitem:gab77836657b23b8e2672dee471447d75b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gaa8e44a329b04c220d865a66e33ebd605">AddExprTrait_</a>&lt; RT, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab77836657b23b8e2672dee471447d75b">operator+</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gab77836657b23b8e2672dee471447d75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#gab77836657b23b8e2672dee471447d75b">More...</a><br /></td></tr>
<tr class="separator:gab77836657b23b8e2672dee471447d75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga068e03e6f02970be744291010a67a19d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga068e03e6f02970be744291010a67a19d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gaa8e44a329b04c220d865a66e33ebd605">AddExprTrait_</a>&lt; T, RT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga068e03e6f02970be744291010a67a19d">operator+</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga068e03e6f02970be744291010a67a19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#ga068e03e6f02970be744291010a67a19d">More...</a><br /></td></tr>
<tr class="separator:ga068e03e6f02970be744291010a67a19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29046682a45948f84d1a1b3c6191517c"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:ga29046682a45948f84d1a1b3c6191517c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d92/group__math__traits.html#gae9375f8308fc6db4d92f3aea659d02cd">SubExprTrait_</a>&lt; RT1, RT2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga29046682a45948f84d1a1b3c6191517c">operator-</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga29046682a45948f84d1a1b3c6191517c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#ga29046682a45948f84d1a1b3c6191517c">More...</a><br /></td></tr>
<tr class="separator:ga29046682a45948f84d1a1b3c6191517c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fcbf1a711707a84e97237005f22c25b"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T &gt; </td></tr>
<tr class="memitem:ga6fcbf1a711707a84e97237005f22c25b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gae9375f8308fc6db4d92f3aea659d02cd">SubExprTrait_</a>&lt; RT, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6fcbf1a711707a84e97237005f22c25b">operator-</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga6fcbf1a711707a84e97237005f22c25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#ga6fcbf1a711707a84e97237005f22c25b">More...</a><br /></td></tr>
<tr class="separator:ga6fcbf1a711707a84e97237005f22c25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5080f4b995a0c2e03eb7c501927ee8e3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga5080f4b995a0c2e03eb7c501927ee8e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gae9375f8308fc6db4d92f3aea659d02cd">SubExprTrait_</a>&lt; T, RT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5080f4b995a0c2e03eb7c501927ee8e3">operator-</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5080f4b995a0c2e03eb7c501927ee8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#ga5080f4b995a0c2e03eb7c501927ee8e3">More...</a><br /></td></tr>
<tr class="separator:ga5080f4b995a0c2e03eb7c501927ee8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3e29f7298decd0ae4c3bda3ec54f9a4"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:gaf3e29f7298decd0ae4c3bda3ec54f9a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; RT1, RT2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf3e29f7298decd0ae4c3bda3ec54f9a4">operator*</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf3e29f7298decd0ae4c3bda3ec54f9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#gaf3e29f7298decd0ae4c3bda3ec54f9a4">More...</a><br /></td></tr>
<tr class="separator:gaf3e29f7298decd0ae4c3bda3ec54f9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeccc7fde3dea868994666d5fdd6db48"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T &gt; </td></tr>
<tr class="memitem:gaeeccc7fde3dea868994666d5fdd6db48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; RT, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaeeccc7fde3dea868994666d5fdd6db48">operator*</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaeeccc7fde3dea868994666d5fdd6db48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#gaeeccc7fde3dea868994666d5fdd6db48">More...</a><br /></td></tr>
<tr class="separator:gaeeccc7fde3dea868994666d5fdd6db48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8658465973024d2229a2e8a108477a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gadc8658465973024d2229a2e8a108477a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">MultExprTrait_</a>&lt; T, RT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gadc8658465973024d2229a2e8a108477a">operator*</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gadc8658465973024d2229a2e8a108477a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#gadc8658465973024d2229a2e8a108477a">More...</a><br /></td></tr>
<tr class="separator:gadc8658465973024d2229a2e8a108477a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga651064469d7636b7d3864906333e0014"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:ga651064469d7636b7d3864906333e0014"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">DivExprTrait_</a>&lt; RT1, RT2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga651064469d7636b7d3864906333e0014">operator/</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga651064469d7636b7d3864906333e0014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#ga651064469d7636b7d3864906333e0014">More...</a><br /></td></tr>
<tr class="separator:ga651064469d7636b7d3864906333e0014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65027c13a81c1e42ef8360ae9c833d6e"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T &gt; </td></tr>
<tr class="memitem:ga65027c13a81c1e42ef8360ae9c833d6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">DivExprTrait_</a>&lt; RT, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga65027c13a81c1e42ef8360ae9c833d6e">operator/</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga65027c13a81c1e42ef8360ae9c833d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#ga65027c13a81c1e42ef8360ae9c833d6e">More...</a><br /></td></tr>
<tr class="separator:ga65027c13a81c1e42ef8360ae9c833d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfae38b5a07c03b6a3be2cd9d8866288"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gabfae38b5a07c03b6a3be2cd9d8866288"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, <a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">DivExprTrait_</a>&lt; T, RT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabfae38b5a07c03b6a3be2cd9d8866288">operator/</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabfae38b5a07c03b6a3be2cd9d8866288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#gabfae38b5a07c03b6a3be2cd9d8866288">More...</a><br /></td></tr>
<tr class="separator:gabfae38b5a07c03b6a3be2cd9d8866288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga035d23379f82bda953132324d4aa17f3"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:ga035d23379f82bda953132324d4aa17f3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga035d23379f82bda953132324d4aa17f3">operator==</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga035d23379f82bda953132324d4aa17f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#ga035d23379f82bda953132324d4aa17f3">More...</a><br /></td></tr>
<tr class="separator:ga035d23379f82bda953132324d4aa17f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac9a1e877f0970c75e5d94f6b51d648"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T &gt; </td></tr>
<tr class="memitem:ga0ac9a1e877f0970c75e5d94f6b51d648"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0ac9a1e877f0970c75e5d94f6b51d648">operator==</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga0ac9a1e877f0970c75e5d94f6b51d648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#ga0ac9a1e877f0970c75e5d94f6b51d648">More...</a><br /></td></tr>
<tr class="separator:ga0ac9a1e877f0970c75e5d94f6b51d648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac47cfeadfd9f8ea8f1c173e7db321d2a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gac47cfeadfd9f8ea8f1c173e7db321d2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac47cfeadfd9f8ea8f1c173e7db321d2a">operator==</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac47cfeadfd9f8ea8f1c173e7db321d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#gac47cfeadfd9f8ea8f1c173e7db321d2a">More...</a><br /></td></tr>
<tr class="separator:gac47cfeadfd9f8ea8f1c173e7db321d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4abf1755e20af8b6ca00a9dc7f9483d"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:gae4abf1755e20af8b6ca00a9dc7f9483d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae4abf1755e20af8b6ca00a9dc7f9483d">operator!=</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae4abf1755e20af8b6ca00a9dc7f9483d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#gae4abf1755e20af8b6ca00a9dc7f9483d">More...</a><br /></td></tr>
<tr class="separator:gae4abf1755e20af8b6ca00a9dc7f9483d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga613a009a02c94ff760a9b143cb4450c5"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T &gt; </td></tr>
<tr class="memitem:ga613a009a02c94ff760a9b143cb4450c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga613a009a02c94ff760a9b143cb4450c5">operator!=</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga613a009a02c94ff760a9b143cb4450c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#ga613a009a02c94ff760a9b143cb4450c5">More...</a><br /></td></tr>
<tr class="separator:ga613a009a02c94ff760a9b143cb4450c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56119f9017f06f4028706d5e2ec920eb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga56119f9017f06f4028706d5e2ec920eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga56119f9017f06f4028706d5e2ec920eb">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga56119f9017f06f4028706d5e2ec920eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquality comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#ga56119f9017f06f4028706d5e2ec920eb">More...</a><br /></td></tr>
<tr class="separator:ga56119f9017f06f4028706d5e2ec920eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65821b80ccae33417341537e4227f868"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:ga65821b80ccae33417341537e4227f868"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga65821b80ccae33417341537e4227f868">operator&lt;</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga65821b80ccae33417341537e4227f868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#ga65821b80ccae33417341537e4227f868">More...</a><br /></td></tr>
<tr class="separator:ga65821b80ccae33417341537e4227f868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacacd66f2c976a44c3f2857886ee2c5ef"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T &gt; </td></tr>
<tr class="memitem:gacacd66f2c976a44c3f2857886ee2c5ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gacacd66f2c976a44c3f2857886ee2c5ef">operator&lt;</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gacacd66f2c976a44c3f2857886ee2c5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#gacacd66f2c976a44c3f2857886ee2c5ef">More...</a><br /></td></tr>
<tr class="separator:gacacd66f2c976a44c3f2857886ee2c5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3affbadcbe2fa10bbadf62d3acf38436"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga3affbadcbe2fa10bbadf62d3acf38436"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3affbadcbe2fa10bbadf62d3acf38436">operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3affbadcbe2fa10bbadf62d3acf38436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#ga3affbadcbe2fa10bbadf62d3acf38436">More...</a><br /></td></tr>
<tr class="separator:ga3affbadcbe2fa10bbadf62d3acf38436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40f8244f6749d5d4f160add9f963c78d"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:ga40f8244f6749d5d4f160add9f963c78d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga40f8244f6749d5d4f160add9f963c78d">operator&gt;</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga40f8244f6749d5d4f160add9f963c78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#ga40f8244f6749d5d4f160add9f963c78d">More...</a><br /></td></tr>
<tr class="separator:ga40f8244f6749d5d4f160add9f963c78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3913fbf4f9a3c3789d070d5885d7bff"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T &gt; </td></tr>
<tr class="memitem:gaf3913fbf4f9a3c3789d070d5885d7bff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf3913fbf4f9a3c3789d070d5885d7bff">operator&gt;</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaf3913fbf4f9a3c3789d070d5885d7bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#gaf3913fbf4f9a3c3789d070d5885d7bff">More...</a><br /></td></tr>
<tr class="separator:gaf3913fbf4f9a3c3789d070d5885d7bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae84b073f9bab3a64cdc42cca0b5e4c59"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gae84b073f9bab3a64cdc42cca0b5e4c59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae84b073f9bab3a64cdc42cca0b5e4c59">operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae84b073f9bab3a64cdc42cca0b5e4c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#gae84b073f9bab3a64cdc42cca0b5e4c59">More...</a><br /></td></tr>
<tr class="separator:gae84b073f9bab3a64cdc42cca0b5e4c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24730d792522ea8882c06888e00ae7e"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:gac24730d792522ea8882c06888e00ae7e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac24730d792522ea8882c06888e00ae7e">operator&lt;=</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac24730d792522ea8882c06888e00ae7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#gac24730d792522ea8882c06888e00ae7e">More...</a><br /></td></tr>
<tr class="separator:gac24730d792522ea8882c06888e00ae7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ce7b5872578339b90f5b076c6ccd3a"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T &gt; </td></tr>
<tr class="memitem:ga89ce7b5872578339b90f5b076c6ccd3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga89ce7b5872578339b90f5b076c6ccd3a">operator&lt;=</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga89ce7b5872578339b90f5b076c6ccd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#ga89ce7b5872578339b90f5b076c6ccd3a">More...</a><br /></td></tr>
<tr class="separator:ga89ce7b5872578339b90f5b076c6ccd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca80fe4815b55825241b2d778ca2d0be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gaca80fe4815b55825241b2d778ca2d0be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaca80fe4815b55825241b2d778ca2d0be">operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaca80fe4815b55825241b2d778ca2d0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#gaca80fe4815b55825241b2d778ca2d0be">More...</a><br /></td></tr>
<tr class="separator:gaca80fe4815b55825241b2d778ca2d0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59183d72b56569f5a047b9db01b780a"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:gad59183d72b56569f5a047b9db01b780a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad59183d72b56569f5a047b9db01b780a">operator&gt;=</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad59183d72b56569f5a047b9db01b780a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#gad59183d72b56569f5a047b9db01b780a">More...</a><br /></td></tr>
<tr class="separator:gad59183d72b56569f5a047b9db01b780a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64d1aefb1ac70a804ef31ed56e0a3cba"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T &gt; </td></tr>
<tr class="memitem:ga64d1aefb1ac70a804ef31ed56e0a3cba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga64d1aefb1ac70a804ef31ed56e0a3cba">operator&gt;=</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga64d1aefb1ac70a804ef31ed56e0a3cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#ga64d1aefb1ac70a804ef31ed56e0a3cba">More...</a><br /></td></tr>
<tr class="separator:ga64d1aefb1ac70a804ef31ed56e0a3cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6fff919826d9ff569b941329dc827d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga3e6fff919826d9ff569b941329dc827d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">IsProxy</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3e6fff919826d9ff569b941329dc827d">operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3e6fff919826d9ff569b941329dc827d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#ga3e6fff919826d9ff569b941329dc827d">More...</a><br /></td></tr>
<tr class="separator:ga3e6fff919826d9ff569b941329dc827d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa14e76b894f5467df70d6d330fb66c0e"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gaa14e76b894f5467df70d6d330fb66c0e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa14e76b894f5467df70d6d330fb66c0e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa14e76b894f5467df70d6d330fb66c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class template.  <a href="../../de/df1/group__math.html#gaa14e76b894f5467df70d6d330fb66c0e">More...</a><br /></td></tr>
<tr class="separator:gaa14e76b894f5467df70d6d330fb66c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Proxy global functions</div></td></tr>
<tr class="memitem:gad9415fd177aafcd396620d1bbc0bb0d3"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gad9415fd177aafcd396620d1bbc0bb0d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad9415fd177aafcd396620d1bbc0bb0d3">trans</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(trans(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:gad9415fd177aafcd396620d1bbc0bb0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the transpose of the represented element.  <a href="../../de/df1/group__math.html#gad9415fd177aafcd396620d1bbc0bb0d3">More...</a><br /></td></tr>
<tr class="separator:gad9415fd177aafcd396620d1bbc0bb0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7b4772ffd3e850d96295a0a6581e5a5"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gaa7b4772ffd3e850d96295a0a6581e5a5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa7b4772ffd3e850d96295a0a6581e5a5">ctrans</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(ctrans(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:gaa7b4772ffd3e850d96295a0a6581e5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the conjugate transpose of the represented element.  <a href="../../de/df1/group__math.html#gaa7b4772ffd3e850d96295a0a6581e5a5">More...</a><br /></td></tr>
<tr class="separator:gaa7b4772ffd3e850d96295a0a6581e5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fa936e4c54505b471720a312daead16"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga3fa936e4c54505b471720a312daead16"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3fa936e4c54505b471720a312daead16">abs</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(abs(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga3fa936e4c54505b471720a312daead16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the absolute value of the represented element.  <a href="../../de/df1/group__math.html#ga3fa936e4c54505b471720a312daead16">More...</a><br /></td></tr>
<tr class="separator:ga3fa936e4c54505b471720a312daead16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c823c3bf8cebef99fc1c15580aae57d"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga1c823c3bf8cebef99fc1c15580aae57d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1c823c3bf8cebef99fc1c15580aae57d">conj</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(conj(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga1c823c3bf8cebef99fc1c15580aae57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the complex conjugate of the represented element.  <a href="../../de/df1/group__math.html#ga1c823c3bf8cebef99fc1c15580aae57d">More...</a><br /></td></tr>
<tr class="separator:ga1c823c3bf8cebef99fc1c15580aae57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cdcbc492123a0204efab1444808ad4f"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga0cdcbc492123a0204efab1444808ad4f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0cdcbc492123a0204efab1444808ad4f">real</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(real(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga0cdcbc492123a0204efab1444808ad4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the real part of the represented element.  <a href="../../de/df1/group__math.html#ga0cdcbc492123a0204efab1444808ad4f">More...</a><br /></td></tr>
<tr class="separator:ga0cdcbc492123a0204efab1444808ad4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04be265b160ef0353a9eff377d339321"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga04be265b160ef0353a9eff377d339321"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga04be265b160ef0353a9eff377d339321">imag</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(imag(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga04be265b160ef0353a9eff377d339321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the imaginary part of the represented element.  <a href="../../de/df1/group__math.html#ga04be265b160ef0353a9eff377d339321">More...</a><br /></td></tr>
<tr class="separator:ga04be265b160ef0353a9eff377d339321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab398e26ccfbf8589c4110a0bd71a75cd"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gab398e26ccfbf8589c4110a0bd71a75cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab398e26ccfbf8589c4110a0bd71a75cd">sqrt</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(sqrt(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:gab398e26ccfbf8589c4110a0bd71a75cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the square root of the represented element.  <a href="../../de/df1/group__math.html#gab398e26ccfbf8589c4110a0bd71a75cd">More...</a><br /></td></tr>
<tr class="separator:gab398e26ccfbf8589c4110a0bd71a75cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49828bb72966fe8272aa4b966ac302ee"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga49828bb72966fe8272aa4b966ac302ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga49828bb72966fe8272aa4b966ac302ee">invsqrt</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(invsqrt(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga49828bb72966fe8272aa4b966ac302ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse square root of the represented element.  <a href="../../de/df1/group__math.html#ga49828bb72966fe8272aa4b966ac302ee">More...</a><br /></td></tr>
<tr class="separator:ga49828bb72966fe8272aa4b966ac302ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72a915c0728c0c35ccfdbdf1ebb5c486"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga72a915c0728c0c35ccfdbdf1ebb5c486"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga72a915c0728c0c35ccfdbdf1ebb5c486">cbrt</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(cbrt(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga72a915c0728c0c35ccfdbdf1ebb5c486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the cubic root of the represented element.  <a href="../../de/df1/group__math.html#ga72a915c0728c0c35ccfdbdf1ebb5c486">More...</a><br /></td></tr>
<tr class="separator:ga72a915c0728c0c35ccfdbdf1ebb5c486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a4e6c97bf9145a314b208e40fe67e29"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga3a4e6c97bf9145a314b208e40fe67e29"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3a4e6c97bf9145a314b208e40fe67e29">invcbrt</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(invcbrt(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga3a4e6c97bf9145a314b208e40fe67e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse cubic root of the represented element.  <a href="../../de/df1/group__math.html#ga3a4e6c97bf9145a314b208e40fe67e29">More...</a><br /></td></tr>
<tr class="separator:ga3a4e6c97bf9145a314b208e40fe67e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed95dc85489fb4e04480d3688e79364d"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gaed95dc85489fb4e04480d3688e79364d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaed95dc85489fb4e04480d3688e79364d">floor</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(floor(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:gaed95dc85489fb4e04480d3688e79364d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integral value that is not greater than the represented element.  <a href="../../de/df1/group__math.html#gaed95dc85489fb4e04480d3688e79364d">More...</a><br /></td></tr>
<tr class="separator:gaed95dc85489fb4e04480d3688e79364d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7678fdeec6a3fd669e8dda6a30cf3bb"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gab7678fdeec6a3fd669e8dda6a30cf3bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab7678fdeec6a3fd669e8dda6a30cf3bb">ceil</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(ceil(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:gab7678fdeec6a3fd669e8dda6a30cf3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integral value that is not less than the represented element.  <a href="../../de/df1/group__math.html#gab7678fdeec6a3fd669e8dda6a30cf3bb">More...</a><br /></td></tr>
<tr class="separator:gab7678fdeec6a3fd669e8dda6a30cf3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga712a08e999ad4cd09ad021fd48a624cb"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename ET &gt; </td></tr>
<tr class="memitem:ga712a08e999ad4cd09ad021fd48a624cb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga712a08e999ad4cd09ad021fd48a624cb">pow</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy, const ET &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">exp</a>) -&gt; decltype(pow(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;(), <a class="el" href="../../db/df0/group__dense__matrix.html#gace3face2f497ce3065754db58ce162d4">exp</a>))</td></tr>
<tr class="memdesc:ga712a08e999ad4cd09ad021fd48a624cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the exponential value of the represented element.  <a href="../../de/df1/group__math.html#ga712a08e999ad4cd09ad021fd48a624cb">More...</a><br /></td></tr>
<tr class="separator:ga712a08e999ad4cd09ad021fd48a624cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cee186129bbc430bb6d6bb97ecbf803"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga1cee186129bbc430bb6d6bb97ecbf803"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1cee186129bbc430bb6d6bb97ecbf803">exp</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(exp(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga1cee186129bbc430bb6d6bb97ecbf803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the base-e exponential of the represented element.  <a href="../../de/df1/group__math.html#ga1cee186129bbc430bb6d6bb97ecbf803">More...</a><br /></td></tr>
<tr class="separator:ga1cee186129bbc430bb6d6bb97ecbf803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2da176086ee8826bcca1111d06264d8b"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga2da176086ee8826bcca1111d06264d8b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2da176086ee8826bcca1111d06264d8b">sin</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(sin(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga2da176086ee8826bcca1111d06264d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the sine of the represented element.  <a href="../../de/df1/group__math.html#ga2da176086ee8826bcca1111d06264d8b">More...</a><br /></td></tr>
<tr class="separator:ga2da176086ee8826bcca1111d06264d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46bebd91fbc5a6f958a62945489fce3e"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga46bebd91fbc5a6f958a62945489fce3e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga46bebd91fbc5a6f958a62945489fce3e">asin</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(asin(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga46bebd91fbc5a6f958a62945489fce3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse sine of the represented element.  <a href="../../de/df1/group__math.html#ga46bebd91fbc5a6f958a62945489fce3e">More...</a><br /></td></tr>
<tr class="separator:ga46bebd91fbc5a6f958a62945489fce3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48772e9a50d5c91c7dd57094c4bd012f"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga48772e9a50d5c91c7dd57094c4bd012f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga48772e9a50d5c91c7dd57094c4bd012f">sinh</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(sinh(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga48772e9a50d5c91c7dd57094c4bd012f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the hyperbolic sine of the represented element.  <a href="../../de/df1/group__math.html#ga48772e9a50d5c91c7dd57094c4bd012f">More...</a><br /></td></tr>
<tr class="separator:ga48772e9a50d5c91c7dd57094c4bd012f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d3b0d0d6440fdf14dc3b9399e7b1246"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga7d3b0d0d6440fdf14dc3b9399e7b1246"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7d3b0d0d6440fdf14dc3b9399e7b1246">asinh</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(asinh(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga7d3b0d0d6440fdf14dc3b9399e7b1246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse hyperbolic sine of the represented element.  <a href="../../de/df1/group__math.html#ga7d3b0d0d6440fdf14dc3b9399e7b1246">More...</a><br /></td></tr>
<tr class="separator:ga7d3b0d0d6440fdf14dc3b9399e7b1246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23905b798e6819d020da2729939d6ec0"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga23905b798e6819d020da2729939d6ec0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga23905b798e6819d020da2729939d6ec0">cos</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(cos(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga23905b798e6819d020da2729939d6ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the cosine of the represented element.  <a href="../../de/df1/group__math.html#ga23905b798e6819d020da2729939d6ec0">More...</a><br /></td></tr>
<tr class="separator:ga23905b798e6819d020da2729939d6ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae44805ba9c9000b64a5940ba2b4e1758"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gae44805ba9c9000b64a5940ba2b4e1758"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae44805ba9c9000b64a5940ba2b4e1758">acos</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(acos(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:gae44805ba9c9000b64a5940ba2b4e1758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse cosine of the represented element.  <a href="../../de/df1/group__math.html#gae44805ba9c9000b64a5940ba2b4e1758">More...</a><br /></td></tr>
<tr class="separator:gae44805ba9c9000b64a5940ba2b4e1758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c5d57d6bb0498b2fb3c6d8e6bb2a855"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga7c5d57d6bb0498b2fb3c6d8e6bb2a855"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7c5d57d6bb0498b2fb3c6d8e6bb2a855">cosh</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(cosh(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga7c5d57d6bb0498b2fb3c6d8e6bb2a855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the hyperbolic cosine of the represented element.  <a href="../../de/df1/group__math.html#ga7c5d57d6bb0498b2fb3c6d8e6bb2a855">More...</a><br /></td></tr>
<tr class="separator:ga7c5d57d6bb0498b2fb3c6d8e6bb2a855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga071a2a1cadf554c944b3c7fccb350361"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga071a2a1cadf554c944b3c7fccb350361"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga071a2a1cadf554c944b3c7fccb350361">acosh</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(acosh(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga071a2a1cadf554c944b3c7fccb350361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse hyperbolic cosine of the represented element.  <a href="../../de/df1/group__math.html#ga071a2a1cadf554c944b3c7fccb350361">More...</a><br /></td></tr>
<tr class="separator:ga071a2a1cadf554c944b3c7fccb350361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf798263893c7d06aeb8b119a44860244"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gaf798263893c7d06aeb8b119a44860244"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf798263893c7d06aeb8b119a44860244">tan</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(tan(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:gaf798263893c7d06aeb8b119a44860244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the tangent of the represented element.  <a href="../../de/df1/group__math.html#gaf798263893c7d06aeb8b119a44860244">More...</a><br /></td></tr>
<tr class="separator:gaf798263893c7d06aeb8b119a44860244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga210fffd6bf243dbb8f5fe59b4115d16b"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga210fffd6bf243dbb8f5fe59b4115d16b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga210fffd6bf243dbb8f5fe59b4115d16b">atan</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(atan(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga210fffd6bf243dbb8f5fe59b4115d16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse tangent of the represented element.  <a href="../../de/df1/group__math.html#ga210fffd6bf243dbb8f5fe59b4115d16b">More...</a><br /></td></tr>
<tr class="separator:ga210fffd6bf243dbb8f5fe59b4115d16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e46d423b6b946ee8e0ea3f1a2df770"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga51e46d423b6b946ee8e0ea3f1a2df770"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga51e46d423b6b946ee8e0ea3f1a2df770">tanh</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(tanh(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga51e46d423b6b946ee8e0ea3f1a2df770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the hyperbolic tangent of the represented element.  <a href="../../de/df1/group__math.html#ga51e46d423b6b946ee8e0ea3f1a2df770">More...</a><br /></td></tr>
<tr class="separator:ga51e46d423b6b946ee8e0ea3f1a2df770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga062ee112115d13afc404803553d8af90"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga062ee112115d13afc404803553d8af90"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga062ee112115d13afc404803553d8af90">atanh</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy) -&gt; decltype(atanh(std::declval&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">RepresentedType_</a>&lt; PT &gt; &gt;()))</td></tr>
<tr class="memdesc:ga062ee112115d13afc404803553d8af90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse hyperbolic tangent of the represented element.  <a href="../../de/df1/group__math.html#ga062ee112115d13afc404803553d8af90">More...</a><br /></td></tr>
<tr class="separator:ga062ee112115d13afc404803553d8af90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga664fc6202989987071c22966ab8b18d5"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga664fc6202989987071c22966ab8b18d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga664fc6202989987071c22966ab8b18d5">transpose</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga664fc6202989987071c22966ab8b18d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place transpose of the represented matrix element.  <a href="../../de/df1/group__math.html#ga664fc6202989987071c22966ab8b18d5">More...</a><br /></td></tr>
<tr class="separator:ga664fc6202989987071c22966ab8b18d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff7b7fcc6534302c97b09c07655902f5"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gaff7b7fcc6534302c97b09c07655902f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaff7b7fcc6534302c97b09c07655902f5">ctranspose</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaff7b7fcc6534302c97b09c07655902f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place conjugate transpose of the represented matrix element.  <a href="../../de/df1/group__math.html#gaff7b7fcc6534302c97b09c07655902f5">More...</a><br /></td></tr>
<tr class="separator:gaff7b7fcc6534302c97b09c07655902f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b8198c1bb8ffdf1a77c3b3d3f01508d"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga5b8198c1bb8ffdf1a77c3b3d3f01508d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5b8198c1bb8ffdf1a77c3b3d3f01508d">invert</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga5b8198c1bb8ffdf1a77c3b3d3f01508d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the represented element.  <a href="../../de/df1/group__math.html#ga5b8198c1bb8ffdf1a77c3b3d3f01508d">More...</a><br /></td></tr>
<tr class="separator:ga5b8198c1bb8ffdf1a77c3b3d3f01508d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6a33ec01ed8420e939104d4796438ad"><td class="memTemplParams" colspan="2">template&lt;InversionFlag IF, typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gad6a33ec01ed8420e939104d4796438ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad6a33ec01ed8420e939104d4796438ad">invert</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad6a33ec01ed8420e939104d4796438ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the represented element.  <a href="../../de/df1/group__math.html#gad6a33ec01ed8420e939104d4796438ad">More...</a><br /></td></tr>
<tr class="separator:gad6a33ec01ed8420e939104d4796438ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga616a23f1493e67dad3aab8904565b930"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga616a23f1493e67dad3aab8904565b930"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga616a23f1493e67dad3aab8904565b930">isReal</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga616a23f1493e67dad3aab8904565b930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the element represents a real number.  <a href="../../de/df1/group__math.html#ga616a23f1493e67dad3aab8904565b930">More...</a><br /></td></tr>
<tr class="separator:ga616a23f1493e67dad3aab8904565b930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb590540bc62e93f6095dfef63a7dbc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga5fb590540bc62e93f6095dfef63a7dbc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5fb590540bc62e93f6095dfef63a7dbc">isZero</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga5fb590540bc62e93f6095dfef63a7dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../de/df1/group__math.html#ga5fb590540bc62e93f6095dfef63a7dbc">More...</a><br /></td></tr>
<tr class="separator:ga5fb590540bc62e93f6095dfef63a7dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3969435074887952b2d652d4b27298f7"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga3969435074887952b2d652d4b27298f7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3969435074887952b2d652d4b27298f7">isOne</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga3969435074887952b2d652d4b27298f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../de/df1/group__math.html#ga3969435074887952b2d652d4b27298f7">More...</a><br /></td></tr>
<tr class="separator:ga3969435074887952b2d652d4b27298f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ff9be338882a06b760b1b0563a6132"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gae6ff9be338882a06b760b1b0563a6132"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae6ff9be338882a06b760b1b0563a6132">isnan</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gae6ff9be338882a06b760b1b0563a6132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../de/df1/group__math.html#gae6ff9be338882a06b760b1b0563a6132">More...</a><br /></td></tr>
<tr class="separator:gae6ff9be338882a06b760b1b0563a6132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SparseMatrixProxy global functions</div></td></tr>
<tr class="memitem:ga34acd458b656ec2167762cc3fb1bdd1f"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga34acd458b656ec2167762cc3fb1bdd1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga34acd458b656ec2167762cc3fb1bdd1f">begin</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga34acd458b656ec2167762cc3fb1bdd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#ga34acd458b656ec2167762cc3fb1bdd1f">More...</a><br /></td></tr>
<tr class="separator:ga34acd458b656ec2167762cc3fb1bdd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa97c7a3f2a26f8a8a918b3ef33ea1adc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaa97c7a3f2a26f8a8a918b3ef33ea1adc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa97c7a3f2a26f8a8a918b3ef33ea1adc">cbegin</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gaa97c7a3f2a26f8a8a918b3ef33ea1adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#gaa97c7a3f2a26f8a8a918b3ef33ea1adc">More...</a><br /></td></tr>
<tr class="separator:gaa97c7a3f2a26f8a8a918b3ef33ea1adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff459171ee4708a8fc325de33d9345aa"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaff459171ee4708a8fc325de33d9345aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaff459171ee4708a8fc325de33d9345aa">end</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gaff459171ee4708a8fc325de33d9345aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#gaff459171ee4708a8fc325de33d9345aa">More...</a><br /></td></tr>
<tr class="separator:gaff459171ee4708a8fc325de33d9345aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b9786b8a311ab1bf97f247f566edd9"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga58b9786b8a311ab1bf97f247f566edd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga58b9786b8a311ab1bf97f247f566edd9">cend</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga58b9786b8a311ab1bf97f247f566edd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#ga58b9786b8a311ab1bf97f247f566edd9">More...</a><br /></td></tr>
<tr class="separator:ga58b9786b8a311ab1bf97f247f566edd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e08caafa4583f32333b5d17f1c4ef5"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga51e08caafa4583f32333b5d17f1c4ef5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga51e08caafa4583f32333b5d17f1c4ef5">rows</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga51e08caafa4583f32333b5d17f1c4ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of rows of the represented matrix.  <a href="../../de/df1/group__math.html#ga51e08caafa4583f32333b5d17f1c4ef5">More...</a><br /></td></tr>
<tr class="separator:ga51e08caafa4583f32333b5d17f1c4ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69887db471553a593455e9939bd20e8"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaa69887db471553a593455e9939bd20e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa69887db471553a593455e9939bd20e8">columns</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa69887db471553a593455e9939bd20e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of columns of the represented matrix.  <a href="../../de/df1/group__math.html#gaa69887db471553a593455e9939bd20e8">More...</a><br /></td></tr>
<tr class="separator:gaa69887db471553a593455e9939bd20e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d7b618c624d4911ae7f3882a05dc14"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaf8d7b618c624d4911ae7f3882a05dc14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf8d7b618c624d4911ae7f3882a05dc14">capacity</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaf8d7b618c624d4911ae7f3882a05dc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the represented matrix.  <a href="../../de/df1/group__math.html#gaf8d7b618c624d4911ae7f3882a05dc14">More...</a><br /></td></tr>
<tr class="separator:gaf8d7b618c624d4911ae7f3882a05dc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3df62b3c237c2a2b04fc28e7a20dcf"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga1c3df62b3c237c2a2b04fc28e7a20dcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1c3df62b3c237c2a2b04fc28e7a20dcf">capacity</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga1c3df62b3c237c2a2b04fc28e7a20dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the specified row/column of the represented matrix.  <a href="../../de/df1/group__math.html#ga1c3df62b3c237c2a2b04fc28e7a20dcf">More...</a><br /></td></tr>
<tr class="separator:ga1c3df62b3c237c2a2b04fc28e7a20dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8d4a1ad716a90d183a1f310887f678f"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gad8d4a1ad716a90d183a1f310887f678f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad8d4a1ad716a90d183a1f310887f678f">nonZeros</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad8d4a1ad716a90d183a1f310887f678f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the represented matrix.  <a href="../../de/df1/group__math.html#gad8d4a1ad716a90d183a1f310887f678f">More...</a><br /></td></tr>
<tr class="separator:gad8d4a1ad716a90d183a1f310887f678f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe8aa45ed742cea841472f9f575f9c71"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gabe8aa45ed742cea841472f9f575f9c71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabe8aa45ed742cea841472f9f575f9c71">nonZeros</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gabe8aa45ed742cea841472f9f575f9c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the specified row/column of the represented matrix.  <a href="../../de/df1/group__math.html#gabe8aa45ed742cea841472f9f575f9c71">More...</a><br /></td></tr>
<tr class="separator:gabe8aa45ed742cea841472f9f575f9c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad355337adec8b62593dc482cc5d01a87"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gad355337adec8b62593dc482cc5d01a87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad355337adec8b62593dc482cc5d01a87">resize</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve)</td></tr>
<tr class="memdesc:gad355337adec8b62593dc482cc5d01a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the size of the represented matrix.  <a href="../../de/df1/group__math.html#gad355337adec8b62593dc482cc5d01a87">More...</a><br /></td></tr>
<tr class="separator:gad355337adec8b62593dc482cc5d01a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df60d6b50394cad1e546a4cd8969af6"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga7df60d6b50394cad1e546a4cd8969af6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7df60d6b50394cad1e546a4cd8969af6">reset</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga7df60d6b50394cad1e546a4cd8969af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../de/df1/group__math.html#ga7df60d6b50394cad1e546a4cd8969af6">More...</a><br /></td></tr>
<tr class="separator:ga7df60d6b50394cad1e546a4cd8969af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a8a33a97692e307634bf7db10cd6276"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga5a8a33a97692e307634bf7db10cd6276"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5a8a33a97692e307634bf7db10cd6276">reset</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga5a8a33a97692e307634bf7db10cd6276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column of the represented matrix.  <a href="../../de/df1/group__math.html#ga5a8a33a97692e307634bf7db10cd6276">More...</a><br /></td></tr>
<tr class="separator:ga5a8a33a97692e307634bf7db10cd6276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a52ebee9e73c73f6492af64841cdca"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga98a52ebee9e73c73f6492af64841cdca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga98a52ebee9e73c73f6492af64841cdca">clear</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga98a52ebee9e73c73f6492af64841cdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented matrix.  <a href="../../de/df1/group__math.html#ga98a52ebee9e73c73f6492af64841cdca">More...</a><br /></td></tr>
<tr class="separator:ga98a52ebee9e73c73f6492af64841cdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SparseVectorProxy global functions</div></td></tr>
<tr class="memitem:ga8d0d84fb462bcda9e4ac1b46da8f4e3a"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga8d0d84fb462bcda9e4ac1b46da8f4e3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga8d0d84fb462bcda9e4ac1b46da8f4e3a">begin</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga8d0d84fb462bcda9e4ac1b46da8f4e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the represented vector.  <a href="../../de/df1/group__math.html#ga8d0d84fb462bcda9e4ac1b46da8f4e3a">More...</a><br /></td></tr>
<tr class="separator:ga8d0d84fb462bcda9e4ac1b46da8f4e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64edd34b7ccc061871ebf7b372a0d1c"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gaa64edd34b7ccc061871ebf7b372a0d1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa64edd34b7ccc061871ebf7b372a0d1c">cbegin</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa64edd34b7ccc061871ebf7b372a0d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the represented vector.  <a href="../../de/df1/group__math.html#gaa64edd34b7ccc061871ebf7b372a0d1c">More...</a><br /></td></tr>
<tr class="separator:gaa64edd34b7ccc061871ebf7b372a0d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2eb393d47a7d6681303ec6729fe259"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga7a2eb393d47a7d6681303ec6729fe259"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7a2eb393d47a7d6681303ec6729fe259">end</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga7a2eb393d47a7d6681303ec6729fe259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the represented vector.  <a href="../../de/df1/group__math.html#ga7a2eb393d47a7d6681303ec6729fe259">More...</a><br /></td></tr>
<tr class="separator:ga7a2eb393d47a7d6681303ec6729fe259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1731ef12d4ac4b1847d616935cd74cc8"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga1731ef12d4ac4b1847d616935cd74cc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1731ef12d4ac4b1847d616935cd74cc8">cend</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga1731ef12d4ac4b1847d616935cd74cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the represented vector.  <a href="../../de/df1/group__math.html#ga1731ef12d4ac4b1847d616935cd74cc8">More...</a><br /></td></tr>
<tr class="separator:ga1731ef12d4ac4b1847d616935cd74cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d73069d106d356f221e1dca36f86f8"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gac0d73069d106d356f221e1dca36f86f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac0d73069d106d356f221e1dca36f86f8">size</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gac0d73069d106d356f221e1dca36f86f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the represented vector.  <a href="../../de/df1/group__math.html#gac0d73069d106d356f221e1dca36f86f8">More...</a><br /></td></tr>
<tr class="separator:gac0d73069d106d356f221e1dca36f86f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16914bece2ebf39b5e72e42727593ffd"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga16914bece2ebf39b5e72e42727593ffd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga16914bece2ebf39b5e72e42727593ffd">capacity</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga16914bece2ebf39b5e72e42727593ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the represented vector.  <a href="../../de/df1/group__math.html#ga16914bece2ebf39b5e72e42727593ffd">More...</a><br /></td></tr>
<tr class="separator:ga16914bece2ebf39b5e72e42727593ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c458777c59275735f874c6bb6b3dcc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gae3c458777c59275735f874c6bb6b3dcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae3c458777c59275735f874c6bb6b3dcc">nonZeros</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gae3c458777c59275735f874c6bb6b3dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the represented vector.  <a href="../../de/df1/group__math.html#gae3c458777c59275735f874c6bb6b3dcc">More...</a><br /></td></tr>
<tr class="separator:gae3c458777c59275735f874c6bb6b3dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f67582634373482383eec8008558c6"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gaa3f67582634373482383eec8008558c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa3f67582634373482383eec8008558c6">resize</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve)</td></tr>
<tr class="memdesc:gaa3f67582634373482383eec8008558c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the size of the represented vector.  <a href="../../de/df1/group__math.html#gaa3f67582634373482383eec8008558c6">More...</a><br /></td></tr>
<tr class="separator:gaa3f67582634373482383eec8008558c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad18d9138d144ff01dcf136f703443a80"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gad18d9138d144ff01dcf136f703443a80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad18d9138d144ff01dcf136f703443a80">reset</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad18d9138d144ff01dcf136f703443a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../de/df1/group__math.html#gad18d9138d144ff01dcf136f703443a80">More...</a><br /></td></tr>
<tr class="separator:gad18d9138d144ff01dcf136f703443a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga727608d5ba71b44eb89fb8d00e567c5f"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga727608d5ba71b44eb89fb8d00e567c5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga727608d5ba71b44eb89fb8d00e567c5f">clear</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga727608d5ba71b44eb89fb8d00e567c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../de/df1/group__math.html#ga727608d5ba71b44eb89fb8d00e567c5f">More...</a><br /></td></tr>
<tr class="separator:ga727608d5ba71b44eb89fb8d00e567c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dense matrix SMP functions</div></td></tr>
<tr class="memitem:gaa80808a575ebb4ee487c3ececb49b11b"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:gaa80808a575ebb4ee487c3ececb49b11b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d1a/structblaze_1_1IsDenseMatrix.html">IsDenseMatrix</a>&lt; MT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html#gaa80808a575ebb4ee487c3ececb49b11b">smpAssign</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa80808a575ebb4ee487c3ececb49b11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP assignment of a matrix to a dense matrix.  <a href="../../dc/d00/group__smp.html#gaa80808a575ebb4ee487c3ececb49b11b">More...</a><br /></td></tr>
<tr class="separator:gaa80808a575ebb4ee487c3ececb49b11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab01c138ec4a37641aee46db562c8352b"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:gab01c138ec4a37641aee46db562c8352b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d1a/structblaze_1_1IsDenseMatrix.html">IsDenseMatrix</a>&lt; MT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html#gab01c138ec4a37641aee46db562c8352b">smpAddAssign</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab01c138ec4a37641aee46db562c8352b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP addition assignment of a matrix to a dense matrix.  <a href="../../dc/d00/group__smp.html#gab01c138ec4a37641aee46db562c8352b">More...</a><br /></td></tr>
<tr class="separator:gab01c138ec4a37641aee46db562c8352b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5049e0c6aa650f7af95e2fc8810ffb36"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga5049e0c6aa650f7af95e2fc8810ffb36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d1a/structblaze_1_1IsDenseMatrix.html">IsDenseMatrix</a>&lt; MT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html#ga5049e0c6aa650f7af95e2fc8810ffb36">smpSubAssign</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5049e0c6aa650f7af95e2fc8810ffb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP subtraction assignment of a matrix to dense matrix.  <a href="../../dc/d00/group__smp.html#ga5049e0c6aa650f7af95e2fc8810ffb36">More...</a><br /></td></tr>
<tr class="separator:ga5049e0c6aa650f7af95e2fc8810ffb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dense vector SMP functions</div></td></tr>
<tr class="memitem:ga689597b1693b0d9e2b80c595713cabb4"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga689597b1693b0d9e2b80c595713cabb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../da/d50/structblaze_1_1IsDenseVector.html">IsDenseVector</a>&lt; VT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html#ga689597b1693b0d9e2b80c595713cabb4">smpAssign</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga689597b1693b0d9e2b80c595713cabb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP assignment of a vector to a dense vector.  <a href="../../dc/d00/group__smp.html#ga689597b1693b0d9e2b80c595713cabb4">More...</a><br /></td></tr>
<tr class="separator:ga689597b1693b0d9e2b80c595713cabb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae592f4bb354009b404173d72de13685"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </td></tr>
<tr class="memitem:gaae592f4bb354009b404173d72de13685"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../da/d50/structblaze_1_1IsDenseVector.html">IsDenseVector</a>&lt; VT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html#gaae592f4bb354009b404173d72de13685">smpAddAssign</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaae592f4bb354009b404173d72de13685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP addition assignment of a vector to a dense vector.  <a href="../../dc/d00/group__smp.html#gaae592f4bb354009b404173d72de13685">More...</a><br /></td></tr>
<tr class="separator:gaae592f4bb354009b404173d72de13685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87a713f4df721a444169d185255f8a38"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga87a713f4df721a444169d185255f8a38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../da/d50/structblaze_1_1IsDenseVector.html">IsDenseVector</a>&lt; VT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html#ga87a713f4df721a444169d185255f8a38">smpSubAssign</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga87a713f4df721a444169d185255f8a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP subtraction assignment of a vector to a dense vector.  <a href="../../dc/d00/group__smp.html#ga87a713f4df721a444169d185255f8a38">More...</a><br /></td></tr>
<tr class="separator:ga87a713f4df721a444169d185255f8a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6499ce88c1e5244375f0790af111d373"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga6499ce88c1e5244375f0790af111d373"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../da/d50/structblaze_1_1IsDenseVector.html">IsDenseVector</a>&lt; VT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html#ga6499ce88c1e5244375f0790af111d373">smpMultAssign</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga6499ce88c1e5244375f0790af111d373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP multiplication assignment of a vector to a dense vector.  <a href="../../dc/d00/group__smp.html#ga6499ce88c1e5244375f0790af111d373">More...</a><br /></td></tr>
<tr class="separator:ga6499ce88c1e5244375f0790af111d373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c0fa8be85117a66962b76363577e666"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga5c0fa8be85117a66962b76363577e666"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../da/d50/structblaze_1_1IsDenseVector.html">IsDenseVector</a>&lt; VT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html#ga5c0fa8be85117a66962b76363577e666">smpDivAssign</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5c0fa8be85117a66962b76363577e666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP division assignment of a vector to a dense vector.  <a href="../../dc/d00/group__smp.html#ga5c0fa8be85117a66962b76363577e666">More...</a><br /></td></tr>
<tr class="separator:ga5c0fa8be85117a66962b76363577e666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SMP utility functions</div></td></tr>
<tr class="memitem:ga3d5444159a291c35ca703ae5d58366ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html#ga3d5444159a291c35ca703ae5d58366ad">getNumThreads</a> ()</td></tr>
<tr class="memdesc:ga3d5444159a291c35ca703ae5d58366ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of threads used for thread parallel operations.  <a href="../../dc/d00/group__smp.html#ga3d5444159a291c35ca703ae5d58366ad">More...</a><br /></td></tr>
<tr class="separator:ga3d5444159a291c35ca703ae5d58366ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5434a72b76ef2fcf1ecb9901689f8159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html#ga5434a72b76ef2fcf1ecb9901689f8159">setNumThreads</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> number)</td></tr>
<tr class="memdesc:ga5434a72b76ef2fcf1ecb9901689f8159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of threads to be used for thread parallel operations.  <a href="../../dc/d00/group__smp.html#ga5434a72b76ef2fcf1ecb9901689f8159">More...</a><br /></td></tr>
<tr class="separator:ga5434a72b76ef2fcf1ecb9901689f8159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cd94547d34f86f8b15161c968a941fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html#ga5cd94547d34f86f8b15161c968a941fe">shutDownThreads</a> ()</td></tr>
<tr class="memdesc:ga5cd94547d34f86f8b15161c968a941fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a reliable shutdown of C++11 threads for Visual Studio compilers.  <a href="../../dc/d00/group__smp.html#ga5cd94547d34f86f8b15161c968a941fe">More...</a><br /></td></tr>
<tr class="separator:ga5cd94547d34f86f8b15161c968a941fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sparse matrix SMP functions</div></td></tr>
<tr class="memitem:gaa80808a575ebb4ee487c3ececb49b11b"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:gaa80808a575ebb4ee487c3ececb49b11b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d0/d80/structblaze_1_1IsSparseMatrix.html">IsSparseMatrix</a>&lt; MT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gaa80808a575ebb4ee487c3ececb49b11b">smpAssign</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa80808a575ebb4ee487c3ececb49b11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP assignment of a matrix to a sparse matrix.  <a href="#gaa80808a575ebb4ee487c3ececb49b11b">More...</a><br /></td></tr>
<tr class="separator:gaa80808a575ebb4ee487c3ececb49b11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab01c138ec4a37641aee46db562c8352b"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:gab01c138ec4a37641aee46db562c8352b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d0/d80/structblaze_1_1IsSparseMatrix.html">IsSparseMatrix</a>&lt; MT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gab01c138ec4a37641aee46db562c8352b">smpAddAssign</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab01c138ec4a37641aee46db562c8352b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP addition assignment of a matrix to a sparse matrix.  <a href="#gab01c138ec4a37641aee46db562c8352b">More...</a><br /></td></tr>
<tr class="separator:gab01c138ec4a37641aee46db562c8352b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5049e0c6aa650f7af95e2fc8810ffb36"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga5049e0c6aa650f7af95e2fc8810ffb36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d0/d80/structblaze_1_1IsSparseMatrix.html">IsSparseMatrix</a>&lt; MT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga5049e0c6aa650f7af95e2fc8810ffb36">smpSubAssign</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5049e0c6aa650f7af95e2fc8810ffb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP subtraction assignment of a matrix to sparse matrix.  <a href="#ga5049e0c6aa650f7af95e2fc8810ffb36">More...</a><br /></td></tr>
<tr class="separator:ga5049e0c6aa650f7af95e2fc8810ffb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sparse vector SMP functions</div></td></tr>
<tr class="memitem:ga689597b1693b0d9e2b80c595713cabb4"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga689597b1693b0d9e2b80c595713cabb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d4/de1/structblaze_1_1IsSparseVector.html">IsSparseVector</a>&lt; VT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga689597b1693b0d9e2b80c595713cabb4">smpAssign</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga689597b1693b0d9e2b80c595713cabb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP assignment of a vector to a sparse vector.  <a href="#ga689597b1693b0d9e2b80c595713cabb4">More...</a><br /></td></tr>
<tr class="separator:ga689597b1693b0d9e2b80c595713cabb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae592f4bb354009b404173d72de13685"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </td></tr>
<tr class="memitem:gaae592f4bb354009b404173d72de13685"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d4/de1/structblaze_1_1IsSparseVector.html">IsSparseVector</a>&lt; VT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#gaae592f4bb354009b404173d72de13685">smpAddAssign</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaae592f4bb354009b404173d72de13685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP addition assignment of a vector to a sparse vector.  <a href="#gaae592f4bb354009b404173d72de13685">More...</a><br /></td></tr>
<tr class="separator:gaae592f4bb354009b404173d72de13685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87a713f4df721a444169d185255f8a38"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga87a713f4df721a444169d185255f8a38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d4/de1/structblaze_1_1IsSparseVector.html">IsSparseVector</a>&lt; VT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga87a713f4df721a444169d185255f8a38">smpSubAssign</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga87a713f4df721a444169d185255f8a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP subtraction assignment of a vector to a sparse vector.  <a href="#ga87a713f4df721a444169d185255f8a38">More...</a><br /></td></tr>
<tr class="separator:ga87a713f4df721a444169d185255f8a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6499ce88c1e5244375f0790af111d373"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga6499ce88c1e5244375f0790af111d373"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d4/de1/structblaze_1_1IsSparseVector.html">IsSparseVector</a>&lt; VT1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ga6499ce88c1e5244375f0790af111d373">smpMultAssign</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga6499ce88c1e5244375f0790af111d373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the SMP multiplication assignment of a vector to a sparse vector.  <a href="#ga6499ce88c1e5244375f0790af111d373">More...</a><br /></td></tr>
<tr class="separator:ga6499ce88c1e5244375f0790af111d373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ParallelSection functions</div></td></tr>
<tr class="memitem:ga3f63764e8ba4c7c7d3afc27d04289811"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html#ga3f63764e8ba4c7c7d3afc27d04289811">isParallelSectionActive</a> ()</td></tr>
<tr class="memdesc:ga3f63764e8ba4c7c7d3afc27d04289811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a parallel section is active or not.  <a href="../../dc/d00/group__smp.html#ga3f63764e8ba4c7c7d3afc27d04289811">More...</a><br /></td></tr>
<tr class="separator:ga3f63764e8ba4c7c7d3afc27d04289811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SerialSection functions</div></td></tr>
<tr class="memitem:ga979ab229459b4bf93dbcbe923813c4ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html#ga979ab229459b4bf93dbcbe923813c4ca">isSerialSectionActive</a> ()</td></tr>
<tr class="memdesc:ga979ab229459b4bf93dbcbe923813c4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a serial section is active or not.  <a href="../../dc/d00/group__smp.html#ga979ab229459b4bf93dbcbe923813c4ca">More...</a><br /></td></tr>
<tr class="separator:ga979ab229459b4bf93dbcbe923813c4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:abf9121d66e4f555b603820206cf7b911"><td class="memItemLeft" align="right" valign="top"><a id="abf9121d66e4f555b603820206cf7b911"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CompressedMatrix</b> ()</td></tr>
<tr class="separator:abf9121d66e4f555b603820206cf7b911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711f260a93048a915784ef61d2ca99b9"><td class="memItemLeft" align="right" valign="top"><a id="a711f260a93048a915784ef61d2ca99b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CompressedMatrix</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="separator:a711f260a93048a915784ef61d2ca99b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba5ee63d68293ca7cda10eb708a6a70"><td class="memItemLeft" align="right" valign="top"><a id="a6ba5ee63d68293ca7cda10eb708a6a70"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CompressedMatrix</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> nonzeros)</td></tr>
<tr class="separator:a6ba5ee63d68293ca7cda10eb708a6a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9abbebc2cc355ef9636845262a90d6"><td class="memItemLeft" align="right" valign="top"><a id="aee9abbebc2cc355ef9636845262a90d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CompressedMatrix</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, const std::vector&lt; <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> &gt; &amp;nonzeros)</td></tr>
<tr class="separator:aee9abbebc2cc355ef9636845262a90d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c4351e1596000fd4f9b29054fae538"><td class="memItemLeft" align="right" valign="top"><a id="a71c4351e1596000fd4f9b29054fae538"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CompressedMatrix</b> (const <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;sm)</td></tr>
<tr class="separator:a71c4351e1596000fd4f9b29054fae538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44d5d9b67c9ffc5ea902a9f1acbd716"><td class="memItemLeft" align="right" valign="top"><a id="ae44d5d9b67c9ffc5ea902a9f1acbd716"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CompressedMatrix</b> (<a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;&amp;sm) noexcept</td></tr>
<tr class="separator:ae44d5d9b67c9ffc5ea902a9f1acbd716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dfa2c776d882dfb3e71c3214e3a83b"><td class="memTemplParams" colspan="2"><a id="af1dfa2c776d882dfb3e71c3214e3a83b"></a>
template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:af1dfa2c776d882dfb3e71c3214e3a83b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CompressedMatrix</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="separator:af1dfa2c776d882dfb3e71c3214e3a83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0bc85543b6a902d0ce5d4ecde877b3"><td class="memTemplParams" colspan="2"><a id="a5a0bc85543b6a902d0ce5d4ecde877b3"></a>
template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:a5a0bc85543b6a902d0ce5d4ecde877b3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CompressedMatrix</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="separator:a5a0bc85543b6a902d0ce5d4ecde877b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a7381caf10ec95e0bc98c9212e6db969d"><td class="memItemLeft" align="right" valign="top"><a id="a7381caf10ec95e0bc98c9212e6db969d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~CompressedMatrix</b> ()</td></tr>
<tr class="separator:a7381caf10ec95e0bc98c9212e6db969d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:a92d74d7a18196123e8e118493e53ef97"><td class="memItemLeft" align="right" valign="top"><a id="a92d74d7a18196123e8e118493e53ef97"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a18a879317ffe7c431aba1333d2eacaab">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) noexcept</td></tr>
<tr class="separator:a92d74d7a18196123e8e118493e53ef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0a45ce5b1e79a1545c4165dde8e4a9"><td class="memItemLeft" align="right" valign="top"><a id="aad0a45ce5b1e79a1545c4165dde8e4a9"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a18a879317ffe7c431aba1333d2eacaab">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="separator:aad0a45ce5b1e79a1545c4165dde8e4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c831f637c4f74cdca5a531d837facd7"><td class="memItemLeft" align="right" valign="top"><a id="a0c831f637c4f74cdca5a531d837facd7"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) noexcept</td></tr>
<tr class="separator:a0c831f637c4f74cdca5a531d837facd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab648dc2c7e2598993cd66a7e800e08"><td class="memItemLeft" align="right" valign="top"><a id="aeab648dc2c7e2598993cd66a7e800e08"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const noexcept</td></tr>
<tr class="separator:aeab648dc2c7e2598993cd66a7e800e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6b923eced07b17c2fff321cacb8388"><td class="memItemLeft" align="right" valign="top"><a id="aee6b923eced07b17c2fff321cacb8388"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) noexcept</td></tr>
<tr class="separator:aee6b923eced07b17c2fff321cacb8388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8fa6b7fa852b71863520cfd9562036"><td class="memItemLeft" align="right" valign="top"><a id="a2a8fa6b7fa852b71863520cfd9562036"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const noexcept</td></tr>
<tr class="separator:a2a8fa6b7fa852b71863520cfd9562036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment operators</div></td></tr>
<tr class="memitem:a9f7b278135c455fa2fbeec5f1d451131"><td class="memItemLeft" align="right" valign="top"><a id="a9f7b278135c455fa2fbeec5f1d451131"></a>
<a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;rhs)</td></tr>
<tr class="separator:a9f7b278135c455fa2fbeec5f1d451131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292175bf305a9e386d3f8a5b94d9260c"><td class="memItemLeft" align="right" valign="top"><a id="a292175bf305a9e386d3f8a5b94d9260c"></a>
<a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="separator:a292175bf305a9e386d3f8a5b94d9260c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827e4b63ec3d15d86a239aca519b8624"><td class="memTemplParams" colspan="2"><a id="a827e4b63ec3d15d86a239aca519b8624"></a>
template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:a827e4b63ec3d15d86a239aca519b8624"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a827e4b63ec3d15d86a239aca519b8624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbf2f14a3bf796bfd0f6932ac8ab277"><td class="memTemplParams" colspan="2"><a id="afdbf2f14a3bf796bfd0f6932ac8ab277"></a>
template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:afdbf2f14a3bf796bfd0f6932ac8ab277"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:afdbf2f14a3bf796bfd0f6932ac8ab277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabda429872b8c24c991a914f4366bd7"><td class="memTemplParams" colspan="2"><a id="aaabda429872b8c24c991a914f4366bd7"></a>
template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:aaabda429872b8c24c991a914f4366bd7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:aaabda429872b8c24c991a914f4366bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa11c5cf66841725ebbd321fc0a04c22"><td class="memTemplParams" colspan="2"><a id="aaa11c5cf66841725ebbd321fc0a04c22"></a>
template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:aaa11c5cf66841725ebbd321fc0a04c22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:aaa11c5cf66841725ebbd321fc0a04c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6eaead1be02b4350fbb3f55df9f8b65"><td class="memTemplParams" colspan="2"><a id="ad6eaead1be02b4350fbb3f55df9f8b65"></a>
template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ad6eaead1be02b4350fbb3f55df9f8b65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:ad6eaead1be02b4350fbb3f55df9f8b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3df7a11c912b96bc592f6f6198c0ea"><td class="memTemplParams" colspan="2"><a id="a6c3df7a11c912b96bc592f6f6198c0ea"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a6c3df7a11c912b96bc592f6f6198c0ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (Other rhs)</td></tr>
<tr class="separator:a6c3df7a11c912b96bc592f6f6198c0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00077f6ec0dedca1064f072a4e683197"><td class="memTemplParams" colspan="2"><a id="a00077f6ec0dedca1064f072a4e683197"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a00077f6ec0dedca1064f072a4e683197"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (Other rhs)</td></tr>
<tr class="separator:a00077f6ec0dedca1064f072a4e683197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility functions</div></td></tr>
<tr class="memitem:adcdec1bd8671af45180726104748ee06"><td class="memItemLeft" align="right" valign="top"><a id="adcdec1bd8671af45180726104748ee06"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rows</b> () const noexcept</td></tr>
<tr class="separator:adcdec1bd8671af45180726104748ee06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055658f25e978f00b3ceec12edcc54d7"><td class="memItemLeft" align="right" valign="top"><a id="a055658f25e978f00b3ceec12edcc54d7"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>columns</b> () const noexcept</td></tr>
<tr class="separator:a055658f25e978f00b3ceec12edcc54d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaf6fe528a556d45641f8178ce2421f"><td class="memItemLeft" align="right" valign="top"><a id="a0eaf6fe528a556d45641f8178ce2421f"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> () const noexcept</td></tr>
<tr class="separator:a0eaf6fe528a556d45641f8178ce2421f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c49349e55a332696462d7a4636b5f9"><td class="memItemLeft" align="right" valign="top"><a id="a28c49349e55a332696462d7a4636b5f9"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const noexcept</td></tr>
<tr class="separator:a28c49349e55a332696462d7a4636b5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5309ce07e8c191e52189db952190f9b"><td class="memItemLeft" align="right" valign="top"><a id="ad5309ce07e8c191e52189db952190f9b"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nonZeros</b> () const</td></tr>
<tr class="separator:ad5309ce07e8c191e52189db952190f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd535083efe84b5aecfdcb8d95b05bcc"><td class="memItemLeft" align="right" valign="top"><a id="acd535083efe84b5aecfdcb8d95b05bcc"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nonZeros</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const</td></tr>
<tr class="separator:acd535083efe84b5aecfdcb8d95b05bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9bbb46c6e28c5a7b4ef8e888ec28f1"><td class="memItemLeft" align="right" valign="top"><a id="a7c9bbb46c6e28c5a7b4ef8e888ec28f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> ()</td></tr>
<tr class="separator:a7c9bbb46c6e28c5a7b4ef8e888ec28f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c4f177cf6fc74c762cdb61eb8eb910"><td class="memItemLeft" align="right" valign="top"><a id="a07c4f177cf6fc74c762cdb61eb8eb910"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="separator:a07c4f177cf6fc74c762cdb61eb8eb910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7126b7d5343e1156506f34971f9e30"><td class="memItemLeft" align="right" valign="top"><a id="ada7126b7d5343e1156506f34971f9e30"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:ada7126b7d5343e1156506f34971f9e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bb1e844ec68146d83f47d25be23171"><td class="memItemLeft" align="right" valign="top"><a id="ac9bb1e844ec68146d83f47d25be23171"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>set</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const Type &amp;value)</td></tr>
<tr class="separator:ac9bb1e844ec68146d83f47d25be23171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f643149e6f6b877bb94304010f3a26"><td class="memItemLeft" align="right" valign="top"><a id="ab3f643149e6f6b877bb94304010f3a26"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const Type &amp;value)</td></tr>
<tr class="separator:ab3f643149e6f6b877bb94304010f3a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c71aa2386648234a7e7f391083aac0c"><td class="memItemLeft" align="right" valign="top"><a id="a9c71aa2386648234a7e7f391083aac0c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="separator:a9c71aa2386648234a7e7f391083aac0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69066840580e3fe5f8bf7870adbd806"><td class="memItemLeft" align="right" valign="top"><a id="ac69066840580e3fe5f8bf7870adbd806"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, <a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a> pos)</td></tr>
<tr class="separator:ac69066840580e3fe5f8bf7870adbd806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59248f94491c20bbb6aea4e8a193cd61"><td class="memItemLeft" align="right" valign="top"><a id="a59248f94491c20bbb6aea4e8a193cd61"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, <a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a> first, <a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a> last)</td></tr>
<tr class="separator:a59248f94491c20bbb6aea4e8a193cd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad64b9fe3e79938eca605927b660e9f"><td class="memItemLeft" align="right" valign="top"><a id="aaad64b9fe3e79938eca605927b660e9f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve=true)</td></tr>
<tr class="separator:aaad64b9fe3e79938eca605927b660e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0715f95d0aebcfb0b067081b95f878"><td class="memItemLeft" align="right" valign="top"><a id="adf0715f95d0aebcfb0b067081b95f878"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> nonzeros)</td></tr>
<tr class="separator:adf0715f95d0aebcfb0b067081b95f878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a5b33411f3a0e07beb1e8810c6f106"><td class="memItemLeft" align="right" valign="top"><a id="a39a5b33411f3a0e07beb1e8810c6f106"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> nonzeros)</td></tr>
<tr class="separator:a39a5b33411f3a0e07beb1e8810c6f106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17232b57a7bacc30c47b0d4289fc8c6"><td class="memItemLeft" align="right" valign="top"><a id="aa17232b57a7bacc30c47b0d4289fc8c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>trim</b> ()</td></tr>
<tr class="separator:aa17232b57a7bacc30c47b0d4289fc8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17964db7b84b58703913f0de91d9f12"><td class="memItemLeft" align="right" valign="top"><a id="ac17964db7b84b58703913f0de91d9f12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>trim</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="separator:ac17964db7b84b58703913f0de91d9f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8794b26efcb8d431215e38c3ae9ea906"><td class="memItemLeft" align="right" valign="top"><a id="a8794b26efcb8d431215e38c3ae9ea906"></a>
<a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>transpose</b> ()</td></tr>
<tr class="separator:a8794b26efcb8d431215e38c3ae9ea906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f854ba0c00d81fddfeb0d3e2d63344"><td class="memItemLeft" align="right" valign="top"><a id="ac8f854ba0c00d81fddfeb0d3e2d63344"></a>
<a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ctranspose</b> ()</td></tr>
<tr class="separator:ac8f854ba0c00d81fddfeb0d3e2d63344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af708dbc7ed57eab964ce24eba8ab15c1"><td class="memTemplParams" colspan="2"><a id="af708dbc7ed57eab964ce24eba8ab15c1"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:af708dbc7ed57eab964ce24eba8ab15c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scale</b> (const Other &amp;scalar)</td></tr>
<tr class="separator:af708dbc7ed57eab964ce24eba8ab15c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac779d5681263459fa8d306e69087059f"><td class="memTemplParams" colspan="2"><a id="ac779d5681263459fa8d306e69087059f"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ac779d5681263459fa8d306e69087059f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scaleDiagonal</b> (Other scalar)</td></tr>
<tr class="separator:ac779d5681263459fa8d306e69087059f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a75ae4f735536f1ce1809be69fe53cc"><td class="memItemLeft" align="right" valign="top"><a id="a2a75ae4f735536f1ce1809be69fe53cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a> &amp;sm) noexcept</td></tr>
<tr class="separator:a2a75ae4f735536f1ce1809be69fe53cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22228f3b56d799280d1c238dfe733f99"><td class="memItemLeft" align="right" valign="top"><a id="a22228f3b56d799280d1c238dfe733f99"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a> pos, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const Type &amp;value)</td></tr>
<tr class="separator:a22228f3b56d799280d1c238dfe733f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251f0c96db98b19d99b5cdf334a9d475"><td class="memItemLeft" align="right" valign="top"><a id="a251f0c96db98b19d99b5cdf334a9d475"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>extendCapacity</b> () const noexcept</td></tr>
<tr class="separator:a251f0c96db98b19d99b5cdf334a9d475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4407cacca4be1e6d57daed7c2a22f2"><td class="memItemLeft" align="right" valign="top"><a id="a9b4407cacca4be1e6d57daed7c2a22f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserveElements</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> nonzeros)</td></tr>
<tr class="separator:a9b4407cacca4be1e6d57daed7c2a22f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Lookup functions</div></td></tr>
<tr class="memitem:a0f24d351e8c33f92a485315c47b9bf87"><td class="memItemLeft" align="right" valign="top"><a id="a0f24d351e8c33f92a485315c47b9bf87"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="separator:a0f24d351e8c33f92a485315c47b9bf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e36109960457c22f4713a9155778f9"><td class="memItemLeft" align="right" valign="top"><a id="a81e36109960457c22f4713a9155778f9"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lowerBound</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="separator:a81e36109960457c22f4713a9155778f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb2a4b2769b83bc24b5d34a7a1fcf18"><td class="memItemLeft" align="right" valign="top"><a id="abcb2a4b2769b83bc24b5d34a7a1fcf18"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>upperBound</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="separator:abcb2a4b2769b83bc24b5d34a7a1fcf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low-level utility functions</div></td></tr>
<tr class="memitem:aa0413ac4a9ea02f6c578a8802a52e154"><td class="memItemLeft" align="right" valign="top"><a id="aa0413ac4a9ea02f6c578a8802a52e154"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const Type &amp;value, bool check=false)</td></tr>
<tr class="separator:aa0413ac4a9ea02f6c578a8802a52e154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0b2b4d8d55700e9981b8823eeb8808"><td class="memItemLeft" align="right" valign="top"><a id="adf0b2b4d8d55700e9981b8823eeb8808"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>finalize</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="separator:adf0b2b4d8d55700e9981b8823eeb8808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression template evaluation functions</div></td></tr>
<tr class="memitem:ae30502e70278933e3c699d88050bbb48"><td class="memTemplParams" colspan="2"><a id="ae30502e70278933e3c699d88050bbb48"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ae30502e70278933e3c699d88050bbb48"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>canAlias</b> (const Other *alias) const noexcept</td></tr>
<tr class="separator:ae30502e70278933e3c699d88050bbb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879c056472c8860c1ba16de1ab735c18"><td class="memTemplParams" colspan="2"><a id="a879c056472c8860c1ba16de1ab735c18"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a879c056472c8860c1ba16de1ab735c18"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isAliased</b> (const Other *alias) const noexcept</td></tr>
<tr class="separator:a879c056472c8860c1ba16de1ab735c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41398f660760e979ffe144e3213506e9"><td class="memItemLeft" align="right" valign="top"><a id="a41398f660760e979ffe144e3213506e9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>canSMPAssign</b> () const noexcept</td></tr>
<tr class="separator:a41398f660760e979ffe144e3213506e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422e365abe1ea6785330b8dddde8a2f7"><td class="memTemplParams" colspan="2"><a id="a422e365abe1ea6785330b8dddde8a2f7"></a>
template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:a422e365abe1ea6785330b8dddde8a2f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a422e365abe1ea6785330b8dddde8a2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6881e3f2a64e285a71df53ec6cf693"><td class="memTemplParams" colspan="2"><a id="acd6881e3f2a64e285a71df53ec6cf693"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:acd6881e3f2a64e285a71df53ec6cf693"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:acd6881e3f2a64e285a71df53ec6cf693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452bdece21b80194056cfbcb6a1f6eea"><td class="memTemplParams" colspan="2"><a id="a452bdece21b80194056cfbcb6a1f6eea"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a452bdece21b80194056cfbcb6a1f6eea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a452bdece21b80194056cfbcb6a1f6eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57358fe4c06af1dc914d20ccf5209c32"><td class="memTemplParams" colspan="2"><a id="a57358fe4c06af1dc914d20ccf5209c32"></a>
template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:a57358fe4c06af1dc914d20ccf5209c32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a57358fe4c06af1dc914d20ccf5209c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f3412261bd1d658e465bb344f67e5b"><td class="memTemplParams" colspan="2"><a id="a94f3412261bd1d658e465bb344f67e5b"></a>
template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:a94f3412261bd1d658e465bb344f67e5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a94f3412261bd1d658e465bb344f67e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8780d8dac1cc3c856214c2384352a4"><td class="memTemplParams" colspan="2"><a id="a2f8780d8dac1cc3c856214c2384352a4"></a>
template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:a2f8780d8dac1cc3c856214c2384352a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a2f8780d8dac1cc3c856214c2384352a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed59345524ef5e73a199b8d727a4a779"><td class="memTemplParams" colspan="2"><a id="aed59345524ef5e73a199b8d727a4a779"></a>
template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:aed59345524ef5e73a199b8d727a4a779"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:aed59345524ef5e73a199b8d727a4a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">CompressedVector operators</div></td></tr>
<tr class="memitem:gac0ed24aa47bf231ae7bc5794ed3b8ff6"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:gac0ed24aa47bf231ae7bc5794ed3b8ff6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html#gac0ed24aa47bf231ae7bc5794ed3b8ff6">reset</a> (<a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a>&lt; Type, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:gac0ed24aa47bf231ae7bc5794ed3b8ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given compressed vector.  <a href="../../d1/da9/group__compressed__vector.html#gac0ed24aa47bf231ae7bc5794ed3b8ff6">More...</a><br /></td></tr>
<tr class="separator:gac0ed24aa47bf231ae7bc5794ed3b8ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf95dc88c6e4048e3de85ba165c57f89d"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:gaf95dc88c6e4048e3de85ba165c57f89d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html#gaf95dc88c6e4048e3de85ba165c57f89d">clear</a> (<a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a>&lt; Type, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:gaf95dc88c6e4048e3de85ba165c57f89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given compressed vector.  <a href="../../d1/da9/group__compressed__vector.html#gaf95dc88c6e4048e3de85ba165c57f89d">More...</a><br /></td></tr>
<tr class="separator:gaf95dc88c6e4048e3de85ba165c57f89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7822f2645f85dc043311b92711e45cfd"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:ga7822f2645f85dc043311b92711e45cfd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html#ga7822f2645f85dc043311b92711e45cfd">isDefault</a> (const <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a>&lt; Type, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga7822f2645f85dc043311b92711e45cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given compressed vector is in default state.  <a href="../../d1/da9/group__compressed__vector.html#ga7822f2645f85dc043311b92711e45cfd">More...</a><br /></td></tr>
<tr class="separator:ga7822f2645f85dc043311b92711e45cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e71646d6d656bd9aad555bdd1aaa73"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:ga03e71646d6d656bd9aad555bdd1aaa73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html#ga03e71646d6d656bd9aad555bdd1aaa73">isIntact</a> (const <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a>&lt; Type, TF &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga03e71646d6d656bd9aad555bdd1aaa73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given compressed vector are intact.  <a href="../../d1/da9/group__compressed__vector.html#ga03e71646d6d656bd9aad555bdd1aaa73">More...</a><br /></td></tr>
<tr class="separator:ga03e71646d6d656bd9aad555bdd1aaa73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e5d89603e6d1305b562f194878fe9e0"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:ga8e5d89603e6d1305b562f194878fe9e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html#ga8e5d89603e6d1305b562f194878fe9e0">swap</a> (<a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a>&lt; Type, TF &gt; &amp;a, <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a>&lt; Type, TF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga8e5d89603e6d1305b562f194878fe9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two compressed vectors.  <a href="../../d1/da9/group__compressed__vector.html#ga8e5d89603e6d1305b562f194878fe9e0">More...</a><br /></td></tr>
<tr class="separator:ga8e5d89603e6d1305b562f194878fe9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">MatrixAccessProxy global functions</div></td></tr>
<tr class="memitem:gaa329d4ff44a8780cb8f29343ffc32790"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaa329d4ff44a8780cb8f29343ffc32790"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa329d4ff44a8780cb8f29343ffc32790">reset</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa329d4ff44a8780cb8f29343ffc32790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../d0/d45/group__sparse__matrix.html#gaa329d4ff44a8780cb8f29343ffc32790">More...</a><br /></td></tr>
<tr class="separator:gaa329d4ff44a8780cb8f29343ffc32790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga3d9a939b2471f71e81d8eee8c22a5ae4">clear</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../d0/d45/group__sparse__matrix.html#ga3d9a939b2471f71e81d8eee8c22a5ae4">More...</a><br /></td></tr>
<tr class="separator:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga045077f88b05d5f5fa13c4ef1eaf0161"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga045077f88b05d5f5fa13c4ef1eaf0161"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga045077f88b05d5f5fa13c4ef1eaf0161">isDefault</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga045077f88b05d5f5fa13c4ef1eaf0161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../d0/d45/group__sparse__matrix.html#ga045077f88b05d5f5fa13c4ef1eaf0161">More...</a><br /></td></tr>
<tr class="separator:ga045077f88b05d5f5fa13c4ef1eaf0161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e93d386f385481def668d7a6edc03b"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga87e93d386f385481def668d7a6edc03b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga87e93d386f385481def668d7a6edc03b">isReal</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga87e93d386f385481def668d7a6edc03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix element represents a real number.  <a href="../../d0/d45/group__sparse__matrix.html#ga87e93d386f385481def668d7a6edc03b">More...</a><br /></td></tr>
<tr class="separator:ga87e93d386f385481def668d7a6edc03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4459ccfdf53dffab841e1a7ea2b3833"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gad4459ccfdf53dffab841e1a7ea2b3833"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gad4459ccfdf53dffab841e1a7ea2b3833">isZero</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad4459ccfdf53dffab841e1a7ea2b3833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../d0/d45/group__sparse__matrix.html#gad4459ccfdf53dffab841e1a7ea2b3833">More...</a><br /></td></tr>
<tr class="separator:gad4459ccfdf53dffab841e1a7ea2b3833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab379db74bff9739a4b1d7dcf7594766a"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gab379db74bff9739a4b1d7dcf7594766a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gab379db74bff9739a4b1d7dcf7594766a">isOne</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gab379db74bff9739a4b1d7dcf7594766a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../d0/d45/group__sparse__matrix.html#gab379db74bff9739a4b1d7dcf7594766a">More...</a><br /></td></tr>
<tr class="separator:gab379db74bff9739a4b1d7dcf7594766a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272972206a96bceac26706156979ddc0"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga272972206a96bceac26706156979ddc0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga272972206a96bceac26706156979ddc0">isnan</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga272972206a96bceac26706156979ddc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../d0/d45/group__sparse__matrix.html#ga272972206a96bceac26706156979ddc0">More...</a><br /></td></tr>
<tr class="separator:ga272972206a96bceac26706156979ddc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48b3ef0a633565ae5ae8d03422150d66"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga48b3ef0a633565ae5ae8d03422150d66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga48b3ef0a633565ae5ae8d03422150d66">swap</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;a, const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga48b3ef0a633565ae5ae8d03422150d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two access proxies.  <a href="../../d0/d45/group__sparse__matrix.html#ga48b3ef0a633565ae5ae8d03422150d66">More...</a><br /></td></tr>
<tr class="separator:ga48b3ef0a633565ae5ae8d03422150d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e363bb9d02dc099d3d52ba6ad93373"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga56e363bb9d02dc099d3d52ba6ad93373"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga56e363bb9d02dc099d3d52ba6ad93373">swap</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;a, T &amp;b) noexcept</td></tr>
<tr class="memdesc:ga56e363bb9d02dc099d3d52ba6ad93373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="../../d0/d45/group__sparse__matrix.html#ga56e363bb9d02dc099d3d52ba6ad93373">More...</a><br /></td></tr>
<tr class="separator:ga56e363bb9d02dc099d3d52ba6ad93373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba7ff15d755e738537539e75ec37072"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:ga1ba7ff15d755e738537539e75ec37072"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga1ba7ff15d755e738537539e75ec37072">swap</a> (T &amp;a, const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga1ba7ff15d755e738537539e75ec37072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="../../d0/d45/group__sparse__matrix.html#ga1ba7ff15d755e738537539e75ec37072">More...</a><br /></td></tr>
<tr class="separator:ga1ba7ff15d755e738537539e75ec37072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SparseMatrix operators</div></td></tr>
<tr class="memitem:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga5be271299bf9d21d79adbc98fefc7c73">operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5be271299bf9d21d79adbc98fefc7c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two row-major sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#ga5be271299bf9d21d79adbc98fefc7c73">More...</a><br /></td></tr>
<tr class="separator:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3f69b34e146551053564a5ddba4469c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gac3f69b34e146551053564a5ddba4469c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gac3f69b34e146551053564a5ddba4469c">operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac3f69b34e146551053564a5ddba4469c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two column-major sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#gac3f69b34e146551053564a5ddba4469c">More...</a><br /></td></tr>
<tr class="separator:gac3f69b34e146551053564a5ddba4469c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga52adc17fd1c3cf58857e4bbe59d5215a">operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two sparse matrices with different storage order.  <a href="../../d0/d45/group__sparse__matrix.html#ga52adc17fd1c3cf58857e4bbe59d5215a">More...</a><br /></td></tr>
<tr class="separator:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23358313c28966ce20d3e636914c151f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga23358313c28966ce20d3e636914c151f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga23358313c28966ce20d3e636914c151f">operator!=</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga23358313c28966ce20d3e636914c151f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#ga23358313c28966ce20d3e636914c151f">More...</a><br /></td></tr>
<tr class="separator:ga23358313c28966ce20d3e636914c151f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SparseMatrix functions</div></td></tr>
<tr class="memitem:ga5fd7ae64eff3d41879d3fc8a138daa7d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga5fd7ae64eff3d41879d3fc8a138daa7d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga5fd7ae64eff3d41879d3fc8a138daa7d">isnan</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga5fd7ae64eff3d41879d3fc8a138daa7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given sparse matrix for not-a-number elements.  <a href="../../d0/d45/group__sparse__matrix.html#ga5fd7ae64eff3d41879d3fc8a138daa7d">More...</a><br /></td></tr>
<tr class="separator:ga5fd7ae64eff3d41879d3fc8a138daa7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf68c6f947e934a922cdd9b332bd1d06"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaaf68c6f947e934a922cdd9b332bd1d06"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaaf68c6f947e934a922cdd9b332bd1d06">isSymmetric</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaaf68c6f947e934a922cdd9b332bd1d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is symmetric.  <a href="../../d0/d45/group__sparse__matrix.html#gaaf68c6f947e934a922cdd9b332bd1d06">More...</a><br /></td></tr>
<tr class="separator:gaaf68c6f947e934a922cdd9b332bd1d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c0fd85aab1d79528022abb07c8e9839"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga5c0fd85aab1d79528022abb07c8e9839"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga5c0fd85aab1d79528022abb07c8e9839">isHermitian</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga5c0fd85aab1d79528022abb07c8e9839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is Hermitian.  <a href="../../d0/d45/group__sparse__matrix.html#ga5c0fd85aab1d79528022abb07c8e9839">More...</a><br /></td></tr>
<tr class="separator:ga5c0fd85aab1d79528022abb07c8e9839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e0ca7a0d5a81488e6edf5ff596331a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga47e0ca7a0d5a81488e6edf5ff596331a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga47e0ca7a0d5a81488e6edf5ff596331a">isUniform</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga47e0ca7a0d5a81488e6edf5ff596331a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a uniform matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga47e0ca7a0d5a81488e6edf5ff596331a">More...</a><br /></td></tr>
<tr class="separator:ga47e0ca7a0d5a81488e6edf5ff596331a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57a4918696d365b52a9e35935be3b3b6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga57a4918696d365b52a9e35935be3b3b6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga57a4918696d365b52a9e35935be3b3b6">isLower</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga57a4918696d365b52a9e35935be3b3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a lower triangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga57a4918696d365b52a9e35935be3b3b6">More...</a><br /></td></tr>
<tr class="separator:ga57a4918696d365b52a9e35935be3b3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4917d0546e6bcde7ed986fa6ae72cf25"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4917d0546e6bcde7ed986fa6ae72cf25"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4917d0546e6bcde7ed986fa6ae72cf25">isUniLower</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga4917d0546e6bcde7ed986fa6ae72cf25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a lower unitriangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga4917d0546e6bcde7ed986fa6ae72cf25">More...</a><br /></td></tr>
<tr class="separator:ga4917d0546e6bcde7ed986fa6ae72cf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2707785425307e33a2950873b56ac70"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae2707785425307e33a2950873b56ac70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gae2707785425307e33a2950873b56ac70">isStrictlyLower</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gae2707785425307e33a2950873b56ac70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a strictly lower triangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#gae2707785425307e33a2950873b56ac70">More...</a><br /></td></tr>
<tr class="separator:gae2707785425307e33a2950873b56ac70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ded972e027174cb24eeb360addd187f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga1ded972e027174cb24eeb360addd187f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga1ded972e027174cb24eeb360addd187f">isUpper</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga1ded972e027174cb24eeb360addd187f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is an upper triangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga1ded972e027174cb24eeb360addd187f">More...</a><br /></td></tr>
<tr class="separator:ga1ded972e027174cb24eeb360addd187f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4449cb73b43824d7f82352816237a1be"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4449cb73b43824d7f82352816237a1be"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4449cb73b43824d7f82352816237a1be">isUniUpper</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga4449cb73b43824d7f82352816237a1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is an upper unitriangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga4449cb73b43824d7f82352816237a1be">More...</a><br /></td></tr>
<tr class="separator:ga4449cb73b43824d7f82352816237a1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f046512b938b1f2377975ff3b1060d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga67f046512b938b1f2377975ff3b1060d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga67f046512b938b1f2377975ff3b1060d">isStrictlyUpper</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga67f046512b938b1f2377975ff3b1060d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a strictly upper triangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga67f046512b938b1f2377975ff3b1060d">More...</a><br /></td></tr>
<tr class="separator:ga67f046512b938b1f2377975ff3b1060d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cde1c159ec32c203e73427e98de26c8"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga9cde1c159ec32c203e73427e98de26c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga9cde1c159ec32c203e73427e98de26c8">isDiagonal</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga9cde1c159ec32c203e73427e98de26c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the give sparse matrix is diagonal.  <a href="../../d0/d45/group__sparse__matrix.html#ga9cde1c159ec32c203e73427e98de26c8">More...</a><br /></td></tr>
<tr class="separator:ga9cde1c159ec32c203e73427e98de26c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f2b973088b1ae6f538c6fe66837b6d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga33f2b973088b1ae6f538c6fe66837b6d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga33f2b973088b1ae6f538c6fe66837b6d">isIdentity</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga33f2b973088b1ae6f538c6fe66837b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the give sparse matrix is an identity matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga33f2b973088b1ae6f538c6fe66837b6d">More...</a><br /></td></tr>
<tr class="separator:ga33f2b973088b1ae6f538c6fe66837b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga939c2915cf7e6cb391d024b4c90dca15"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga939c2915cf7e6cb391d024b4c90dca15"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga939c2915cf7e6cb391d024b4c90dca15">min</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga939c2915cf7e6cb391d024b4c90dca15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the sparse matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga939c2915cf7e6cb391d024b4c90dca15">More...</a><br /></td></tr>
<tr class="separator:ga939c2915cf7e6cb391d024b4c90dca15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a5f94e2e6c14eba8ca707b7a6b7d4b2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga9a5f94e2e6c14eba8ca707b7a6b7d4b2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga9a5f94e2e6c14eba8ca707b7a6b7d4b2">max</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga9a5f94e2e6c14eba8ca707b7a6b7d4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the sparse matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga9a5f94e2e6c14eba8ca707b7a6b7d4b2">More...</a><br /></td></tr>
<tr class="separator:ga9a5f94e2e6c14eba8ca707b7a6b7d4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SparseVector operators</div></td></tr>
<tr class="memitem:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga3abacbc4a4ecdb439384f1ce2ae38246">operator==</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two sparse vectors.  <a href="../../d6/d2f/group__sparse__vector.html#ga3abacbc4a4ecdb439384f1ce2ae38246">More...</a><br /></td></tr>
<tr class="separator:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga47bd825d8a1516cf16134c4dc9ac918a">operator!=</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two sparse vectors.  <a href="../../d6/d2f/group__sparse__vector.html#ga47bd825d8a1516cf16134c4dc9ac918a">More...</a><br /></td></tr>
<tr class="separator:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SparseVector functions</div></td></tr>
<tr class="memitem:ga4490b16f3da675eb29db391adcf46f98"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4490b16f3da675eb29db391adcf46f98"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga4490b16f3da675eb29db391adcf46f98">isnan</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga4490b16f3da675eb29db391adcf46f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given sparse vector for not-a-number elements.  <a href="../../d6/d2f/group__sparse__vector.html#ga4490b16f3da675eb29db391adcf46f98">More...</a><br /></td></tr>
<tr class="separator:ga4490b16f3da675eb29db391adcf46f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa58862b9f216db8c76842cd7c649d092"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa58862b9f216db8c76842cd7c649d092"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa58862b9f216db8c76842cd7c649d092">isUniform</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa58862b9f216db8c76842cd7c649d092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse vector is a uniform vector.  <a href="../../d6/d2f/group__sparse__vector.html#gaa58862b9f216db8c76842cd7c649d092">More...</a><br /></td></tr>
<tr class="separator:gaa58862b9f216db8c76842cd7c649d092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26eb8f27519826300e4c6e05540f4f7a"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga26eb8f27519826300e4c6e05540f4f7a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga26eb8f27519826300e4c6e05540f4f7a">sqrLength</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga26eb8f27519826300e4c6e05540f4f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the sparse vector square length <img class="formulaInl" alt="$|\vec{a}|^2$" src="../../form_63.png"/>.  <a href="../../d6/d2f/group__sparse__vector.html#ga26eb8f27519826300e4c6e05540f4f7a">More...</a><br /></td></tr>
<tr class="separator:ga26eb8f27519826300e4c6e05540f4f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69b4ec965b7288218a79549c50b51db"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa69b4ec965b7288218a79549c50b51db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa69b4ec965b7288218a79549c50b51db">length</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv) -&gt; decltype(<a class="el" href="../../db/df0/group__dense__matrix.html#ga660a4e2de4b63aac4181af49ac9160d8">sqrt</a>(<a class="el" href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32">sqrLength</a>(~sv)))</td></tr>
<tr class="memdesc:gaa69b4ec965b7288218a79549c50b51db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the sparse vector length <img class="formulaInl" alt="$|\vec{a}|$" src="../../form_64.png"/>.  <a href="../../d6/d2f/group__sparse__vector.html#gaa69b4ec965b7288218a79549c50b51db">More...</a><br /></td></tr>
<tr class="separator:gaa69b4ec965b7288218a79549c50b51db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1c42aadfa3bdbe0be24df9ecd47c222"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa1c42aadfa3bdbe0be24df9ecd47c222"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa1c42aadfa3bdbe0be24df9ecd47c222">min</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa1c42aadfa3bdbe0be24df9ecd47c222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the sparse vector.  <a href="../../d6/d2f/group__sparse__vector.html#gaa1c42aadfa3bdbe0be24df9ecd47c222">More...</a><br /></td></tr>
<tr class="separator:gaa1c42aadfa3bdbe0be24df9ecd47c222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f496dbc22cefdf5b31975f57271caf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gad7f496dbc22cefdf5b31975f57271caf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gad7f496dbc22cefdf5b31975f57271caf">max</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gad7f496dbc22cefdf5b31975f57271caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the sparse vector.  <a href="../../d6/d2f/group__sparse__vector.html#gad7f496dbc22cefdf5b31975f57271caf">More...</a><br /></td></tr>
<tr class="separator:gad7f496dbc22cefdf5b31975f57271caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">VectorAccessProxy global functions</div></td></tr>
<tr class="memitem:ga4ccb520d1605428c703fb1e231984b8a"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga4ccb520d1605428c703fb1e231984b8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga4ccb520d1605428c703fb1e231984b8a">reset</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga4ccb520d1605428c703fb1e231984b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../d6/d2f/group__sparse__vector.html#ga4ccb520d1605428c703fb1e231984b8a">More...</a><br /></td></tr>
<tr class="separator:ga4ccb520d1605428c703fb1e231984b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga548f8ae65fde704870019a244c4aa68d"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga548f8ae65fde704870019a244c4aa68d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga548f8ae65fde704870019a244c4aa68d">clear</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga548f8ae65fde704870019a244c4aa68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../d6/d2f/group__sparse__vector.html#ga548f8ae65fde704870019a244c4aa68d">More...</a><br /></td></tr>
<tr class="separator:ga548f8ae65fde704870019a244c4aa68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb3ad1af3a538107952f5d3f03dab8d5"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gacb3ad1af3a538107952f5d3f03dab8d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gacb3ad1af3a538107952f5d3f03dab8d5">isDefault</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gacb3ad1af3a538107952f5d3f03dab8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../d6/d2f/group__sparse__vector.html#gacb3ad1af3a538107952f5d3f03dab8d5">More...</a><br /></td></tr>
<tr class="separator:gacb3ad1af3a538107952f5d3f03dab8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6615fb157a5b5d597f371c749618b73"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gac6615fb157a5b5d597f371c749618b73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gac6615fb157a5b5d597f371c749618b73">isReal</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gac6615fb157a5b5d597f371c749618b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector element represents a real number.  <a href="../../d6/d2f/group__sparse__vector.html#gac6615fb157a5b5d597f371c749618b73">More...</a><br /></td></tr>
<tr class="separator:gac6615fb157a5b5d597f371c749618b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab97eab0b10c2649a287c00702bb79cd"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gaab97eab0b10c2649a287c00702bb79cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaab97eab0b10c2649a287c00702bb79cd">isZero</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaab97eab0b10c2649a287c00702bb79cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../d6/d2f/group__sparse__vector.html#gaab97eab0b10c2649a287c00702bb79cd">More...</a><br /></td></tr>
<tr class="separator:gaab97eab0b10c2649a287c00702bb79cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3437d191e9f05d5c256bf363ccb36e4"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gac3437d191e9f05d5c256bf363ccb36e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gac3437d191e9f05d5c256bf363ccb36e4">isOne</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gac3437d191e9f05d5c256bf363ccb36e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../d6/d2f/group__sparse__vector.html#gac3437d191e9f05d5c256bf363ccb36e4">More...</a><br /></td></tr>
<tr class="separator:gac3437d191e9f05d5c256bf363ccb36e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga577795ebd00f8faab87d16b964d158cc"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga577795ebd00f8faab87d16b964d158cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga577795ebd00f8faab87d16b964d158cc">isnan</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga577795ebd00f8faab87d16b964d158cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../d6/d2f/group__sparse__vector.html#ga577795ebd00f8faab87d16b964d158cc">More...</a><br /></td></tr>
<tr class="separator:ga577795ebd00f8faab87d16b964d158cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a932337ccd811dc6d27859066a47b4"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gad2a932337ccd811dc6d27859066a47b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gad2a932337ccd811dc6d27859066a47b4">swap</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;a, const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gad2a932337ccd811dc6d27859066a47b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two access proxies.  <a href="../../d6/d2f/group__sparse__vector.html#gad2a932337ccd811dc6d27859066a47b4">More...</a><br /></td></tr>
<tr class="separator:gad2a932337ccd811dc6d27859066a47b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga533b968699a6e37d569137d4481bcef4"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename T &gt; </td></tr>
<tr class="memitem:ga533b968699a6e37d569137d4481bcef4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga533b968699a6e37d569137d4481bcef4">swap</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;a, T &amp;b) noexcept</td></tr>
<tr class="memdesc:ga533b968699a6e37d569137d4481bcef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="../../d6/d2f/group__sparse__vector.html#ga533b968699a6e37d569137d4481bcef4">More...</a><br /></td></tr>
<tr class="separator:ga533b968699a6e37d569137d4481bcef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ec20cc3a5938208cd23728631130f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename VT &gt; </td></tr>
<tr class="memitem:gae1ec20cc3a5938208cd23728631130f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gae1ec20cc3a5938208cd23728631130f0">swap</a> (T &amp;a, const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gae1ec20cc3a5938208cd23728631130f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="../../d6/d2f/group__sparse__vector.html#gae1ec20cc3a5938208cd23728631130f0">More...</a><br /></td></tr>
<tr class="separator:gae1ec20cc3a5938208cd23728631130f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vector operators</div></td></tr>
<tr class="memitem:ga57e4b791b56659eb724b5a70f1f33f10"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga57e4b791b56659eb724b5a70f1f33f10"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga57e4b791b56659eb724b5a70f1f33f10">inner</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga57e4b791b56659eb724b5a70f1f33f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (dot/inner product) of two vectors ( <img class="formulaInl" alt="$ s=(\vec{a},\vec{b}) $" src="../../form_169.png"/>).  <a href="../../dc/dcf/group__vector.html#ga57e4b791b56659eb724b5a70f1f33f10">More...</a><br /></td></tr>
<tr class="separator:ga57e4b791b56659eb724b5a70f1f33f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69cab43577d4efbb0fb62a939419664"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa69cab43577d4efbb0fb62a939419664"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#gaa69cab43577d4efbb0fb62a939419664">inner</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa69cab43577d4efbb0fb62a939419664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (dot/inner product) of two vectors ( <img class="formulaInl" alt="$ s=(\vec{a},\vec{b}) $" src="../../form_169.png"/>).  <a href="../../dc/dcf/group__vector.html#gaa69cab43577d4efbb0fb62a939419664">More...</a><br /></td></tr>
<tr class="separator:gaa69cab43577d4efbb0fb62a939419664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ce9697116eda1c9bfd3ac96f66019dc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0ce9697116eda1c9bfd3ac96f66019dc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga0ce9697116eda1c9bfd3ac96f66019dc">inner</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0ce9697116eda1c9bfd3ac96f66019dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (dot/inner product) of two vectors ( <img class="formulaInl" alt="$ s=(\vec{a},\vec{b}) $" src="../../form_169.png"/>).  <a href="../../dc/dcf/group__vector.html#ga0ce9697116eda1c9bfd3ac96f66019dc">More...</a><br /></td></tr>
<tr class="separator:ga0ce9697116eda1c9bfd3ac96f66019dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga298c3c151b8e547a638ff3c1ee05a605"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga298c3c151b8e547a638ff3c1ee05a605"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga298c3c151b8e547a638ff3c1ee05a605">inner</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga298c3c151b8e547a638ff3c1ee05a605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (dot/inner product) of two vectors ( <img class="formulaInl" alt="$ s=(\vec{a},\vec{b}) $" src="../../form_169.png"/>).  <a href="../../dc/dcf/group__vector.html#ga298c3c151b8e547a638ff3c1ee05a605">More...</a><br /></td></tr>
<tr class="separator:ga298c3c151b8e547a638ff3c1ee05a605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00f5980d8886c15959f631f2ffc94751"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga00f5980d8886c15959f631f2ffc94751"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga00f5980d8886c15959f631f2ffc94751">dot</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga00f5980d8886c15959f631f2ffc94751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (dot/inner product) of two vectors ( <img class="formulaInl" alt="$ s=(\vec{a},\vec{b}) $" src="../../form_169.png"/>).  <a href="../../dc/dcf/group__vector.html#ga00f5980d8886c15959f631f2ffc94751">More...</a><br /></td></tr>
<tr class="separator:ga00f5980d8886c15959f631f2ffc94751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4306d8460f697ff1a7b3a4f8ac860d97"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga4306d8460f697ff1a7b3a4f8ac860d97"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga4306d8460f697ff1a7b3a4f8ac860d97">operator,</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4306d8460f697ff1a7b3a4f8ac860d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (dot/inner product) of two vectors ( <img class="formulaInl" alt="$ s=(\vec{a},\vec{b}) $" src="../../form_169.png"/>).  <a href="../../dc/dcf/group__vector.html#ga4306d8460f697ff1a7b3a4f8ac860d97">More...</a><br /></td></tr>
<tr class="separator:ga4306d8460f697ff1a7b3a4f8ac860d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73391ed2a17ebe2992ee2c982b32df63"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga73391ed2a17ebe2992ee2c982b32df63"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga73391ed2a17ebe2992ee2c982b32df63">outer</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga73391ed2a17ebe2992ee2c982b32df63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the outer product of two vectors ( <img class="formulaInl" alt="$ s=(\vec{a},\vec{b}) $" src="../../form_169.png"/>).  <a href="../../dc/dcf/group__vector.html#ga73391ed2a17ebe2992ee2c982b32df63">More...</a><br /></td></tr>
<tr class="separator:ga73391ed2a17ebe2992ee2c982b32df63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga575787a6d9c442fedd76e17d3e2b67cd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga575787a6d9c442fedd76e17d3e2b67cd"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga575787a6d9c442fedd76e17d3e2b67cd">outer</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga575787a6d9c442fedd76e17d3e2b67cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the outer product of two vectors ( <img class="formulaInl" alt="$ s=(\vec{a},\vec{b}) $" src="../../form_169.png"/>).  <a href="../../dc/dcf/group__vector.html#ga575787a6d9c442fedd76e17d3e2b67cd">More...</a><br /></td></tr>
<tr class="separator:ga575787a6d9c442fedd76e17d3e2b67cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93f25340d691696f139f249d8331b206"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga93f25340d691696f139f249d8331b206"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga93f25340d691696f139f249d8331b206">outer</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga93f25340d691696f139f249d8331b206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the outer product of two vectors ( <img class="formulaInl" alt="$ s=(\vec{a},\vec{b}) $" src="../../form_169.png"/>).  <a href="../../dc/dcf/group__vector.html#ga93f25340d691696f139f249d8331b206">More...</a><br /></td></tr>
<tr class="separator:ga93f25340d691696f139f249d8331b206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefe7be55eed7441a98d0d5f3b10e8f78"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaefe7be55eed7441a98d0d5f3b10e8f78"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T1 &gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#gaefe7be55eed7441a98d0d5f3b10e8f78">outer</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaefe7be55eed7441a98d0d5f3b10e8f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the outer product of two vectors ( <img class="formulaInl" alt="$ s=(\vec{a},\vec{b}) $" src="../../form_169.png"/>).  <a href="../../dc/dcf/group__vector.html#gaefe7be55eed7441a98d0d5f3b10e8f78">More...</a><br /></td></tr>
<tr class="separator:gaefe7be55eed7441a98d0d5f3b10e8f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga459ba08d52dd8ace7955cd1be814da30"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga459ba08d52dd8ace7955cd1be814da30"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga459ba08d52dd8ace7955cd1be814da30">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga459ba08d52dd8ace7955cd1be814da30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for dense and sparse vectors.  <a href="../../dc/dcf/group__vector.html#ga459ba08d52dd8ace7955cd1be814da30">More...</a><br /></td></tr>
<tr class="separator:ga459ba08d52dd8ace7955cd1be814da30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Column operators</div></td></tr>
<tr class="memitem:ga34153cd04981a0b4b8b2b7b1fbbcb353"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool SF&gt; </td></tr>
<tr class="memitem:ga34153cd04981a0b4b8b2b7b1fbbcb353"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/db4/group__column.html#ga34153cd04981a0b4b8b2b7b1fbbcb353">reset</a> (<a class="el" href="../../df/d79/classblaze_1_1Column.html">Column</a>&lt; MT, SO, DF, SF &gt; &amp;<a class="el" href="../../d0/d48/group__views.html#ga90d2efe628ac27ced94db06b3aa3cf9b">column</a>)</td></tr>
<tr class="memdesc:ga34153cd04981a0b4b8b2b7b1fbbcb353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given column.  <a href="../../d8/db4/group__column.html#ga34153cd04981a0b4b8b2b7b1fbbcb353">More...</a><br /></td></tr>
<tr class="separator:ga34153cd04981a0b4b8b2b7b1fbbcb353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5fa1c5bdc166ab447de727a1a19c55e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool SF&gt; </td></tr>
<tr class="memitem:gaa5fa1c5bdc166ab447de727a1a19c55e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/db4/group__column.html#gaa5fa1c5bdc166ab447de727a1a19c55e">clear</a> (<a class="el" href="../../df/d79/classblaze_1_1Column.html">Column</a>&lt; MT, SO, DF, SF &gt; &amp;<a class="el" href="../../d0/d48/group__views.html#ga90d2efe628ac27ced94db06b3aa3cf9b">column</a>)</td></tr>
<tr class="memdesc:gaa5fa1c5bdc166ab447de727a1a19c55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given column.  <a href="../../d8/db4/group__column.html#gaa5fa1c5bdc166ab447de727a1a19c55e">More...</a><br /></td></tr>
<tr class="separator:gaa5fa1c5bdc166ab447de727a1a19c55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga786dd6712f270eb9b4f8394253f8909b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool SF&gt; </td></tr>
<tr class="memitem:ga786dd6712f270eb9b4f8394253f8909b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/db4/group__column.html#ga786dd6712f270eb9b4f8394253f8909b">isDefault</a> (const <a class="el" href="../../df/d79/classblaze_1_1Column.html">Column</a>&lt; MT, SO, DF, SF &gt; &amp;<a class="el" href="../../d0/d48/group__views.html#ga90d2efe628ac27ced94db06b3aa3cf9b">column</a>)</td></tr>
<tr class="memdesc:ga786dd6712f270eb9b4f8394253f8909b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given column is in default state.  <a href="../../d8/db4/group__column.html#ga786dd6712f270eb9b4f8394253f8909b">More...</a><br /></td></tr>
<tr class="separator:ga786dd6712f270eb9b4f8394253f8909b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89aabd0e845e7c0ffb4720faa18c46e9"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool SF&gt; </td></tr>
<tr class="memitem:ga89aabd0e845e7c0ffb4720faa18c46e9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/db4/group__column.html#ga89aabd0e845e7c0ffb4720faa18c46e9">isIntact</a> (const <a class="el" href="../../df/d79/classblaze_1_1Column.html">Column</a>&lt; MT, SO, DF, SF &gt; &amp;<a class="el" href="../../d0/d48/group__views.html#ga90d2efe628ac27ced94db06b3aa3cf9b">column</a>) noexcept</td></tr>
<tr class="memdesc:ga89aabd0e845e7c0ffb4720faa18c46e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given column are intact.  <a href="../../d8/db4/group__column.html#ga89aabd0e845e7c0ffb4720faa18c46e9">More...</a><br /></td></tr>
<tr class="separator:ga89aabd0e845e7c0ffb4720faa18c46e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6e8f6d2f52838063b628c9091a41a0c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool SF&gt; </td></tr>
<tr class="memitem:gaf6e8f6d2f52838063b628c9091a41a0c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/db4/group__column.html#gaf6e8f6d2f52838063b628c9091a41a0c">isSame</a> (const <a class="el" href="../../df/d79/classblaze_1_1Column.html">Column</a>&lt; MT, SO, DF, SF &gt; &amp;a, const <a class="el" href="../../df/d79/classblaze_1_1Column.html">Column</a>&lt; MT, SO, DF, SF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gaf6e8f6d2f52838063b628c9091a41a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two given columns represent the same observable state.  <a href="../../d8/db4/group__column.html#gaf6e8f6d2f52838063b628c9091a41a0c">More...</a><br /></td></tr>
<tr class="separator:gaf6e8f6d2f52838063b628c9091a41a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Row operators</div></td></tr>
<tr class="memitem:ga8d64659b6abff89fbfb299b5d39a07d9"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool SF&gt; </td></tr>
<tr class="memitem:ga8d64659b6abff89fbfb299b5d39a07d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d09/group__row.html#ga8d64659b6abff89fbfb299b5d39a07d9">reset</a> (<a class="el" href="../../d2/d67/classblaze_1_1Row.html">Row</a>&lt; MT, SO, DF, SF &gt; &amp;<a class="el" href="../../d0/d48/group__views.html#ga3a6376617370d461c81682f09a4a5772">row</a>)</td></tr>
<tr class="memdesc:ga8d64659b6abff89fbfb299b5d39a07d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given row.  <a href="../../d2/d09/group__row.html#ga8d64659b6abff89fbfb299b5d39a07d9">More...</a><br /></td></tr>
<tr class="separator:ga8d64659b6abff89fbfb299b5d39a07d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98117be21f11c157c0bebbfa575d6443"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool SF&gt; </td></tr>
<tr class="memitem:ga98117be21f11c157c0bebbfa575d6443"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d09/group__row.html#ga98117be21f11c157c0bebbfa575d6443">clear</a> (<a class="el" href="../../d2/d67/classblaze_1_1Row.html">Row</a>&lt; MT, SO, DF, SF &gt; &amp;<a class="el" href="../../d0/d48/group__views.html#ga3a6376617370d461c81682f09a4a5772">row</a>)</td></tr>
<tr class="memdesc:ga98117be21f11c157c0bebbfa575d6443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given row.  <a href="../../d2/d09/group__row.html#ga98117be21f11c157c0bebbfa575d6443">More...</a><br /></td></tr>
<tr class="separator:ga98117be21f11c157c0bebbfa575d6443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b0fc5961f5edcae580268663208a043"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool SF&gt; </td></tr>
<tr class="memitem:ga4b0fc5961f5edcae580268663208a043"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d09/group__row.html#ga4b0fc5961f5edcae580268663208a043">isDefault</a> (const <a class="el" href="../../d2/d67/classblaze_1_1Row.html">Row</a>&lt; MT, SO, DF, SF &gt; &amp;<a class="el" href="../../d0/d48/group__views.html#ga3a6376617370d461c81682f09a4a5772">row</a>)</td></tr>
<tr class="memdesc:ga4b0fc5961f5edcae580268663208a043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given row is in default state.  <a href="../../d2/d09/group__row.html#ga4b0fc5961f5edcae580268663208a043">More...</a><br /></td></tr>
<tr class="separator:ga4b0fc5961f5edcae580268663208a043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aae81b28d3c7b2dcb18f2ad7a91218d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool SF&gt; </td></tr>
<tr class="memitem:ga2aae81b28d3c7b2dcb18f2ad7a91218d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d09/group__row.html#ga2aae81b28d3c7b2dcb18f2ad7a91218d">isIntact</a> (const <a class="el" href="../../d2/d67/classblaze_1_1Row.html">Row</a>&lt; MT, SO, DF, SF &gt; &amp;<a class="el" href="../../d0/d48/group__views.html#ga3a6376617370d461c81682f09a4a5772">row</a>) noexcept</td></tr>
<tr class="memdesc:ga2aae81b28d3c7b2dcb18f2ad7a91218d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given row are intact.  <a href="../../d2/d09/group__row.html#ga2aae81b28d3c7b2dcb18f2ad7a91218d">More...</a><br /></td></tr>
<tr class="separator:ga2aae81b28d3c7b2dcb18f2ad7a91218d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f1b9f156157e75d9ee070854517019"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, bool DF, bool SF&gt; </td></tr>
<tr class="memitem:gad7f1b9f156157e75d9ee070854517019"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d09/group__row.html#gad7f1b9f156157e75d9ee070854517019">isSame</a> (const <a class="el" href="../../d2/d67/classblaze_1_1Row.html">Row</a>&lt; MT, SO, DF, SF &gt; &amp;a, const <a class="el" href="../../d2/d67/classblaze_1_1Row.html">Row</a>&lt; MT, SO, DF, SF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gad7f1b9f156157e75d9ee070854517019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two given rows represent the same observable state.  <a href="../../d2/d09/group__row.html#gad7f1b9f156157e75d9ee070854517019">More...</a><br /></td></tr>
<tr class="separator:gad7f1b9f156157e75d9ee070854517019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Submatrix operators</div></td></tr>
<tr class="memitem:ga657a8f00d474e80a660d94b6f02b2725"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga657a8f00d474e80a660d94b6f02b2725"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#ga657a8f00d474e80a660d94b6f02b2725">reset</a> (<a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga657a8f00d474e80a660d94b6f02b2725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given submatrix.  <a href="../../dd/de6/group__submatrix.html#ga657a8f00d474e80a660d94b6f02b2725">More...</a><br /></td></tr>
<tr class="separator:ga657a8f00d474e80a660d94b6f02b2725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga324610ae87df9c7d2eb937c0f4917d3e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga324610ae87df9c7d2eb937c0f4917d3e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#ga324610ae87df9c7d2eb937c0f4917d3e">reset</a> (<a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;sm, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga324610ae87df9c7d2eb937c0f4917d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column of the given submatrix.  <a href="../../dd/de6/group__submatrix.html#ga324610ae87df9c7d2eb937c0f4917d3e">More...</a><br /></td></tr>
<tr class="separator:ga324610ae87df9c7d2eb937c0f4917d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad567a06068c607bfad6ca6be1c9eeaf"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gaad567a06068c607bfad6ca6be1c9eeaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#gaad567a06068c607bfad6ca6be1c9eeaf">clear</a> (<a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaad567a06068c607bfad6ca6be1c9eeaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given matrix.  <a href="../../dd/de6/group__submatrix.html#gaad567a06068c607bfad6ca6be1c9eeaf">More...</a><br /></td></tr>
<tr class="separator:gaad567a06068c607bfad6ca6be1c9eeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga781aea2d768076f283ffa221573e06ab"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga781aea2d768076f283ffa221573e06ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#ga781aea2d768076f283ffa221573e06ab">isDefault</a> (const <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga781aea2d768076f283ffa221573e06ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given submatrix is in default state.  <a href="../../dd/de6/group__submatrix.html#ga781aea2d768076f283ffa221573e06ab">More...</a><br /></td></tr>
<tr class="separator:ga781aea2d768076f283ffa221573e06ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0e173c4f2301bf6008a2956f87efaf"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gacf0e173c4f2301bf6008a2956f87efaf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#gacf0e173c4f2301bf6008a2956f87efaf">isIntact</a> (const <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;sm) noexcept</td></tr>
<tr class="memdesc:gacf0e173c4f2301bf6008a2956f87efaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given submatrix are intact.  <a href="../../dd/de6/group__submatrix.html#gacf0e173c4f2301bf6008a2956f87efaf">More...</a><br /></td></tr>
<tr class="separator:gacf0e173c4f2301bf6008a2956f87efaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f28bbf6d95ae08f8a7e5f4665057a8d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga9f28bbf6d95ae08f8a7e5f4665057a8d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#ga9f28bbf6d95ae08f8a7e5f4665057a8d">isSymmetric</a> (const <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga9f28bbf6d95ae08f8a7e5f4665057a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given submatrix is symmetric.  <a href="../../dd/de6/group__submatrix.html#ga9f28bbf6d95ae08f8a7e5f4665057a8d">More...</a><br /></td></tr>
<tr class="separator:ga9f28bbf6d95ae08f8a7e5f4665057a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e1026b209098516c8ec9b88a42e9247"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga0e1026b209098516c8ec9b88a42e9247"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#ga0e1026b209098516c8ec9b88a42e9247">isHermitian</a> (const <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga0e1026b209098516c8ec9b88a42e9247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given submatrix is Hermitian.  <a href="../../dd/de6/group__submatrix.html#ga0e1026b209098516c8ec9b88a42e9247">More...</a><br /></td></tr>
<tr class="separator:ga0e1026b209098516c8ec9b88a42e9247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74379545ec5f7dae4a750e5b97f4ef9e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga74379545ec5f7dae4a750e5b97f4ef9e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#ga74379545ec5f7dae4a750e5b97f4ef9e">isLower</a> (const <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga74379545ec5f7dae4a750e5b97f4ef9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given submatrix is a lower triangular matrix.  <a href="../../dd/de6/group__submatrix.html#ga74379545ec5f7dae4a750e5b97f4ef9e">More...</a><br /></td></tr>
<tr class="separator:ga74379545ec5f7dae4a750e5b97f4ef9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6051c9a79efd944162d4992bcae58ac"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gaa6051c9a79efd944162d4992bcae58ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#gaa6051c9a79efd944162d4992bcae58ac">isUniLower</a> (const <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaa6051c9a79efd944162d4992bcae58ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given submatrix is a lower unitriangular matrix.  <a href="../../dd/de6/group__submatrix.html#gaa6051c9a79efd944162d4992bcae58ac">More...</a><br /></td></tr>
<tr class="separator:gaa6051c9a79efd944162d4992bcae58ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7e4fe0327463ed1fce54d1fd1fb7095"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gab7e4fe0327463ed1fce54d1fd1fb7095"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#gab7e4fe0327463ed1fce54d1fd1fb7095">isStrictlyLower</a> (const <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;sm)</td></tr>
<tr class="memdesc:gab7e4fe0327463ed1fce54d1fd1fb7095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given submatrix is a strictly lower triangular matrix.  <a href="../../dd/de6/group__submatrix.html#gab7e4fe0327463ed1fce54d1fd1fb7095">More...</a><br /></td></tr>
<tr class="separator:gab7e4fe0327463ed1fce54d1fd1fb7095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a02e34f59dc340a16ca7abf87cbb1c3"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga8a02e34f59dc340a16ca7abf87cbb1c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#ga8a02e34f59dc340a16ca7abf87cbb1c3">isUpper</a> (const <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga8a02e34f59dc340a16ca7abf87cbb1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given submatrix is an upper triangular matrix.  <a href="../../dd/de6/group__submatrix.html#ga8a02e34f59dc340a16ca7abf87cbb1c3">More...</a><br /></td></tr>
<tr class="separator:ga8a02e34f59dc340a16ca7abf87cbb1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga024a5580665633dbde1a318f85d4c771"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga024a5580665633dbde1a318f85d4c771"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#ga024a5580665633dbde1a318f85d4c771">isUniUpper</a> (const <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga024a5580665633dbde1a318f85d4c771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given submatrix is an upper unitriangular matrix.  <a href="../../dd/de6/group__submatrix.html#ga024a5580665633dbde1a318f85d4c771">More...</a><br /></td></tr>
<tr class="separator:ga024a5580665633dbde1a318f85d4c771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1bcadee88a4e928f9cf98dcfbe1fea"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga7c1bcadee88a4e928f9cf98dcfbe1fea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#ga7c1bcadee88a4e928f9cf98dcfbe1fea">isStrictlyUpper</a> (const <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga7c1bcadee88a4e928f9cf98dcfbe1fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given submatrix is a strictly upper triangular matrix.  <a href="../../dd/de6/group__submatrix.html#ga7c1bcadee88a4e928f9cf98dcfbe1fea">More...</a><br /></td></tr>
<tr class="separator:ga7c1bcadee88a4e928f9cf98dcfbe1fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae37ca41c3928719ceea816c4de3468a4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gae37ca41c3928719ceea816c4de3468a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#gae37ca41c3928719ceea816c4de3468a4">isSame</a> (const <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;a, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gae37ca41c3928719ceea816c4de3468a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given matrix and submatrix represent the same observable state.  <a href="../../dd/de6/group__submatrix.html#gae37ca41c3928719ceea816c4de3468a4">More...</a><br /></td></tr>
<tr class="separator:gae37ca41c3928719ceea816c4de3468a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga213def603fe67df930ed6bd8cd3aa85a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:ga213def603fe67df930ed6bd8cd3aa85a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#ga213def603fe67df930ed6bd8cd3aa85a">isSame</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;a, const <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga213def603fe67df930ed6bd8cd3aa85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given matrix and submatrix represent the same observable state.  <a href="../../dd/de6/group__submatrix.html#ga213def603fe67df930ed6bd8cd3aa85a">More...</a><br /></td></tr>
<tr class="separator:ga213def603fe67df930ed6bd8cd3aa85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd8a3a7334ce5d713d110c6b6d87dd20"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF, bool SO, bool DF&gt; </td></tr>
<tr class="memitem:gabd8a3a7334ce5d713d110c6b6d87dd20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/de6/group__submatrix.html#gabd8a3a7334ce5d713d110c6b6d87dd20">isSame</a> (const <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;a, const <a class="el" href="../../d1/da2/classblaze_1_1Submatrix.html">Submatrix</a>&lt; MT, AF, SO, DF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gabd8a3a7334ce5d713d110c6b6d87dd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two given submatrices represent the same observable state.  <a href="../../dd/de6/group__submatrix.html#gabd8a3a7334ce5d713d110c6b6d87dd20">More...</a><br /></td></tr>
<tr class="separator:gabd8a3a7334ce5d713d110c6b6d87dd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subvector operators</div></td></tr>
<tr class="memitem:ga76d5ada2b484cc22a2dc6e91bd3dd158"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF, bool TF, bool DF&gt; </td></tr>
<tr class="memitem:ga76d5ada2b484cc22a2dc6e91bd3dd158"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d99/group__subvector.html#ga76d5ada2b484cc22a2dc6e91bd3dd158">reset</a> (<a class="el" href="../../d4/dd2/classblaze_1_1Subvector.html">Subvector</a>&lt; VT, AF, TF, DF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga76d5ada2b484cc22a2dc6e91bd3dd158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given subvector.  <a href="../../d7/d99/group__subvector.html#ga76d5ada2b484cc22a2dc6e91bd3dd158">More...</a><br /></td></tr>
<tr class="separator:ga76d5ada2b484cc22a2dc6e91bd3dd158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2244d517f293c67659737c80c40ec533"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF, bool TF, bool DF&gt; </td></tr>
<tr class="memitem:ga2244d517f293c67659737c80c40ec533"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d99/group__subvector.html#ga2244d517f293c67659737c80c40ec533">clear</a> (<a class="el" href="../../d4/dd2/classblaze_1_1Subvector.html">Subvector</a>&lt; VT, AF, TF, DF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga2244d517f293c67659737c80c40ec533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given subvector.  <a href="../../d7/d99/group__subvector.html#ga2244d517f293c67659737c80c40ec533">More...</a><br /></td></tr>
<tr class="separator:ga2244d517f293c67659737c80c40ec533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272d57c5fd40c7b11c0dc398fbde6bf0"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF, bool TF, bool DF&gt; </td></tr>
<tr class="memitem:ga272d57c5fd40c7b11c0dc398fbde6bf0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d99/group__subvector.html#ga272d57c5fd40c7b11c0dc398fbde6bf0">isDefault</a> (const <a class="el" href="../../d4/dd2/classblaze_1_1Subvector.html">Subvector</a>&lt; VT, AF, TF, DF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga272d57c5fd40c7b11c0dc398fbde6bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given subvector is in default state.  <a href="../../d7/d99/group__subvector.html#ga272d57c5fd40c7b11c0dc398fbde6bf0">More...</a><br /></td></tr>
<tr class="separator:ga272d57c5fd40c7b11c0dc398fbde6bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593ae42d24a9e766765f5acdc53c455e"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF, bool TF, bool DF&gt; </td></tr>
<tr class="memitem:ga593ae42d24a9e766765f5acdc53c455e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d99/group__subvector.html#ga593ae42d24a9e766765f5acdc53c455e">isIntact</a> (const <a class="el" href="../../d4/dd2/classblaze_1_1Subvector.html">Subvector</a>&lt; VT, AF, TF, DF &gt; &amp;sv) noexcept</td></tr>
<tr class="memdesc:ga593ae42d24a9e766765f5acdc53c455e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the invariants of the given subvector vector are intact.  <a href="../../d7/d99/group__subvector.html#ga593ae42d24a9e766765f5acdc53c455e">More...</a><br /></td></tr>
<tr class="separator:ga593ae42d24a9e766765f5acdc53c455e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga107bd6c8e2431389e840590d88d48575"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF, bool TF, bool DF&gt; </td></tr>
<tr class="memitem:ga107bd6c8e2431389e840590d88d48575"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d99/group__subvector.html#ga107bd6c8e2431389e840590d88d48575">isSame</a> (const <a class="el" href="../../d4/dd2/classblaze_1_1Subvector.html">Subvector</a>&lt; VT, AF, TF, DF &gt; &amp;a, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga107bd6c8e2431389e840590d88d48575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given vector and subvector represent the same observable state.  <a href="../../d7/d99/group__subvector.html#ga107bd6c8e2431389e840590d88d48575">More...</a><br /></td></tr>
<tr class="separator:ga107bd6c8e2431389e840590d88d48575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca174f239f72143636c40cf422d2136"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF, bool TF, bool DF&gt; </td></tr>
<tr class="memitem:ga4ca174f239f72143636c40cf422d2136"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d99/group__subvector.html#ga4ca174f239f72143636c40cf422d2136">isSame</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;a, const <a class="el" href="../../d4/dd2/classblaze_1_1Subvector.html">Subvector</a>&lt; VT, AF, TF, DF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga4ca174f239f72143636c40cf422d2136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given vector and subvector represent the same observable state.  <a href="../../d7/d99/group__subvector.html#ga4ca174f239f72143636c40cf422d2136">More...</a><br /></td></tr>
<tr class="separator:ga4ca174f239f72143636c40cf422d2136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69433e50152d2e66094f5767e874c1ca"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF, bool TF, bool DF&gt; </td></tr>
<tr class="memitem:ga69433e50152d2e66094f5767e874c1ca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d99/group__subvector.html#ga69433e50152d2e66094f5767e874c1ca">isSame</a> (const <a class="el" href="../../d4/dd2/classblaze_1_1Subvector.html">Subvector</a>&lt; VT, AF, TF, DF &gt; &amp;a, const <a class="el" href="../../d4/dd2/classblaze_1_1Subvector.html">Subvector</a>&lt; VT, AF, TF, DF &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga69433e50152d2e66094f5767e874c1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two given subvectors represent the same observable state.  <a href="../../d7/d99/group__subvector.html#ga69433e50152d2e66094f5767e874c1ca">More...</a><br /></td></tr>
<tr class="separator:ga69433e50152d2e66094f5767e874c1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">AlignedAllocator operators</div></td></tr>
<tr class="memitem:a9e0b25bd1d6022c2927572277c7ff9d1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a9e0b25bd1d6022c2927572277c7ff9d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a9e0b25bd1d6022c2927572277c7ff9d1">operator==</a> (const <a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; T2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a9e0b25bd1d6022c2927572277c7ff9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html" title="Allocator for type-specific aligned memory.The AlignedAllocator class template represents an implemen...">AlignedAllocator</a> objects.  <a href="#a9e0b25bd1d6022c2927572277c7ff9d1">More...</a><br /></td></tr>
<tr class="separator:a9e0b25bd1d6022c2927572277c7ff9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21213984e62323440a6c3145ae22101"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac21213984e62323440a6c3145ae22101"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ac21213984e62323440a6c3145ae22101">operator!=</a> (const <a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; T2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac21213984e62323440a6c3145ae22101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html" title="Allocator for type-specific aligned memory.The AlignedAllocator class template represents an implemen...">AlignedAllocator</a> objects.  <a href="#ac21213984e62323440a6c3145ae22101">More...</a><br /></td></tr>
<tr class="separator:ac21213984e62323440a6c3145ae22101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">InputString operators</div></td></tr>
<tr class="memitem:ga942b82bb3e222d3e7651094a372cabd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga942b82bb3e222d3e7651094a372cabd6">IsFileName</a> (const <a class="el" href="../../da/dfc/classblaze_1_1InputString.html">InputString</a> &amp;s)</td></tr>
<tr class="memdesc:ga942b82bb3e222d3e7651094a372cabd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for a valid file name.  <a href="../../d4/d3a/group__util.html#ga942b82bb3e222d3e7651094a372cabd6">More...</a><br /></td></tr>
<tr class="separator:ga942b82bb3e222d3e7651094a372cabd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1ba7ee1b13541bf5bef5cb2eaf66207"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaa1ba7ee1b13541bf5bef5cb2eaf66207">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../da/dfc/classblaze_1_1InputString.html">InputString</a> &amp;str)</td></tr>
<tr class="memdesc:gaa1ba7ee1b13541bf5bef5cb2eaf66207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for the <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class.  <a href="../../d4/d3a/group__util.html#gaa1ba7ee1b13541bf5bef5cb2eaf66207">More...</a><br /></td></tr>
<tr class="separator:gaa1ba7ee1b13541bf5bef5cb2eaf66207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a4395873ec4d104b68f12f5e9dc29f"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga80a4395873ec4d104b68f12f5e9dc29f">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../da/dfc/classblaze_1_1InputString.html">InputString</a> &amp;str)</td></tr>
<tr class="memdesc:ga80a4395873ec4d104b68f12f5e9dc29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global input operator for the <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class.  <a href="../../d4/d3a/group__util.html#ga80a4395873ec4d104b68f12f5e9dc29f">More...</a><br /></td></tr>
<tr class="separator:ga80a4395873ec4d104b68f12f5e9dc29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Pointer cast operators</div></td></tr>
<tr class="memitem:ga297b8d4addf0242658e5b89e9204460f"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga297b8d4addf0242658e5b89e9204460f"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga297b8d4addf0242658e5b89e9204460f">static_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga297b8d4addf0242658e5b89e9204460f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static cast for pointer types.  <a href="../../d4/d3a/group__util.html#ga297b8d4addf0242658e5b89e9204460f">More...</a><br /></td></tr>
<tr class="separator:ga297b8d4addf0242658e5b89e9204460f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5e788ec214cce869014db4e8d5366e"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga6f5e788ec214cce869014db4e8d5366e"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga6f5e788ec214cce869014db4e8d5366e">dynamic_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga6f5e788ec214cce869014db4e8d5366e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast for pointer types.  <a href="../../d4/d3a/group__util.html#ga6f5e788ec214cce869014db4e8d5366e">More...</a><br /></td></tr>
<tr class="separator:ga6f5e788ec214cce869014db4e8d5366e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28219d814bac7718746d5042aef9de09"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga28219d814bac7718746d5042aef9de09"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga28219d814bac7718746d5042aef9de09">const_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga28219d814bac7718746d5042aef9de09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const cast for pointer types.  <a href="../../d4/d3a/group__util.html#ga28219d814bac7718746d5042aef9de09">More...</a><br /></td></tr>
<tr class="separator:ga28219d814bac7718746d5042aef9de09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga3e7e73afb20167f3b3dc8f1a032b98c4">reinterpret_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret cast for pointer types.  <a href="../../d4/d3a/group__util.html#ga3e7e73afb20167f3b3dc8f1a032b98c4">More...</a><br /></td></tr>
<tr class="separator:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Smart pointer cast operators</div></td></tr>
<tr class="memitem:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga70575290b13daca96bd7bcdf1ea2ae65">static_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static cast for smart pointers.  <a href="../../d4/d3a/group__util.html#ga70575290b13daca96bd7bcdf1ea2ae65">More...</a><br /></td></tr>
<tr class="separator:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga29989fd5881d9e3d3204be7cc9c7c3db">dynamic_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast for smart pointers.  <a href="../../d4/d3a/group__util.html#ga29989fd5881d9e3d3204be7cc9c7c3db">More...</a><br /></td></tr>
<tr class="separator:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga618bf0481250b859a7d953d54a31fffa"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga618bf0481250b859a7d953d54a31fffa"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga618bf0481250b859a7d953d54a31fffa">const_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga618bf0481250b859a7d953d54a31fffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const cast for smart pointers.  <a href="../../d4/d3a/group__util.html#ga618bf0481250b859a7d953d54a31fffa">More...</a><br /></td></tr>
<tr class="separator:ga618bf0481250b859a7d953d54a31fffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e5a317853deb66bcd03883873f20ee"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga29e5a317853deb66bcd03883873f20ee"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga29e5a317853deb66bcd03883873f20ee">reinterpret_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga29e5a317853deb66bcd03883873f20ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret cast for smart pointers.  <a href="../../d4/d3a/group__util.html#ga29e5a317853deb66bcd03883873f20ee">More...</a><br /></td></tr>
<tr class="separator:ga29e5a317853deb66bcd03883873f20ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PtrIterator operators</div></td></tr>
<tr class="memitem:a83125315ff1fc56974b1525cd6d9c4cf"><td class="memTemplParams" colspan="2">template&lt;typename TypeL , typename TypeR &gt; </td></tr>
<tr class="memitem:a83125315ff1fc56974b1525cd6d9c4cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a83125315ff1fc56974b1525cd6d9c4cf">operator==</a> (const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;lhs, const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a83125315ff1fc56974b1525cd6d9c4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects.  <a href="#a83125315ff1fc56974b1525cd6d9c4cf">More...</a><br /></td></tr>
<tr class="separator:a83125315ff1fc56974b1525cd6d9c4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8a3e3b7fb672689907927512c04839"><td class="memTemplParams" colspan="2">template&lt;typename TypeL , typename TypeR &gt; </td></tr>
<tr class="memitem:aac8a3e3b7fb672689907927512c04839"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#aac8a3e3b7fb672689907927512c04839">operator!=</a> (const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;lhs, const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aac8a3e3b7fb672689907927512c04839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects.  <a href="#aac8a3e3b7fb672689907927512c04839">More...</a><br /></td></tr>
<tr class="separator:aac8a3e3b7fb672689907927512c04839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf608ae97f0284e56745139e110ea699"><td class="memTemplParams" colspan="2">template&lt;typename TypeL , typename TypeR &gt; </td></tr>
<tr class="memitem:aaf608ae97f0284e56745139e110ea699"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#aaf608ae97f0284e56745139e110ea699">operator&lt;</a> (const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;lhs, const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aaf608ae97f0284e56745139e110ea699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects.  <a href="#aaf608ae97f0284e56745139e110ea699">More...</a><br /></td></tr>
<tr class="separator:aaf608ae97f0284e56745139e110ea699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378bc920e7d0cfddbe90600e14f358c4"><td class="memTemplParams" colspan="2">template&lt;typename TypeL , typename TypeR &gt; </td></tr>
<tr class="memitem:a378bc920e7d0cfddbe90600e14f358c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a378bc920e7d0cfddbe90600e14f358c4">operator&gt;</a> (const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;lhs, const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a378bc920e7d0cfddbe90600e14f358c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects.  <a href="#a378bc920e7d0cfddbe90600e14f358c4">More...</a><br /></td></tr>
<tr class="separator:a378bc920e7d0cfddbe90600e14f358c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7399c56304153ea6b9068cbe00d41085"><td class="memTemplParams" colspan="2">template&lt;typename TypeL , typename TypeR &gt; </td></tr>
<tr class="memitem:a7399c56304153ea6b9068cbe00d41085"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a7399c56304153ea6b9068cbe00d41085">operator&lt;=</a> (const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;lhs, const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7399c56304153ea6b9068cbe00d41085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects.  <a href="#a7399c56304153ea6b9068cbe00d41085">More...</a><br /></td></tr>
<tr class="separator:a7399c56304153ea6b9068cbe00d41085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c6bd436ad385878f4c70a9b9ee5dd5"><td class="memTemplParams" colspan="2">template&lt;typename TypeL , typename TypeR &gt; </td></tr>
<tr class="memitem:ad4c6bd436ad385878f4c70a9b9ee5dd5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ad4c6bd436ad385878f4c70a9b9ee5dd5">operator&gt;=</a> (const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;lhs, const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad4c6bd436ad385878f4c70a9b9ee5dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects.  <a href="#ad4c6bd436ad385878f4c70a9b9ee5dd5">More...</a><br /></td></tr>
<tr class="separator:ad4c6bd436ad385878f4c70a9b9ee5dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PtrVector operators</div></td></tr>
<tr class="memitem:a4bd2908dd4b8aae738fcb0aa21d494af"><td class="memTemplParams" colspan="2">template&lt;typename T , typename D , typename G &gt; </td></tr>
<tr class="memitem:a4bd2908dd4b8aae738fcb0aa21d494af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a4bd2908dd4b8aae738fcb0aa21d494af">operator==</a> (const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;lhs, const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4bd2908dd4b8aae738fcb0aa21d494af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two pointer vectors.  <a href="#a4bd2908dd4b8aae738fcb0aa21d494af">More...</a><br /></td></tr>
<tr class="separator:a4bd2908dd4b8aae738fcb0aa21d494af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c24212630a6f1d6597740647e3413eb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename D , typename G &gt; </td></tr>
<tr class="memitem:a9c24212630a6f1d6597740647e3413eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a9c24212630a6f1d6597740647e3413eb">operator!=</a> (const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;lhs, const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9c24212630a6f1d6597740647e3413eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two pointer vectors.  <a href="#a9c24212630a6f1d6597740647e3413eb">More...</a><br /></td></tr>
<tr class="separator:a9c24212630a6f1d6597740647e3413eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57f2ec8572d4bae84bc6a9d9e5e400d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename D , typename G &gt; </td></tr>
<tr class="memitem:ac57f2ec8572d4bae84bc6a9d9e5e400d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ac57f2ec8572d4bae84bc6a9d9e5e400d">swap</a> (<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;a, <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ac57f2ec8572d4bae84bc6a9d9e5e400d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two pointer vectors.  <a href="#ac57f2ec8572d4bae84bc6a9d9e5e400d">More...</a><br /></td></tr>
<tr class="separator:ac57f2ec8572d4bae84bc6a9d9e5e400d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Random number functions</div></td></tr>
<tr class="memitem:ga0d06d962406a7a4a2414899bea18f3e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0d06d962406a7a4a2414899bea18f3e4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#ga0d06d962406a7a4a2414899bea18f3e4">rand</a> ()</td></tr>
<tr class="memdesc:ga0d06d962406a7a4a2414899bea18f3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/dc4/classblaze_1_1Random.html" title="Random number generator.The Random class encapsulates the initialization of the given random number g...">Random</a> number function.  <a href="../../dd/d10/group__random.html#ga0d06d962406a7a4a2414899bea18f3e4">More...</a><br /></td></tr>
<tr class="separator:ga0d06d962406a7a4a2414899bea18f3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbfc3acb32794e6ba7e7adcd3e17f4ef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:gacbfc3acb32794e6ba7e7adcd3e17f4ef"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#gacbfc3acb32794e6ba7e7adcd3e17f4ef">rand</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gacbfc3acb32794e6ba7e7adcd3e17f4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/dc4/classblaze_1_1Random.html" title="Random number generator.The Random class encapsulates the initialization of the given random number g...">Random</a> number function.  <a href="../../dd/d10/group__random.html#gacbfc3acb32794e6ba7e7adcd3e17f4ef">More...</a><br /></td></tr>
<tr class="separator:gacbfc3acb32794e6ba7e7adcd3e17f4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8f3c515b77abff4d16b814e7df8c481"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae8f3c515b77abff4d16b814e7df8c481"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#gae8f3c515b77abff4d16b814e7df8c481">randomize</a> (T &amp;value)</td></tr>
<tr class="memdesc:gae8f3c515b77abff4d16b814e7df8c481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomization of a given variable.  <a href="../../dd/d10/group__random.html#gae8f3c515b77abff4d16b814e7df8c481">More...</a><br /></td></tr>
<tr class="separator:gae8f3c515b77abff4d16b814e7df8c481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c5d06c80dad756b6292b137ea025ac6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ga2c5d06c80dad756b6292b137ea025ac6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#ga2c5d06c80dad756b6292b137ea025ac6">randomize</a> (T &amp;value, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga2c5d06c80dad756b6292b137ea025ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomization of a given variable.  <a href="../../dd/d10/group__random.html#ga2c5d06c80dad756b6292b137ea025ac6">More...</a><br /></td></tr>
<tr class="separator:ga2c5d06c80dad756b6292b137ea025ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b252fbb81d16fadb97d292910dee23e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/dba/classblaze_1_1uint32__t.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#ga6b252fbb81d16fadb97d292910dee23e">defaultSeed</a> ()</td></tr>
<tr class="memdesc:ga6b252fbb81d16fadb97d292910dee23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default random seed.  <a href="../../dd/d10/group__random.html#ga6b252fbb81d16fadb97d292910dee23e">More...</a><br /></td></tr>
<tr class="separator:ga6b252fbb81d16fadb97d292910dee23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab75f5d7517c2c6367e7432fe42e888c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/dba/classblaze_1_1uint32__t.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#gab75f5d7517c2c6367e7432fe42e888c6">getSeed</a> ()</td></tr>
<tr class="memdesc:gab75f5d7517c2c6367e7432fe42e888c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current seed of the random number generator.  <a href="../../dd/d10/group__random.html#gab75f5d7517c2c6367e7432fe42e888c6">More...</a><br /></td></tr>
<tr class="separator:gab75f5d7517c2c6367e7432fe42e888c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab75d4f60ec07ee3a9681a437395afc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#ga2ab75d4f60ec07ee3a9681a437395afc">setSeed</a> (<a class="el" href="../../d6/dba/classblaze_1_1uint32__t.html">uint32_t</a> seed)</td></tr>
<tr class="memdesc:ga2ab75d4f60ec07ee3a9681a437395afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the seed of the random number generator.  <a href="../../dd/d10/group__random.html#ga2ab75d4f60ec07ee3a9681a437395afc">More...</a><br /></td></tr>
<tr class="separator:ga2ab75d4f60ec07ee3a9681a437395afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">System clock setup functions</div></td></tr>
<tr class="memitem:ga0547f7041f58ea87ba920e520236bd12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga2da9ea9bd53246d80cc49aa7365b9e0c">SystemClockID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga0547f7041f58ea87ba920e520236bd12">theSystemClock</a> ()</td></tr>
<tr class="memdesc:ga0547f7041f58ea87ba920e520236bd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the Blaze system clock.  <a href="../../d4/d3a/group__util.html#ga0547f7041f58ea87ba920e520236bd12">More...</a><br /></td></tr>
<tr class="separator:ga0547f7041f58ea87ba920e520236bd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Time functions</div></td></tr>
<tr class="memitem:ga4fb888631070076eac5ab46d3caddbd5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga4fb888631070076eac5ab46d3caddbd5">getDate</a> ()</td></tr>
<tr class="memdesc:ga4fb888631070076eac5ab46d3caddbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a formated date string in the form YYYY-MM-DD.  <a href="../../d4/d3a/group__util.html#ga4fb888631070076eac5ab46d3caddbd5">More...</a><br /></td></tr>
<tr class="separator:ga4fb888631070076eac5ab46d3caddbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3829412570c98a06a4bc95c550da95d8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga3829412570c98a06a4bc95c550da95d8">getTime</a> ()</td></tr>
<tr class="memdesc:ga3829412570c98a06a4bc95c550da95d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a formated time and date string.  <a href="../../d4/d3a/group__util.html#ga3829412570c98a06a4bc95c550da95d8">More...</a><br /></td></tr>
<tr class="separator:ga3829412570c98a06a4bc95c550da95d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d046bc597081ad84f727946f245a800"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga2d046bc597081ad84f727946f245a800">getWcTime</a> ()</td></tr>
<tr class="memdesc:ga2d046bc597081ad84f727946f245a800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current wall clock time in seconds.  <a href="../../d4/d3a/group__util.html#ga2d046bc597081ad84f727946f245a800">More...</a><br /></td></tr>
<tr class="separator:ga2d046bc597081ad84f727946f245a800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ff2b8c34d2384faa6b3e97954b98e78"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga2ff2b8c34d2384faa6b3e97954b98e78">getCpuTime</a> ()</td></tr>
<tr class="memdesc:ga2ff2b8c34d2384faa6b3e97954b98e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current CPU time in seconds.  <a href="../../d4/d3a/group__util.html#ga2ff2b8c34d2384faa6b3e97954b98e78">More...</a><br /></td></tr>
<tr class="separator:ga2ff2b8c34d2384faa6b3e97954b98e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">UnsignedValue operators</div></td></tr>
<tr class="memitem:af275fc8373d91ea8aff2b0b8e8dd3e89"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af275fc8373d91ea8aff2b0b8e8dd3e89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#af275fc8373d91ea8aff2b0b8e8dd3e89">operator==</a> (const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af275fc8373d91ea8aff2b0b8e8dd3e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects.  <a href="#af275fc8373d91ea8aff2b0b8e8dd3e89">More...</a><br /></td></tr>
<tr class="separator:af275fc8373d91ea8aff2b0b8e8dd3e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b94802b1621abe72010aa92b1c323a3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a0b94802b1621abe72010aa92b1c323a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a0b94802b1621abe72010aa92b1c323a3">operator!=</a> (const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0b94802b1621abe72010aa92b1c323a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects.  <a href="#a0b94802b1621abe72010aa92b1c323a3">More...</a><br /></td></tr>
<tr class="separator:a0b94802b1621abe72010aa92b1c323a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17b6ccf3e72a2176b217b977c8e0981"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad17b6ccf3e72a2176b217b977c8e0981"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ad17b6ccf3e72a2176b217b977c8e0981">operator&lt;</a> (const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad17b6ccf3e72a2176b217b977c8e0981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects.  <a href="#ad17b6ccf3e72a2176b217b977c8e0981">More...</a><br /></td></tr>
<tr class="separator:ad17b6ccf3e72a2176b217b977c8e0981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4918d3c24509bf7651948a10524dbdb9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a4918d3c24509bf7651948a10524dbdb9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a4918d3c24509bf7651948a10524dbdb9">operator&gt;</a> (const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4918d3c24509bf7651948a10524dbdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects.  <a href="#a4918d3c24509bf7651948a10524dbdb9">More...</a><br /></td></tr>
<tr class="separator:a4918d3c24509bf7651948a10524dbdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602483ca8c570c315b235511663102eb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a602483ca8c570c315b235511663102eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a602483ca8c570c315b235511663102eb">operator&lt;=</a> (const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a602483ca8c570c315b235511663102eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects.  <a href="#a602483ca8c570c315b235511663102eb">More...</a><br /></td></tr>
<tr class="separator:a602483ca8c570c315b235511663102eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73335dc2737714119ab3747f7d4d48b0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a73335dc2737714119ab3747f7d4d48b0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a73335dc2737714119ab3747f7d4d48b0">operator&gt;=</a> (const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a73335dc2737714119ab3747f7d4d48b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects.  <a href="#a73335dc2737714119ab3747f7d4d48b0">More...</a><br /></td></tr>
<tr class="separator:a73335dc2737714119ab3747f7d4d48b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d629135d4db89e1fcdcfd4b8f7c347e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d629135d4db89e1fcdcfd4b8f7c347e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a8d629135d4db89e1fcdcfd4b8f7c347e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T &gt; &amp;uv)</td></tr>
<tr class="memdesc:a8d629135d4db89e1fcdcfd4b8f7c347e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for the <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper.  <a href="#a8d629135d4db89e1fcdcfd4b8f7c347e">More...</a><br /></td></tr>
<tr class="separator:a8d629135d4db89e1fcdcfd4b8f7c347e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc275ea3ab616899091b50d46fc6e1a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc275ea3ab616899091b50d46fc6e1a3"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#afc275ea3ab616899091b50d46fc6e1a3">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T &gt; &amp;uv)</td></tr>
<tr class="memdesc:afc275ea3ab616899091b50d46fc6e1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global input operator for the <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper.  <a href="#afc275ea3ab616899091b50d46fc6e1a3">More...</a><br /></td></tr>
<tr class="separator:afc275ea3ab616899091b50d46fc6e1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga5db4d1645f9629f412681b40bf122d62"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga5db4d1645f9629f412681b40bf122d62">cacheSize</a> = 3145728UL</td></tr>
<tr class="memdesc:ga5db4d1645f9629f412681b40bf122d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache size of the target architecture.This setting specifies the available cache size in Byte of the used target architecture. Several algorithms use this setting for an optimized evaluation.  <a href="../../d1/d44/group__config.html#ga5db4d1645f9629f412681b40bf122d62">More...</a><br /></td></tr>
<tr class="separator:ga5db4d1645f9629f412681b40bf122d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36a5a3694a765e87f0f212347aa27119"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga36a5a3694a765e87f0f212347aa27119">usePadding</a> = true</td></tr>
<tr class="memdesc:ga36a5a3694a765e87f0f212347aa27119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration of the padding of dense vectors and matrices.This configuration switch enables/disables the padding of dense vectors and matrices. Padding is used by the Blaze library in order to achieve maximum performance for both dense vector and matrix operations. Due to padding, the proper alignment of data elements can be guaranteed and the need for remainder loops is minimized. In case the switch is set to <em>true</em>, padding is enabled for all native dense vectors and matrices. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the switch is set to <em>false</em>, padding is generally disabled.  <a href="../../d1/d44/group__config.html#ga36a5a3694a765e87f0f212347aa27119">More...</a><br /></td></tr>
<tr class="separator:ga36a5a3694a765e87f0f212347aa27119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8e31c64eb5c56a82a5195db7d2a5a3e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gad8e31c64eb5c56a82a5195db7d2a5a3e">useStreaming</a> = true</td></tr>
<tr class="memdesc:gad8e31c64eb5c56a82a5195db7d2a5a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration of the streaming behavior.For large vectors and matrices non-temporal stores can provide a significant performance advantage of about 20%. However, this advantage is only in effect in case the memory bandwidth of the target architecture is maxed out. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the target architecture's memory bandwidth cannot be exhausted the use of non-temporal stores can decrease performance instead of increasing it.  <a href="../../d1/d44/group__config.html#gad8e31c64eb5c56a82a5195db7d2a5a3e">More...</a><br /></td></tr>
<tr class="separator:gad8e31c64eb5c56a82a5195db7d2a5a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c4bbf3f897c6b8b9196398963d6df3b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga9c4bbf3f897c6b8b9196398963d6df3b">useOptimizedKernels</a> = true</td></tr>
<tr class="memdesc:ga9c4bbf3f897c6b8b9196398963d6df3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration switch for optimized kernels.This configuration switch enables/disables all optimized compute kernels of the Blaze library, including all vectorized and data type depending kernels. In case the switch is set to <em>true</em> the optimized kernels are used whenever possible. In case the switch is set to <em>false</em> all optimized kernels are not used, even if it would be possible.  <a href="../../d1/d44/group__config.html#ga9c4bbf3f897c6b8b9196398963d6df3b">More...</a><br /></td></tr>
<tr class="separator:ga9c4bbf3f897c6b8b9196398963d6df3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81e9d63fc9118c76cc84e0a55394e9b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaf81e9d63fc9118c76cc84e0a55394e9b">defaultStorageOrder</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a></td></tr>
<tr class="memdesc:gaf81e9d63fc9118c76cc84e0a55394e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default storage order for all matrices of the Blaze library.This value specifies the default storage order for all matrices of the Blaze library. In case no explicit storage order is specified with the according matrix type, this setting is used.  <a href="../../d1/d44/group__config.html#gaf81e9d63fc9118c76cc84e0a55394e9b">More...</a><br /></td></tr>
<tr class="separator:gaf81e9d63fc9118c76cc84e0a55394e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff2b3162e8e727e87757b26e3c7a2b7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gabff2b3162e8e727e87757b26e3c7a2b7">DMATDVECMULT_USER_THRESHOLD</a> = 4000000UL</td></tr>
<tr class="memdesc:gabff2b3162e8e727e87757b26e3c7a2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major dense matrix/dense vector multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the row-major dense matrix/dense vector multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#gabff2b3162e8e727e87757b26e3c7a2b7">More...</a><br /></td></tr>
<tr class="separator:gabff2b3162e8e727e87757b26e3c7a2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad423636e960a35c1940486074d1fbf42"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gad423636e960a35c1940486074d1fbf42">TDMATDVECMULT_USER_THRESHOLD</a> = 62500UL</td></tr>
<tr class="memdesc:gad423636e960a35c1940486074d1fbf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major dense matrix/dense vector multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the column-major dense matrix/dense vector multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#gad423636e960a35c1940486074d1fbf42">More...</a><br /></td></tr>
<tr class="separator:gad423636e960a35c1940486074d1fbf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4b9bd8ac28ac5cc5b926bd752bfda5c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gad4b9bd8ac28ac5cc5b926bd752bfda5c">TDVECDMATMULT_USER_THRESHOLD</a> = 62500UL</td></tr>
<tr class="memdesc:gad4b9bd8ac28ac5cc5b926bd752bfda5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense Vector/row-major dense matrix multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the dense vector/row-major dense matrix multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#gad4b9bd8ac28ac5cc5b926bd752bfda5c">More...</a><br /></td></tr>
<tr class="separator:gad4b9bd8ac28ac5cc5b926bd752bfda5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b4490aac211c21601fe1cef8a899200"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga8b4490aac211c21601fe1cef8a899200">TDVECTDMATMULT_USER_THRESHOLD</a> = 4000000UL</td></tr>
<tr class="memdesc:ga8b4490aac211c21601fe1cef8a899200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense Vector/column-major dense matrix multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the dense vector/column-major dense matrix multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#ga8b4490aac211c21601fe1cef8a899200">More...</a><br /></td></tr>
<tr class="separator:ga8b4490aac211c21601fe1cef8a899200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc091259379417f6c3ef075cc6c5b86"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga6cc091259379417f6c3ef075cc6c5b86">DMATDMATMULT_USER_THRESHOLD</a> = 4900UL</td></tr>
<tr class="memdesc:ga6cc091259379417f6c3ef075cc6c5b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major dense matrix/row-major dense matrix multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the row-major dense matrix/row-major dense matrix multiplication. In case the number of elements of the target matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the target matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#ga6cc091259379417f6c3ef075cc6c5b86">More...</a><br /></td></tr>
<tr class="separator:ga6cc091259379417f6c3ef075cc6c5b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b3946c89721e8a133da9856a5c4b4e6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga4b3946c89721e8a133da9856a5c4b4e6">DMATTDMATMULT_USER_THRESHOLD</a> = 4900UL</td></tr>
<tr class="memdesc:ga4b3946c89721e8a133da9856a5c4b4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major dense matrix/column-major dense matrix multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the row-major dense matrix/column-major dense matrix multiplication. In case the number of elements of the target matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the target matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#ga4b3946c89721e8a133da9856a5c4b4e6">More...</a><br /></td></tr>
<tr class="separator:ga4b3946c89721e8a133da9856a5c4b4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada08201915e8f9a4ed753901e89fb24a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gada08201915e8f9a4ed753901e89fb24a">TDMATDMATMULT_USER_THRESHOLD</a> = 4900UL</td></tr>
<tr class="memdesc:gada08201915e8f9a4ed753901e89fb24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major dense matrix/row-major dense matrix multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the column-major dense matrix/row-major dense matrix multiplication. In case the number of elements of the target matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the target matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#gada08201915e8f9a4ed753901e89fb24a">More...</a><br /></td></tr>
<tr class="separator:gada08201915e8f9a4ed753901e89fb24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42629469e24d03cd069a6ef2992b422b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga42629469e24d03cd069a6ef2992b422b">TDMATTDMATMULT_USER_THRESHOLD</a> = 4900UL</td></tr>
<tr class="memdesc:ga42629469e24d03cd069a6ef2992b422b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major dense matrix/column-major dense matrix multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the column-major dense matrix/column-major dense matrix multiplication. In case the number of elements of the target matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the target matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#ga42629469e24d03cd069a6ef2992b422b">More...</a><br /></td></tr>
<tr class="separator:ga42629469e24d03cd069a6ef2992b422b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7325edc799fd1e79f469ba1e6dcd4352"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga7325edc799fd1e79f469ba1e6dcd4352">DMATSMATMULT_USER_THRESHOLD</a> = 2500UL</td></tr>
<tr class="memdesc:ga7325edc799fd1e79f469ba1e6dcd4352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major dense matrix/row-major sparse matrix multiplication threshold.This setting specifies the threshold between the application of the Blaze kernels for small and for large row-major dense matrix/row-major sparse matrix multiplications. In case the number of elements of the target matrix is equal or higher than this value, the kernel for large matrices is preferred over the kernel for small matrices. In case the number of elements in the target matrix is smaller, the kernel for small matrices is used.  <a href="../../d1/d44/group__config.html#ga7325edc799fd1e79f469ba1e6dcd4352">More...</a><br /></td></tr>
<tr class="separator:ga7325edc799fd1e79f469ba1e6dcd4352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331c5d12a11613af16e3210733c15616"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga331c5d12a11613af16e3210733c15616">TDMATSMATMULT_USER_THRESHOLD</a> = 2500UL</td></tr>
<tr class="memdesc:ga331c5d12a11613af16e3210733c15616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major dense matrix/row-major sparse matrix multiplication threshold.This setting specifies the threshold between the application of the Blaze kernels for small and for large column-major dense matrix/row-major sparse matrix multiplications. In case the number of elements of the target matrix is equal or higher than this value, the kernel for large matrices is preferred over the kernel for small matrices. In case the number of elements in the target matrix is smaller, the kernel for small matrices is used.  <a href="../../d1/d44/group__config.html#ga331c5d12a11613af16e3210733c15616">More...</a><br /></td></tr>
<tr class="separator:ga331c5d12a11613af16e3210733c15616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4075adff9953d50eb42b5f719e30312"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gab4075adff9953d50eb42b5f719e30312">TSMATDMATMULT_USER_THRESHOLD</a> = 10000UL</td></tr>
<tr class="memdesc:gab4075adff9953d50eb42b5f719e30312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major sparse matrix/row-major dense matrix multiplication threshold.This setting specifies the threshold between the application of the Blaze kernels for small and for large column-major sparse matrix/row-major dense matrix multiplications. In case the number of elements of the target matrix is equal or higher than this value, the kernel for large matrices is preferred over the kernel for small matrices. In case the number of elements in the target matrix is smaller, the kernel for small matrices is used.  <a href="../../d1/d44/group__config.html#gab4075adff9953d50eb42b5f719e30312">More...</a><br /></td></tr>
<tr class="separator:gab4075adff9953d50eb42b5f719e30312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cb46b52049d0a79b24ae6f0ad4f464a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga2cb46b52049d0a79b24ae6f0ad4f464a">TSMATTDMATMULT_USER_THRESHOLD</a> = 22500UL</td></tr>
<tr class="memdesc:ga2cb46b52049d0a79b24ae6f0ad4f464a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major sparse matrix/column-major dense matrix multiplication threshold.This setting specifies the threshold between the application of the Blaze kernels for small and for large column-major sparse matrix/column-major dense matrix multiplications. In case the number of elements of the target matrix is equal or higher than this value, the kernel for large matrices is preferred over the kernel for small matrices. In case the number of elements in the target matrix is smaller, the kernel for small matrices is used.  <a href="../../d1/d44/group__config.html#ga2cb46b52049d0a79b24ae6f0ad4f464a">More...</a><br /></td></tr>
<tr class="separator:ga2cb46b52049d0a79b24ae6f0ad4f464a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga082bcb7375f834ce4a401afda018c4ec"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga082bcb7375f834ce4a401afda018c4ec">SMP_DVECASSIGN_USER_THRESHOLD</a> = 38000UL</td></tr>
<tr class="memdesc:ga082bcb7375f834ce4a401afda018c4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector assignment threshold.This threshold specifies when an assignment of a simple dense vector can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga082bcb7375f834ce4a401afda018c4ec">More...</a><br /></td></tr>
<tr class="separator:ga082bcb7375f834ce4a401afda018c4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42b9d15d759ed255d59cc7790c4e9afc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga42b9d15d759ed255d59cc7790c4e9afc">SMP_DVECDVECADD_USER_THRESHOLD</a> = 38000UL</td></tr>
<tr class="memdesc:ga42b9d15d759ed255d59cc7790c4e9afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/dense vector addition threshold.This threshold specifies when a dense vector/dense vector addition can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga42b9d15d759ed255d59cc7790c4e9afc">More...</a><br /></td></tr>
<tr class="separator:ga42b9d15d759ed255d59cc7790c4e9afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7690c8397893260d591ed91fd6b255f0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga7690c8397893260d591ed91fd6b255f0">SMP_DVECDVECSUB_USER_THRESHOLD</a> = 38000UL</td></tr>
<tr class="memdesc:ga7690c8397893260d591ed91fd6b255f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/dense vector subtraction threshold.This threshold specifies when a dense vector/dense vector subtraction can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga7690c8397893260d591ed91fd6b255f0">More...</a><br /></td></tr>
<tr class="separator:ga7690c8397893260d591ed91fd6b255f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga093facb31775ad5c92221f30a355b92b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga093facb31775ad5c92221f30a355b92b">SMP_DVECDVECMULT_USER_THRESHOLD</a> = 38000UL</td></tr>
<tr class="memdesc:ga093facb31775ad5c92221f30a355b92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/dense vector multiplication threshold.This threshold specifies when a dense vector/dense vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga093facb31775ad5c92221f30a355b92b">More...</a><br /></td></tr>
<tr class="separator:ga093facb31775ad5c92221f30a355b92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga907563a416abd14fae4d3829687c9d5d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga907563a416abd14fae4d3829687c9d5d">SMP_DVECDVECDIV_USER_THRESHOLD</a> = 38000UL</td></tr>
<tr class="memdesc:ga907563a416abd14fae4d3829687c9d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/dense vector division threshold.This threshold specifies when a dense vector/dense vector division can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga907563a416abd14fae4d3829687c9d5d">More...</a><br /></td></tr>
<tr class="separator:ga907563a416abd14fae4d3829687c9d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab84e6ffafea36e2f32076e6aa68ecd4c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gab84e6ffafea36e2f32076e6aa68ecd4c">SMP_DVECSCALARMULT_USER_THRESHOLD</a> = 51000UL</td></tr>
<tr class="memdesc:gab84e6ffafea36e2f32076e6aa68ecd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/scalar multiplication/division threshold.This threshold specifies when a dense vector/scalar multiplication/division can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gab84e6ffafea36e2f32076e6aa68ecd4c">More...</a><br /></td></tr>
<tr class="separator:gab84e6ffafea36e2f32076e6aa68ecd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cdc8aa468e8fd2e3f403ff1bbde2d1c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga2cdc8aa468e8fd2e3f403ff1bbde2d1c">SMP_DMATDVECMULT_USER_THRESHOLD</a> = 330UL</td></tr>
<tr class="memdesc:ga2cdc8aa468e8fd2e3f403ff1bbde2d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/dense vector multiplication threshold.This threshold specifies when a row-major dense matrix/dense vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga2cdc8aa468e8fd2e3f403ff1bbde2d1c">More...</a><br /></td></tr>
<tr class="separator:ga2cdc8aa468e8fd2e3f403ff1bbde2d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aad6b6d83ff0edfaea5e0ea864d389b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga1aad6b6d83ff0edfaea5e0ea864d389b">SMP_TDMATDVECMULT_USER_THRESHOLD</a> = 360UL</td></tr>
<tr class="memdesc:ga1aad6b6d83ff0edfaea5e0ea864d389b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major dense matrix/dense vector multiplication threshold.This threshold specifies when a column-major dense matrix/dense vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga1aad6b6d83ff0edfaea5e0ea864d389b">More...</a><br /></td></tr>
<tr class="separator:ga1aad6b6d83ff0edfaea5e0ea864d389b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e087a9997f0d2206222641984d1e2c5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga0e087a9997f0d2206222641984d1e2c5">SMP_TDVECDMATMULT_USER_THRESHOLD</a> = 370UL</td></tr>
<tr class="memdesc:ga0e087a9997f0d2206222641984d1e2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/row-major dense matrix multiplication threshold.This threshold specifies when a dense vector/row-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga0e087a9997f0d2206222641984d1e2c5">More...</a><br /></td></tr>
<tr class="separator:ga0e087a9997f0d2206222641984d1e2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a49c1140252953f00f4188fac98f5e8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga0a49c1140252953f00f4188fac98f5e8">SMP_TDVECTDMATMULT_USER_THRESHOLD</a> = 340UL</td></tr>
<tr class="memdesc:ga0a49c1140252953f00f4188fac98f5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/column-major dense matrix multiplication threshold.This threshold specifies when a dense vector/column-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga0a49c1140252953f00f4188fac98f5e8">More...</a><br /></td></tr>
<tr class="separator:ga0a49c1140252953f00f4188fac98f5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8533e755547380502ef4bc63e7d9c38"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaf8533e755547380502ef4bc63e7d9c38">SMP_DMATSVECMULT_USER_THRESHOLD</a> = 480UL</td></tr>
<tr class="memdesc:gaf8533e755547380502ef4bc63e7d9c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/sparse vector multiplication threshold.This threshold specifies when a row-major dense matrix/sparse vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gaf8533e755547380502ef4bc63e7d9c38">More...</a><br /></td></tr>
<tr class="separator:gaf8533e755547380502ef4bc63e7d9c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga126ade3c60a6280ac072a768d3410429"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga126ade3c60a6280ac072a768d3410429">SMP_TDMATSVECMULT_USER_THRESHOLD</a> = 910UL</td></tr>
<tr class="memdesc:ga126ade3c60a6280ac072a768d3410429"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major dense matrix/sparse vector multiplication threshold.This threshold specifies when a column-major dense matrix/sparse vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga126ade3c60a6280ac072a768d3410429">More...</a><br /></td></tr>
<tr class="separator:ga126ade3c60a6280ac072a768d3410429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0057fc78805376644a1051cd9bf3529"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gab0057fc78805376644a1051cd9bf3529">SMP_TSVECDMATMULT_USER_THRESHOLD</a> = 910UL</td></tr>
<tr class="memdesc:gab0057fc78805376644a1051cd9bf3529"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP sparse vector/row-major dense matrix multiplication threshold.This threshold specifies when a sparse vector/row-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gab0057fc78805376644a1051cd9bf3529">More...</a><br /></td></tr>
<tr class="separator:gab0057fc78805376644a1051cd9bf3529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4df2fe48bce2e4cbcf2096e023374a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga3e4df2fe48bce2e4cbcf2096e023374a">SMP_TSVECTDMATMULT_USER_THRESHOLD</a> = 480UL</td></tr>
<tr class="memdesc:ga3e4df2fe48bce2e4cbcf2096e023374a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP sparse vector/column-major dense matrix multiplication threshold.This threshold specifies when a sparse vector/column-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga3e4df2fe48bce2e4cbcf2096e023374a">More...</a><br /></td></tr>
<tr class="separator:ga3e4df2fe48bce2e4cbcf2096e023374a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab34d1671bee2cacab558a90c0eac9bec"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gab34d1671bee2cacab558a90c0eac9bec">SMP_SMATDVECMULT_USER_THRESHOLD</a> = 600UL</td></tr>
<tr class="memdesc:gab34d1671bee2cacab558a90c0eac9bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major sparse matrix/dense vector multiplication threshold.This threshold specifies when a row-major sparse matrix/dense vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gab34d1671bee2cacab558a90c0eac9bec">More...</a><br /></td></tr>
<tr class="separator:gab34d1671bee2cacab558a90c0eac9bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8ec7cd52b2546d53b3f158f95b45e7f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaa8ec7cd52b2546d53b3f158f95b45e7f">SMP_TSMATDVECMULT_USER_THRESHOLD</a> = 1250UL</td></tr>
<tr class="memdesc:gaa8ec7cd52b2546d53b3f158f95b45e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major sparse matrix/dense vector multiplication threshold.This threshold specifies when a column-major sparse matrix/dense vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gaa8ec7cd52b2546d53b3f158f95b45e7f">More...</a><br /></td></tr>
<tr class="separator:gaa8ec7cd52b2546d53b3f158f95b45e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c5197743440c3d72fdfab57a1f5ead"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaa4c5197743440c3d72fdfab57a1f5ead">SMP_TDVECSMATMULT_USER_THRESHOLD</a> = 1190UL</td></tr>
<tr class="memdesc:gaa4c5197743440c3d72fdfab57a1f5ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/row-major sparse matrix multiplication threshold.This threshold specifies when a dense vector/row-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gaa4c5197743440c3d72fdfab57a1f5ead">More...</a><br /></td></tr>
<tr class="separator:gaa4c5197743440c3d72fdfab57a1f5ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13900f5ff8064908a26df58dbabec7af"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga13900f5ff8064908a26df58dbabec7af">SMP_TDVECTSMATMULT_USER_THRESHOLD</a> = 530UL</td></tr>
<tr class="memdesc:ga13900f5ff8064908a26df58dbabec7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/column-major sparse matrix multiplication threshold.This threshold specifies when a dense vector/column-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga13900f5ff8064908a26df58dbabec7af">More...</a><br /></td></tr>
<tr class="separator:ga13900f5ff8064908a26df58dbabec7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ff6ecb46d7acb471a809104188dc6a8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga2ff6ecb46d7acb471a809104188dc6a8">SMP_SMATSVECMULT_USER_THRESHOLD</a> = 260UL</td></tr>
<tr class="memdesc:ga2ff6ecb46d7acb471a809104188dc6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major sparse matrix/sparse vector multiplication threshold.This threshold specifies when a row-major sparse matrix/sparse vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga2ff6ecb46d7acb471a809104188dc6a8">More...</a><br /></td></tr>
<tr class="separator:ga2ff6ecb46d7acb471a809104188dc6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21440047f0acc3e00038693277287f72"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga21440047f0acc3e00038693277287f72">SMP_TSMATSVECMULT_USER_THRESHOLD</a> = 2160UL</td></tr>
<tr class="memdesc:ga21440047f0acc3e00038693277287f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major sparse matrix/sparse vector multiplication threshold.This threshold specifies when a column-major sparse matrix/sparse vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga21440047f0acc3e00038693277287f72">More...</a><br /></td></tr>
<tr class="separator:ga21440047f0acc3e00038693277287f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff27198a03e663703c0541b99b594f72"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaff27198a03e663703c0541b99b594f72">SMP_TSVECSMATMULT_USER_THRESHOLD</a> = 2160UL</td></tr>
<tr class="memdesc:gaff27198a03e663703c0541b99b594f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP sparse vector/row-major sparse matrix multiplication threshold.This threshold specifies when a sparse vector/row-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gaff27198a03e663703c0541b99b594f72">More...</a><br /></td></tr>
<tr class="separator:gaff27198a03e663703c0541b99b594f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7bcd6e785ccd4fef4f4bcea8d77e106"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaa7bcd6e785ccd4fef4f4bcea8d77e106">SMP_TSVECTSMATMULT_USER_THRESHOLD</a> = 260UL</td></tr>
<tr class="memdesc:gaa7bcd6e785ccd4fef4f4bcea8d77e106"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP sparse vector/column-major sparse matrix multiplication threshold.This threshold specifies when a sparse vector/column-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gaa7bcd6e785ccd4fef4f4bcea8d77e106">More...</a><br /></td></tr>
<tr class="separator:gaa7bcd6e785ccd4fef4f4bcea8d77e106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9650a6f21d2ebc4d913c0926bdea4f6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaa9650a6f21d2ebc4d913c0926bdea4f6">SMP_DMATASSIGN_USER_THRESHOLD</a> = 48400UL</td></tr>
<tr class="memdesc:gaa9650a6f21d2ebc4d913c0926bdea4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense matrix assignment threshold.This threshold specifies when an assignment with a simple dense matrix can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gaa9650a6f21d2ebc4d913c0926bdea4f6">More...</a><br /></td></tr>
<tr class="separator:gaa9650a6f21d2ebc4d913c0926bdea4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90dfb06d424355fe8f33859b0c678289"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga90dfb06d424355fe8f33859b0c678289">SMP_DMATDMATADD_USER_THRESHOLD</a> = 36100UL</td></tr>
<tr class="memdesc:ga90dfb06d424355fe8f33859b0c678289"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/row-major dense matrix addition threshold.This threshold specifies when a row-major dense matrix/row-major dense matrix addition can be executed in parallel. This threshold affects both additions between two row-major matrices or two column-major dense matrices. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga90dfb06d424355fe8f33859b0c678289">More...</a><br /></td></tr>
<tr class="separator:ga90dfb06d424355fe8f33859b0c678289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga573494cddff4ccc8c3e81f77b7863903"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga573494cddff4ccc8c3e81f77b7863903">SMP_DMATTDMATADD_USER_THRESHOLD</a> = 30625UL</td></tr>
<tr class="memdesc:ga573494cddff4ccc8c3e81f77b7863903"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/column-major dense matrix addition threshold.This threshold specifies when a row-major dense matrix/column-major dense matrix addition can be executed in parallel. This threshold affects both additions between a row-major matrix and a column-major matrix and a column-major matrix and a row-major matrix. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga573494cddff4ccc8c3e81f77b7863903">More...</a><br /></td></tr>
<tr class="separator:ga573494cddff4ccc8c3e81f77b7863903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec34718abb3acaf0ec643c7c2b13d312"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaec34718abb3acaf0ec643c7c2b13d312">SMP_DMATDMATSUB_USER_THRESHOLD</a> = 36100UL</td></tr>
<tr class="memdesc:gaec34718abb3acaf0ec643c7c2b13d312"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/row-major dense matrix subtraction threshold.This threshold specifies when a row-major dense matrix/row-major dense matrix subtraction can be executed in parallel. This threshold affects both subtractions between two row-major matrices or two column-major dense matrices. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gaec34718abb3acaf0ec643c7c2b13d312">More...</a><br /></td></tr>
<tr class="separator:gaec34718abb3acaf0ec643c7c2b13d312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d18af68a4930dd963843fb7e8f374e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga88d18af68a4930dd963843fb7e8f374e">SMP_DMATTDMATSUB_USER_THRESHOLD</a> = 30625UL</td></tr>
<tr class="memdesc:ga88d18af68a4930dd963843fb7e8f374e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/column-major dense matrix subtraction threshold.This threshold specifies when a row-major dense matrix/column-major dense matrix subtraction can be executed in parallel. This threshold affects both subtractions between a row-major matrix and a column-major matrix and a column-major matrix and a row-major matrix. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga88d18af68a4930dd963843fb7e8f374e">More...</a><br /></td></tr>
<tr class="separator:ga88d18af68a4930dd963843fb7e8f374e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1acb6fdf5a74d4a679984462f66cf2a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gab1acb6fdf5a74d4a679984462f66cf2a">SMP_DMATSCALARMULT_USER_THRESHOLD</a> = 48400UL</td></tr>
<tr class="memdesc:gab1acb6fdf5a74d4a679984462f66cf2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense matrix/scalar multiplication/division threshold.This threshold specifies when a dense matrix/scalar multiplication or division can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gab1acb6fdf5a74d4a679984462f66cf2a">More...</a><br /></td></tr>
<tr class="separator:gab1acb6fdf5a74d4a679984462f66cf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8d1576ef69a0eee5c76a303da6aaa02"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gac8d1576ef69a0eee5c76a303da6aaa02">SMP_DMATDMATMULT_USER_THRESHOLD</a> = 3025UL</td></tr>
<tr class="memdesc:gac8d1576ef69a0eee5c76a303da6aaa02"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/row-major dense matrix multiplication threshold.This threshold specifies when a row-major dense matrix/row-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gac8d1576ef69a0eee5c76a303da6aaa02">More...</a><br /></td></tr>
<tr class="separator:gac8d1576ef69a0eee5c76a303da6aaa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe302e1d378dea2222f94ac2bf944e2b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gabe302e1d378dea2222f94ac2bf944e2b">SMP_DMATTDMATMULT_USER_THRESHOLD</a> = 3025UL</td></tr>
<tr class="memdesc:gabe302e1d378dea2222f94ac2bf944e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/column-major dense matrix multiplication threshold.This threshold specifies when a row-major dense matrix/column-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gabe302e1d378dea2222f94ac2bf944e2b">More...</a><br /></td></tr>
<tr class="separator:gabe302e1d378dea2222f94ac2bf944e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac20340a345af6b11290727c20f93d8a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaac20340a345af6b11290727c20f93d8a">SMP_TDMATDMATMULT_USER_THRESHOLD</a> = 3025UL</td></tr>
<tr class="memdesc:gaac20340a345af6b11290727c20f93d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major dense matrix/row-major dense matrix multiplication threshold.This threshold specifies when a column-major dense matrix/row-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gaac20340a345af6b11290727c20f93d8a">More...</a><br /></td></tr>
<tr class="separator:gaac20340a345af6b11290727c20f93d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71af01643a978ad91d4a96accc7051bc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga71af01643a978ad91d4a96accc7051bc">SMP_TDMATTDMATMULT_USER_THRESHOLD</a> = 3025UL</td></tr>
<tr class="memdesc:ga71af01643a978ad91d4a96accc7051bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major dense matrix/column-major dense matrix multiplication threshold.This threshold specifies when a column-major dense matrix/column-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga71af01643a978ad91d4a96accc7051bc">More...</a><br /></td></tr>
<tr class="separator:ga71af01643a978ad91d4a96accc7051bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e4e6c980cf4337d2ac71172a6e6f18f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga9e4e6c980cf4337d2ac71172a6e6f18f">SMP_DMATSMATMULT_USER_THRESHOLD</a> = 4096UL</td></tr>
<tr class="memdesc:ga9e4e6c980cf4337d2ac71172a6e6f18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/row-major sparse matrix multiplication threshold.This threshold specifies when a row-major dense matrix/row-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga9e4e6c980cf4337d2ac71172a6e6f18f">More...</a><br /></td></tr>
<tr class="separator:ga9e4e6c980cf4337d2ac71172a6e6f18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37de0478232998de87e025b6cdec8419"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga37de0478232998de87e025b6cdec8419">SMP_DMATTSMATMULT_USER_THRESHOLD</a> = 4624UL</td></tr>
<tr class="memdesc:ga37de0478232998de87e025b6cdec8419"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/column-major sparse matrix multiplication threshold.This threshold specifies when a row-major dense matrix/column-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga37de0478232998de87e025b6cdec8419">More...</a><br /></td></tr>
<tr class="separator:ga37de0478232998de87e025b6cdec8419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c747342c12a0de3cefa229037aa22e2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga1c747342c12a0de3cefa229037aa22e2">SMP_TDMATSMATMULT_USER_THRESHOLD</a> = 8100UL</td></tr>
<tr class="memdesc:ga1c747342c12a0de3cefa229037aa22e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major dense matrix/row-major sparse matrix multiplication threshold.This threshold specifies when a column-major dense matrix/row-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga1c747342c12a0de3cefa229037aa22e2">More...</a><br /></td></tr>
<tr class="separator:ga1c747342c12a0de3cefa229037aa22e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f710faaf4fb96ac8173887b263f4d72"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga7f710faaf4fb96ac8173887b263f4d72">SMP_TDMATTSMATMULT_USER_THRESHOLD</a> = 8100UL</td></tr>
<tr class="memdesc:ga7f710faaf4fb96ac8173887b263f4d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major dense matrix/column-major sparse matrix multiplication threshold.This threshold specifies when a column-major dense matrix/column-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga7f710faaf4fb96ac8173887b263f4d72">More...</a><br /></td></tr>
<tr class="separator:ga7f710faaf4fb96ac8173887b263f4d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4146af68e09bf51383b7874f2102ca53"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga4146af68e09bf51383b7874f2102ca53">SMP_SMATDMATMULT_USER_THRESHOLD</a> = 7744UL</td></tr>
<tr class="memdesc:ga4146af68e09bf51383b7874f2102ca53"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major sparse matrix/row-major dense matrix multiplication threshold.This threshold specifies when a row-major sparse matrix/row-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga4146af68e09bf51383b7874f2102ca53">More...</a><br /></td></tr>
<tr class="separator:ga4146af68e09bf51383b7874f2102ca53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146ae0c59f44b78744b57b35feee0b13"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga146ae0c59f44b78744b57b35feee0b13">SMP_SMATTDMATMULT_USER_THRESHOLD</a> = 5184UL</td></tr>
<tr class="memdesc:ga146ae0c59f44b78744b57b35feee0b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major sparse matrix/column-major dense matrix multiplication threshold.This threshold specifies when a row-major sparse matrix/column-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga146ae0c59f44b78744b57b35feee0b13">More...</a><br /></td></tr>
<tr class="separator:ga146ae0c59f44b78744b57b35feee0b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga336ac103c3a00a2f2a85f81cd8840f12"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga336ac103c3a00a2f2a85f81cd8840f12">SMP_TSMATDMATMULT_USER_THRESHOLD</a> = 4356UL</td></tr>
<tr class="memdesc:ga336ac103c3a00a2f2a85f81cd8840f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major sparse matrix/row-major dense matrix multiplication threshold.This threshold specifies when a column-major sparse matrix/row-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga336ac103c3a00a2f2a85f81cd8840f12">More...</a><br /></td></tr>
<tr class="separator:ga336ac103c3a00a2f2a85f81cd8840f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7a724111c87941ad8e56328ba56c7cd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gab7a724111c87941ad8e56328ba56c7cd">SMP_TSMATTDMATMULT_USER_THRESHOLD</a> = 4356UL</td></tr>
<tr class="memdesc:gab7a724111c87941ad8e56328ba56c7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major sparse matrix/column-major dense matrix multiplication threshold.This threshold specifies when a column-major sparse matrix/column-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gab7a724111c87941ad8e56328ba56c7cd">More...</a><br /></td></tr>
<tr class="separator:gab7a724111c87941ad8e56328ba56c7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bb401c4dfa100f272b56afa3b8ddd9c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga0bb401c4dfa100f272b56afa3b8ddd9c">SMP_SMATSMATMULT_USER_THRESHOLD</a> = 22500UL</td></tr>
<tr class="memdesc:ga0bb401c4dfa100f272b56afa3b8ddd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major sparse matrix/row-major sparse matrix multiplication threshold.This threshold specifies when a row-major sparse matrix/row-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga0bb401c4dfa100f272b56afa3b8ddd9c">More...</a><br /></td></tr>
<tr class="separator:ga0bb401c4dfa100f272b56afa3b8ddd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf9443e0a55fb895db5012e4bd540f47"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gabf9443e0a55fb895db5012e4bd540f47">SMP_SMATTSMATMULT_USER_THRESHOLD</a> = 19600UL</td></tr>
<tr class="memdesc:gabf9443e0a55fb895db5012e4bd540f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major sparse matrix/column-major sparse matrix multiplication threshold.This threshold specifies when a row-major sparse matrix/column-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gabf9443e0a55fb895db5012e4bd540f47">More...</a><br /></td></tr>
<tr class="separator:gabf9443e0a55fb895db5012e4bd540f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga228fa3a394e6bdd1d87842536452e697"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga228fa3a394e6bdd1d87842536452e697">SMP_TSMATSMATMULT_USER_THRESHOLD</a> = 19600UL</td></tr>
<tr class="memdesc:ga228fa3a394e6bdd1d87842536452e697"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major sparse matrix/row-major sparse matrix multiplication threshold.This threshold specifies when a column-major sparse matrix/row-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#ga228fa3a394e6bdd1d87842536452e697">More...</a><br /></td></tr>
<tr class="separator:ga228fa3a394e6bdd1d87842536452e697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8264a6f4e310b78a56ffedbf240a1d1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gac8264a6f4e310b78a56ffedbf240a1d1">SMP_TSMATTSMATMULT_USER_THRESHOLD</a> = 22500UL</td></tr>
<tr class="memdesc:gac8264a6f4e310b78a56ffedbf240a1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major sparse matrix/column-major sparse matrix multiplication threshold.This threshold specifies when a column-major sparse matrix/column-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gac8264a6f4e310b78a56ffedbf240a1d1">More...</a><br /></td></tr>
<tr class="separator:gac8264a6f4e310b78a56ffedbf240a1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae413fb17a0ca57aa1f6171cada20d6c8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gae413fb17a0ca57aa1f6171cada20d6c8">SMP_DVECTDVECMULT_USER_THRESHOLD</a> = 84100UL</td></tr>
<tr class="memdesc:gae413fb17a0ca57aa1f6171cada20d6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/dense vector outer product threshold.This threshold specifies when a dense vector/dense vector outer product can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded.  <a href="../../d1/d44/group__config.html#gae413fb17a0ca57aa1f6171cada20d6c8">More...</a><br /></td></tr>
<tr class="separator:gae413fb17a0ca57aa1f6171cada20d6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace7f5aa368eb7728224553c0641f3486"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gace7f5aa368eb7728224553c0641f3486">defaultTransposeFlag</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">columnVector</a></td></tr>
<tr class="memdesc:gace7f5aa368eb7728224553c0641f3486"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default transpose flag for all vectors of the Blaze library.This value specifies the default transpose flag for all vector of the Blaze library. In case no explicit transpose flag is specified with the according vector type, this setting is used.  <a href="../../d1/d44/group__config.html#gace7f5aa368eb7728224553c0641f3486">More...</a><br /></td></tr>
<tr class="separator:gace7f5aa368eb7728224553c0641f3486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5273b2715d3354c16d049d1313f7e72"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae5273b2715d3354c16d049d1313f7e72">accuracy</a></td></tr>
<tr class="memdesc:gae5273b2715d3354c16d049d1313f7e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> instance.The <a class="el" href="../../de/df1/group__math.html#gae5273b2715d3354c16d049d1313f7e72" title="Global Accuracy instance.The blaze::accuracy instance can be used wherever a floating point data type...">blaze::accuracy</a> instance can be used wherever a floating point data type is expected. It is implicitly converted to the corresponding floating point data type and represents the computation accuracy of the Blaze library for the according data type. <br /></td></tr>
<tr class="separator:gae5273b2715d3354c16d049d1313f7e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9182d2466faf6f39bfc6a7cd2e5895a5"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9182d2466faf6f39bfc6a7cd2e5895a5">unaligned</a> = false</td></tr>
<tr class="memdesc:ga9182d2466faf6f39bfc6a7cd2e5895a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment flag for unaligned vectors and matrices.Via this flag it is possible to specify subvectors, submatrices, custom vectors and matrices as unaligned. The following example demonstrates the setup of an unaligned subvector:  <a href="../../de/df1/group__math.html#ga9182d2466faf6f39bfc6a7cd2e5895a5">More...</a><br /></td></tr>
<tr class="separator:ga9182d2466faf6f39bfc6a7cd2e5895a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30a412c45e10cff7eba4dacc999d55c7"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga30a412c45e10cff7eba4dacc999d55c7">aligned</a> = true</td></tr>
<tr class="memdesc:ga30a412c45e10cff7eba4dacc999d55c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment flag for aligned vectors and matrices.Via this flag it is possible to specify subvectors, submatrices, custom vectors and matrices as aligned. The following example demonstrates the setup of an aligned subvector:  <a href="../../de/df1/group__math.html#ga30a412c45e10cff7eba4dacc999d55c7">More...</a><br /></td></tr>
<tr class="separator:ga30a412c45e10cff7eba4dacc999d55c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa03c9c30b62492e78ae9d1f595650f99"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="../../d1/d44/group__config.html#gaf3e403c679e31e0915664a12344b5e8c">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa03c9c30b62492e78ae9d1f595650f99">M_E</a> = 2.7182818284590452353602874713526625</td></tr>
<tr class="memdesc:gaa03c9c30b62492e78ae9d1f595650f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ e $" src="../../form_26.png"/>. <br /></td></tr>
<tr class="separator:gaa03c9c30b62492e78ae9d1f595650f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e8d5300fa173204cdf2b8d874e41f5"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="../../d1/d44/group__config.html#gaf3e403c679e31e0915664a12344b5e8c">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga17e8d5300fa173204cdf2b8d874e41f5">M_LOG2E</a> = 1.4426950408889634073599246810018921</td></tr>
<tr class="memdesc:ga17e8d5300fa173204cdf2b8d874e41f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \log_2 e $" src="../../form_27.png"/>. <br /></td></tr>
<tr class="separator:ga17e8d5300fa173204cdf2b8d874e41f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd12c336b727fa152948e3bc40b2f6ce"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="../../d1/d44/group__config.html#gaf3e403c679e31e0915664a12344b5e8c">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gadd12c336b727fa152948e3bc40b2f6ce">M_LOG10E</a> = 0.4342944819032518276511289189166051</td></tr>
<tr class="memdesc:gadd12c336b727fa152948e3bc40b2f6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \log_{10} e $" src="../../form_28.png"/>. <br /></td></tr>
<tr class="separator:gadd12c336b727fa152948e3bc40b2f6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e0a2e76c4380fca5e9519f9740e9620"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="../../d1/d44/group__config.html#gaf3e403c679e31e0915664a12344b5e8c">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2e0a2e76c4380fca5e9519f9740e9620">M_LN2</a> = 0.6931471805599453094172321214581766</td></tr>
<tr class="memdesc:ga2e0a2e76c4380fca5e9519f9740e9620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \ln 2 $" src="../../form_29.png"/>. <br /></td></tr>
<tr class="separator:ga2e0a2e76c4380fca5e9519f9740e9620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7075250a4e63399e83b94a05b7d3421"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="../../d1/d44/group__config.html#gaf3e403c679e31e0915664a12344b5e8c">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae7075250a4e63399e83b94a05b7d3421">M_LN10</a> = 2.3025850929940456840179914546843642</td></tr>
<tr class="memdesc:gae7075250a4e63399e83b94a05b7d3421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \ln 10 $" src="../../form_30.png"/>. <br /></td></tr>
<tr class="separator:gae7075250a4e63399e83b94a05b7d3421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga365d3bb76032ee7d017accffc216cf31"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="../../d1/d44/group__config.html#gaf3e403c679e31e0915664a12344b5e8c">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga365d3bb76032ee7d017accffc216cf31">M_PI</a> = 3.1415926535897932384626433832795029</td></tr>
<tr class="memdesc:ga365d3bb76032ee7d017accffc216cf31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \pi $" src="../../form_31.png"/>. <br /></td></tr>
<tr class="separator:ga365d3bb76032ee7d017accffc216cf31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2739ba53f04d76dbaafd40837fa43d33"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="../../d1/d44/group__config.html#gaf3e403c679e31e0915664a12344b5e8c">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2739ba53f04d76dbaafd40837fa43d33">M_SQRT2</a> = 1.4142135623730950488016887242096981</td></tr>
<tr class="memdesc:ga2739ba53f04d76dbaafd40837fa43d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \sqrt{2} $" src="../../form_32.png"/>. <br /></td></tr>
<tr class="separator:ga2739ba53f04d76dbaafd40837fa43d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe462b2d2021ff821312133d36474c2a"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="../../d1/d44/group__config.html#gaf3e403c679e31e0915664a12344b5e8c">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gafe462b2d2021ff821312133d36474c2a">M_SQRT3</a> = 1.7320508075688772935274463415058724</td></tr>
<tr class="memdesc:gafe462b2d2021ff821312133d36474c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \sqrt{3} $" src="../../form_33.png"/>. <br /></td></tr>
<tr class="separator:gafe462b2d2021ff821312133d36474c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7691c4cf9181e1f56571cf39d785cf3"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad7691c4cf9181e1f56571cf39d785cf3">epsilon</a></td></tr>
<tr class="memdesc:gad7691c4cf9181e1f56571cf39d785cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> instance.The <a class="el" href="../../de/df1/group__math.html#gad7691c4cf9181e1f56571cf39d785cf3" title="Global Epsilon instance.The blaze::epsilon instance can be used wherever a floating point data type i...">blaze::epsilon</a> instance can be used wherever a floating point data type is expected. It is implicitly converted to the corresponding floating point data type and represents the smallest possible difference between two values of the according data type. <br /></td></tr>
<tr class="separator:gad7691c4cf9181e1f56571cf39d785cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3096c2ff9c7323a2d390af40c1c18a66"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3096c2ff9c7323a2d390af40c1c18a66">inf</a></td></tr>
<tr class="memdesc:ga3096c2ff9c7323a2d390af40c1c18a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> instance.The <a class="el" href="../../de/df1/group__math.html#ga3096c2ff9c7323a2d390af40c1c18a66" title="Global Infinity instance.The blaze::inf instance can be used wherever a built-in data type is expecte...">blaze::inf</a> instance can be used wherever a built-in data type is expected. It is implicitly converted to the corresponding built-in data type and represents its largest possible data value. <br /></td></tr>
<tr class="separator:ga3096c2ff9c7323a2d390af40c1c18a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc7ae55b6c72483aab8062ac750a2bc"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaedc7ae55b6c72483aab8062ac750a2bc">unpadded</a> = false</td></tr>
<tr class="memdesc:gaedc7ae55b6c72483aab8062ac750a2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Padding flag for unpadded vectors and matrices.Via this flag it is possible to specify custom vectors and matrices as unpadded. The following example demonstrates the setup of an unaligned, unpadded custom row vector of size 7:  <a href="../../de/df1/group__math.html#gaedc7ae55b6c72483aab8062ac750a2bc">More...</a><br /></td></tr>
<tr class="separator:gaedc7ae55b6c72483aab8062ac750a2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b4adba70768d85bb6e8f5c8c1250c56"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5b4adba70768d85bb6e8f5c8c1250c56">padded</a> = true</td></tr>
<tr class="memdesc:ga5b4adba70768d85bb6e8f5c8c1250c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Padding flag for padded vectors and matrices.Via this flag it is possible to specify custom vectors and matrices as aligned. The following example demonstrates the setup of an aligned, padded custom row vector of size 7:  <a href="../../de/df1/group__math.html#ga5b4adba70768d85bb6e8f5c8c1250c56">More...</a><br /></td></tr>
<tr class="separator:ga5b4adba70768d85bb6e8f5c8c1250c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511878ce70095271b6d0dd5b855a9eaa"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a> = false</td></tr>
<tr class="memdesc:a511878ce70095271b6d0dd5b855a9eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage order flag for row-major matrices.  <a href="#a511878ce70095271b6d0dd5b855a9eaa">More...</a><br /></td></tr>
<tr class="separator:a511878ce70095271b6d0dd5b855a9eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e42e1508f7d4d364fe7c64eef78a583"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">columnMajor</a> = true</td></tr>
<tr class="memdesc:a5e42e1508f7d4d364fe7c64eef78a583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage order flag for column-major matrices.  <a href="#a5e42e1508f7d4d364fe7c64eef78a583">More...</a><br /></td></tr>
<tr class="separator:a5e42e1508f7d4d364fe7c64eef78a583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee466faebcaba59afde0fbfe22041aa"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">columnVector</a> = false</td></tr>
<tr class="memdesc:acee466faebcaba59afde0fbfe22041aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose flag for column vectors.  <a href="#acee466faebcaba59afde0fbfe22041aa">More...</a><br /></td></tr>
<tr class="separator:acee466faebcaba59afde0fbfe22041aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006b6328815f2632d2c5ab8b869c5cf0"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">rowVector</a> = true</td></tr>
<tr class="memdesc:a006b6328815f2632d2c5ab8b869c5cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose flag for row vectors.  <a href="#a006b6328815f2632d2c5ab8b869c5cf0">More...</a><br /></td></tr>
<tr class="separator:a006b6328815f2632d2c5ab8b869c5cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e44d940e5eb6234d8885e3e3020e9c5"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga4e44d940e5eb6234d8885e3e3020e9c5">DMATDVECMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga4e44d940e5eb6234d8885e3e3020e9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major dense matrix/dense vector multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gabff2b3162e8e727e87757b26e3c7a2b7" title="Row-major dense matrix/dense vector multiplication threshold.This setting specifies the threshold bet...">blaze::DMATDVECMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the row-major dense matrix/dense vector multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used. <br /></td></tr>
<tr class="separator:ga4e44d940e5eb6234d8885e3e3020e9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe0448995461b28db89e36af8b12b179"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gabe0448995461b28db89e36af8b12b179">TDMATDVECMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:gabe0448995461b28db89e36af8b12b179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major dense matrix/dense vector multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gad423636e960a35c1940486074d1fbf42" title="Column-major dense matrix/dense vector multiplication threshold.This setting specifies the threshold ...">blaze::TDMATDVECMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the column-major dense matrix/dense vector multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used. <br /></td></tr>
<tr class="separator:gabe0448995461b28db89e36af8b12b179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c54c6b9ba7fa0ac9785bb3a1ae37b5"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga31c54c6b9ba7fa0ac9785bb3a1ae37b5">TDVECDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga31c54c6b9ba7fa0ac9785bb3a1ae37b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense Vector/row-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gad4b9bd8ac28ac5cc5b926bd752bfda5c" title="Dense Vector/row-major dense matrix multiplication threshold.This setting specifies the threshold bet...">blaze::TDVECDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the dense vector/row-major dense matrix multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used. <br /></td></tr>
<tr class="separator:ga31c54c6b9ba7fa0ac9785bb3a1ae37b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a33e674047ad9a71d8661b4d554bb8"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga41a33e674047ad9a71d8661b4d554bb8">TDVECTDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga41a33e674047ad9a71d8661b4d554bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense Vector/column-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga8b4490aac211c21601fe1cef8a899200" title="Dense Vector/column-major dense matrix multiplication threshold.This setting specifies the threshold ...">blaze::TDVECTDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the dense vector/column-major dense matrix multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used. <br /></td></tr>
<tr class="separator:ga41a33e674047ad9a71d8661b4d554bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1b5dab2d1a961b96d8adebe2dff235d"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaa1b5dab2d1a961b96d8adebe2dff235d">DMATDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:gaa1b5dab2d1a961b96d8adebe2dff235d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major dense matrix/row-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga6cc091259379417f6c3ef075cc6c5b86" title="Row-major dense matrix/row-major dense matrix multiplication threshold.This setting specifies the thr...">blaze::DMATDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the row-major dense matrix/row-major dense matrix multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used. <br /></td></tr>
<tr class="separator:gaa1b5dab2d1a961b96d8adebe2dff235d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2dca98a425d9283341ef5e8d8bef25b"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaa2dca98a425d9283341ef5e8d8bef25b">DMATTDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:gaa2dca98a425d9283341ef5e8d8bef25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major dense matrix/column-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga4b3946c89721e8a133da9856a5c4b4e6" title="Row-major dense matrix/column-major dense matrix multiplication threshold.This setting specifies the ...">blaze::DMATTDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the row-major dense matrix/column-major dense matrix multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used. <br /></td></tr>
<tr class="separator:gaa2dca98a425d9283341ef5e8d8bef25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b59a54d347abb5366d82e8fa2434d98"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga9b59a54d347abb5366d82e8fa2434d98">TDMATDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga9b59a54d347abb5366d82e8fa2434d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major dense matrix/row-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gada08201915e8f9a4ed753901e89fb24a" title="Column-major dense matrix/row-major dense matrix multiplication threshold.This setting specifies the ...">blaze::TDMATDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the column-major dense matrix/row-major dense matrix multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used. <br /></td></tr>
<tr class="separator:ga9b59a54d347abb5366d82e8fa2434d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470d6a2cb17b9fcc5093b210a781056b"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga470d6a2cb17b9fcc5093b210a781056b">TDMATTDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga470d6a2cb17b9fcc5093b210a781056b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major dense matrix/column-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga42629469e24d03cd069a6ef2992b422b" title="Column-major dense matrix/column-major dense matrix multiplication threshold.This setting specifies t...">blaze::TDMATTDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the column-major dense matrix/column-major dense matrix multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are preferred over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used. <br /></td></tr>
<tr class="separator:ga470d6a2cb17b9fcc5093b210a781056b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bb8c8be3df96d5a1e17d50f99de467f"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga7bb8c8be3df96d5a1e17d50f99de467f">DMATSMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga7bb8c8be3df96d5a1e17d50f99de467f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major dense matrix/row-major sparse matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga7325edc799fd1e79f469ba1e6dcd4352" title="Row-major dense matrix/row-major sparse matrix multiplication threshold.This setting specifies the th...">blaze::DMATSMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies the threshold between the application of the Blaze kernels for small and for large row-major dense matrix/row-major sparse matrix multiplications. In case the number of elements of the target matrix is equal or higher than this value, the kernel for large matrices is preferred over the kernel for small matrices. In case the number of elements in the target matrix is smaller, the kernel for small matrices is used. <br /></td></tr>
<tr class="separator:ga7bb8c8be3df96d5a1e17d50f99de467f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa63450dabb0e098e97b2273e44409619"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaa63450dabb0e098e97b2273e44409619">TDMATSMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:gaa63450dabb0e098e97b2273e44409619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major dense matrix/row-major sparse matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga7325edc799fd1e79f469ba1e6dcd4352" title="Row-major dense matrix/row-major sparse matrix multiplication threshold.This setting specifies the th...">blaze::DMATSMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies the threshold between the application of the Blaze kernels for small and for large column-major dense matrix/row-major sparse matrix multiplications. In case the number of elements of the target matrix is equal or higher than this value, the kernel for large matrices is preferred over the kernel for small matrices. In case the number of elements in the target matrix is smaller, the kernel for small matrices is used. <br /></td></tr>
<tr class="separator:gaa63450dabb0e098e97b2273e44409619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4a2ef6423809ae72bd03a6efaf5d6e0"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gad4a2ef6423809ae72bd03a6efaf5d6e0">TSMATDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:gad4a2ef6423809ae72bd03a6efaf5d6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major sparse matrix/row-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gab4075adff9953d50eb42b5f719e30312" title="Column-major sparse matrix/row-major dense matrix multiplication threshold.This setting specifies the...">blaze::TSMATDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies the threshold between the application of the Blaze kernels for small and for large column-major sparse matrix/row-major dense matrix multiplications. In case the number of elements of the target matrix is equal or higher than this value, the kernel for large matrices is preferred over the kernel for small matrices. In case the number of elements in the target matrix is smaller, the kernel for small matrices is used. <br /></td></tr>
<tr class="separator:gad4a2ef6423809ae72bd03a6efaf5d6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac67323584e181a38fe47597dd893611b"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gac67323584e181a38fe47597dd893611b">TSMATTDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:gac67323584e181a38fe47597dd893611b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major sparse matrix/column-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga2cb46b52049d0a79b24ae6f0ad4f464a" title="Column-major sparse matrix/column-major dense matrix multiplication threshold.This setting specifies ...">blaze::TSMATTDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies the threshold between the application of the Blaze kernels for small and for large column-major sparse matrix/column-major dense matrix multiplications. In case the number of elements of the target matrix is equal or higher than this value, the kernel for large matrices is preferred over the kernel for small matrices. In case the number of elements in the target matrix is smaller, the kernel for small matrices is used. <br /></td></tr>
<tr class="separator:gac67323584e181a38fe47597dd893611b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc3a6ec03679f7385eee712590c1c99"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga6cc3a6ec03679f7385eee712590c1c99">SMP_DVECASSIGN_DEBUG_THRESHOLD</a> = 32UL</td></tr>
<tr class="memdesc:ga6cc3a6ec03679f7385eee712590c1c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector assignment threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga082bcb7375f834ce4a401afda018c4ec" title="SMP dense vector assignment threshold.This threshold specifies when an assignment of a simple dense v...">blaze::SMP_DVECASSIGN_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when an assignment of a simple dense vector can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga6cc3a6ec03679f7385eee712590c1c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4112dfe23cb403cd930b3294d4d63d4"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gab4112dfe23cb403cd930b3294d4d63d4">SMP_DVECDVECADD_DEBUG_THRESHOLD</a> = 32UL</td></tr>
<tr class="memdesc:gab4112dfe23cb403cd930b3294d4d63d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/dense vector addition threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga42b9d15d759ed255d59cc7790c4e9afc" title="SMP dense vector/dense vector addition threshold.This threshold specifies when a dense vector/dense v...">blaze::SMP_DVECDVECADD_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a dense vector/dense vector addition can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:gab4112dfe23cb403cd930b3294d4d63d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca9f585388b41090c349212948f7df27"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaca9f585388b41090c349212948f7df27">SMP_DVECDVECSUB_DEBUG_THRESHOLD</a> = 32UL</td></tr>
<tr class="memdesc:gaca9f585388b41090c349212948f7df27"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/dense vector subtraction threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga7690c8397893260d591ed91fd6b255f0" title="SMP dense vector/dense vector subtraction threshold.This threshold specifies when a dense vector/dens...">blaze::SMP_DVECDVECSUB_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a dense vector/dense vector subtraction can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:gaca9f585388b41090c349212948f7df27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1491cf0c7b5d75e0662458eb87cc7494"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga1491cf0c7b5d75e0662458eb87cc7494">SMP_DVECDVECMULT_DEBUG_THRESHOLD</a> = 32UL</td></tr>
<tr class="memdesc:ga1491cf0c7b5d75e0662458eb87cc7494"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/dense vector multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga093facb31775ad5c92221f30a355b92b" title="SMP dense vector/dense vector multiplication threshold.This threshold specifies when a dense vector/d...">blaze::SMP_DVECDVECMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a dense vector/dense vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga1491cf0c7b5d75e0662458eb87cc7494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dab4c1690ca329f535c8c07aac94aee"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga3dab4c1690ca329f535c8c07aac94aee">SMP_DVECDVECDIV_DEBUG_THRESHOLD</a> = 32UL</td></tr>
<tr class="memdesc:ga3dab4c1690ca329f535c8c07aac94aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/dense vector division threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga907563a416abd14fae4d3829687c9d5d" title="SMP dense vector/dense vector division threshold.This threshold specifies when a dense vector/dense v...">blaze::SMP_DVECDVECDIV_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a dense vector/dense vector division can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga3dab4c1690ca329f535c8c07aac94aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a76b6633cb244eb53eba3164d3313b4"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga7a76b6633cb244eb53eba3164d3313b4">SMP_DVECSCALARMULT_DEBUG_THRESHOLD</a> = 32UL</td></tr>
<tr class="memdesc:ga7a76b6633cb244eb53eba3164d3313b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/scalar multiplication/division threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gab84e6ffafea36e2f32076e6aa68ecd4c" title="SMP dense vector/scalar multiplication/division threshold.This threshold specifies when a dense vecto...">blaze::SMP_DVECSCALARMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a dense vector/scalar multiplication/division can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga7a76b6633cb244eb53eba3164d3313b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49813e7503412ba8f5c272120d7469e7"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga49813e7503412ba8f5c272120d7469e7">SMP_DMATDVECMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:ga49813e7503412ba8f5c272120d7469e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/dense vector multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga2cdc8aa468e8fd2e3f403ff1bbde2d1c" title="SMP row-major dense matrix/dense vector multiplication threshold.This threshold specifies when a row-...">blaze::SMP_DMATDVECMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major dense matrix/dense vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga49813e7503412ba8f5c272120d7469e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07bb132ffa768e4ad0b8dbd2b7dfca47"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga07bb132ffa768e4ad0b8dbd2b7dfca47">SMP_TDMATDVECMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:ga07bb132ffa768e4ad0b8dbd2b7dfca47"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major dense matrix/dense vector multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga1aad6b6d83ff0edfaea5e0ea864d389b" title="SMP column-major dense matrix/dense vector multiplication threshold.This threshold specifies when a c...">blaze::SMP_TDMATDVECMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a column-major dense matrix/dense vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga07bb132ffa768e4ad0b8dbd2b7dfca47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga384fe88d8ae68523de6494a01c14e94e"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga384fe88d8ae68523de6494a01c14e94e">SMP_TDVECDMATMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:ga384fe88d8ae68523de6494a01c14e94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/row-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga0e087a9997f0d2206222641984d1e2c5" title="SMP dense vector/row-major dense matrix multiplication threshold.This threshold specifies when a dens...">blaze::SMP_TDVECDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a dense vector/row-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga384fe88d8ae68523de6494a01c14e94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b482fa9476ba6db9bdf99ac1df3312"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga51b482fa9476ba6db9bdf99ac1df3312">SMP_TDVECTDMATMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:ga51b482fa9476ba6db9bdf99ac1df3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/column-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga0a49c1140252953f00f4188fac98f5e8" title="SMP dense vector/column-major dense matrix multiplication threshold.This threshold specifies when a d...">blaze::SMP_TDVECTDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a dense vector/column-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga51b482fa9476ba6db9bdf99ac1df3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac59a32f94dd425ce4ab9db52239a708e"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gac59a32f94dd425ce4ab9db52239a708e">SMP_DMATSVECMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:gac59a32f94dd425ce4ab9db52239a708e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/sparse vector multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gaf8533e755547380502ef4bc63e7d9c38" title="SMP row-major dense matrix/sparse vector multiplication threshold.This threshold specifies when a row...">blaze::SMP_DMATSVECMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major dense matrix/sparse vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:gac59a32f94dd425ce4ab9db52239a708e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c2ecca1d9fd08d91e812e8d4671644a"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga8c2ecca1d9fd08d91e812e8d4671644a">SMP_TDMATSVECMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:ga8c2ecca1d9fd08d91e812e8d4671644a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major dense matrix/sparse vector multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga126ade3c60a6280ac072a768d3410429" title="SMP column-major dense matrix/sparse vector multiplication threshold.This threshold specifies when a ...">blaze::SMP_TDMATSVECMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a column-major dense matrix/sparse vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga8c2ecca1d9fd08d91e812e8d4671644a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6978d10de9c375d6b9cec09da0548aa9"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga6978d10de9c375d6b9cec09da0548aa9">SMP_TSVECDMATMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:ga6978d10de9c375d6b9cec09da0548aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP sparse vector/row-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gab0057fc78805376644a1051cd9bf3529" title="SMP sparse vector/row-major dense matrix multiplication threshold.This threshold specifies when a spa...">blaze::SMP_TSVECDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a sparse vector/row-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga6978d10de9c375d6b9cec09da0548aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b6528504a8d927fb7772bccd954cd79"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga6b6528504a8d927fb7772bccd954cd79">SMP_TSVECTDMATMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:ga6b6528504a8d927fb7772bccd954cd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP sparse vector/column-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga3e4df2fe48bce2e4cbcf2096e023374a" title="SMP sparse vector/column-major dense matrix multiplication threshold.This threshold specifies when a ...">blaze::SMP_TSVECTDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a sparse vector/column-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga6b6528504a8d927fb7772bccd954cd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc765b3066c49f6aff842a751117746"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga5fc765b3066c49f6aff842a751117746">SMP_SMATDVECMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:ga5fc765b3066c49f6aff842a751117746"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major sparse matrix/dense vector multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gab34d1671bee2cacab558a90c0eac9bec" title="SMP row-major sparse matrix/dense vector multiplication threshold.This threshold specifies when a row...">blaze::SMP_SMATDVECMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major sparse matrix/dense vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga5fc765b3066c49f6aff842a751117746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30f68e0bcb07fb260292fa3850cb1bc"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaf30f68e0bcb07fb260292fa3850cb1bc">SMP_TSMATDVECMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:gaf30f68e0bcb07fb260292fa3850cb1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major sparse matrix/dense vector multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gaa8ec7cd52b2546d53b3f158f95b45e7f" title="SMP column-major sparse matrix/dense vector multiplication threshold.This threshold specifies when a ...">blaze::SMP_TSMATDVECMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a column-major sparse matrix/dense vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:gaf30f68e0bcb07fb260292fa3850cb1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c61f7e888418a1937aadbc83866c600"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga3c61f7e888418a1937aadbc83866c600">SMP_TDVECSMATMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:ga3c61f7e888418a1937aadbc83866c600"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/row-major sparse matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gaa4c5197743440c3d72fdfab57a1f5ead" title="SMP dense vector/row-major sparse matrix multiplication threshold.This threshold specifies when a den...">blaze::SMP_TDVECSMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a dense vector/row-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga3c61f7e888418a1937aadbc83866c600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb210894bc7cacff77aad28b15ea8291"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gabb210894bc7cacff77aad28b15ea8291">SMP_TDVECTSMATMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:gabb210894bc7cacff77aad28b15ea8291"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/column-major sparse matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga13900f5ff8064908a26df58dbabec7af" title="SMP dense vector/column-major sparse matrix multiplication threshold.This threshold specifies when a ...">blaze::SMP_TDVECTSMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a dense vector/column-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:gabb210894bc7cacff77aad28b15ea8291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ccfc000412fa5140bbfbedb07e10da8"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga5ccfc000412fa5140bbfbedb07e10da8">SMP_SMATSVECMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:ga5ccfc000412fa5140bbfbedb07e10da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major sparse matrix/sparse vector multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga2ff6ecb46d7acb471a809104188dc6a8" title="SMP row-major sparse matrix/sparse vector multiplication threshold.This threshold specifies when a ro...">blaze::SMP_SMATSVECMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major sparse matrix/sparse vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga5ccfc000412fa5140bbfbedb07e10da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ad8aee3c014604937c49bdca1416fcd"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga4ad8aee3c014604937c49bdca1416fcd">SMP_TSMATSVECMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:ga4ad8aee3c014604937c49bdca1416fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major sparse matrix/sparse vector multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga21440047f0acc3e00038693277287f72" title="SMP column-major sparse matrix/sparse vector multiplication threshold.This threshold specifies when a...">blaze::SMP_TSMATSVECMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a column-major sparse matrix/sparse vector multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga4ad8aee3c014604937c49bdca1416fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8bf1a1bda947ab80bbce0fe7fe1d62f"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gae8bf1a1bda947ab80bbce0fe7fe1d62f">SMP_TSVECSMATMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:gae8bf1a1bda947ab80bbce0fe7fe1d62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP sparse vector/row-major sparse matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gaff27198a03e663703c0541b99b594f72" title="SMP sparse vector/row-major sparse matrix multiplication threshold.This threshold specifies when a sp...">blaze::SMP_TSVECSMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a sparse vector/row-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:gae8bf1a1bda947ab80bbce0fe7fe1d62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ce0e03b08d9a9a2e77f56502d63c191"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga9ce0e03b08d9a9a2e77f56502d63c191">SMP_TSVECTSMATMULT_DEBUG_THRESHOLD</a> = 16UL</td></tr>
<tr class="memdesc:ga9ce0e03b08d9a9a2e77f56502d63c191"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP sparse vector/column-major sparse matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gaa7bcd6e785ccd4fef4f4bcea8d77e106" title="SMP sparse vector/column-major sparse matrix multiplication threshold.This threshold specifies when a...">blaze::SMP_TSVECTSMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a sparse vector/column-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target vector is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga9ce0e03b08d9a9a2e77f56502d63c191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75893e2854b9afac96d4b1b379968b21"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga75893e2854b9afac96d4b1b379968b21">SMP_DMATASSIGN_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga75893e2854b9afac96d4b1b379968b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense matrix assignment threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gaa9650a6f21d2ebc4d913c0926bdea4f6" title="SMP dense matrix assignment threshold.This threshold specifies when an assignment with a simple dense...">blaze::SMP_DMATASSIGN_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when an assignment with a simple dense matrix can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga75893e2854b9afac96d4b1b379968b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga993641b8d96359df506bffa5803a37d0"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga993641b8d96359df506bffa5803a37d0">SMP_DMATDMATADD_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga993641b8d96359df506bffa5803a37d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/row-major dense matrix addition threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga90dfb06d424355fe8f33859b0c678289" title="SMP row-major dense matrix/row-major dense matrix addition threshold.This threshold specifies when a ...">blaze::SMP_DMATDMATADD_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major dense matrix/row-major dense matrix addition can be executed in parallel. This threshold affects both additions between two row-major matrices or two column-major dense matrices. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga993641b8d96359df506bffa5803a37d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4431d570f2bc4e169334adab22127615"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga4431d570f2bc4e169334adab22127615">SMP_DMATTDMATADD_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga4431d570f2bc4e169334adab22127615"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/column-major dense matrix addition threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga573494cddff4ccc8c3e81f77b7863903" title="SMP row-major dense matrix/column-major dense matrix addition threshold.This threshold specifies when...">blaze::SMP_DMATTDMATADD_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major dense matrix/column-major dense matrix addition can be executed in parallel. This threshold affects both additions between a row-major matrix and a column-major matrix and a column-major matrix and a row-major matrix. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga4431d570f2bc4e169334adab22127615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62e07c90da091ff019b99fe87046c4ae"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga62e07c90da091ff019b99fe87046c4ae">SMP_DMATDMATSUB_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga62e07c90da091ff019b99fe87046c4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/row-major dense matrix subtraction threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gaec34718abb3acaf0ec643c7c2b13d312" title="SMP row-major dense matrix/row-major dense matrix subtraction threshold.This threshold specifies when...">blaze::SMP_DMATDMATSUB_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major dense matrix/row-major dense matrix subtraction can be executed in parallel. This threshold affects both subtractions between two row-major matrices or two column-major dense matrices. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga62e07c90da091ff019b99fe87046c4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf9e623de6a4ada0bf1be8cbc32727c"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga6bf9e623de6a4ada0bf1be8cbc32727c">SMP_DMATTDMATSUB_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga6bf9e623de6a4ada0bf1be8cbc32727c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/column-major dense matrix subtraction threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga88d18af68a4930dd963843fb7e8f374e" title="SMP row-major dense matrix/column-major dense matrix subtraction threshold.This threshold specifies w...">blaze::SMP_DMATTDMATSUB_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major dense matrix/column-major dense matrix subtraction can be executed in parallel. This threshold affects both subtractions between a row-major matrix and a column-major matrix and a column-major matrix and a row-major matrix. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga6bf9e623de6a4ada0bf1be8cbc32727c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61b63cdc35cf03c2b60071a311fbc8e0"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga61b63cdc35cf03c2b60071a311fbc8e0">SMP_DMATSCALARMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga61b63cdc35cf03c2b60071a311fbc8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense matrix/scalar multiplication/division threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gab1acb6fdf5a74d4a679984462f66cf2a" title="SMP dense matrix/scalar multiplication/division threshold.This threshold specifies when a dense matri...">blaze::SMP_DMATSCALARMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a dense matrix/scalar multiplication or division can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga61b63cdc35cf03c2b60071a311fbc8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f0b002bbb1f51dc15de3f173e27a0c3"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga7f0b002bbb1f51dc15de3f173e27a0c3">SMP_DMATDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga7f0b002bbb1f51dc15de3f173e27a0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/row-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gac8d1576ef69a0eee5c76a303da6aaa02" title="SMP row-major dense matrix/row-major dense matrix multiplication threshold.This threshold specifies w...">blaze::SMP_DMATDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major dense matrix/row-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga7f0b002bbb1f51dc15de3f173e27a0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3841bc1b0b50b5d412a6d22bdca4bac2"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga3841bc1b0b50b5d412a6d22bdca4bac2">SMP_DMATTDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga3841bc1b0b50b5d412a6d22bdca4bac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/column-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gabe302e1d378dea2222f94ac2bf944e2b" title="SMP row-major dense matrix/column-major dense matrix multiplication threshold.This threshold specifie...">blaze::SMP_DMATTDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major dense matrix/column-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga3841bc1b0b50b5d412a6d22bdca4bac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9671ce437893a377dd36de8029e849f9"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga9671ce437893a377dd36de8029e849f9">SMP_TDMATDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga9671ce437893a377dd36de8029e849f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major dense matrix/row-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gaac20340a345af6b11290727c20f93d8a" title="SMP column-major dense matrix/row-major dense matrix multiplication threshold.This threshold specifie...">blaze::SMP_TDMATDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a column-major dense matrix/row-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga9671ce437893a377dd36de8029e849f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab99ca68a101f184495bec7a477757a9b"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gab99ca68a101f184495bec7a477757a9b">SMP_TDMATTDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:gab99ca68a101f184495bec7a477757a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major dense matrix/column-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga71af01643a978ad91d4a96accc7051bc" title="SMP column-major dense matrix/column-major dense matrix multiplication threshold.This threshold speci...">blaze::SMP_TDMATTDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a column-major dense matrix/column-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:gab99ca68a101f184495bec7a477757a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga187bb7695948b5f4304f501ee30e8c78"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga187bb7695948b5f4304f501ee30e8c78">SMP_DMATSMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga187bb7695948b5f4304f501ee30e8c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/row-major sparse matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga9e4e6c980cf4337d2ac71172a6e6f18f" title="SMP row-major dense matrix/row-major sparse matrix multiplication threshold.This threshold specifies ...">blaze::SMP_DMATSMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major dense matrix/row-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga187bb7695948b5f4304f501ee30e8c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf88550f7bf4422cce0a79a08f0db18a8"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaf88550f7bf4422cce0a79a08f0db18a8">SMP_DMATTSMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:gaf88550f7bf4422cce0a79a08f0db18a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major dense matrix/column-major sparse matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga37de0478232998de87e025b6cdec8419" title="SMP row-major dense matrix/column-major sparse matrix multiplication threshold.This threshold specifi...">blaze::SMP_DMATTSMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major dense matrix/column-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:gaf88550f7bf4422cce0a79a08f0db18a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbbc485fb26c18a5ed65d223c5c45084"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gabbbc485fb26c18a5ed65d223c5c45084">SMP_TDMATSMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:gabbbc485fb26c18a5ed65d223c5c45084"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major dense matrix/row-major sparse matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga1c747342c12a0de3cefa229037aa22e2" title="SMP column-major dense matrix/row-major sparse matrix multiplication threshold.This threshold specifi...">blaze::SMP_TDMATSMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a column-major dense matrix/row-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:gabbbc485fb26c18a5ed65d223c5c45084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae8ba9844bab6c3bbfaf2a017d22bf5d"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaae8ba9844bab6c3bbfaf2a017d22bf5d">SMP_TDMATTSMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:gaae8ba9844bab6c3bbfaf2a017d22bf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major dense matrix/column-major sparse matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga7f710faaf4fb96ac8173887b263f4d72" title="SMP column-major dense matrix/column-major sparse matrix multiplication threshold.This threshold specifies when a column-major dense matrix/column-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. If the number of elements is below this threshold the operation is executed single-threaded. ">blaze::SMP_TDMATTSMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a column-major dense matrix/column-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:gaae8ba9844bab6c3bbfaf2a017d22bf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e2c3f0015e5cb37162018488d2d75e"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaa4e2c3f0015e5cb37162018488d2d75e">SMP_SMATDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:gaa4e2c3f0015e5cb37162018488d2d75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major sparse matrix/row-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga4146af68e09bf51383b7874f2102ca53" title="SMP row-major sparse matrix/row-major dense matrix multiplication threshold.This threshold specifies ...">blaze::SMP_SMATDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major sparse matrix/row-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:gaa4e2c3f0015e5cb37162018488d2d75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b52009c96a90bde21e51296914c1f7c"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga1b52009c96a90bde21e51296914c1f7c">SMP_SMATTDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga1b52009c96a90bde21e51296914c1f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major sparse matrix/column-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga146ae0c59f44b78744b57b35feee0b13" title="SMP row-major sparse matrix/column-major dense matrix multiplication threshold.This threshold specifi...">blaze::SMP_SMATTDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major sparse matrix/column-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga1b52009c96a90bde21e51296914c1f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0df0dc174331070219d968089f28e282"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga0df0dc174331070219d968089f28e282">SMP_TSMATDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga0df0dc174331070219d968089f28e282"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major sparse matrix/row-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga336ac103c3a00a2f2a85f81cd8840f12" title="SMP column-major sparse matrix/row-major dense matrix multiplication threshold.This threshold specifi...">blaze::SMP_TSMATDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a column-major sparse matrix/row-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga0df0dc174331070219d968089f28e282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92fa2ff2038c46d384a831e8d89ed112"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga92fa2ff2038c46d384a831e8d89ed112">SMP_TSMATTDMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga92fa2ff2038c46d384a831e8d89ed112"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major sparse matrix/column-major dense matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gab7a724111c87941ad8e56328ba56c7cd" title="SMP column-major sparse matrix/column-major dense matrix multiplication threshold.This threshold specifies when a column-major sparse matrix/column-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. If the number of elements is below this threshold the operation is executed single-threaded. ">blaze::SMP_TSMATTDMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a column-major sparse matrix/column-major dense matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga92fa2ff2038c46d384a831e8d89ed112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23524f4d247de51d09a22a9d54b80146"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga23524f4d247de51d09a22a9d54b80146">SMP_SMATSMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga23524f4d247de51d09a22a9d54b80146"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major sparse matrix/row-major sparse matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga0bb401c4dfa100f272b56afa3b8ddd9c" title="SMP row-major sparse matrix/row-major sparse matrix multiplication threshold.This threshold specifies...">blaze::SMP_SMATSMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major sparse matrix/row-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga23524f4d247de51d09a22a9d54b80146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd846767e2d752c55aa17a7c83de02b"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaedd846767e2d752c55aa17a7c83de02b">SMP_SMATTSMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:gaedd846767e2d752c55aa17a7c83de02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP row-major sparse matrix/column-major sparse matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gabf9443e0a55fb895db5012e4bd540f47" title="SMP row-major sparse matrix/column-major sparse matrix multiplication threshold.This threshold specif...">blaze::SMP_SMATTSMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a row-major sparse matrix/column-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:gaedd846767e2d752c55aa17a7c83de02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1898715ae6493934216ea1561be49e64"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga1898715ae6493934216ea1561be49e64">SMP_TSMATSMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga1898715ae6493934216ea1561be49e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major sparse matrix/row-major sparse matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#ga228fa3a394e6bdd1d87842536452e697" title="SMP column-major sparse matrix/row-major sparse matrix multiplication threshold.This threshold specif...">blaze::SMP_TSMATSMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a column-major sparse matrix/row-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga1898715ae6493934216ea1561be49e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96c258bf502c36d01ea76ccefce97d4c"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga96c258bf502c36d01ea76ccefce97d4c">SMP_TSMATTSMATMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga96c258bf502c36d01ea76ccefce97d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP column-major sparse matrix/column-major sparse matrix multiplication threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gac8264a6f4e310b78a56ffedbf240a1d1" title="SMP column-major sparse matrix/column-major sparse matrix multiplication threshold.This threshold specifies when a column-major sparse matrix/column-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. If the number of elements is below this threshold the operation is executed single-threaded. ">blaze::SMP_TSMATTSMATMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a column-major sparse matrix/column-major sparse matrix multiplication can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga96c258bf502c36d01ea76ccefce97d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0102507a0eae7d0342658c694fdd23df"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga0102507a0eae7d0342658c694fdd23df">SMP_DVECTDVECMULT_DEBUG_THRESHOLD</a> = 256UL</td></tr>
<tr class="memdesc:ga0102507a0eae7d0342658c694fdd23df"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP dense vector/dense vector outer product threshold.This debug value is used instead of the <a class="el" href="../../d1/d44/group__config.html#gae413fb17a0ca57aa1f6171cada20d6c8" title="SMP dense vector/dense vector outer product threshold.This threshold specifies when a dense vector/de...">blaze::SMP_DVECTDVECMULT_USER_THRESHOLD</a> while the Blaze debug mode is active. It specifies when a dense vector/dense vector outer product can be executed in parallel. In case the number of elements of the target matrix is larger or equal to this threshold, the operation is executed in parallel. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the number of elements is below this threshold the operation is executed single-threaded. <br /></td></tr>
<tr class="separator:ga0102507a0eae7d0342658c694fdd23df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:a8746f87c85b6e007b2a6d4f66310de11"><td class="memItemLeft" align="right" valign="top"><a id="a8746f87c85b6e007b2a6d4f66310de11"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a8746f87c85b6e007b2a6d4f66310de11">m_</a></td></tr>
<tr class="memdesc:a8746f87c85b6e007b2a6d4f66310de11"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current number of rows of the sparse matrix. <br /></td></tr>
<tr class="separator:a8746f87c85b6e007b2a6d4f66310de11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecdea3aadfd7fe58f677bf7fb0ec389"><td class="memItemLeft" align="right" valign="top"><a id="a0ecdea3aadfd7fe58f677bf7fb0ec389"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a0ecdea3aadfd7fe58f677bf7fb0ec389">n_</a></td></tr>
<tr class="memdesc:a0ecdea3aadfd7fe58f677bf7fb0ec389"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current number of columns of the sparse matrix. <br /></td></tr>
<tr class="separator:a0ecdea3aadfd7fe58f677bf7fb0ec389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58381da08591c9e54a0f9563595c8acf"><td class="memItemLeft" align="right" valign="top"><a id="a58381da08591c9e54a0f9563595c8acf"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a58381da08591c9e54a0f9563595c8acf">capacity_</a></td></tr>
<tr class="memdesc:a58381da08591c9e54a0f9563595c8acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current capacity of the pointer array. <br /></td></tr>
<tr class="separator:a58381da08591c9e54a0f9563595c8acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3dac851e11b9fdc01526f7c4b5cee3"><td class="memItemLeft" align="right" valign="top"><a id="a8b3dac851e11b9fdc01526f7c4b5cee3"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a8b3dac851e11b9fdc01526f7c4b5cee3">begin_</a></td></tr>
<tr class="memdesc:a8b3dac851e11b9fdc01526f7c4b5cee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointers to the first non-zero element of each column. <br /></td></tr>
<tr class="separator:a8b3dac851e11b9fdc01526f7c4b5cee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac079c072108ef771a98cb5210278fb84"><td class="memItemLeft" align="right" valign="top"><a id="ac079c072108ef771a98cb5210278fb84"></a>
<a class="el" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">Iterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ac079c072108ef771a98cb5210278fb84">end_</a></td></tr>
<tr class="memdesc:ac079c072108ef771a98cb5210278fb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointers one past the last non-zero element of each column. <br /></td></tr>
<tr class="separator:ac079c072108ef771a98cb5210278fb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f679c038f75611332258e305f45e24"><td class="memItemLeft" align="right" valign="top"><a id="a03f679c038f75611332258e305f45e24"></a>
static const Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a03f679c038f75611332258e305f45e24">zero_</a></td></tr>
<tr class="memdesc:a03f679c038f75611332258e305f45e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neutral element for accesses to zero elements. <br /></td></tr>
<tr class="separator:a03f679c038f75611332258e305f45e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace of the <b>Blaze</b> C++ math library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aa66bdb6fd80a82c4f231125a9b7e8820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66bdb6fd80a82c4f231125a9b7e8820">&sect;&nbsp;</a></span>BaseType_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#aa66bdb6fd80a82c4f231125a9b7e8820">blaze::BaseType_</a> = typedef typename T::BaseType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>BaseType</code> type definitions.The BaseType_ alias declaration provides a convenient shortcut to access the nested <em>BaseType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> <a class="code" href="../../d2/de9/namespaceblaze.html#ada7c5527ae2ac48cfdb3de233d5a46a6">T::BaseType</a>;</div><div class="line"><span class="keyword">using</span> Type2 = BaseType_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="acf0851f216dd228db447fbf55718e18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0851f216dd228db447fbf55718e18c">&sect;&nbsp;</a></span>CompositeType_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#acf0851f216dd228db447fbf55718e18c">blaze::CompositeType_</a> = typedef typename T::CompositeType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>CompositeType</code> type definitions.The CompositeType_ alias declaration provides a convenient shortcut to access the nested <em>CompositeType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a65f17a6068c222e5986b1fd69f34bd78">T::CompositeType</a>;</div><div class="line"><span class="keyword">using</span> Type2 = CompositeType_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="aa1d864b56dde1649490ccd585cb20508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d864b56dde1649490ccd585cb20508">&sect;&nbsp;</a></span>ConstIterator_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#aa1d864b56dde1649490ccd585cb20508">blaze::ConstIterator_</a> = typedef typename T::ConstIterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>ConstIterator</code> type definitions.The ConstIterator_ alias declaration provides a convenient shortcut to access the nested <em>ConstIterator</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">T::ConstIterator</a>;</div><div class="line"><span class="keyword">using</span> Type2 = ConstIterator_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="afe86491b935b63fcc07559cd23830314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe86491b935b63fcc07559cd23830314">&sect;&nbsp;</a></span>ConstPointer_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#afe86491b935b63fcc07559cd23830314">blaze::ConstPointer_</a> = typedef typename T::ConstPointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>ConstPointer</code> type definitions.The ConstPointer_ alias declaration provides a convenient shortcut to access the nested <em>ConstPointer</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> T::ConstPointer;</div><div class="line"><span class="keyword">using</span> Type2 = ConstPointer_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="a7428fec1f7754658bd4d765ed6e87841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7428fec1f7754658bd4d765ed6e87841">&sect;&nbsp;</a></span>ConstReference_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#a7428fec1f7754658bd4d765ed6e87841">blaze::ConstReference_</a> = typedef typename T::ConstReference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>ConstReference</code> type definitions.The ConstReference_ alias declaration provides a convenient shortcut to access the nested <em>ConstReference</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a72b07ee0a0ca85061e6a3d8306e092a7">T::ConstReference</a>;</div><div class="line"><span class="keyword">using</span> Type2 = ConstReference_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="a9d478221c22767e2ab79fe64681a744b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d478221c22767e2ab79fe64681a744b">&sect;&nbsp;</a></span>ElementType_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">blaze::ElementType_</a> = typedef typename T::ElementType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>ElementType</code> type definitions.The ElementType_ alias declaration provides a convenient shortcut to access the nested <em>ElementType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> <a class="code" href="../../d2/de9/namespaceblaze.html#ae1b4e9cc4b409c6fc6cac71e78f0d0f9">T::ElementType</a>;</div><div class="line"><span class="keyword">using</span> Type2 = ElementType_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="a55cefc4108da9a311933047654da11b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cefc4108da9a311933047654da11b1">&sect;&nbsp;</a></span>Iterator_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#a55cefc4108da9a311933047654da11b1">blaze::Iterator_</a> = typedef typename T::Iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>Iterator</code> type definitions.The Iterator_ alias declaration provides a convenient shortcut to access the nested <em>Iterator</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">T::Iterator</a>;</div><div class="line"><span class="keyword">using</span> Type2 = Iterator_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="a79d0b1baafdb999e088b9cb10b7346d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d0b1baafdb999e088b9cb10b7346d9">&sect;&nbsp;</a></span>LeftOperand_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#a79d0b1baafdb999e088b9cb10b7346d9">blaze::LeftOperand_</a> = typedef typename T::LeftOperand</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>LeftOperand</code> type definitions.The LeftOperand_ alias declaration provides a convenient shortcut to access the nested <em>LeftOperand</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> T::LeftOperand;</div><div class="line"><span class="keyword">using</span> Type2 = LeftOperand_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="a8aedbbd636a9bb4c0c5b633710f861e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aedbbd636a9bb4c0c5b633710f861e7">&sect;&nbsp;</a></span>Operand_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#a8aedbbd636a9bb4c0c5b633710f861e7">blaze::Operand_</a> = typedef typename T::Operand</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>Operand</code> type definitions.The Operand_ alias declaration provides a convenient shortcut to access the nested <em>Operand</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> T::Operand;</div><div class="line"><span class="keyword">using</span> Type2 = Operand_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="ad282ad15aa380c05ce262000a81e6d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad282ad15aa380c05ce262000a81e6d81">&sect;&nbsp;</a></span>OppositeType_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#ad282ad15aa380c05ce262000a81e6d81">blaze::OppositeType_</a> = typedef typename T::OppositeType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>OppositeType</code> type definitions.The OppositeType_ alias declaration provides a convenient shortcut to access the nested <em>OppositeType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a72be1239ba1aeee2cfb0111420725425">T::OppositeType</a>;</div><div class="line"><span class="keyword">using</span> Type2 = OppositeType_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="a52d7e49942dc7ea47dc5289b3f43c35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d7e49942dc7ea47dc5289b3f43c35b">&sect;&nbsp;</a></span>Pointer_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#a52d7e49942dc7ea47dc5289b3f43c35b">blaze::Pointer_</a> = typedef typename T::Pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>Pointer</code> type definitions.The Pointer_ alias declaration provides a convenient shortcut to access the nested <em>Pointer</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> T::Pointer;</div><div class="line"><span class="keyword">using</span> Type2 = Pointer_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="a1285adb17e7a11f3dee9b2b0f03f8a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1285adb17e7a11f3dee9b2b0f03f8a89">&sect;&nbsp;</a></span>Reference_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#a1285adb17e7a11f3dee9b2b0f03f8a89">blaze::Reference_</a> = typedef typename T::Reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>Reference</code> type definitions.The Reference_ alias declaration provides a convenient shortcut to access the nested <em>Reference</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a18a879317ffe7c431aba1333d2eacaab">T::Reference</a>;</div><div class="line"><span class="keyword">using</span> Type2 = Reference_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="ae10b120fdcec644d7b612ec666aeebde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10b120fdcec644d7b612ec666aeebde">&sect;&nbsp;</a></span>RepresentedType_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#ae10b120fdcec644d7b612ec666aeebde">blaze::RepresentedType_</a> = typedef typename T::RepresentedType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>RepresentedType</code> type definitions.The RepresentedType_ alias declaration provides a convenient shortcut to access the nested <em>RepresentedType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> T::RepresentedType;</div><div class="line"><span class="keyword">using</span> Type2 = RepresentedType_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="a5a86db58851c76c3500769d8afdc759e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a86db58851c76c3500769d8afdc759e">&sect;&nbsp;</a></span>ResultType_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#a5a86db58851c76c3500769d8afdc759e">blaze::ResultType_</a> = typedef typename T::ResultType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>ResultType</code> type definitions.The ResultType_ alias declaration provides a convenient shortcut to access the nested <em>ResultType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> <a class="code" href="../../d2/de9/namespaceblaze.html#ab880bcfe14bd3b7e561200b678e5f28b">T::ResultType</a>;</div><div class="line"><span class="keyword">using</span> Type2 = ResultType_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="aa2e2edcdde49d73a7ca7d2515046b088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e2edcdde49d73a7ca7d2515046b088">&sect;&nbsp;</a></span>ReturnType_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#aa2e2edcdde49d73a7ca7d2515046b088">blaze::ReturnType_</a> = typedef typename T::ReturnType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>ReturnType</code> type definitions.The ReturnType_ alias declaration provides a convenient shortcut to access the nested <em>ReturnType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> <a class="code" href="../../d2/de9/namespaceblaze.html#ae6f92fc9fe8248ba74d39f106f08e1b7">T::ReturnType</a>;</div><div class="line"><span class="keyword">using</span> Type2 = ReturnType_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="a494d63c91ad9b77468f45f852098c5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494d63c91ad9b77468f45f852098c5e7">&sect;&nbsp;</a></span>RightOperand_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#a494d63c91ad9b77468f45f852098c5e7">blaze::RightOperand_</a> = typedef typename T::RightOperand</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>RightOperand</code> type definitions.The RightOperand_ alias declaration provides a convenient shortcut to access the nested <em>RightOperand</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> T::RightOperand;</div><div class="line"><span class="keyword">using</span> Type2 = RightOperand_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="acae826b6abc142b9ae2a5b4ca14cc679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae826b6abc142b9ae2a5b4ca14cc679">&sect;&nbsp;</a></span>SIMDType_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#acae826b6abc142b9ae2a5b4ca14cc679">blaze::SIMDType_</a> = typedef typename T::SIMDType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>SIMDType</code> type definitions.The SIMDType_ alias declaration provides a convenient shortcut to access the nested <em>SIMDType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> T::SIMDType;</div><div class="line"><span class="keyword">using</span> Type2 = SIMDType_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="aca0f2ff41fa8f2a1a6ff10fe09817cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0f2ff41fa8f2a1a6ff10fe09817cd8">&sect;&nbsp;</a></span>TransposeType_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#aca0f2ff41fa8f2a1a6ff10fe09817cd8">blaze::TransposeType_</a> = typedef typename T::TransposeType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>TransposeType</code> type definitions.The TransposeType_ alias declaration provides a convenient shortcut to access the nested <em>TransposeType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a2fc33d53e646d54b24573e3b1212025f">T::TransposeType</a>;</div><div class="line"><span class="keyword">using</span> Type2 = TransposeType_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="a43526a90acc81e127cc2e3242087e82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43526a90acc81e127cc2e3242087e82e">&sect;&nbsp;</a></span>ValueType_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/de9/namespaceblaze.html#a43526a90acc81e127cc2e3242087e82e">blaze::ValueType_</a> = typedef typename T::ValueType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for nested <code>ValueType</code> type definitions.The ValueType_ alias declaration provides a convenient shortcut to access the nested <em>ValueType</em> type definition of the given type <em>T</em>. The following code example shows both ways to access the nested type definition: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> T::ValueType;</div><div class="line"><span class="keyword">using</span> Type2 = ValueType_&lt;T&gt;;</div><div class="line"></div><div class="line"><a class="code" href="../../db/d68/group__constraints.html#gad3ed5b4cdf45d3573782bf645c769d32">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_SAME_TYPE</a>( Type1, Type2 );</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa80ba51df1c16662de4f801aef22974f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80ba51df1c16662de4f801aef22974f">&sect;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compilation flag for SMP assignments. </p>
<p>The <em>smpAssignable</em> compilation flag indicates whether the matrix can be used in SMP (shared memory parallel) assignments (both on the left-hand and right-hand side of the assignment). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf1a0f267ad32bb5a074fa67bba6cb698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1a0f267ad32bb5a074fa67bba6cb698">&sect;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt;T&gt;, T* &gt; blaze::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned array allocation for user-specific class types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of elements of the given type to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first element of the aligned array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Allocation failed.</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698" title="Aligned array allocation for built-in data types. ">allocate()</a> function provides the functionality to allocate memory based on the alignment restrictions of the given user-specific class type. For instance, in case the given type has the requirement to be 32-byte aligned, the returned pointer is guaranteed to be 32-byte aligned. Additionally, all elements of the array are guaranteed to be default constructed. Note that the <a class="el" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698" title="Aligned array allocation for built-in data types. ">allocate()</a> function provides exception safety similar to the new operator: In case any element throws an exception during construction, all elements that have already been constructed are destroyed in reverse order and the allocated memory is deallocated again. </p>

</div>
</div>
<a id="gacba35bf708a4ea62cdca2a4a18a24c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacba35bf708a4ea62cdca2a4a18a24c4b">&sect;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt;T&gt; &gt; blaze::deallocate </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocation of memory for user-specific class types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the first element of the array to be deallocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function deallocates the given memory that was previously allocated via the <a class="el" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698" title="Aligned array allocation for built-in data types. ">allocate()</a> function. </p>

</div>
</div>
<a id="ga4d22caf00780add553e8ef31199bbc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d22caf00780add553e8ef31199bbc6d">&sect;&nbsp;</a></span>decldiag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT&gt;, const MT&amp; &gt; blaze::decldiag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redeclares the given diagonal sparse matrix expression <em>sm</em> as diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix.</dd></dl>
<p>The <em>decldiag</em> function redeclares the given diagonal sparse matrix expression <em>sm</em> as diagonal. The function returns a reference to the already diagonal matrix expression. </p>

</div>
</div>
<a id="ga69a9b7ca9d7f7eb53ed37ddd2ee43874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69a9b7ca9d7f7eb53ed37ddd2ee43874">&sect;&nbsp;</a></span>decldiag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT&gt;, const MT&amp; &gt; blaze::decldiag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redeclares the given diagonal dense matrix expression <em>dm</em> as diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared dense matrix.</dd></dl>
<p>The <em>decldiag</em> function redeclares the given diagonal dense matrix expression <em>dm</em> as diagonal. The function returns a reference to the already diagonal matrix expression. </p>

</div>
</div>
<a id="ga648c564eb671f51f21076710551b20f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga648c564eb671f51f21076710551b20f4">&sect;&nbsp;</a></span>declherm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d6/daf/structblaze_1_1IsHermitian.html">IsHermitian</a>&lt;MT&gt;, const MT&amp; &gt; blaze::declherm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redeclares the given Hermitian sparse matrix expression <em>sm</em> as Hermitian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix.</dd></dl>
<p>The <em>declherm</em> function redeclares the given Hermitian sparse matrix expression <em>sm</em> as Hermitian. The function returns a reference to the already Hermitian matrix expression. </p>

</div>
</div>
<a id="ga7d1c7499ea0f5524b537273a98f3c09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d1c7499ea0f5524b537273a98f3c09c">&sect;&nbsp;</a></span>declherm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d6/daf/structblaze_1_1IsHermitian.html">IsHermitian</a>&lt;MT&gt;, const MT&amp; &gt; blaze::declherm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redeclares the given Hermitian dense matrix expression <em>dm</em> as Hermitian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared dense matrix.</dd></dl>
<p>The <em>declherm</em> function redeclares the given Hermitian dense matrix expression <em>dm</em> as Hermitian. The function returns a reference to the already Hermitian matrix expression. </p>

</div>
</div>
<a id="gaae87fc98150845d427d4f991b02e29d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae87fc98150845d427d4f991b02e29d6">&sect;&nbsp;</a></span>decllow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT&gt;, const MT&amp; &gt; blaze::decllow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redeclares the given lower sparse matrix expression <em>sm</em> as lower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix.</dd></dl>
<p>The <em>decllow</em> function redeclares the given lower sparse matrix expression <em>sm</em> as lower. The function returns a reference to the already lower matrix expression. </p>

</div>
</div>
<a id="gab7f9f220af2ef0545f54ff4b5c34b139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7f9f220af2ef0545f54ff4b5c34b139">&sect;&nbsp;</a></span>decllow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT&gt;, const MT&amp; &gt; blaze::decllow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redeclares the given lower dense matrix expression <em>dm</em> as lower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared dense matrix.</dd></dl>
<p>The <em>decllow</em> function redeclares the given lower dense matrix expression <em>dm</em> as lower. The function returns a reference to the already lower matrix expression. </p>

</div>
</div>
<a id="gae57991e440a9182c47df1bdb5a7b3777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae57991e440a9182c47df1bdb5a7b3777">&sect;&nbsp;</a></span>declsym() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;MT&gt;, const MT&amp; &gt; blaze::declsym </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redeclares the given symmetric sparse matrix expression <em>sm</em> as symmetric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix.</dd></dl>
<p>The <em>declsym</em> function redeclares the given symmetric sparse matrix expression <em>sm</em> as symmetric. The function returns a reference to the already symmetric matrix expression. </p>

</div>
</div>
<a id="ga8e0db5d90417a72a963f8dcbf3e3b6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e0db5d90417a72a963f8dcbf3e3b6a2">&sect;&nbsp;</a></span>declsym() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;MT&gt;, const MT&amp; &gt; blaze::declsym </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redeclares the given symmetric dense matrix expression <em>dm</em> as symmetric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared dense matrix.</dd></dl>
<p>The <em>declsym</em> function redeclares the given symmetric dense matrix expression <em>dm</em> as symmetric. The function returns a reference to the already symmetric matrix expression. </p>

</div>
</div>
<a id="gaf2bcedc4df50276d86ae996d5e14db46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2bcedc4df50276d86ae996d5e14db46">&sect;&nbsp;</a></span>declupp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT&gt;, const MT&amp; &gt; blaze::declupp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redeclares the given upper sparse matrix expression <em>sm</em> as upper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix.</dd></dl>
<p>The <em>declupp</em> function redeclares the given upper sparse matrix expression <em>sm</em> as upper. The function returns a reference to the already upper matrix expression. </p>

</div>
</div>
<a id="ga8ebe177b75c6ea9edbd850b65591df1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ebe177b75c6ea9edbd850b65591df1f">&sect;&nbsp;</a></span>declupp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT&gt;, const MT&amp; &gt; blaze::declupp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redeclares the given upper dense matrix expression <em>dm</em> as upper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared dense matrix.</dd></dl>
<p>The <em>declupp</em> function redeclares the given upper dense matrix expression <em>dm</em> as upper. The function returns a reference to the already upper matrix expression. </p>

</div>
</div>
<a id="ac67f16ca20411912924171d84ee37413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67f16ca20411912924171d84ee37413">&sect;&nbsp;</a></span>deserialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::deserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d14/classblaze_1_1Archive.html">Archive</a> &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes a vector from the given archive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">archive</td><td>The archive to be read from. </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to be deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> could not be deserialized.</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="../../d2/de9/namespaceblaze.html#a9963c898337ff56c101fac8a1997513f" title="Deserializes a matrix from the given archive. ">deserialize()</a> function converts the portable, binary representation contained in the given archive into the given vector type. For a detailed example that demonstrates the (de-)serialization process of vectors, see the <a class="el" href="../../d2/de9/namespaceblaze.html#a3eb8155b9a2cd60299756402c877e598" title="Serializes the given matrix and writes it to the archive. ">serialize()</a> function. </p>

</div>
</div>
<a id="a9963c898337ff56c101fac8a1997513f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9963c898337ff56c101fac8a1997513f">&sect;&nbsp;</a></span>deserialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::deserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d14/classblaze_1_1Archive.html">Archive</a> &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes a matrix from the given archive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">archive</td><td>The archive to be read from. </td></tr>
    <tr><td class="paramname">mat</td><td>The matrix to be deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> could not be deserialized.</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="../../d2/de9/namespaceblaze.html#a9963c898337ff56c101fac8a1997513f" title="Deserializes a matrix from the given archive. ">deserialize()</a> function converts the portable, binary representation contained in the given archive into the given matrix type. For a detailed example that demonstrates the (de-)serialization process of matrices, see the <a class="el" href="../../d2/de9/namespaceblaze.html#a3eb8155b9a2cd60299756402c877e598" title="Serializes the given matrix and writes it to the archive. ">serialize()</a> function. </p>

</div>
</div>
<a id="gac4a4f91650b74b5a9e9f75644de855a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4a4f91650b74b5a9e9f75644de855a9">&sect;&nbsp;</a></span>loada() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,2UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDint16, SIMDuint16 &gt; &gt; blaze::loada </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector of 2-byte integral values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The first integral value to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded vector of integral values.</dd></dl>
<p>This function loads a vector of 2-byte integral values. The given address must be aligned according to the enabled instruction set (16-byte alignment in case of SSE, 32-byte alignment in case of AVX, and 64-byte alignment in case of MIC). </p>

</div>
</div>
<a id="ga404fa5fb3449f8075ac59e90b82c4008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga404fa5fb3449f8075ac59e90b82c4008">&sect;&nbsp;</a></span>loada() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,2UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDcint16, SIMDcuint16 &gt; &gt; blaze::loada </td>
          <td>(</td>
          <td class="paramtype">const complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector of 2-byte integral complex values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The first integral complex value to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded vector of integral complex values.</dd></dl>
<p>This function loads a vector of 2-byte integral complex values. The given address must be aligned according to the enabled instruction set (16-byte alignment in case of SSE, 32-byte alignment in case of AVX, and 64-byte alignment in case of MIC). </p>

</div>
</div>
<a id="gac4a4f91650b74b5a9e9f75644de855a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4a4f91650b74b5a9e9f75644de855a9">&sect;&nbsp;</a></span>loada() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,4UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDint32, SIMDuint32 &gt; &gt; blaze::loada </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector of 4-byte integral values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The first integral value to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded vector of integral values.</dd></dl>
<p>This function loads a vector of 4-byte integral values. The given address must be aligned according to the enabled instruction set (16-byte alignment in case of SSE, 32-byte alignment in case of AVX, and 64-byte alignment in case of MIC). </p>

</div>
</div>
<a id="ga404fa5fb3449f8075ac59e90b82c4008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga404fa5fb3449f8075ac59e90b82c4008">&sect;&nbsp;</a></span>loada() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,4UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDcint32, SIMDcuint32 &gt; &gt; blaze::loada </td>
          <td>(</td>
          <td class="paramtype">const complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector of 4-byte integral complex values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The first integral complex value to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded vector of integral complex values.</dd></dl>
<p>This function loads a vector of 4-byte integral complex values. The given address must be aligned according to the enabled instruction set (16-byte alignment in case of SSE, 32-byte alignment in case of AVX, and 64-byte alignment in case of MIC). </p>

</div>
</div>
<a id="gac4a4f91650b74b5a9e9f75644de855a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4a4f91650b74b5a9e9f75644de855a9">&sect;&nbsp;</a></span>loada() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,8UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDint64, SIMDuint64 &gt; &gt; blaze::loada </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector of 8-byte integral values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The first integral value to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded vector of integral values.</dd></dl>
<p>This function loads a vector of 8-byte integral values. The given address must be aligned according to the enabled instruction set (16-byte alignment in case of SSE, 32-byte alignment in case of AVX, and 64-byte alignment in case of MIC). </p>

</div>
</div>
<a id="ga404fa5fb3449f8075ac59e90b82c4008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga404fa5fb3449f8075ac59e90b82c4008">&sect;&nbsp;</a></span>loada() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,8UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDcint64, SIMDcuint64 &gt; &gt; blaze::loada </td>
          <td>(</td>
          <td class="paramtype">const complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector of 8-byte integral complex values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The first integral complex value to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded vector of integral complex values.</dd></dl>
<p>This function loads a vector of 8-byte integral complex values. The given address must be aligned according to the enabled instruction set (16-byte alignment in case of SSE, 32-byte alignment in case of AVX, and 64-byte alignment in case of MIC). </p>

</div>
</div>
<a id="ga5f63e61aa59bef1a8fdb4d001c5f8308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f63e61aa59bef1a8fdb4d001c5f8308">&sect;&nbsp;</a></span>loadu() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,2UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDint16, SIMDuint16 &gt; &gt; blaze::loadu </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector of 2-byte integral values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The first integral value to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded vector of integral values.</dd></dl>
<p>This function loads a vector of 2-byte integral values. In contrast to the according <code><a class="el" href="../../dc/d7b/group__simd.html#gac4a4f91650b74b5a9e9f75644de855a9" title="Loads a vector of 1-byte integral values. ">loada()</a></code> function, the given address is not required to be properly aligned. </p>

</div>
</div>
<a id="gac8da21dcf40da70f6a44976dfeccda5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8da21dcf40da70f6a44976dfeccda5d">&sect;&nbsp;</a></span>loadu() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,2UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDcint16, SIMDcuint16 &gt; &gt; blaze::loadu </td>
          <td>(</td>
          <td class="paramtype">const complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector of 2-byte integral complex values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The first integral complex value to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded vector of integral complex values.</dd></dl>
<p>This function loads a vector of 2-byte integral complex values. In contrast to the according <code><a class="el" href="../../dc/d7b/group__simd.html#gac4a4f91650b74b5a9e9f75644de855a9" title="Loads a vector of 1-byte integral values. ">loada()</a></code> function, the given address is not required to be properly aligned. </p>

</div>
</div>
<a id="ga5f63e61aa59bef1a8fdb4d001c5f8308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f63e61aa59bef1a8fdb4d001c5f8308">&sect;&nbsp;</a></span>loadu() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,4UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDint32, SIMDuint32 &gt; &gt; blaze::loadu </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector of 4-byte integral values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The first integral value to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded vector of integral values.</dd></dl>
<p>This function loads a vector of 4-byte integral values. In contrast to the according <code><a class="el" href="../../dc/d7b/group__simd.html#gac4a4f91650b74b5a9e9f75644de855a9" title="Loads a vector of 1-byte integral values. ">loada()</a></code> function, the given address is not required to be properly aligned. </p>

</div>
</div>
<a id="gac8da21dcf40da70f6a44976dfeccda5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8da21dcf40da70f6a44976dfeccda5d">&sect;&nbsp;</a></span>loadu() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,4UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDcint32, SIMDcuint32 &gt; &gt; blaze::loadu </td>
          <td>(</td>
          <td class="paramtype">const complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector of 4-byte integral complex values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The first integral complex value to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded vector of integral complex values.</dd></dl>
<p>This function loads a vector of 4-byte integral complex values. In contrast to the according <code><a class="el" href="../../dc/d7b/group__simd.html#gac4a4f91650b74b5a9e9f75644de855a9" title="Loads a vector of 1-byte integral values. ">loada()</a></code> function, the given address is not required to be properly aligned. </p>

</div>
</div>
<a id="ga5f63e61aa59bef1a8fdb4d001c5f8308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f63e61aa59bef1a8fdb4d001c5f8308">&sect;&nbsp;</a></span>loadu() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,8UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDint64, SIMDuint64 &gt; &gt; blaze::loadu </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector of 8-byte integral values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The first integral value to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded vector of integral values.</dd></dl>
<p>This function loads a vector of 8-byte integral values. In contrast to the according <code><a class="el" href="../../dc/d7b/group__simd.html#gac4a4f91650b74b5a9e9f75644de855a9" title="Loads a vector of 1-byte integral values. ">loada()</a></code> function, the given address is not required to be properly aligned. </p>

</div>
</div>
<a id="gac8da21dcf40da70f6a44976dfeccda5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8da21dcf40da70f6a44976dfeccda5d">&sect;&nbsp;</a></span>loadu() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,8UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDcint64, SIMDcuint64 &gt; &gt; blaze::loadu </td>
          <td>(</td>
          <td class="paramtype">const complex&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector of 8-byte integral complex values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The first integral complex value to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded vector of integral complex values.</dd></dl>
<p>This function loads a vector of 8-byte integral complex values. In contrast to the according <code><a class="el" href="../../dc/d7b/group__simd.html#gac4a4f91650b74b5a9e9f75644de855a9" title="Loads a vector of 1-byte integral values. ">loada()</a></code> function, the given address is not required to be properly aligned. </p>

</div>
</div>
<a id="a455459c9ffcc5dc1f4c2a9f46597c9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455459c9ffcc5dc1f4c2a9f46597c9c7">&sect;&nbsp;</a></span>normalize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d7/dc2/classblaze_1_1SVecScalarMultExpr.html">SVecScalarMultExpr</a>&lt;VT,<a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt;VT&gt;,TF&gt; blaze::normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalization of the sparse vector ( <img class="formulaInl" alt="$|\vec{a}|=1$" src="../../form_112.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The given sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized result vector.</dd></dl>
<p>This function represents the normalization of a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">a = <a class="code" href="../../d2/de9/namespaceblaze.html#a6f2668e5cb0df05ba8a40057211bcc67">normalize</a>( a );</div></div><!-- fragment --><p>The function returns an expression representing the normalized sparse vector. Note that this function only works for floating point vectors. The attempt to use this function for an integral vector results in a compile time error. </p>

</div>
</div>
<a id="a6f2668e5cb0df05ba8a40057211bcc67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2668e5cb0df05ba8a40057211bcc67">&sect;&nbsp;</a></span>normalize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../df/de8/classblaze_1_1DVecScalarMultExpr.html">DVecScalarMultExpr</a>&lt;VT,<a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt;VT&gt;,TF&gt; blaze::normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalization of the dense vector ( <img class="formulaInl" alt="$|\vec{a}|=1$" src="../../form_112.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The given dense vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized result vector.</dd></dl>
<p>This function represents the normalization of a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">a = <a class="code" href="../../d2/de9/namespaceblaze.html#a6f2668e5cb0df05ba8a40057211bcc67">normalize</a>( a );</div></div><!-- fragment --><p>The function returns an expression representing the normalized dense vector. Note that this function only works for floating point vectors. The attempt to use this function for an integral vector results in a compile time error. </p>

</div>
</div>
<a id="a0b94802b1621abe72010aa92b1c323a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b94802b1621abe72010aa92b1c323a3">&sect;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two values are not equal, <em>true</em> if they are equal. </dd></dl>

</div>
</div>
<a id="ac21213984e62323440a6c3145ae22101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21213984e62323440a6c3145ae22101">&sect;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html" title="Allocator for type-specific aligned memory.The AlignedAllocator class template represents an implemen...">AlignedAllocator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side aligned allocator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side aligned allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>false</em>. </dd></dl>

</div>
</div>
<a id="aac8a3e3b7fb672689907927512c04839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8a3e3b7fb672689907927512c04839">&sect;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeL , typename TypeR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side pointer iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side pointer iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the iterators don't point to the same element, <em>false</em> if they do. </dd></dl>

</div>
</div>
<a id="ab8a3af293c57b38ce351c31dd3d34b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a3af293c57b38ce351c31dd3d34b6c">&sect;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool AF1, typename T2 , bool AF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T1, AF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T2, AF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the iterators don't refer to the same element, <em>false</em> if they do. </dd></dl>

</div>
</div>
<a id="a9c24212630a6f1d6597740647e3413eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c24212630a6f1d6597740647e3413eb">&sect;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two pointer vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side pointer vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side pointer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two pointer vectors are inequal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a id="ga1953db9322377dfe0a9d07808968d9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1953db9322377dfe0a9d07808968d9d2">&sect;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; TDVecDVecMultExprHelper&lt;T1,T2&gt; , const <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">MultTrait_</a>&lt; <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt;T1&gt;, <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt;T2&gt; &gt; &gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD optimized multiplication operator for the scalar product (inner product) of two dense vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_119.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of two dense vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> a, b;</div><div class="line">blaze::double res;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">res = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>(a) * b;</div></div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="acc4bc8412b1132b17be23b06833cadc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4bc8412b1132b17be23b06833cadc2">&sect;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt; &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d8c/classblaze_1_1ptrdiff__t.html">ptrdiff_t</a>&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition between a <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> and an integral value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator to be incremented. </td></tr>
    <tr><td class="paramname">inc</td><td>The number of elements the iterator is incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incremented iterator. </dd></dl>

</div>
</div>
<a id="a3ea90488b629d69d4511711e24f23ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea90488b629d69d4511711e24f23ba7">&sect;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d8c/classblaze_1_1ptrdiff__t.html">ptrdiff_t</a>&#160;</td>
          <td class="paramname"><em>inc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt; &amp;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition between an integral value and a <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inc</td><td>The number of elements the iterator is incremented. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incremented iterator. </dd></dl>

</div>
</div>
<a id="ad8032b6bc6514096c8edb2f3a731cea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8032b6bc6514096c8edb2f3a731cea0">&sect;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt; &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d8c/classblaze_1_1ptrdiff__t.html">ptrdiff_t</a>&#160;</td>
          <td class="paramname"><em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction between a <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> and an integral value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator to be decremented. </td></tr>
    <tr><td class="paramname">dec</td><td>The number of elements the iterator is decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decremented iterator. </dd></dl>

</div>
</div>
<a id="a46b2c6f50fef6e812d34a712843d2a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b2c6f50fef6e812d34a712843d2a43">&sect;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d8c/classblaze_1_1ptrdiff__t.html">ptrdiff_t</a> blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculating the number of elements between two <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements between the two iterators. </dd></dl>

</div>
</div>
<a id="ad17b6ccf3e72a2176b217b977c8e0981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17b6ccf3e72a2176b217b977c8e0981">&sect;&nbsp;</a></span>operator<() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left value is less than the right value, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="aaf608ae97f0284e56745139e110ea699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf608ae97f0284e56745139e110ea699">&sect;&nbsp;</a></span>operator<() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeL , typename TypeR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side pointer iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side pointer iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side iterator points to a lower element, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="a8e054b943082e9dc5e339b0254f9800e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e054b943082e9dc5e339b0254f9800e">&sect;&nbsp;</a></span>operator<() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool AF1, typename T2 , bool AF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T1, AF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T2, AF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between two <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side iterator is smaller, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="a8d629135d4db89e1fcdcfd4b8f7c347e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d629135d4db89e1fcdcfd4b8f7c347e">&sect;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; blaze::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>uv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global output operator for the <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Reference to the output stream. </td></tr>
    <tr><td class="paramname">uv</td><td>Reference to a <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

</div>
</div>
<a id="a602483ca8c570c315b235511663102eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602483ca8c570c315b235511663102eb">&sect;&nbsp;</a></span>operator<=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left value is less or equal than the right value, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="a5a38d325a718086ca9868451731c8e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a38d325a718086ca9868451731c8e1a">&sect;&nbsp;</a></span>operator<=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than or equal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ad64366d49a029dfec828c27e0656858c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64366d49a029dfec828c27e0656858c">&sect;&nbsp;</a></span>operator<=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than or equal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="a7c62512759a851e43c57bffe569e23da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c62512759a851e43c57bffe569e23da">&sect;&nbsp;</a></span>operator<=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than or equal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ad758ad59687b87663c017fe19eee961c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad758ad59687b87663c017fe19eee961c">&sect;&nbsp;</a></span>operator<=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than or equal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="a7399c56304153ea6b9068cbe00d41085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7399c56304153ea6b9068cbe00d41085">&sect;&nbsp;</a></span>operator<=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeL , typename TypeR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side pointer iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side pointer iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side iterator points to a lower or the same element, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="a32dc9a29df3b365fb40f34963519d791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32dc9a29df3b365fb40f34963519d791">&sect;&nbsp;</a></span>operator<=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool AF1, typename T2 , bool AF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T1, AF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T2, AF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between two <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side iterator is less or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="af275fc8373d91ea8aff2b0b8e8dd3e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af275fc8373d91ea8aff2b0b8e8dd3e89">&sect;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two values are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="a9e0b25bd1d6022c2927572277c7ff9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0b25bd1d6022c2927572277c7ff9d1">&sect;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html" title="Allocator for type-specific aligned memory.The AlignedAllocator class template represents an implemen...">AlignedAllocator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side aligned allocator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side aligned allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em>. </dd></dl>

</div>
</div>
<a id="a83125315ff1fc56974b1525cd6d9c4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83125315ff1fc56974b1525cd6d9c4cf">&sect;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeL , typename TypeR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side pointer iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side pointer iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the iterators point to the same element, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ae1c6af9cbb860721101fd603adb7c90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c6af9cbb860721101fd603adb7c90b">&sect;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool AF1, typename T2 , bool AF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T1, AF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T2, AF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the iterators refer to the same element, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="a4bd2908dd4b8aae738fcb0aa21d494af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd2908dd4b8aae738fcb0aa21d494af">&sect;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two pointer vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side pointer vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side pointer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two pointer vectors are equal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a id="a4918d3c24509bf7651948a10524dbdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4918d3c24509bf7651948a10524dbdb9">&sect;&nbsp;</a></span>operator>() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left value if greater than the right value, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="a378bc920e7d0cfddbe90600e14f358c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378bc920e7d0cfddbe90600e14f358c4">&sect;&nbsp;</a></span>operator>() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeL , typename TypeR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side pointer iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side pointer iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side iterator points to a higher element, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="a5d38aa4cd7b79617b957c33b7f50cdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d38aa4cd7b79617b957c33b7f50cdb4">&sect;&nbsp;</a></span>operator>() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool AF1, typename T2 , bool AF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T1, AF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T2, AF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between two <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side iterator is greater, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="a73335dc2737714119ab3747f7d4d48b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73335dc2737714119ab3747f7d4d48b0">&sect;&nbsp;</a></span>operator>=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left value is greater or equal than the right value, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="a7c0ebf4f1d1c12bfda98557fcdefd5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0ebf4f1d1c12bfda98557fcdefd5c6">&sect;&nbsp;</a></span>operator>=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than or equal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="a9e6b0ae6e6543208758f78731a1a87d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6b0ae6e6543208758f78731a1a87d5">&sect;&nbsp;</a></span>operator>=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than or equal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="a670fa090b177992074b4153c6de2673a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670fa090b177992074b4153c6de2673a">&sect;&nbsp;</a></span>operator>=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than or equal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="a863334584b1a632888e4162ac4e1965b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863334584b1a632888e4162ac4e1965b">&sect;&nbsp;</a></span>operator>=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than or equal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ad4c6bd436ad385878f4c70a9b9ee5dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c6bd436ad385878f4c70a9b9ee5dd5">&sect;&nbsp;</a></span>operator>=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeL , typename TypeR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side pointer iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side pointer iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side iterator points to a higher or the same element, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ad2acacc78f03cb0ec8e8e7218b96f93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2acacc78f03cb0ec8e8e7218b96f93b">&sect;&nbsp;</a></span>operator>=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool AF1, typename T2 , bool AF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T1, AF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; T2, AF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between two <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side iterator is greater or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="afc275ea3ab616899091b50d46fc6e1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc275ea3ab616899091b50d46fc6e1a3">&sect;&nbsp;</a></span>operator>>()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; blaze::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>uv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global input operator for the <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Reference to the input stream. </td></tr>
    <tr><td class="paramname">uv</td><td>Reference to a <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream.</dd></dl>
<p>The input operator guarantees that this object is not changed in the case of an input error. Only values suitable for the according built-in unsigned integral data type <em>T</em> are allowed. Otherwise, the input stream's position is returned to its previous position and the <em>std::istream::failbit</em> is set. </p>

</div>
</div>
<a id="a300de20d22689dc8157697e1d2026f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300de20d22689dc8157697e1d2026f10">&sect;&nbsp;</a></span>polymorphicCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::polymorphicCount </td>
          <td>(</td>
          <td class="paramtype">S *const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S *const *&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the pointer to objects with dynamic type <em>D</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first pointer of the pointer range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the pointer one past the last pointer of the pointer range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of objects with dynamic type <em>D</em>.</dd></dl>
<p>This function traverses the range <img class="formulaInl" alt="$ [first,last) $" src="../../form_184.png"/> of pointers to objects with static type <em>S</em> and counts all polymorphic pointers to objects of dynamic type <em>D</em>. Note that in case <em>D</em> is not a type derived from <em>S</em>, a compile time error is created! </p>

</div>
</div>
<a id="a526e1bd58f6ea4e93e56d5fd71a0168d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526e1bd58f6ea4e93e56d5fd71a0168d">&sect;&nbsp;</a></span>polymorphicFind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S* const* blaze::polymorphicFind </td>
          <td>(</td>
          <td class="paramtype">S *const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S *const *&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next pointer to an object with dynamic type <em>D</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first pointer of the pointer range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the pointer one past the last pointer of the pointer range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next pointer to an object with dynamic type <em>D</em>.</dd></dl>
<p>This function traverses the range <img class="formulaInl" alt="$ [first,last) $" src="../../form_184.png"/> of pointers to objects with static type <em>S</em> until it finds the next polymorphic pointer to an object of dynamic type <em>D</em>. Note that in case <em>D</em> is not a type derived from <em>S</em>, a compile time error is created! </p>

</div>
</div>
<a id="a34083587480905fa636afb2190918892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34083587480905fa636afb2190918892">&sect;&nbsp;</a></span>serialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d14/classblaze_1_1Archive.html">Archive</a> &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes the given vector and writes it to the archive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">archive</td><td>The archive to be written. </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to be serialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Error during serialization.</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="../../d2/de9/namespaceblaze.html#a3eb8155b9a2cd60299756402c877e598" title="Serializes the given matrix and writes it to the archive. ">serialize()</a> function converts the given vector into a portable, binary representation. The following example demonstrates the (de-)serialization process of vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"></div><div class="line"><span class="comment">// Serialization of both vectors</span></div><div class="line">{</div><div class="line">   <a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;double,5UL,rowVector&gt;</a> d;</div><div class="line">   <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;int,columnVector&gt;</a> s;</div><div class="line"></div><div class="line">   <span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line">   <span class="comment">// Creating an archive that writes into a the file &quot;vectors.blaze&quot;</span></div><div class="line">   <a class="code" href="../../dd/d14/classblaze_1_1Archive.html">blaze::Archive&lt;std::ofstream&gt;</a> archive( <span class="stringliteral">&quot;vectors.blaze&quot;</span> );</div><div class="line"></div><div class="line">   <span class="comment">// Serialization of both vectors into the same archive. Note that d lies before s!</span></div><div class="line">   archive &lt;&lt; d &lt;&lt; s;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Reconstitution of both vectors</span></div><div class="line">{</div><div class="line">   <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a> d1;</div><div class="line">   <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;int,rowVector&gt;</a> d2;</div><div class="line"></div><div class="line">   <span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line">   <span class="comment">// Creating an archive that reads from the file &quot;vectors.blaze&quot;</span></div><div class="line">   <a class="code" href="../../dd/d14/classblaze_1_1Archive.html">blaze::Archive&lt;std::ofstream&gt;</a> archive( <span class="stringliteral">&quot;vectors.blaze&quot;</span> );</div><div class="line"></div><div class="line">   <span class="comment">// Reconstituting the former d vector into d1. Note that it is possible to reconstitute</span></div><div class="line">   <span class="comment">// the vector into a differrent kind of vector (StaticVector -&gt; DynamicVector), but that</span></div><div class="line">   <span class="comment">// the type of elements has to be the same.</span></div><div class="line">   archive &gt;&gt; d1;</div><div class="line"></div><div class="line">   <span class="comment">// Reconstituting the former s vector into d2. Note that is is even possible to reconstitute</span></div><div class="line">   <span class="comment">// a sparse vector as a dense vector (also the reverse is possible) and that a column vector</span></div><div class="line">   <span class="comment">// can be reconstituted as row vector (and vice versa). Note however that also in this case</span></div><div class="line">   <span class="comment">// the type of elements is the same!</span></div><div class="line">   archive &gt;&gt; d2</div><div class="line">}</div></div><!-- fragment --><p>As the example demonstrates, the vector serialization offers an enormous flexibility. However, several actions result in errors:</p>
<ul>
<li>vectors cannot be reconstituted as matrices (and vice versa)</li>
<li>the element type of the serialized and reconstituted vector must match, which means that on the source and destination platform the general type (signed/unsigned integral or floating point) and the size of the type must be exactly the same</li>
<li>when reconstituting a <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a>, its size must match the size of the serialized vector</li>
</ul>
<p>In case an error is encountered during (de-)serialization, a <em>std::runtime_exception</em> is thrown. </p>

</div>
</div>
<a id="a3eb8155b9a2cd60299756402c877e598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb8155b9a2cd60299756402c877e598">&sect;&nbsp;</a></span>serialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d14/classblaze_1_1Archive.html">Archive</a> &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes the given matrix and writes it to the archive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">archive</td><td>The archive to be written. </td></tr>
    <tr><td class="paramname">mat</td><td>The matrix to be serialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> could not be serialized.</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="../../d2/de9/namespaceblaze.html#a3eb8155b9a2cd60299756402c877e598" title="Serializes the given matrix and writes it to the archive. ">serialize()</a> function converts the given matrix into a portable, binary representation. The following example demonstrates the (de-)serialization process of matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><span class="comment">// Serialization of both matrices</span></div><div class="line">{</div><div class="line">   <a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;double,3UL,5UL,rowMajor&gt;</a> D;</div><div class="line">   <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,columnMajor&gt;</a> S;</div><div class="line"></div><div class="line">   <span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line">   <span class="comment">// Creating an archive that writes into a the file &quot;matrices.blaze&quot;</span></div><div class="line">   <a class="code" href="../../dd/d14/classblaze_1_1Archive.html">blaze::Archive&lt;std::ofstream&gt;</a> archive( <span class="stringliteral">&quot;matrices.blaze&quot;</span> );</div><div class="line"></div><div class="line">   <span class="comment">// Serialization of both matrices into the same archive. Note that D lies before S!</span></div><div class="line">   archive &lt;&lt; D &lt;&lt; S;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Reconstitution of both matrices</span></div><div class="line">{</div><div class="line">   <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> D1;</div><div class="line">   <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,rowMajor&gt;</a> D2;</div><div class="line"></div><div class="line">   <span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line">   <span class="comment">// Creating an archive that reads from the file &quot;matrices.blaze&quot;</span></div><div class="line">   <a class="code" href="../../dd/d14/classblaze_1_1Archive.html">blaze::Archive&lt;std::ofstream&gt;</a> archive( <span class="stringliteral">&quot;matrices.blaze&quot;</span> );</div><div class="line"></div><div class="line">   <span class="comment">// Reconstituting the former D matrix into D1. Note that it is possible to reconstitute</span></div><div class="line">   <span class="comment">// the matrix into a differrent kind of matrix (StaticMatrix -&gt; DynamicMatrix), but that</span></div><div class="line">   <span class="comment">// the type of elements has to be the same.</span></div><div class="line">   archive &gt;&gt; D1;</div><div class="line"></div><div class="line">   <span class="comment">// Reconstituting the former S matrix into D2. Note that is is even possible to reconstitute</span></div><div class="line">   <span class="comment">// a sparse matrix as a dense matrix (also the reverse is possible) and that a column-major</span></div><div class="line">   <span class="comment">// matrix can be reconstituted as row-major matrix (and vice versa). Note however that also</span></div><div class="line">   <span class="comment">// in this case the type of elements is the same!</span></div><div class="line">   archive &gt;&gt; D2</div><div class="line">}</div></div><!-- fragment --><p>As the example demonstrates, the matrix serialization offers an enormous flexibility. However, several actions result in errors:</p>
<ul>
<li>matrices cannot be reconstituted as vectors (and vice versa)</li>
<li>the element type of the serialized and reconstituted matrix must match, which means that on the source and destination platform the general type (signed/unsigned integral or floating point) and the size of the type must be exactly the same</li>
<li>when reconstituting a <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a>, the number of rows and columns must match those of the serialized matrix</li>
</ul>
<p>In case an error is encountered during (de-)serialization, a <em>std::runtime_exception</em> is thrown. </p>

</div>
</div>
<a id="ga123bb79d57112645ef44ef5675361a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga123bb79d57112645ef44ef5675361a4c">&sect;&nbsp;</a></span>set() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,2UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDint16, SIMDuint16 &gt; &gt; blaze::set </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all values in the vector to the given 2-byte integral value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The given 2-byte integral value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set vector of 2-byte integral values. </dd></dl>

</div>
</div>
<a id="ga0bd1dc51798d68a2458f7f1164cb59ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bd1dc51798d68a2458f7f1164cb59ab">&sect;&nbsp;</a></span>set() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,2UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDcint16, SIMDcuint16 &gt; &gt; blaze::set </td>
          <td>(</td>
          <td class="paramtype">complex&lt; T &gt;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all values in the vector to the given 2-byte integral complex value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The given 2-byte integral complex value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set vector of 2-byte integral complex values. </dd></dl>

</div>
</div>
<a id="ga123bb79d57112645ef44ef5675361a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga123bb79d57112645ef44ef5675361a4c">&sect;&nbsp;</a></span>set() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,4UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDint32, SIMDuint32 &gt; &gt; blaze::set </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all values in the vector to the given 4-byte integral value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The given 4-byte integral value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set vector of 4-byte integral values. </dd></dl>

</div>
</div>
<a id="ga0bd1dc51798d68a2458f7f1164cb59ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bd1dc51798d68a2458f7f1164cb59ab">&sect;&nbsp;</a></span>set() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,4UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDcint32, SIMDcuint32 &gt; &gt; blaze::set </td>
          <td>(</td>
          <td class="paramtype">complex&lt; T &gt;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all values in the vector to the given 4-byte integral complex value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The given 4-byte integral complex value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set vector of 4-byte integral complex values. </dd></dl>

</div>
</div>
<a id="ga123bb79d57112645ef44ef5675361a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga123bb79d57112645ef44ef5675361a4c">&sect;&nbsp;</a></span>set() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,8UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDint64, SIMDuint64 &gt; &gt; blaze::set </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all values in the vector to the given 8-byte integral value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The given 8-byte integral value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set vector of 8-byte integral values. </dd></dl>

</div>
</div>
<a id="ga0bd1dc51798d68a2458f7f1164cb59ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bd1dc51798d68a2458f7f1164cb59ab">&sect;&nbsp;</a></span>set() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt;T&gt;, <a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a>&lt;T,8UL&gt; &gt; , If_&lt; IsSigned&lt;T&gt;, SIMDcint64, SIMDcuint64 &gt; &gt; blaze::set </td>
          <td>(</td>
          <td class="paramtype">complex&lt; T &gt;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all values in the vector to the given 8-byte integral complex value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The given 8-byte integral complex value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set vector of 8-byte integral complex values. </dd></dl>

</div>
</div>
<a id="gaae592f4bb354009b404173d72de13685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae592f4bb354009b404173d72de13685">&sect;&nbsp;</a></span>smpAddAssign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d4/de1/structblaze_1_1IsSparseVector.html">IsSparseVector</a>&lt; VT1 &gt; &gt; blaze::smpAddAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the SMP addition assignment of a vector to a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the default SMP addition assignment of a vector to a sparse vector.<br />
This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="gab01c138ec4a37641aee46db562c8352b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab01c138ec4a37641aee46db562c8352b">&sect;&nbsp;</a></span>smpAddAssign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d0/d80/structblaze_1_1IsSparseMatrix.html">IsSparseMatrix</a>&lt; MT1 &gt; &gt; blaze::smpAddAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the SMP addition assignment of a matrix to a sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse matrix. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the default SMP addition assignment of a matrix to a sparse matrix.<br />
This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="gaa80808a575ebb4ee487c3ececb49b11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa80808a575ebb4ee487c3ececb49b11b">&sect;&nbsp;</a></span>smpAssign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d0/d80/structblaze_1_1IsSparseMatrix.html">IsSparseMatrix</a>&lt; MT1 &gt; &gt; blaze::smpAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the SMP assignment of a matrix to a sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse matrix. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the default SMP assignment of a matrix to a sparse matrix.<br />
This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="ga689597b1693b0d9e2b80c595713cabb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga689597b1693b0d9e2b80c595713cabb4">&sect;&nbsp;</a></span>smpAssign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d4/de1/structblaze_1_1IsSparseVector.html">IsSparseVector</a>&lt; VT1 &gt; &gt; blaze::smpAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the SMP assignment of a vector to a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the default SMP assignment of a vector to a sparse vector.<br />
This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="ga6499ce88c1e5244375f0790af111d373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6499ce88c1e5244375f0790af111d373">&sect;&nbsp;</a></span>smpMultAssign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d4/de1/structblaze_1_1IsSparseVector.html">IsSparseVector</a>&lt; VT1 &gt; &gt; blaze::smpMultAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the SMP multiplication assignment of a vector to a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the default SMP multiplication assignment of a vector to a sparse vector.<br />
This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="ga87a713f4df721a444169d185255f8a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87a713f4df721a444169d185255f8a38">&sect;&nbsp;</a></span>smpSubAssign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d4/de1/structblaze_1_1IsSparseVector.html">IsSparseVector</a>&lt; VT1 &gt; &gt; blaze::smpSubAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the SMP subtraction assignment of a vector to a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the default SMP subtraction assignment of a vector to a sparse vector.<br />
This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="ga5049e0c6aa650f7af95e2fc8810ffb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5049e0c6aa650f7af95e2fc8810ffb36">&sect;&nbsp;</a></span>smpSubAssign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d0/d80/structblaze_1_1IsSparseMatrix.html">IsSparseMatrix</a>&lt; MT1 &gt; &gt; blaze::smpSubAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the SMP subtraction assignment of a matrix to sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse matrix. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the default SMP subtraction assignment of a matrix to a sparse matrix.<br />
This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="ac57f2ec8572d4bae84bc6a9d9e5e400d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57f2ec8572d4bae84bc6a9d9e5e400d">&sect;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two pointer vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first pointer vector to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The second pointer vector to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0a0b6c9115d86e08908397fd2949cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a0b6c9115d86e08908397fd2949cef">&sect;&nbsp;</a></span>transfer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator blaze::transfer </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfers the elements from the given source range to the destination range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element of the source range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the element one past the last element of the source range. </td></tr>
    <tr><td class="paramname">dest</td><td>Iterator to the first element of the destination range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element one past the last copied element.</dd></dl>
<p>This function transfers the elements in the range <img class="formulaInl" alt="$ [first,last) $" src="../../form_184.png"/> to the specified destination range. In case the elements provide a no-throw move assignment, the transfer operation is handled via move. Else the elements are copied. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5e42e1508f7d4d364fe7c64eef78a583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e42e1508f7d4d364fe7c64eef78a583">&sect;&nbsp;</a></span>columnMajor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool blaze::columnMajor = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Storage order flag for column-major matrices. </p>
<p>Via this flag it is possible to specify the storage order of matrices as column-major. For instance, given the following matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{3}{c}} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ \end{array}\right)\]" src="../../form_65.png"/>
</p>
<p><br />
 in case of column-major order the elements are stored in the order</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{6}{c}} 1 &amp; 4 &amp; 2 &amp; 5 &amp; 3 &amp; 6. \\ \end{array}\right)\]" src="../../form_67.png"/>
</p>
<p>The following example demonstrates the setup of this <img class="formulaInl" alt="$ 2 \times 3 $" src="../../form_168.png"/> matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;int,2UL,3UL,columnMajor&gt;</a> A( { { 1, 2, 3 }, { 4, 5, 6 } } );</div></div><!-- fragment --> 
</div>
</div>
<a id="acee466faebcaba59afde0fbfe22041aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee466faebcaba59afde0fbfe22041aa">&sect;&nbsp;</a></span>columnVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool blaze::columnVector = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose flag for column vectors. </p>
<p>Via this flag it is possible to specify vectors as column vectors. The following example demonstrates the setup of a 3-dimensional column vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;int,3UL,columnVector&gt;</a> v( 1, 2, 3 );</div></div><!-- fragment --> 
</div>
</div>
<a id="a511878ce70095271b6d0dd5b855a9eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511878ce70095271b6d0dd5b855a9eaa">&sect;&nbsp;</a></span>rowMajor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool blaze::rowMajor = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Storage order flag for row-major matrices. </p>
<p>Via this flag it is possible to specify the storage order of matrices as row-major. For instance, given the following matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{3}{c}} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ \end{array}\right)\]" src="../../form_65.png"/>
</p>
<p><br />
 in case of row-major order the elements are stored in the order</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{6}{c}} 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6. \\ \end{array}\right)\]" src="../../form_66.png"/>
</p>
<p>The following example demonstrates the setup of this <img class="formulaInl" alt="$ 2 \times 3 $" src="../../form_168.png"/> matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;int,2UL,3UL,rowMajor&gt;</a> A( { { 1, 2, 3 }, { 4, 5, 6 } } );</div></div><!-- fragment --> 
</div>
</div>
<a id="a006b6328815f2632d2c5ab8b869c5cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006b6328815f2632d2c5ab8b869c5cf0">&sect;&nbsp;</a></span>rowVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool blaze::rowVector = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose flag for row vectors. </p>
<p>Via this flag it is possible to specify vectors as row vectors. The following example demonstrates the setup of a 3-dimensional row vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;int,3UL,rowVector&gt;</a> v( 1, 2, 3 );</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 8 2016 01:03:48 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
